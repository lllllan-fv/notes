<!DOCTYPE html>
<html lang="zh">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>同步与互斥 | lllllan</title>
    <meta name="generator" content="VuePress 1.9.7">
    <script src="https://cdn.jsdelivr.net/npm/react/umd/react.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/react-dom/umd/react-dom.production.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@babel/standalone/babel.min.js"></script>
    <link rel="alternate" type="application/atom+xml" href="https://notes.lllllan.cn/atom.xml" title="lllllan Atom Feed">
    <link rel="alternate" type="application/json" href="https://notes.lllllan.cn/feed.json" title="lllllan JSON Feed">
    <link rel="alternate" type="application/rss+xml" href="https://notes.lllllan.cn/rss.xml" title="lllllan RSS Feed">
    <link rel="icon" href="/logo.png">
    <link rel="icon" href="/logo.png" type="image/png" sizes="512x512">
    <link rel="icon" href="/logo.png" type="image/png" sizes="192x192">
    <link rel="icon" href="/logo.png" type="image/png" sizes="512x512">
    <link rel="icon" href="/logo.png" type="image/png" sizes="192x192">
    <link rel="manifest" href="/manifest.webmanifest" crossorigin="use-credentials">
    <link rel="apple-touch-icon" href="/logo.png">
    <meta name="description" content="">
    <meta property="og:url" content="/cs-basic/os/wangdao/2/3/">
    <meta property="og:site_name" content="lllllan">
    <meta property="og:title" content="同步与互斥">
    <meta property="og:description" content="转载声明《王道考研-操作系统》; 开中断和关中断; 一、同步与互斥的基本概念 在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。&quot; 例如，让系统计算 1 + 2 x 3，假设系统产生两个进程：一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程">
    <meta property="og:type" content="article">
    <meta property="og:locale" content="zh">
    <meta property="og:locale:alternate" content="en-US">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:image:alt" content="lllllan">
    <meta property="article:author" content="lllllan">
    <meta property="article:tag" content="操作系统">
    <meta name="theme-color" content="#46bd87">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="msapplication-TileImage" content="/logo.png">
    <meta name="msapplication-TileColor" content="#ffffff">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, viewport-fit=cover">
    
    <link rel="preload" href="/assets/css/0.styles.8357e793.css" as="style"><link rel="preload" href="/assets/js/app.3cfaf037.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Layout.57f7cf63.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.b5e5e957.js" as="script"><link rel="preload" href="/assets/js/page-同步与互斥.e0216efd.js" as="script"><link rel="preload" href="/assets/js/vendors~layout-Blog~layout-Layout.3d94df6c.js" as="script"><link rel="prefetch" href="/assets/js/146.8ecf0fcc.js"><link rel="prefetch" href="/assets/js/147.7277abfe.js"><link rel="prefetch" href="/assets/js/148.72b87788.js"><link rel="prefetch" href="/assets/js/149.5b1c78b5.js"><link rel="prefetch" href="/assets/js/150.9f3c442c.js"><link rel="prefetch" href="/assets/js/151.397eb6c6.js"><link rel="prefetch" href="/assets/js/152.946d1bed.js"><link rel="prefetch" href="/assets/js/layout-Blog.f99d2bb8.js"><link rel="prefetch" href="/assets/js/layout-Layout.54f62305.js"><link rel="prefetch" href="/assets/js/layout-NotFound.d261f6b6.js"><link rel="prefetch" href="/assets/js/layout-Slide.ea59fbea.js"><link rel="prefetch" href="/assets/js/page--07c97f1e.9682816c.js"><link rel="prefetch" href="/assets/js/page-ArrayList源码解读.ac617910.js"><link rel="prefetch" href="/assets/js/page-CPU缓存.b1450893.js"><link rel="prefetch" href="/assets/js/page-Class类文件的结构.fff783c4.js"><link rel="prefetch" href="/assets/js/page-ConcurrentHashMap源码解读.7d274ff4.js"><link rel="prefetch" href="/assets/js/page-HTTP传输大文件.d069f78c.js"><link rel="prefetch" href="/assets/js/page-HTTP各版本.0f54efa8.js"><link rel="prefetch" href="/assets/js/page-HTTP和HTTPS.a307440d.js"><link rel="prefetch" href="/assets/js/page-HTTP常见面试题.02cfb7ad.js"><link rel="prefetch" href="/assets/js/page-HashMap源码解读.e4b0b293.js"><link rel="prefetch" href="/assets/js/page-HashTable源码解读.8dfd411b.js"><link rel="prefetch" href="/assets/js/page-HotSpot的算法实现细节.b3692516.js"><link rel="prefetch" href="/assets/js/page-HotSpot虚拟机中的对象.d8064812.js"><link rel="prefetch" href="/assets/js/page-IO多路复用.ea148810.js"><link rel="prefetch" href="/assets/js/page-IO管理概述.db862336.js"><link rel="prefetch" href="/assets/js/page-JVM常见问题.e2418f44.js"><link rel="prefetch" href="/assets/js/page-Java-IO.6369db6e.js"><link rel="prefetch" href="/assets/js/page-Java-反射.67f807aa.js"><link rel="prefetch" href="/assets/js/page-Java-基本概念与常识.ee6063ec.js"><link rel="prefetch" href="/assets/js/page-Java-基础语法.bdad3a89.js"><link rel="prefetch" href="/assets/js/page-Java-异常.9839f810.js"><link rel="prefetch" href="/assets/js/page-Java-数据类型.94028146.js"><link rel="prefetch" href="/assets/js/page-Java-注解.e0de1c52.js"><link rel="prefetch" href="/assets/js/page-Java-面向对象.0cb9a8a8.js"><link rel="prefetch" href="/assets/js/page-Java集合框架基础知识.5041ae0e.js"><link rel="prefetch" href="/assets/js/page-MVCC.d3753661.js"><link rel="prefetch" href="/assets/js/page-MySQL基础架构.9323b9b1.js"><link rel="prefetch" href="/assets/js/page-MySQL日志系统.8c5ad6eb.js"><link rel="prefetch" href="/assets/js/page-MySQL面试题合集.79f4bdf0.js"><link rel="prefetch" href="/assets/js/page-OSI和TCPIP网络分层模型详解.9a83baa3.js"><link rel="prefetch" href="/assets/js/page-TCP可靠传输.dbf4f132.js"><link rel="prefetch" href="/assets/js/page-TCP常见面试题.17d88d75.js"><link rel="prefetch" href="/assets/js/page-Vector源码解读.1f7882ef.js"><link rel="prefetch" href="/assets/js/page-keep-alive.660d6377.js"><link rel="prefetch" href="/assets/js/page-next-key锁.1c1605b7.js"><link rel="prefetch" href="/assets/js/page-三次握手.eeca79bd.js"><link rel="prefetch" href="/assets/js/page-不稳定的快速排序.847b1f67.js"><link rel="prefetch" href="/assets/js/page-事务.7fd522ac.js"><link rel="prefetch" href="/assets/js/page-二叉搜索树代码实现.ba59d2ea.js"><link rel="prefetch" href="/assets/js/page-代理模式.33e7d015.js"><link rel="prefetch" href="/assets/js/page-低延迟垃圾收集器.5957b38b.js"><link rel="prefetch" href="/assets/js/page-内存分配与回收策略.fa1beb18.js"><link rel="prefetch" href="/assets/js/page-内存管理.21c2b061.js"><link rel="prefetch" href="/assets/js/page-内存管理概念.fd14d2bf.js"><link rel="prefetch" href="/assets/js/page-动态类型语言支持.cc325dab.js"><link rel="prefetch" href="/assets/js/page-四次挥手.5f9bf01e.js"><link rel="prefetch" href="/assets/js/page-垃圾收集算法.4ffb0014.js"><link rel="prefetch" href="/assets/js/page-处理机调度.206354d1.js"><link rel="prefetch" href="/assets/js/page-字节后端实习.5f806ee8.js"><link rel="prefetch" href="/assets/js/page-字节后端日常实习.682f997d.js"><link rel="prefetch" href="/assets/js/page-字节客户端春招.5da03438.js"><link rel="prefetch" href="/assets/js/page-字节抖音直播支付日常实习.70b08b50.js"><link rel="prefetch" href="/assets/js/page-字节番茄后端实习.d08dd9b5.js"><link rel="prefetch" href="/assets/js/page-字节码指令简介.28f93755.js"><link rel="prefetch" href="/assets/js/page-字节码解释执行引擎.2e2e8d2c.js"><link rel="prefetch" href="/assets/js/page-字节飞书后端春招.a8861f6e.js"><link rel="prefetch" href="/assets/js/page-对象已死.81214d58.js"><link rel="prefetch" href="/assets/js/page-常见面试题.d9eb79ea.js"><link rel="prefetch" href="/assets/js/page-平衡搜索树.01472381.js"><link rel="prefetch" href="/assets/js/page-排序算法.0fc7cd5e.js"><link rel="prefetch" href="/assets/js/page-操作系统.bcbaa656.js"><link rel="prefetch" href="/assets/js/page-操作系统发展历程.1643b450.js"><link rel="prefetch" href="/assets/js/page-操作系统的基本概念.0d693799.js"><link rel="prefetch" href="/assets/js/page-操作系统结构.e665da9b.js"><link rel="prefetch" href="/assets/js/page-操作系统运行环境.fd564f64.js"><link rel="prefetch" href="/assets/js/page-数据结构.7bcfc44f.js"><link rel="prefetch" href="/assets/js/page-数据结构和算法.fd8d96d6.js"><link rel="prefetch" href="/assets/js/page-文件管理.17c3170b.js"><link rel="prefetch" href="/assets/js/page-文件系统.2119f002.js"><link rel="prefetch" href="/assets/js/page-方法调用.7c89d00f.js"><link rel="prefetch" href="/assets/js/page-无关性的基石.f9392463.js"><link rel="prefetch" href="/assets/js/page-框架技术概览.040752f8.js"><link rel="prefetch" href="/assets/js/page-概述.83749280.js"><link rel="prefetch" href="/assets/js/page-死锁.02c94d20.js"><link rel="prefetch" href="/assets/js/page-目录.18627bc0.js"><link rel="prefetch" href="/assets/js/page-磁盘和固态硬盘.ae5b6830.js"><link rel="prefetch" href="/assets/js/page-第一章、Web及网络基础.bd9f2488.js"><link rel="prefetch" href="/assets/js/page-第一章、浏览器生成消息.8487d4c1.js"><link rel="prefetch" href="/assets/js/page-第一章、进程与线程的基本概念.61ff5e39.js"><link rel="prefetch" href="/assets/js/page-第七章、HTTPS.705f7cf3.js"><link rel="prefetch" href="/assets/js/page-第七章、重排序与happens-before.f397aa11.js"><link rel="prefetch" href="/assets/js/page-第三章、HTTP报文.cd78f9a3.js"><link rel="prefetch" href="/assets/js/page-第三章、从网线到网络设备.ee12068c.js"><link rel="prefetch" href="/assets/js/page-第三章、线程组和线程优先级.eb5780ec.js"><link rel="prefetch" href="/assets/js/page-第九章、synchronized与锁.545db104.js"><link rel="prefetch" href="/assets/js/page-第九章、追加协议.4c3565e9.js"><link rel="prefetch" href="/assets/js/page-第二十章、计划任务.db158ba5.js"><link rel="prefetch" href="/assets/js/page-第二章、Java多线程入门类和接口.d67fade0.js"><link rel="prefetch" href="/assets/js/page-第二章、用电信号传输TCPIP数据.6ca26d3f.js"><link rel="prefetch" href="/assets/js/page-第二章、简单的HTTP协议.482c12da.js"><link rel="prefetch" href="/assets/js/page-第五章、Java线程间的通信.87783899.js"><link rel="prefetch" href="/assets/js/page-第五章、Web服务器.a3458c74.js"><link rel="prefetch" href="/assets/js/page-第八章、volatile.79caedc9.js"><link rel="prefetch" href="/assets/js/page-第八章、确认用户身份.d1254733.js"><link rel="prefetch" href="/assets/js/page-第六章、Http首部.4e518637.js"><link rel="prefetch" href="/assets/js/page-第六章、Java内存模型基础知识.c6da8868.js"><link rel="prefetch" href="/assets/js/page-第十一章、AQS（不懂）.511d4d29.js"><link rel="prefetch" href="/assets/js/page-第十一章、Web的攻击技术.fbf36423.js"><link rel="prefetch" href="/assets/js/page-第十七章、通信工具类.0fb368b3.js"><link rel="prefetch" href="/assets/js/page-第十三章、阻塞队列.208bddeb.js"><link rel="prefetch" href="/assets/js/page-第十九章、Stream并行计算原理（不懂）.e5a43d6c.js"><link rel="prefetch" href="/assets/js/page-第十二章、线程池原理.3278632a.js"><link rel="prefetch" href="/assets/js/page-第十五章、并发容器集合.41631d72.js"><link rel="prefetch" href="/assets/js/page-第十八章、ForkJoin框架.1b5c300c.js"><link rel="prefetch" href="/assets/js/page-第十六章、CopyOnWrite容器.704da6e8.js"><link rel="prefetch" href="/assets/js/page-第十四章、锁接口和类.193cf6db.js"><link rel="prefetch" href="/assets/js/page-第十章、CAS与原子操作.c70c1f56.js"><link rel="prefetch" href="/assets/js/page-第十章、构建Web内容的技术.0700ec3d.js"><link rel="prefetch" href="/assets/js/page-第四章、Http状态码.bf7c2706.js"><link rel="prefetch" href="/assets/js/page-第四章、Java线程的状态及主要转化方法.fac7b947.js"><link rel="prefetch" href="/assets/js/page-算法.87f91ecc.js"><link rel="prefetch" href="/assets/js/page-类加载器.0e8812ee.js"><link rel="prefetch" href="/assets/js/page-类加载的时机.8807ba03.js"><link rel="prefetch" href="/assets/js/page-类加载的过程.775f3dea.js"><link rel="prefetch" href="/assets/js/page-索引.efcf3576.js"><link rel="prefetch" href="/assets/js/page-经典垃圾收集器.58be1e98.js"><link rel="prefetch" href="/assets/js/page-虚拟内存管理.544e96eb.js"><link rel="prefetch" href="/assets/js/page-虚拟机.6023f0a9.js"><link rel="prefetch" href="/assets/js/page-计算机基础.61f3ffaa.js"><link rel="prefetch" href="/assets/js/page-计算机网络-常见面试题.9082da64.js"><link rel="prefetch" href="/assets/js/page-设备独立性软件.7a800410.js"><link rel="prefetch" href="/assets/js/page-设计模式.e243f235.js"><link rel="prefetch" href="/assets/js/page-路由器和交换机.378394d6.js"><link rel="prefetch" href="/assets/js/page-输入url网址到页面显示.43f78fb6.js"><link rel="prefetch" href="/assets/js/page-运行时数据区域.4455e38d.js"><link rel="prefetch" href="/assets/js/page-运行时栈帧结构.e6b9f372.js"><link rel="prefetch" href="/assets/js/page-进程与线程.912285b0.js"><link rel="prefetch" href="/assets/js/page-进程和线程.2f7d4f3c.js"><link rel="prefetch" href="/assets/js/page-进程间通信.1fec56ad.js"><link rel="prefetch" href="/assets/js/page-选择合适的垃圾收集器.d5134ff8.js"><link rel="prefetch" href="/assets/js/page-项目主页.efb34bec.js"><link rel="prefetch" href="/assets/js/page-顺序一致性.ff3e582e.js"><link rel="prefetch" href="/assets/js/vendors~flowchart.8857f3dd.js"><link rel="prefetch" href="/assets/js/vendors~mermaid.20000af9.js"><link rel="prefetch" href="/assets/js/vendors~photo-swipe.e38cb1a8.js"><link rel="prefetch" href="/assets/js/vendors~reveal.bec24043.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8357e793.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container has-navbar has-sidebar has-anchor"><header class="navbar"><!----> <div class="content__navbar-start"></div> <button title="Sidebar Button" class="sidebar-button"><span class="icon"></span></button> <a href="/" class="home-link router-link-active"><img src="/logo.png" alt="lllllan" class="logo"> <!----> <span class="site-name can-hide">lllllan</span></a> <!----> <div class="content__navbar-center"></div> <div class="links"><button tabindex="-1" aria-hidden="true" class="color-button"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="skin-icon"><path d="M224 800c0 9.6 3.2 44.8 6.4 54.4 6.4 48-48 76.8-48 76.8s80 41.6 147.2 0 134.4-134.4
        38.4-195.2c-22.4-12.8-41.6-19.2-57.6-19.2C259.2 716.8 227.2 761.6 224 800zM560 675.2l-32
        51.2c-51.2 51.2-83.2 32-83.2 32 25.6 67.2 0 112-12.8 128 25.6 6.4 51.2 9.6 80 9.6 54.4 0
        102.4-9.6 150.4-32l0 0c3.2 0 3.2-3.2 3.2-3.2 22.4-16 12.8-35.2
        6.4-44.8-9.6-12.8-12.8-25.6-12.8-41.6 0-54.4 60.8-99.2 137.6-99.2 6.4 0 12.8 0 22.4
        0 12.8 0 38.4 9.6 48-25.6 0-3.2 0-3.2 3.2-6.4 0-3.2 3.2-6.4 3.2-6.4 6.4-16 6.4-16 6.4-19.2
        9.6-35.2 16-73.6 16-115.2 0-105.6-41.6-198.4-108.8-268.8C704 396.8 560 675.2 560 675.2zM224
        419.2c0-28.8 22.4-51.2 51.2-51.2 28.8 0 51.2 22.4 51.2 51.2 0 28.8-22.4 51.2-51.2 51.2C246.4
        470.4 224 448 224 419.2zM320 284.8c0-22.4 19.2-41.6 41.6-41.6 22.4 0 41.6 19.2 41.6 41.6 0
        22.4-19.2 41.6-41.6 41.6C339.2 326.4 320 307.2 320 284.8zM457.6 208c0-12.8 12.8-25.6 25.6-25.6
        12.8 0 25.6 12.8 25.6 25.6 0 12.8-12.8 25.6-25.6 25.6C470.4 233.6 457.6 220.8 457.6 208zM128
        505.6C128 592 153.6 672 201.6 736c28.8-60.8 112-60.8 124.8-60.8-16-51.2 16-99.2
        16-99.2l316.8-422.4c-48-19.2-99.2-32-150.4-32C297.6 118.4 128 291.2 128 505.6zM764.8
        86.4c-22.4 19.2-390.4 518.4-390.4 518.4-22.4 28.8-12.8 76.8 22.4 99.2l9.6 6.4c35.2 22.4
        80 12.8 99.2-25.6 0 0 6.4-12.8 9.6-19.2 54.4-105.6 275.2-524.8 288-553.6
        6.4-19.2-3.2-32-19.2-32C777.6 76.8 771.2 80 764.8 86.4z"></path></svg> <div class="color-picker-menu" style="display:none;"><div class="theme-options"><ul class="themecolor-select"><label for="themecolor-select">Theme Color:</label> <li><span class="default-theme"></span></li> </ul> <div class="darkmode-toggle"><label for="darkmode-toggle" class="desc">Theme Mode:</label> <div class="darkmode-switch"><div class="item day"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon light-icon"><path d="M512 256a42.667 42.667 0 0 0 42.667-42.667V128a42.667 42.667 0 0 0-85.334 0v85.333A42.667 42.667 0 0 0 512 256zm384 213.333h-85.333a42.667 42.667 0 0 0 0 85.334H896a42.667 42.667 0 0 0 0-85.334zM256 512a42.667 42.667 0 0 0-42.667-42.667H128a42.667 42.667 0 0 0 0 85.334h85.333A42.667 42.667 0 0 0 256 512zm9.387-298.667a42.667 42.667 0 0 0-59.307 62.72l61.44 59.307a42.667 42.667 0 0 0 31.147 11.947 42.667 42.667 0 0 0 30.72-13.227 42.667 42.667 0 0 0 0-60.16zm459.946 133.974a42.667 42.667 0 0 0 29.44-11.947l61.44-59.307a42.667 42.667 0 0 0-57.6-62.72l-61.44 60.587a42.667 42.667 0 0 0 0 60.16 42.667 42.667 0 0 0 28.16 13.227zM512 768a42.667 42.667 0 0 0-42.667 42.667V896a42.667 42.667 0 0 0 85.334 0v-85.333A42.667 42.667 0 0 0 512 768zm244.48-79.36a42.667 42.667 0 0 0-59.307 61.44l61.44 60.587a42.667 42.667 0 0 0 29.44 11.946 42.667 42.667 0 0 0 30.72-12.8 42.667 42.667 0 0 0 0-60.586zm-488.96 0-61.44 59.307a42.667 42.667 0 0 0 0 60.586 42.667 42.667 0 0 0 30.72 12.8 42.667 42.667 0 0 0 28.587-10.666l61.44-59.307a42.667 42.667 0 0 0-59.307-61.44zM512 341.333A170.667 170.667 0 1 0 682.667 512 170.667 170.667 0 0 0 512 341.333z" fill="currentColor"></path></svg></div> <div class="item auto active"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon auto-icon"><path d="M460.864 539.072H564.8L510.592 376l-49.728 163.072zM872 362.368V149.504H659.648L510.528 0l-149.12 149.504H149.12v212.928L0 511.872l149.12 149.504v212.928h212.352l149.12 149.504 149.12-149.504h212.352V661.376l149.12-149.504L872 362.368zM614.464 693.12l-31.616-90.624H438.272l-31.616 90.624h-85.888l144.576-407.68h90.368l144.576 407.68h-85.824zm0 0" fill="currentColor"></path></svg></div> <div class="item night"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon dark-icon"><path d="M935.539 630.402c-11.43-11.432-28.674-14.739-43.531-8.354-46.734 20.103-96.363 30.297-147.508 30.297-99.59 0-193.221-38.784-263.64-109.203-108.637-108.637-139.61-270.022-78.908-411.148a39.497 39.497 0 0 0-51.886-51.887c-52.637 22.64-100.017 54.81-140.826 95.616-85.346 85.346-132.346 198.821-132.346 319.52 0 120.7 47.001 234.172 132.347 319.519S408.063 947.11 528.76 947.11c120.7 0 234.172-47.003 319.52-132.351 40.809-40.81 72.978-88.19 95.616-140.826a39.497 39.497 0 0 0-8.356-43.532z" fill="currentColor"></path></svg></div></div> <!----></div></div></div></button> <div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/" class="nav-link router-link-active"><i class="iconfont icon-home"></i>
  Blog Home
</a></div><div class="nav-item"><a href="/java/basic/" class="nav-link"><!---->
  Java
</a></div><div class="nav-item"><a href="/cs-basic/network/" class="nav-link"><!---->
  计算机网络
</a></div><div class="nav-item"><a href="/cs-basic/os/" class="nav-link router-link-active active"><!---->
  操作系统
</a></div><div class="nav-item"><a href="/mysql/" class="nav-link"><!---->
  MySQL
</a></div></nav> <!----> <a rel="noopener noreferrer" href="https://github.com/lllllan-fv/notes" target="_blank" class="repo-link can-hide">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a> <!----> <div class="content__navbar-end"></div></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><!----> <!----> <div class="content__sidebar-top"></div> <nav class="sidebar-nav-links"><div class="nav-item"><a href="/" class="nav-link router-link-active"><i class="iconfont icon-home"></i>
  Blog Home
</a></div><div class="nav-item"><a href="/java/basic/" class="nav-link"><!---->
  Java
</a></div><div class="nav-item"><a href="/cs-basic/network/" class="nav-link"><!---->
  计算机网络
</a></div><div class="nav-item"><a href="/cs-basic/os/" class="nav-link router-link-active active"><!---->
  操作系统
</a></div><div class="nav-item"><a href="/mysql/" class="nav-link"><!---->
  MySQL
</a></div> <a rel="noopener noreferrer" href="https://github.com/lllllan-fv/notes" target="_blank" class="repo-link">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></nav> <!----> <div class="content__sidebar-center"></div> <ul class="sidebar-links"><li><a href="/cs-basic/os/" aria-current="page" class="sidebar-link"><i class="iconfont icon-page"></i>操作系统</a></li><li><a href="/cs-basic/os/processes&amp;threads/" class="sidebar-link"><i class="iconfont icon-page"></i>进程和线程</a></li><li><a href="/cs-basic/os/memory-manage/" class="sidebar-link"><i class="iconfont icon-page"></i>内存管理</a></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable"><!----> <span class="title">补充</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable depth-0"><p class="sidebar-heading clickable open"><!----> <span class="title">王道-操作系统</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><!----> <span class="title">计算机系统概述</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable open"><!----> <span class="title">进程与线程</span> <span class="arrow down"></span></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/cs-basic/os/wangdao/2/1/" class="sidebar-link"><i class="iconfont icon-page"></i>进程与线程</a></li><li><a href="/cs-basic/os/wangdao/2/2/" class="sidebar-link"><i class="iconfont icon-page"></i>处理机调度</a></li><li><a href="/cs-basic/os/wangdao/2/3/" aria-current="page" class="active sidebar-link"><i class="iconfont icon-page"></i>同步与互斥</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#一、同步与互斥的基本概念" class="sidebar-link">一、同步与互斥的基本概念</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_1-1-临界资源" class="sidebar-link heading3">1.1 临界资源</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_1-2-同步" class="sidebar-link heading3">1.2 同步</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_1-3-互斥" class="sidebar-link heading3">1.3 互斥</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#二、实现临界区互斥的基本方法" class="sidebar-link">二、实现临界区互斥的基本方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_2-1-软件实现方法" class="sidebar-link heading3">2.1 软件实现方法</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_2-2-硬件实现方法" class="sidebar-link heading3">2.2 硬件实现方法</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#三、互斥锁" class="sidebar-link">三、互斥锁</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#四、信号量" class="sidebar-link">四、信号量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_4-1-整型信号量" class="sidebar-link heading3">4.1 整型信号量</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_4-2-记录型信号量" class="sidebar-link heading3">4.2 记录型信号量</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_4-3-利用信号量实现同步" class="sidebar-link heading3">4.3 利用信号量实现同步</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_4-4-利用信号量实现进程互斥" class="sidebar-link heading3">4.4 利用信号量实现进程互斥</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#五、管程" class="sidebar-link">五、管程</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_5-1-管程的定义" class="sidebar-link heading3">5.1 管程的定义</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_5-2-条件变量" class="sidebar-link heading3">5.2 条件变量</a></li></ul></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#六、经典同步问题" class="sidebar-link">六、经典同步问题</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_6-1-生产者-消费者问题" class="sidebar-link heading3">6.1 生产者-消费者问题</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_6-2-读者-写者问题" class="sidebar-link heading3">6.2 读者-写者问题</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_6-3-哲学家进餐问题" class="sidebar-link heading3">6.3 哲学家进餐问题</a></li><li class="sidebar-sub-header"><a href="/cs-basic/os/wangdao/2/3/#_6-4-吸烟者问题" class="sidebar-link heading3">6.4 吸烟者问题</a></li></ul></li></ul></li><li><a href="/cs-basic/os/wangdao/2/4/" class="sidebar-link"><i class="iconfont icon-page"></i>死锁</a></li></ul></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><!----> <span class="title">内存管理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><!----> <span class="title">文件管理</span> <span class="arrow right"></span></p> <!----></section></li><li><section class="sidebar-group collapsable is-sub-group depth-1"><p class="sidebar-heading clickable"><!----> <span class="title">IO管理</span> <span class="arrow right"></span></p> <!----></section></li></ul></section></li></ul> <!----> <div class="content__sidebar-bottom"></div> <!----></aside> <main class="page"><nav class="breadcrumb"><ol vocab="https://schema.org/" typeof="BreadcrumbList"><li property="itemListElement" typeof="ListItem"><a href="/cs-basic/" property="item" typeof="WebPage" class="router-link-active"><i class="iconfont icon-info"></i> <span property="name">计算机基础</span></a> <meta property="position" content="1"></li><li property="itemListElement" typeof="ListItem"><a href="/cs-basic/os/" property="item" typeof="WebPage" class="router-link-active"><i class="iconfont icon-page"></i> <span property="name">操作系统</span></a> <meta property="position" content="2"></li><li property="itemListElement" typeof="ListItem" class="is-active"><a href="/cs-basic/os/wangdao/2/3/" aria-current="page" property="item" typeof="WebPage" class="router-link-exact-active router-link-active"><i class="iconfont icon-page"></i> <span property="name">同步与互斥</span></a> <meta property="position" content="3"></li></ol></nav> <!----> <div class="content__page-top"></div> <div vocab="https://schema.org/" typeof="Article" class="page-title"><h1><i class="iconfont icon-page"></i> <span property="headline">同步与互斥</span></h1> <div class="page-info"><!----> <span aria-label="Author🖊" data-balloon-pos="down" categoryPath="/category/$category/" tagPath="/tag/$tag/"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon author-icon"><path d="M649.6 633.6c86.4-48 147.2-144 147.2-249.6 0-160-128-288-288-288s-288 128-288 288c0 108.8 57.6 201.6 147.2 249.6-121.6 48-214.4 153.6-240 288-3.2 9.6 0 19.2 6.4 25.6 3.2 9.6 12.8 12.8 22.4 12.8h704c9.6 0 19.2-3.2 25.6-12.8 6.4-6.4 9.6-16 6.4-25.6-25.6-134.4-121.6-240-243.2-288z" fill="currentColor"></path></svg> <span property="author">lllllan</span></span><span aria-label="Page views🔢" data-balloon-pos="down" defaultAuthor="lllllan" categoryPath="/category/$category/" tagPath="/tag/$tag/" class="visitor-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon eye-icon"><path d="M992 512.096c0-5.76-.992-10.592-1.28-11.136-.192-2.88-1.152-8.064-2.08-10.816-.256-.672-.544-1.376-.832-2.08-.48-1.568-1.024-3.104-1.6-4.32C897.664 290.112 707.104 160 512 160c-195.072 0-385.632 130.016-473.76 322.592-1.056 2.112-1.792 4.096-2.272 5.856a55.512 55.512 0 0 0-.64 1.6c-1.76 5.088-1.792 8.64-1.632 7.744-.832 3.744-1.568 11.168-1.568 11.168-.224 2.272-.224 4.032.032 6.304 0 0 .736 6.464 1.088 7.808.128 1.824.576 4.512 1.12 6.976h-.032c.448 2.08 1.12 4.096 1.984 6.08.48 1.536.992 2.976 1.472 4.032C126.432 733.856 316.992 864 512 864c195.136 0 385.696-130.048 473.216-321.696 1.376-2.496 2.24-4.832 2.848-6.912.256-.608.48-1.184.672-1.728 1.536-4.48 1.856-8.32 1.728-8.32l-.032.032c.608-3.104 1.568-7.744 1.568-13.28zM512 672c-88.224 0-160-71.776-160-160s71.776-160 160-160 160 71.776 160 160-71.776 160-160 160z" fill="currentColor"></path></svg> <span id="/cs-basic/os/wangdao/2/3/" data-flag-title="同步与互斥" class="leancloud_visitors waline-visitor-count"><span class="leancloud-visitors-count">...</span></span></span><span aria-label="Writing Date📅" data-balloon-pos="down" defaultAuthor="lllllan" categoryPath="/category/$category/" tagPath="/tag/$tag/" class="time-info"><svg viewBox="0 0 1030 1024" xmlns="http://www.w3.org/2000/svg" class="icon calendar-icon"><path d="M716.4 110.137c0-18.753-14.72-33.473-33.472-33.473-18.753 0-33.473 14.72-33.473 33.473v33.473h66.993v-33.473zm-334.87 0c0-18.753-14.72-33.473-33.473-33.473s-33.52 14.72-33.52 33.473v33.473h66.993v-33.473zm468.81 33.52H716.4v100.465c0 18.753-14.72 33.473-33.472 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H381.53v100.465c0 18.753-14.72 33.473-33.473 33.473a33.145 33.145 0 0 1-33.473-33.473V143.657H180.6A134.314 134.314 0 0 0 46.66 277.595v535.756A134.314 134.314 0 0 0 180.6 947.289h669.74a134.36 134.36 0 0 0 133.94-133.938V277.595a134.314 134.314 0 0 0-133.94-133.938zm33.473 267.877H147.126a33.145 33.145 0 0 1-33.473-33.473c0-18.752 14.72-33.473 33.473-33.473h736.687c18.752 0 33.472 14.72 33.472 33.473a33.145 33.145 0 0 1-33.472 33.473z" fill="currentColor"></path></svg> <span property="datePublished">2022-3-31</span></span><span role="navigation" aria-label="Category🌈" data-balloon-pos="down" defaultAuthor="lllllan" tagPath="/tag/$tag/" class="category-info enable"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon category-icon"><path d="M148.41 106.992h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H148.41c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.311-40.31zm-.854 446.486H429.73c22.263 0 40.311 18.048 40.311 40.31v282.176c0 22.263-18.048 40.312-40.31 40.312H147.555c-22.263 0-40.311-18.049-40.311-40.312V593.79c0-22.263 18.048-40.311 40.31-40.311zm446.371-446.486h282.176c22.263 0 40.31 18.048 40.31 40.31V429.48c0 22.263-18.047 40.31-40.31 40.31H593.927c-22.263 0-40.311-18.047-40.311-40.31V147.302c0-22.263 18.048-40.31 40.31-40.31zm136.293 813.51H623.926c-40.925 0-74.22-33.388-74.22-74.425V623.992c0-41.038 33.387-74.424 74.425-74.424h222.085c41.038 0 74.424 33.226 74.424 74.067v114.233c0 10.244-8.304 18.548-18.547 18.548s-18.548-8.304-18.548-18.548V623.635c0-20.388-16.746-36.974-37.33-36.974H624.13c-20.585 0-37.331 16.747-37.331 37.33v222.086c0 20.585 16.654 37.331 37.126 37.331H730.22c10.243 0 18.547 8.304 18.547 18.547 0 10.244-8.304 18.547-18.547 18.547z" fill="currentColor"></path></svg> <span property="articleSection">计算机基础</span></span><span aria-label="Tags🏷" data-balloon-pos="down" defaultAuthor="lllllan" categoryPath="/category/$category/"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon tag-icon"><path d="M939.902 458.563 910.17 144.567c-1.507-16.272-14.465-29.13-30.737-30.737L565.438 84.098h-.402c-3.215 0-5.726 1.005-7.634 2.913l-470.39 470.39a10.004 10.004 0 0 0 0 14.164l365.423 365.424c1.909 1.908 4.42 2.913 7.132 2.913s5.223-1.005 7.132-2.913l470.39-470.39c2.01-2.11 3.014-5.023 2.813-8.036zm-240.067-72.121c-35.458 0-64.286-28.828-64.286-64.286s28.828-64.285 64.286-64.285 64.286 28.828 64.286 64.285-28.829 64.286-64.286 64.286z" fill="currentColor"></path></svg> <ul class="tags-wrapper"><li class="tag clickable tag0"><span role="navigation">操作系统</span></li><li class="tag clickable tag1"><span role="navigation">王道-操作系统</span></li></ul> <meta property="keywords" content="操作系统,王道-操作系统"></span><span aria-label="Reading Time⌛" data-balloon-pos="down" defaultAuthor="lllllan" categoryPath="/category/$category/" tagPath="/tag/$tag/" class="reading-time-info"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon timer-icon"><path d="M799.387 122.15c4.402-2.978 7.38-7.897 7.38-13.463v-1.165c0-8.933-7.38-16.312-16.312-16.312H256.33c-8.933 0-16.311 7.38-16.311 16.312v1.165c0 5.825 2.977 10.874 7.637 13.592 4.143 194.44 97.22 354.963 220.201 392.763-122.204 37.542-214.893 196.511-220.2 389.397-4.661 5.049-7.638 11.651-7.638 19.03v5.825h566.49v-5.825c0-7.379-2.849-13.981-7.509-18.9-5.049-193.016-97.867-351.985-220.2-389.527 123.24-37.67 216.446-198.453 220.588-392.892zM531.16 450.445v352.632c117.674 1.553 211.787 40.778 211.787 88.676H304.097c0-48.286 95.149-87.382 213.728-88.676V450.445c-93.077-3.107-167.901-81.297-167.901-177.093 0-8.803 6.99-15.793 15.793-15.793 8.803 0 15.794 6.99 15.794 15.793 0 80.261 63.69 145.635 142.01 145.635s142.011-65.374 142.011-145.635c0-8.803 6.99-15.793 15.794-15.793s15.793 6.99 15.793 15.793c0 95.019-73.789 172.82-165.96 177.093z" fill="currentColor"></path></svg> <span>About 37 min</span> <meta property="timeRequired" content="PT37M"></span></div> <!----> <hr></div> <div class="anchor-place-holder"><aside id="anchor"><div class="anchor-wrapper"><ul class="anchor-list"><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#一、同步与互斥的基本概念" class="anchor-link heading2"><div>一、同步与互斥的基本概念</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_1-1-临界资源" class="anchor-link heading3"><div>1.1 临界资源</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_1-2-同步" class="anchor-link heading3"><div>1.2 同步</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_1-3-互斥" class="anchor-link heading3"><div>1.3 互斥</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#二、实现临界区互斥的基本方法" class="anchor-link heading2"><div>二、实现临界区互斥的基本方法</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_2-1-软件实现方法" class="anchor-link heading3"><div>2.1 软件实现方法</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_2-2-硬件实现方法" class="anchor-link heading3"><div>2.2 硬件实现方法</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#三、互斥锁" class="anchor-link heading2"><div>三、互斥锁</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#四、信号量" class="anchor-link heading2"><div>四、信号量</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_4-1-整型信号量" class="anchor-link heading3"><div>4.1 整型信号量</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_4-2-记录型信号量" class="anchor-link heading3"><div>4.2 记录型信号量</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_4-3-利用信号量实现同步" class="anchor-link heading3"><div>4.3 利用信号量实现同步</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_4-4-利用信号量实现进程互斥" class="anchor-link heading3"><div>4.4 利用信号量实现进程互斥</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#五、管程" class="anchor-link heading2"><div>五、管程</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_5-1-管程的定义" class="anchor-link heading3"><div>5.1 管程的定义</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_5-2-条件变量" class="anchor-link heading3"><div>5.2 条件变量</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#六、经典同步问题" class="anchor-link heading2"><div>六、经典同步问题</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_6-1-生产者-消费者问题" class="anchor-link heading3"><div>6.1 生产者-消费者问题</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_6-2-读者-写者问题" class="anchor-link heading3"><div>6.2 读者-写者问题</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_6-3-哲学家进餐问题" class="anchor-link heading3"><div>6.3 哲学家进餐问题</div></a></li><li class="anchor"><a href="/cs-basic/os/wangdao/2/3/#_6-4-吸烟者问题" class="anchor-link heading3"><div>6.4 吸烟者问题</div></a></li></ul></div></aside></div> <!----> <div class="content__content-top"></div> <div class="theme-default-content content__default"><div class="custom-block warning"><p class="custom-block-title">转载声明</p> <ul><li>《王道考研-操作系统》</li> <li><a href="https://blog.csdn.net/weixin_34097242/article/details/86458859" target="_blank" rel="noopener noreferrer">开中断和关中断<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <h2 id="一、同步与互斥的基本概念"><a href="#一、同步与互斥的基本概念" class="header-anchor">#</a> 一、同步与互斥的基本概念</h2> <p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p> <blockquote><p>例如，让系统计算 <code>1 + 2 x 3</code>，假设系统产生两个进程：一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后，但实际，上操作系统具有异步性，若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生，而这种机制就是本节要讨论的内容。</p></blockquote> <h3 id="_1-1-临界资源"><a href="#_1-1-临界资源" class="header-anchor">#</a> 1.1 临界资源</h3> <div class="custom-block info"><p class="custom-block-title">临界资源</p> <p>一次仅允许一个进程使用的资源称为临界资源</p></div> <p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所用。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p> <p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分:</p> <ol><li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li> <li><strong>临界区</strong>。进程中访问临界资源的那段代码，又称临界段。</li> <li><strong>退出区</strong>。将正在访问临界区的标志清除。</li> <li><strong>剩余区</strong>。代码中的其余部分。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">do</span> <span class="token punctuation">{</span>
    entry section<span class="token punctuation">;</span>  	<span class="token comment">//进入区</span>
    critical section<span class="token punctuation">;</span>	<span class="token comment">//临界区</span>
    exit section<span class="token punctuation">;</span> 		<span class="token comment">//退出区</span>
    remainder section<span class="token punctuation">;</span>	<span class="token comment">//剩余区</span>
<span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="_1-2-同步"><a href="#_1-2-同步" class="header-anchor">#</a> 1.2 同步</h3> <div class="custom-block info"><p class="custom-block-title">同步</p> <p>同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</p></div> <blockquote><p>进程间的直接制约关系源于它们之间的相互合作。例如，输入进程 A 通过单缓冲向进程 B 提供数据。当该缓冲区空时，进程 B 不能获得所需数据而阻塞，一旦进程 A 将数据送入缓冲区，进程 B 就被唤醒。反之，当缓冲区满时，进程 A 被阻塞，仅当进程 B 取走缓冲数据时，才唤醒进程 A。</p></blockquote> <h3 id="_1-3-互斥"><a href="#_1-3-互斥" class="header-anchor">#</a> 1.3 互斥</h3> <div class="custom-block info"><p class="custom-block-title">互斥</p> <p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p></div> <blockquote><p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，若进程A需要打印时，系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程 B将打印机释放，系统便将进程A唤醒，并将其由阻塞态变为就绪态。</p></blockquote> <p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则:</p> <ol><li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li> <li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li> <li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区。</li> <li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li></ol> <h2 id="二、实现临界区互斥的基本方法"><a href="#二、实现临界区互斥的基本方法" class="header-anchor">#</a> 二、实现临界区互斥的基本方法</h2> <h3 id="_2-1-软件实现方法"><a href="#_2-1-软件实现方法" class="header-anchor">#</a> 2.1 软件实现方法</h3> <p>在进入区设置并检查一些标志 来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p> <hr> <p>算法一：<strong>单标志法</strong>。</p> <p>该算法设置一个公用整型变量 <code>turn</code>，用于指示被允许进入临界区的进程编号，即若 <code>turn = 0</code> ，则允许 P0 进程进入临界区。该算法可确保每次只允许一个进程进入临界区。</p> <!----> <p>但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（ <mark>违背【空闲让进】</mark> ）。这样很容易造成资源利用不充分。若 P0 顺利进入临界区并从临界区离开，则此时临界区是空闲的，但 P1 并没有进入临界区的打算，<code>turn = 1</code> 一直成立，P0 就无法再次进入临界区（一直被while死循环困住）。</p> <hr> <p>算法二：<strong>双标志法先检查</strong>。</p> <p>该算法的基本思想是在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置一个数据 <code>flag[i]</code>，如第i 个元素值为 FALSE，表示 Pi 进程未进入临界区，值为TRUE，表示 Pi 进程进入临界区。</p> <!----> <ul><li>优点：不用交替进入，可连续使用；</li> <li>缺点：Pi 和 Pj 可能同时进入临界区。按序列①②③④执行时，会同时进入临界区（ <mark>违背【忙则等待】</mark> ）。即在检查对方的 flag 后和切换自己的 flag 前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</li></ul> <hr> <p>算法三：<strong>双标志法后检查</strong>。</p> <p>算法二先检测对方的进程状态标志，再置自己的标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后同时进入临界区。为此，算法三先将自己的标志设置为TRUE，再检测对方的状态标志，若对方标志为 TRUE，则进程等待；否则进入临界区。</p> <!----> <p>两个进程几乎 同时都想进入临界区时，它们分别将自己的标志值 flag 设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区时，双方互相谦让，结果谁也进不了临界区，从而 <mark>导致【饥饿】现象</mark></p> <hr> <p>算法四：<strong>Peterson's Algorithm</strong>。</p> <p>为了防止两个进程为进入临界区而无限期等待，又设置了变量 turn，每个进程在先设置自己的标志后再设置 turn 标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</p> <!----> <p>具体如下：考虑进程 Pi，一旦设置 <code>flag[i] = true</code>，就表示它想要进入临界区，同时 <code>turn = j</code>，此时若进程 Pj 已在临界区中，符合进程 Pi 中的 while 循环条件，则 Pi 不能进入临界区。若 Pj 不想要进入临界区，即 <code>flag[j] = false</code>， 循环条件不符合，则 Pi 可以顺利进入，反之亦然。本算法的基本思想是算法一和算法三的结合。利用 flag 解决临界资源的互斥访问，而利用 turn 解决【饥饿】现象。理解Peterson's Algorithm的最好方法就是手动模拟。</p> <h3 id="_2-2-硬件实现方法"><a href="#_2-2-硬件实现方法" class="header-anchor">#</a> 2.2 硬件实现方法</h3> <p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称 <mark>元方法</mark></p> <h4 id="_1-中断屏蔽方法"><a href="#_1-中断屏蔽方法" class="header-anchor">#</a> <strong>1. 中断屏蔽方法</strong></h4> <p>当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简方法是关中断。因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。其典型模式为</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>关中断<span class="token punctuation">;</span>
临界区<span class="token punctuation">;</span>
开中断<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><strong>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低</strong>。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p> <div class="custom-block tip"><p class="custom-block-title">关中断</p> <p>关中断和开中断其实就是像我们生活中的开关一样。 关中断是为了保护一些不能中途停止执行的程序而设计的，计算机的CPU进行的是时分复用，即每个时钟周期内，CPU只能执行一条指令。在多道程序设计的环境下（就是我们通常所说的多个程序同时运行时），CPU是不断地交替地将这些程序的指令一条一条的分别执行，这样从宏观上看我们就感觉多个程序是在同时执行，但从微观上看则是CPU在不同的时间段（极短）内执行着不同程序的单条指令。而CPU在这些指令之间的切换就是通过中断来实现的。关中断就是为了让CPU在一段时间内执行同一程序的多条指令而设计的，比如在出现了非常事件后又恢复正常时，CPU就会忙于恢复非常事件出现之前计算机的工作环境（通常叫做恢复现场），在恢复现场的时候，CPU是不允许被其他的程序打扰的，此时就要启动关中断，不再相应其他的请求。当现场恢复完毕后，CPU就启动开中断，其他等待着的程序的指令就开始被CPU执行，计算机恢复正常。</p> <div class="custom-block danger"><p class="custom-block-title">多核下的关中断又是怎么样的呢？</p></div></div> <hr> <h4 id="_2-硬件指令方法"><a href="#_2-硬件指令方法" class="header-anchor">#</a> <strong>2. 硬件指令方法</strong></h4> <div class="custom-block note"><p class="custom-block-title">TestAndSet 指令</p> <p>这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。指令的功能描述如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>boolean <span class="token function">TestAndSet</span> <span class="token punctuation">(</span>boolean <span class="token operator">*</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    boolean old<span class="token punctuation">;</span>
    old <span class="token operator">=</span> <span class="token operator">*</span>lock<span class="token punctuation">;</span>
    <span class="token operator">*</span>lock <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> old<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>可以为每个临界资源设置一个共享布尔变量 lock，表示资源的两种状态：true表示正被占用，初值为 false。 进程在进入临界区之前，利用 TestAndSet 检查标志 lock，若无进程在临界区，则其值为 false，可以进入，关闭临界资源，把 lock 置为 true，使任何进程都不能进入临界区；若有进程在临界区，则循环检查，直到进程退出。利用该指令实现互斥的过程描述如下:</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><div class="highlighted"> </div><br><br><br><br></div><pre class="language-cpp"><code><span class="token keyword">while</span> <span class="token function">TestAndSet</span> <span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
进程的临界区代码段<span class="token punctuation">;</span>
lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
进程的其他代码<span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div></div> <div class="custom-block note"><p class="custom-block-title">Swap指令</p> <p>该指令的功能是交换两个字(字节)的内容。其功能描述如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">Swap</span><span class="token punctuation">(</span>boolean <span class="token operator">*</span>a<span class="token punctuation">,</span> boolean <span class="token operator">*</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    boolean temp<span class="token punctuation">;</span>
    Temp <span class="token operator">=</span> <span class="token operator">*</span>a<span class="token punctuation">;</span> 
    <span class="token operator">*</span>a <span class="token operator">=</span> tb<span class="token punctuation">;</span>
    <span class="token operator">*</span>b <span class="token operator">=</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p>注意：以上对 TestAndSet 和 Swap 指令的描述仅是功能实现，而并非软件实现的定义。事实上，它们是由硬件逻辑直接实现的，不会被中断。</p></blockquote> <p>用 Swap 指令可以简单有效地实现互斥，为每个临界资源设置一个共享布尔变量 lock，初值为 false；在每个进程中再设置一个局部布尔变量 key，用于与 lock 交换信息。在进入临界区前，先利用 Swap 指令交换 lock 与 key 的内容，然后检查 key 的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。其处理过程描述如下:</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><div class="highlighted"> </div><br><br><br><br></div><pre class="language-cpp"><code>key <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">while</span> <span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token function">Swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">,</span> <span class="token operator">&amp;</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
进程的临界区代码段<span class="token punctuation">;</span>
lock <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
进程的其他代码<span class="token punctuation">;</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div></div> <div class="custom-block tip"><p class="custom-block-title">硬件方法的优缺点</p> <p>硬件方法的优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p> <p>硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择-一个进入临界区，有的进程可能一直选不上， 从而导致【饥饿】现象。</p></div> <h2 id="三、互斥锁"><a href="#三、互斥锁" class="header-anchor">#</a> 三、互斥锁</h2> <p>解决临界区最简单的工具就是 <strong>互斥锁(mutex lock)</strong>。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数 acquire() 获得锁，而函数 release() 释放锁。每个互斥锁有一个布尔变量 available，表示锁是否可用。如果锁是可用的，调用 acqiure() 会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span>available<span class="token punctuation">)</span><span class="token punctuation">;</span>	<span class="token comment">//忙等待</span>
    available <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>	<span class="token comment">//获得锁</span>
<span class="token punctuation">}</span>

<span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    available <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span> 	<span class="token comment">//释放锁</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>acquire() 或 release() 的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p> <p><strong>互斥锁的主要缺点是忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p> <h2 id="四、信号量"><a href="#四、信号量" class="header-anchor">#</a> 四、信号量</h2> <p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 wait(S) 和 signal(S) 访问，也可记为【P操作，申请资源】和【V操作，释放资源】。</p> <div class="custom-block info"><p class="custom-block-title">原语</p> <p>原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。</p></div> <blockquote><p>例如，前述的 Test-and-Set 和 Swap 指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。原语之所以不能被中断执行，是因为原语对变量的操作过程若被打断，可能会去运行另一个对同一-变量的操作过程，从而出现临界段问题。</p></blockquote> <h3 id="_4-1-整型信号量"><a href="#_4-1-整型信号量" class="header-anchor">#</a> 4.1 整型信号量</h3> <p>整型信号量被定义为一个用于表示资源数目的整型量 s，wait 和 signal 操作可描述为</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">wait</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    S <span class="token operator">=</span> S <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">signal</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    S <span class="token operator">=</span> S <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>在整型信号量机制中的 wait 操作，只要信号量 S ≤ 0，就会不断地测试。</p> <p>因此，<mark>该机制并未遵循【让权等待】的准则，而是使进程处于【忙等】的状态</mark></p> <h3 id="_4-2-记录型信号量"><a href="#_4-2-记录型信号量" class="header-anchor">#</a> 4.2 记录型信号量</h3> <p>记录型信号量机制是一种不存在【忙等】现象的进程同步机制。除了需要一个用于代表资源数目的整型变量 value外，再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">process</span> <span class="token operator">*</span>L<span class="token punctuation">;</span>
<span class="token punctuation">}</span> semaphore<span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>相应的 wait(S) 和 signal(S) 的操作如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//相当于申请资源</span>
    s<span class="token punctuation">.</span>value<span class="token operator">--</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        add <span class="token keyword">this</span> process to S<span class="token punctuation">.</span>L<span class="token punctuation">;</span>
        <span class="token function">block</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>L<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>wait 操作，<code>S.value--</code> 表示进程请求一个该类资源，当 <code>S.value &lt; 0</code> 时，表示该类资源已分配完毕，因此进程应调用 block 原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列 S.L，可见该机制遵循了【让权等待】的准则。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">signal</span><span class="token punctuation">(</span>semaphore S<span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//相当于释放资源</span>
    s<span class="token punctuation">.</span>value<span class="token operator">++</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>S<span class="token punctuation">.</span>value <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        remove a process P from S<span class="token punctuation">.</span>L<span class="token punctuation">;</span>
        <span class="token function">wakeup</span><span class="token punctuation">(</span>P<span class="token punctuation">)</span> <span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>signal 操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，因此有 <code>S.value++</code>。若加1后仍是 <code>S.value &lt;= 0</code> ，则表示在 S.L 中仍有等待该资源的进程被阻塞，因此还应调用 wakeup 原语，将 S.L 中的第一个等待进程唤醒。</p> <h3 id="_4-3-利用信号量实现同步"><a href="#_4-3-利用信号量实现同步" class="header-anchor">#</a> 4.3 利用信号量实现同步</h3> <p>信号量机制能用于解决进程间的各种同步问题。设 S 为实现进程 P1，P2 同步的公共信号量，初值为 0。进程 P2 中的语句 y 要使用进程 P1 中语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。其实现进程同步的算法如下：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>semaphore S <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>	<span class="token comment">//初始化信号量</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    x<span class="token punctuation">;</span> 				<span class="token comment">//语句x</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span>			<span class="token comment">//告诉进程P2，语句x已经完成</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">//检查语句x是否运行完成</span>
    y<span class="token punctuation">;</span> 				<span class="token comment">//检查无误，运行y语句</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>若 P2 先执行到 P(S) 时，S 为 0，执行 P 操作会把进程 P2 阻塞，并放入阻塞队列；当进程 P1 中的 x 执行完后，执行 V 操作，把 P2 从阻塞队列中放回就绪队列，当 P2 得到处理机时，就得以继续执行。</p> <h3 id="_4-4-利用信号量实现进程互斥"><a href="#_4-4-利用信号量实现进程互斥" class="header-anchor">#</a> 4.4 利用信号量实现进程互斥</h3> <p>信号量机制也能很方便地解决进程互斥问题。设 S 为实现进程 P1，P2 互斥的信号量，由于每次只允许一个进程进入临界区，所以 S 的初值应为 1 (即可用资源数为1)。只需把临界区置于 P(S) 和 V(S) 之间，即可实现两个进程对临界资源的互斥访问。其算法如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>semaphore S <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>	<span class="token comment">//初始化信号量</span>

<span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">//准备开始访问临界资源，加锁</span>
    进程P1的临界区<span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">//访问结束，解锁</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>

<span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token function">P</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">//准备开始访问临界资源，加锁</span>
    进程P2的临界区<span class="token punctuation">;</span>
    <span class="token function">V</span><span class="token punctuation">(</span>S<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">//访问结束，解锁</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>当没有进程在临界区时，任意一个进程要进入临界区，就要执行 P 操作，把 S 的值减为 0，然后进入临界区；当有进程存在于临界区时，S 的值为 0，再有进程要进入临界区，执行 P 操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。</p> <p>互斥是不同进程对同一信号量进行 P，V 操作实现的，一个进程成功对信号量执行了 P 操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行 V 操作，表示当前没有进程进入临界区，可以让其他进程进入。</p> <h2 id="五、管程"><a href="#五、管程" class="header-anchor">#</a> 五、管程</h2> <p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的 PV 操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具——管程。 管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p> <h3 id="_5-1-管程的定义"><a href="#_5-1-管程的定义" class="header-anchor">#</a> 5.1 管程的定义</h3> <p>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。</p> <p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程( monitor)。管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。</p> <p>由上述定义可知，管程由4部分组成：</p> <ol><li>管程的名称</li> <li>局部于管程内部的共享数据结构说明</li> <li>对该数据结构进行操作的一组过程(或函数)</li> <li>对局部于管程内部的共享数据设置初始值的语句。</li></ol> <p>管程的定义描述举例如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>monitor Demo <span class="token punctuation">{</span> <span class="token comment">// 1.定义一个名称为“Demo&quot;的管程</span>
    <span class="token comment">// 2. 定义共享数据结构，对应系统中的某种共享资源</span>
    共享数据结构S<span class="token punctuation">;</span>
    
    <span class="token comment">// 4. 对共享数据结构初始化的语句</span>
    <span class="token function">init_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        S <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// 初始资源数等于5</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 过程1：申请一个资源</span>
    <span class="token function">take_away</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        对共享 数据结构x的一系列处理<span class="token punctuation">;</span>
        S<span class="token operator">--</span><span class="token punctuation">;</span> <span class="token comment">//可用资源数-1</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>

    <span class="token comment">// 3. 过程2：归还一个资源</span>
    <span class="token function">give_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        对共享数据结构x的一系列处理<span class="token punctuation">;</span>
        S<span class="token operator">++</span><span class="token punctuation">;</span> <span class="token comment">//可用资源数+1</span>
        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>熟悉面向对象程序设计的读者看到管程的组成后，会立即联想到管程很像一个类 (class)。</p> <ol><li>管程把对共享资源的操作封装起来，管程内的共享数据结构只能被管程内的过程所访问。一个进程只有通过调用管程内的过程才能进入管程访问共享资源。对于上例，外部进程只能通过调用 <code>take_away()</code> 过程来申请一个资源；归还资源也一样。</li> <li>每次仅允许一个进程进入管程，从而实现进程互斥。若多个进程同时调用 <code>take_away()</code>，<code>give back()</code>，则只有某个进程运行完它调用的过程后，下个进程才能开始运行它调用的过程。也就是说，各个进程只能串行执行管程内的过程，这一特性保证了进程【互斥】访问共享数据结构 S。</li></ol> <h3 id="_5-2-条件变量"><a href="#_5-2-条件变量" class="header-anchor">#</a> 5.2 条件变量</h3> <p>当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其他进程无法进入管程。为此，将阻塞原因定义为条件变量 condition。 通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即 wait 和 signal。</p> <ul><li>x.wait：当x对应的条件不满足时，正在调用管程的进程调用 x.wait 将自己插入 x 条件的等待队列，并释放管程。此时其他进程可以使用该管程。</li> <li>x.signal：x对应的条件发生了变化，则调用 x.signal，唤醒一个因 x 条件而阻塞的进程。</li></ul> <p>下面给出条件变量的定义和使用:</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><div class="highlighted"> </div><br><br><br></div><pre class="language-cpp"><code>monitor Demo <span class="token punctuation">{</span>
    共享数据结构S<span class="token punctuation">;</span>
    condition x<span class="token punctuation">;</span> <span class="token comment">// 定义一个条件变量x</span>

    <span class="token function">init_code</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span>

    <span class="token function">take_away</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>S <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> x<span class="token punctuation">.</span><span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 资源不够， 在条件变量x上阻塞等待</span>
        资源足够，分配资源，做一系列相应处理<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">give_back</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        归还资源，做一系列相应处理<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>有进程在等待<span class="token punctuation">)</span> x<span class="token punctuation">.</span>signal<span class="token punctuation">;</span> <span class="token comment">// 唤醒一个阻塞进程</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>条件变量和信号量的比较：</p> <p>相似点：条件变量的 wait/signal 操作类似于信号量的 P/V 操作，可以实现进程的阻塞/唤醒。</p> <p>不同点：条件变量是【没有值】的，仅实现了【排队等待】功能；而信号量是【有值】的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</p> <h2 id="六、经典同步问题"><a href="#六、经典同步问题" class="header-anchor">#</a> 六、经典同步问题</h2> <h3 id="_6-1-生产者-消费者问题"><a href="#_6-1-生产者-消费者问题" class="header-anchor">#</a> 6.1 生产者-消费者问题</h3> <p>问题描述：一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p> <p>问题分析：</p> <ol><li>关系分析。<strong>生产者和消费者对缓冲区互斥访问是互斥关系</strong>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，<strong>它们也是同步关系</strong>。</li> <li>整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步 PV 操作的位置。</li> <li>信号量设置。信号量 mutex 作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为1；信号量 full 用于记录当前缓冲池中的【满】缓冲区数，初值为 0。信号量 empty 用于记录当前缓冲池中的【空】缓冲区数，初值为 n。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 				<span class="token comment">// 临界区互斥信号量</span>
semaphore empty <span class="token operator">=</span> n<span class="token punctuation">;</span> 				<span class="token comment">// 空闲缓冲区</span>
semaphore full <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 				<span class="token comment">// 缓冲区初始化为空</span>
<span class="token function">producer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 						<span class="token comment">// 生产者进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        produce an item in nextp<span class="token punctuation">;</span> 	<span class="token comment">// 生产数据</span>
        <span class="token function">P</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 获取空缓冲区单元</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 进入临界区</span>
        add nextp to buffer<span class="token punctuation">;</span> 		<span class="token comment">// 将数据放入缓冲区</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>  					<span class="token comment">// 离开临界区，释放互斥信号量</span>
        <span class="token function">V</span><span class="token punctuation">(</span>full<span class="token punctuation">)</span><span class="token punctuation">;</span>  					<span class="token comment">// 满缓冲区数加1</span>
    <span class="token punctuation">}</span> 
<span class="token punctuation">}</span>

<span class="token function">consumer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 						<span class="token comment">// 消费者进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>fu1l<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 获取满缓冲区单元</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 进入临界区</span>
        remove an item from buffer<span class="token punctuation">;</span> <span class="token comment">// 从缓冲区中取出数据</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 离开临界区，释放互斥信号量</span>
        <span class="token function">V</span><span class="token punctuation">(</span>empty<span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 空缓冲区数加1</span>
        consume the item<span class="token punctuation">;</span> 			<span class="token comment">// 消费数据</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>该类问题要注意对缓冲区大小为 n 的处理，当缓冲区中有空时，便可对 empty 变量执行 P 操作，一旦取走一个产品便要执行V操作以释放空闲区。对 empty 和 full 变量的 P 操作必须放在对 mutex 的 P 操作之前。</p> <p>若生产者进程先执行 P(mutex)，然后执行 P(empty)，消费者执行 P(mutex)，然后执行 P(full)，这样可不可以？答案是否定的。设想生产者进程已将缓冲区放满，消费者进程并没有取产品，即 <code>empty= 0</code>，当下次仍然是生产者进程运行时，它先执行 P(mutex) 封锁信号量，再执行 P(empty) 时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行 P(mutex)，然而由于生产者进程已经封锁 mutex 信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，因此陷入了无休止的等待。</p> <p>同理，若消费者进程已将缓冲区取空，即 full= 0，下次若还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex，full 先释放哪一个 无所谓，消费者先释放 mutex 或 empty 都可以。</p> <p>根据对同步互斥问题的简单总结，我们发现，其实生产者消费者问题只是一个同步互斥问题的综合而已。</p> <hr> <p>下面再看一个较为复杂的生产者-消费者问题。</p> <p>问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出</p> <p><img src="/assets/img/image-20220331091841339.c5f5b997.png" alt="image-20220331091841339" loading="lazy"></p> <p>问题分析：</p> <ol><li>关系分析。这里的关系要稍复杂一些。由每次只能向其中放入一个水果可知，爸爸和妈妈是互斥关系。
爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步
关系，因为他们是选择条件执行，不可能并发，如图2.11所示。</li> <li>整理思路。这里有4个进程，实际上可抽象为两个生产者和两个消费者被连接到大小为 1 的缓冲区上。</li> <li>信号量设置。首先将信号量 plate 设置互斥信号量，表示是否允许向盘子放入水果，初值为 1 表示允许放入，且只允许放入一个。信号量 apple 表示盘子中是否有苹果，初值为 0 表示盘子为空，不许取，apple = 1表示可以取。信号量 orange 表示盘子中是否有橘子，初值为 0 表示盘子为空，不许取，orange = 1表示可以取。</li></ol> <p>解决该问题的代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>semaphore plate <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">,</span> apple <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> orange <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">dad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 								<span class="token comment">// 父亲进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prepare an apple<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 互斥向盘中取、放水果</span>
        put the apple on the plate<span class="token punctuation">;</span>		<span class="token comment">// 向盘中放苹果</span>
        <span class="token function">V</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 允许取苹果</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">mom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 								<span class="token comment">// 母亲进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        prepare an orange<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 互斥向盘中取、放水果</span>
        put the orange on the plate<span class="token punctuation">;</span>	<span class="token comment">// 向盘中放橘子</span>
        <span class="token function">V</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 允许取橘子</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">son</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 								<span class="token comment">// 儿子进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>orange<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 互斥向盘中取橘子</span>
        take an orange from the plate<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 允许向盘中取、放水果</span>
        eat the orange<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">daughter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 							<span class="token comment">// 女儿进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span>l<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>apple<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 互斥向盘中取苹果</span>
        take an apple from the plate<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>plate<span class="token punctuation">)</span><span class="token punctuation">;</span> 						<span class="token comment">// 允许向盘中取、放水果</span>
        eat the apple<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br></div></div><p>进程间的关系如图2.11所示。dad() 和 daughter()、mom() 和 son() 必须连续执行，正因为如此，也只能在女儿拿走苹果后或儿子拿走橘子后才能释放盘子，即 V(plate) 操作。</p> <h3 id="_6-2-读者-写者问题"><a href="#_6-2-读者-写者问题" class="header-anchor">#</a> 6.2 读者-写者问题</h3> <p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p> <ol><li>允许多个读者可以同时对文件执行读操作</li> <li>只允许一个写者往文件中写信息</li> <li>任一写者在完成写操作之前不允许其他读者或写者工作</li> <li>写者执行写操作前，应让已有的读者和写者全部退出。</li></ol> <p>问题分析：</p> <ol><li>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</li> <li>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须在实现与写者互斥的同时，实现与其他读者的同步，因此简单的一-对P操作、V操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。同时，这里不
同读者对计数器的访问也应该是互斥的。</li> <li>信号量设置。首先设置信号量 count 为计数器，用于记录当前读者的数量，初值为 0；设置 mutex 为互斥信号量，用于保护更新 count 变量时的互斥；设置互斥信号量 rw，用于保证读者和写者的互斥访问。</li></ol> <p>代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 				<span class="token comment">// 用于记录当前的读者数量</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">// 用于保护更新count变量时的互斥</span>
semaphore rw <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 			<span class="token comment">// 用于保证读者和写者互斥地访问文件</span>
<span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 					<span class="token comment">// 写者进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> 				<span class="token comment">// 互斥访问共享文件</span>
        writing<span class="token punctuation">;</span> 			<span class="token comment">// 写入</span>
        <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 释放共享文件</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 					<span class="token comment">// 读者进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 互斥访问count变量</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 		<span class="token comment">// 当第一个读进程读共享文件时</span>
            <span class="token function">P</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 阻止写进程写</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> 			<span class="token comment">// 读者计数器加1</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>	 		<span class="token comment">// 释放互斥变量count</span>
        
        reading<span class="token punctuation">;</span>  			<span class="token comment">// 读取</span>
        
        <span class="token function">P</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 互斥访问count变量</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> 			<span class="token comment">// 读者计数器减1</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 		<span class="token comment">// 当最后一个读进程读完共享文件</span>
            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 允许写进程写</span>
        <span class="token function">V</span><span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 释放互斥变量count</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在 <mark>写进程【饿死】的情况</mark></p> <p>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的 writer() 和 reader() 函数中各增加一对 PV 操作，就可以得到写进程优先的解决程序。</p> <div class="language-cpp line-numbers-mode"><div class="highlight-lines"><br><br><br><br><br><br><div class="highlighted"> </div><br><br><br><div class="highlighted"> </div><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><div class="highlighted"> </div><br><br><br><br><br><br><br><br><br><br><br></div><pre class="language-cpp"><code><span class="token keyword">int</span> count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 				<span class="token comment">// 用于记录当前的读者数量</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>		<span class="token comment">// 用于保护更新count变量时的互斥</span>
semaphore rw <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 			<span class="token comment">// 用于保证读者和写者互斥地访问文件</span>
semaphore w <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>			<span class="token comment">// 用于实现写优先</span>
<span class="token function">writer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 					<span class="token comment">// 写者进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 在无写进程时请求进入</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 互斥访问共享文件</span>
        writing<span class="token punctuation">;</span> 			<span class="token comment">// 写入</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 释放共享文件</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 恢复对共享文件的访问</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token function">reader</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 					<span class="token comment">// 读者进程</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 在无写进程时请求进入</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 互斥访问count变量</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 	<span class="token comment">// 当第一个读进程读共享文件时</span>
            <span class="token function">P</span> <span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 阻止写进程写</span>
        count<span class="token operator">++</span><span class="token punctuation">;</span> 			<span class="token comment">// 读者计数器加1</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>	 		<span class="token comment">// 释放互斥变量count</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>w<span class="token punctuation">)</span><span class="token punctuation">;</span>				<span class="token comment">// 恢复对共享文件的访问</span>
        
        reading<span class="token punctuation">;</span>  			<span class="token comment">// 读取</span>
        
        <span class="token function">P</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 互斥访问count变量</span>
        count<span class="token operator">--</span><span class="token punctuation">;</span> 			<span class="token comment">// 读者计数器减1</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> 	<span class="token comment">// 当最后一个读进程读完共享文件</span>
            <span class="token function">V</span><span class="token punctuation">(</span>rw<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 允许写进程写</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 			<span class="token comment">// 释放互斥变量count</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><p>这里的写进程优先是相对而言的，有些书上把这个算法称为读写公平法，即读写进程具有一样的优先级。当一个写进程访问文件时，若先有一些读进程要求访问文件，后有另一个写进程要求访问文件，则当前访问文件的进程结束对文件的写操作时，会是一个读进程而不是一个写进程占用文件（在信号量w的阻塞队列上，因为读进程先来，因此排在阻塞队列队首，而V操作唤醒进程时唤醒的是队首进程），所以说这里的写优先是相对的，想要了解如何做到真正写者优先，</p> <p>可参考其他相关资料。读者-写者问题有一个关键的特征，即有一个互斥访问的计数器 count，因此遇到一个不太好解决的同步互斥问题时，要想一想用互斥访问的计数器 count 能否解决问题。</p> <h3 id="_6-3-哲学家进餐问题"><a href="#_6-3-哲学家进餐问题" class="header-anchor">#</a> 6.3 哲学家进餐问题</h3> <p><img src="/assets/img/image-20220331092329801.88f82844.png" alt="image-20220331092329801" loading="lazy"></p> <p>问题描述：一张圆桌边上坐着5名哲学家，每两名哲学家之间的桌上摆一根筷子，两根筷子中间是一碗米饭，如图2.12所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p> <p>问题分析：</p> <ol><li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li> <li>整理思路。显然，这里有5个进程。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：一是让他们同时拿两根筷子：二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li> <li>信号量设置。定义互斥信号量数组 <code>chopstick[5]={l, 1,1,1,1}</code> ，用于对5个筷子的互斥访问。哲学家按顺序编号为0~4，哲学家i左边筷子的编号为i,哲学家右边筷子的编号为 <code>(i + 1) % 5</code>。</li></ol> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 	<span class="token comment">// 定义信号量数组chopstick[5],并初始化</span>
<span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> 										<span class="token comment">// i号哲学家的进程</span>
    <span class="token keyword">do</span><span class="token punctuation">{</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 取左边筷子</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 取右边筷子</span>
        eat<span class="token punctuation">;</span> 								<span class="token comment">// 进餐</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 放回左边筷子</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 放回右边筷子</span>
        think<span class="token punctuation">;</span> 								<span class="token comment">// 思考</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时（都恰好执行完
<code>wait(chopstick[i);</code>）筷子已被拿光，等到他们再想拿右边的筷子时（执行 <code>wait(chopstick[(i + 1)%5]);</code>）就全被阻塞，因此出现了死锁。</p> <p>为防止死锁发生，可对哲学家进程施加一些限制条件，比如至多允许 4 名哲学家同时进餐；仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子：对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号哲学家刚好相反。</p> <p>制定的正确规则如下：假设采用第二种方法，当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>semaphore chopstick<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span> 	<span class="token comment">// 初始化信号量</span>
semaphore mutex <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> 						<span class="token comment">// 设置取筷子的信号量</span>
<span class="token function">Pi</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>	 									<span class="token comment">// i号哲学家的进程</span>
    <span class="token keyword">do</span><span class="token punctuation">{</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 							<span class="token comment">// 在取筷子前获得互斥量</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 取左边筷子</span>
        <span class="token function">P</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 取右边筷子</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span> 							<span class="token comment">// 释放取筷子的信号量</span>
        eat<span class="token punctuation">;</span> 								<span class="token comment">// 进餐</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 					<span class="token comment">// 放回左边筷子</span>
        <span class="token function">V</span> <span class="token punctuation">(</span>chopstick<span class="token punctuation">[</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 		<span class="token comment">// 放回右边筷子</span>
        think<span class="token punctuation">;</span> 								<span class="token comment">// 思考</span>
    <span class="token punctuation">}</span> <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>此外，还可采用AND型信号量机制来解决哲学家进餐问题，有兴趣的读者可以查阅相关资料，自行思考。熟悉ACM或有过相关训练的读者都应知道贪心算法，哲学家进餐问题的思想其实与贪心算法的思想截然相反，贪心算法强调争取眼前认为最好的，而不考虑后续会有什么后果。若哲学家进餐问题用贪心算法来解决，即只要眼前有筷子能拿起就拿起的话，就会出现死锁。然而，若不仅考虑眼前的一步，而且考虑下一步，即不因为有筷子能拿起就拿起，而考虑能不能一次拿起两根筷子才做决定的话，就会避免死锁问题，这就是哲学家进餐问题的思维精髓。</p> <h3 id="_6-4-吸烟者问题"><a href="#_6-4-吸烟者问题" class="header-anchor">#</a> 6.4 吸烟者问题</h3> <p>问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟， 抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复（让三个抽烟者轮流地抽烟）。</p> <p>问题分析：</p> <ol><li>关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知）。</li> <li>整理思路。显然这里有4个进程。供应者作为生产者向三个抽烟者提供材料。</li> <li>信号量设置。信号量 offerl，offer2，offer3 分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量 finish 用于互斥进行抽烟动作。</li></ol> <p>代码如下:</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> num <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 			<span class="token comment">// 存储随机数</span>
semaphore offer1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 	<span class="token comment">// 定义信号量对应烟草和纸组合的资源</span>
semaphore offer2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 	<span class="token comment">// 定义信号量对应烟草和胶水组合的资源</span>
semaphore offer3 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 	<span class="token comment">// 定义信号量对应纸和胶水组合的资源</span>
semaphore finish <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> 	<span class="token comment">// 定义信号量表示抽烟是否完成</span>

process <span class="token function">P1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>			<span class="token comment">// 供应者</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        num<span class="token operator">++</span><span class="token punctuation">;</span>
        num <span class="token operator">=</span> num <span class="token operator">%</span> <span class="token number">3</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>
            <span class="token function">V</span><span class="token punctuation">(</span>offerl<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 提供烟草和纸</span>
        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span>
            <span class="token function">V</span><span class="token punctuation">(</span>offer2<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 提供烟草和胶水</span>
        <span class="token keyword">else</span>
            <span class="token function">V</span><span class="token punctuation">(</span>offer3<span class="token punctuation">)</span><span class="token punctuation">;</span> 	<span class="token comment">// 提供纸和胶水</span>
        任意两种材料放在桌子上<span class="token punctuation">;</span>
        <span class="token function">P</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

process <span class="token function">P2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 			<span class="token comment">// 拥有烟草者</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>offer3<span class="token punctuation">)</span><span class="token punctuation">;</span>
        拿纸和胶水，卷成烟，抽掉<span class="token punctuation">;</span> 
        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
    
process <span class="token function">P3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 			<span class="token comment">// 拥有纸者</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>offer2<span class="token punctuation">)</span><span class="token punctuation">;</span>
        拿烟草和胶水，卷成烟，抽掉<span class="token punctuation">;</span>
        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

process <span class="token function">P4</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> 			<span class="token comment">// 拥有胶水者</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">P</span><span class="token punctuation">(</span>offerl<span class="token punctuation">)</span><span class="token punctuation">;</span>
        拿烟草和纸，卷成烟，抽掉<span class="token punctuation">;</span> 
        <span class="token function">V</span><span class="token punctuation">(</span>finish<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div></div> <!----> <div class="content__content-bottom"></div> <footer class="page-meta"><div class="edit-link"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon edit-icon"><path d="M117.953 696.992 64.306 959.696l265.931-49.336 450.204-452.505-212.284-213.376-450.204 452.513zm496.384-296.326L219.039 797.993l-46.108-46.34L568.233 354.33l46.104 46.335zm345.357-122.99-114.45 115.04-212.288-213.377 114.45-115.035 212.288 213.371zm0 0" fill="currentColor"></path></svg> <a href="https://github.com/lllllan-fv/notes/edit/main/cs-basic/os/wangdao/2/3/README.md" target="_blank" rel="noopener noreferrer">Edit this page</a></div> <div class="meta-item update-time"><span class="label">Last update:</span> <span class="info">2022年4月3日 16:48</span></div> <div class="meta-item contributors"><span class="label">Contributors: </span> <span class="info"><span title="email: 342310798@qq.com" class="contributor">
          lllllan
        </span> <!----></span></div></footer> <div class="page-nav"><p class="inner"><span class="prev"><a href="/cs-basic/os/wangdao/2/2/" class="prev"><svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon prev-icon"><path d="M906.783 588.79c-.02 8.499-6.882 15.36-15.38 15.37l-443.7-.01 75.704 191.682c2.52 6.42.482 13.763-5.038 17.91-5.52 4.168-13.138 4.147-18.616-.092L123.228 524.175a15.362 15.362 0 0 1-6-12.165c0-4.782 2.222-9.277 6-12.185L499.753 210.35a15.388 15.388 0 0 1 9.38-3.195c3.236 0 6.502 1.034 9.236 3.103 5.52 4.147 7.578 11.49 5.038 17.91L447.683 419.84l443.72-.01c8.498.01 15.36 6.881 15.36 15.36l.02 153.6z" fill="currentColor"></path></svg>
        处理机调度
      </a></span> <span class="next"><a href="/cs-basic/os/wangdao/2/4/">
        死锁
        <svg viewBox="0 0 1024 1024" xmlns="http://www.w3.org/2000/svg" class="icon next-icon"><path d="M906.772 512c0 4.772-2.211 9.267-5.99 12.175L524.257 813.66a15.37 15.37 0 0 1-18.616.092 15.368 15.368 0 0 1-5.038-17.91l75.714-191.672h-443.73c-8.488 0-15.36-6.881-15.36-15.36v-153.6c0-8.489 6.872-15.36 15.36-15.36h443.73l-75.714-191.682a15.358 15.358 0 0 1 5.048-17.91c5.51-4.158 13.128-4.137 18.606.092l376.525 289.485a15.323 15.323 0 0 1 5.99 12.165z" fill="currentColor"></path></svg></a></span></p></div> <!----> <!----> <div class="content__page-bottom"></div></main> <footer class="footer-wrapper"><!----> <div class="footer"><a href="https://beian.miit.gov.cn/" target="_blank">粤ICP备2021095794号</a></div> <div class="copyright">Copyright © 2022 lllllan</div></footer></div><div class="global-ui"><!----><!----><div id="pwa-install"><!----> <div id="install-modal-wrapper" style="display:none;"><div class="background"></div> <div class="install-modal"><div class="header"><button aria-label="Close" class="close-button"><svg width="23" height="22" xmlns="http://www.w3.org/2000/svg" class="icon close-icon"><path fill-rule="evenodd" clip-rule="evenodd" d="M1.12.358a1.224 1.224 0 011.729 0l8.92 8.914L20.686.358a1.224 1.224 0 011.73 1.728L13.497 11l8.92 8.913a1.222 1.222 0 11-1.73 1.729l-8.919-8.913-8.92 8.913a1.224 1.224 0 01-1.729-1.729L10.04 11l-8.92-8.914a1.222 1.222 0 010-1.728z" fill="currentColor"></path></svg></button> <div class="logo"><!----> <div class="title"><h1></h1> <p class="desc">This app can be installed on your PC or mobile device.  This will allow this web app to look and behave like any other installed app.  You will find it in your app lists and be able to pin it to your home screen, start menus or task bars.  This installed web app will also be able to safely interact with other apps and your operating system. </p></div></div></div> <div class="content"><div class="highlight"><!----> <!----></div> <div class="description"><h3>Description</h3> <p></p></div></div> <div class="button-wrapper"><button class="install-button">
        Install <span></span></button> <button class="cancel-button">
        Cancel
      </button></div></div></div></div><div tabindex="-1" role="dialog" aria-hidden="true" class="pswp"><div class="pswp__bg"></div> <div class="pswp__scroll-wrap"><div class="pswp__container"><div class="pswp__item"></div> <div class="pswp__item"></div> <div class="pswp__item"></div></div> <div class="pswp__ui pswp__ui--hidden"><div class="pswp__top-bar"><div class="pswp__counter"></div> <button title="Close" aria-label="Close" class="pswp__button pswp__button--close"></button> <button title="Share" aria-label="Share" class="pswp__button pswp__button--share"></button> <button title="Switch to full screen" aria-label="Switch to full screen" class="pswp__button pswp__button--fs"></button> <button title="Zoom in/out" aria-label="Zoom in/out" class="pswp__button pswp__button--zoom"></button> <div class="pswp__preloader"><div class="pswp__preloader__icn"><div class="pswp__preloader__cut"><div class="pswp__preloader__donut"></div></div></div></div></div> <div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class="pswp__share-tooltip"></div></div> <button title="Prev (Arrow Left)" aria-label="Prev (Arrow Left)" class="pswp__button pswp__button--arrow--left"></button> <button title="Next (Arrow Right)" aria-label="Next (Arrow Right)" class="pswp__button pswp__button--arrow--right"></button> <div class="pswp__caption"><div class="pswp__caption__center"></div></div></div></div></div></div></div>
    <script src="/assets/js/app.3cfaf037.js" defer></script><script src="/assets/js/vendors~layout-Layout.57f7cf63.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout~layout-NotFound.b5e5e957.js" defer></script><script src="/assets/js/page-同步与互斥.e0216efd.js" defer></script><script src="/assets/js/vendors~layout-Blog~layout-Layout.3d94df6c.js" defer></script>
  </body>
</html>
