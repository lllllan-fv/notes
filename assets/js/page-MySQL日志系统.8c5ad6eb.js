(window.webpackJsonp=window.webpackJsonp||[]).push([[35],{1137:function(o,t,l){"use strict";l.r(t);var e=l(1),r=Object(e.a)({},(function(){var o=this,t=o.$createElement,e=o._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":o.$parent.slotKey}},[e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[o._v("转载声明")]),o._v(" "),e("ul",[e("li",[e("a",{attrs:{href:"https://funnylog.gitee.io/mysql45/02%E8%AE%B2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html",target:"_blank",rel:"noopener noreferrer"}},[o._v("02讲日志系统"),e("OutboundLink")],1)]),o._v(" "),e("li",[e("a",{attrs:{href:"https://www.jianshu.com/p/d13b3c98ce30",target:"_blank",rel:"noopener noreferrer"}},[o._v("MySQL之Redo log - 简书 (jianshu.com)"),e("OutboundLink")],1)]),o._v(" "),e("li",[e("a",{attrs:{href:"https://www.cnblogs.com/f-ck-need-u/p/9010872.html#!comments",target:"_blank",rel:"noopener noreferrer"}},[o._v("详细分析MySQL事务日志(redo log和undo log) - 骏马金龙 - 博客园 (cnblogs.com)"),e("OutboundLink")],1),o._v(" ★")]),o._v(" "),e("li",[e("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/190886874",target:"_blank",rel:"noopener noreferrer"}},[o._v("必须了解的MySQL三大日志：binlog、redo log和undo log - 知乎 (zhihu.com)"),e("OutboundLink")],1)])])]),o._v(" "),e("p",[o._v("执行更新语句会涉及到两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。")]),o._v(" "),e("h2",{attrs:{id:"redo-log"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redo-log"}},[o._v("#")]),o._v(" redo log")]),o._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[o._v("redo log 是提升MySQL效率的同时保证数据持久化的物理日志")])]),o._v(" "),e("h3",{attrs:{id:"提升效率"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#提升效率"}},[o._v("#")]),o._v(" 提升效率")]),o._v(" "),e("p",[o._v("首先我们先明确一下 InnoDB 的修改数据的基本流程，当我们想要修改 DB 上某一行数据的时候，"),e("mark",[o._v("InnoDB 是把数据从磁盘读取到内存的缓冲池上进行修改")]),o._v("。")]),o._v(" "),e("p",[o._v("这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为"),e("strong",[o._v("脏页")]),o._v("。"),e("mark",[o._v("InnoDB 对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，如果每一次的更新都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个的IO成本、查找成本都很高")]),o._v("，严重影响 InnoDB 的处理性能。")]),o._v(" "),e("p",[o._v("既然脏页与磁盘中的数据存在差异，那么如果在这期间 DB 出现故障就会造成数据的丢失。为了解决这个问题，redo log 就应运而生了。每次都修改都将内容写进 redo log，事后有时间再更新到磁盘当中。")]),o._v(" "),e("h3",{attrs:{id:"数据持久化"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#数据持久化"}},[o._v("#")]),o._v(" 数据持久化")]),o._v(" "),e("p",[o._v("写内存要比写磁盘更快，所以 redo log 有一部分在内存当中。每次对数据修改只要写入 redo log 的内存部分，能够提升很多性能。但如果只是存在内存当中，发生故障的时候这个 redo log 照样也会丢失。")]),o._v(" "),e("p",[o._v("实际上，redo log 包括两部分："),e("mark",[o._v("重做日志缓冲（redo log buffer）")]),o._v(" ，这部分日志是易失性的， "),e("mark",[o._v("重做日志文件（redo log file）")]),o._v(" ，这部分日志是持久的。")]),o._v(" "),e("p",[e("mark",[o._v("想要保证持久化，就需要将数据/日志写到磁盘当中")]),o._v(" ，否则一出故障内存中的数据都会一起丢失。也就是说必须以损耗一定性能的代价，去保证数据的持久化。InnoDB 会采取一定的策略，将 buffer 中的日志写入到磁盘文件当中。如果某时刻出现故障，事后只要到 redo log file 中逐一将日志内容更新到数据库当中即可。")]),o._v(" "),e("div",{staticClass:"custom-block info"},[e("p",{staticClass:"custom-block-title"},[o._v("都是要写入磁盘，那还要 redo log 干嘛")]),o._v(" "),e("p",[o._v("区别就在于，数据库中的修改，你需要找到具体的位置对具体的信息进行修改。")]),o._v(" "),e("p",[o._v("如果是日志，你只要将这次修改的信息写到文件末即可。")])]),o._v(" "),e("h3",{attrs:{id:"log-file"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#log-file"}},[o._v("#")]),o._v(" log file")]),o._v(" "),e("p",[e("a",{attrs:{href:"https://www.cnblogs.com/f-ck-need-u/p/9010872.html#auto_id_2",target:"_blank",rel:"noopener noreferrer"}},[o._v("详细分析MySQL事务日志(redo log和undo log) - 骏马金龙 - 博客园 (cnblogs.com)"),e("OutboundLink")],1)]),o._v(" "),e("p",[o._v("在概念上，innodb 通过 "),e("strong",[o._v("force log at commit")]),o._v(" 机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的 redo log file 和 undo log file 中进行持久化。")]),o._v(" "),e("p",[o._v("为了确保每次日志都能写入到事务日志文件中，在每次将 log buffer 中的日志写入日志文件的过程中都会调用一次操作系统的 fsync 操作（即fsync()系统调用）。因为 MariaDB/MySQL 是工作在用户空间的，而 log buffer 处于用户空间的内存中。要写入到磁盘上的 log file 中，中间还要经过操作系统内核空间的 os buffer，调用 fsync() 的作用就是将 OS buffer 中的日志刷到磁盘上的 log file 中。")]),o._v(" "),e("p",[e("img",{attrs:{src:l(952),alt:"img",loading:"lazy"}})]),o._v(" "),e("div",{staticClass:"custom-block danger"},[e("p",{staticClass:"custom-block-title"},[o._v("log file")]),o._v(" "),e("p",[o._v("在此处需要注意一点，一般所说的 log file 并不是磁盘上的物理日志文件，而是 "),e("mark",[o._v("操作系统缓存中的 log file")]),o._v("，官方手册上的意思也是如此（例如：With a value of 2, the contents of the "),e("strong",[o._v("InnoDB log buffer are written to the log file")]),o._v(" after each transaction commit and "),e("strong",[o._v("the log file is flushed to disk approximately once per second")]),o._v("）。但说实话，这不太好理解，既然都称为 file 了，应该已经属于物理文件了。所以在本文后续内容中都以 os buffer 或者 file system buffer 来表示官方手册中所说的 Log file，然后 log file 则表示磁盘上的物理日志文件，即log file on disk。")])]),o._v(" "),e("h3",{attrs:{id:"刷盘策略"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#刷盘策略"}},[o._v("#")]),o._v(" 刷盘策略")]),o._v(" "),e("p",[o._v("MySQL支持用户自定义在 commit 时如何将 log buffer 中的日志刷 log file 中。")]),o._v(" "),e("p",[o._v("这种控制通过变量 "),e("code",[o._v("innodb_flush_log_at_trx_commit")]),o._v(" 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制 commit 动作是否刷新 log buffer 到磁盘。")]),o._v(" "),e("ul",[e("li",[o._v("当设置为 1 的时候，"),e("mark",[o._v("事务每次提交都会将 log buffer 中的日志写入 os buffer 并调用 fsync() 刷到磁盘的 log file 中")]),o._v("。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能较差。")]),o._v(" "),e("li",[o._v("当设置为 0 的时候，事务提交时不会将 log buffer 中日志写入到 os buffer，而是 "),e("mark",[o._v("每秒写入 os buffer 并调用 fsync() 写入到磁盘的 log file 中")]),o._v(" 。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。")]),o._v(" "),e("li",[o._v("当设置为 2 的时候，"),e("mark",[o._v("每次提交都仅写入到 os buffer，然后是每秒调用 fsync() 将 os buffer 中的日志写入到磁盘的 log file 中")]),o._v("。")])]),o._v(" "),e("p",[e("img",{attrs:{src:l(953),alt:"img",loading:"lazy"}})]),o._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[o._v("其实值为2和0的时候，它们的差距并不太大，但2却比0要安全的多。")])]),o._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[o._v("问自己")]),o._v(" "),e("ol",[e("li",[o._v("redo log 中记录什么，修改是以什么形式记录下来的")]),o._v(" "),e("li",[o._v("checkpoint")]),o._v(" "),e("li",[o._v("log sequence number")])]),o._v(" "),e("p",[o._v("有点复杂，暂时不深究")])]),o._v(" "),e("h2",{attrs:{id:"binlog"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#binlog"}},[o._v("#")]),o._v(" binlog")]),o._v(" "),e("p",[o._v("redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。")]),o._v(" "),e("p",[o._v("因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。")]),o._v(" "),e("blockquote",[e("p",[o._v("InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为"),e("strong",[o._v("crash-safe")])])]),o._v(" "),e("div",{staticClass:"custom-block tip"},[e("p",{staticClass:"custom-block-title"},[o._v("Tips")]),o._v(" "),e("ol",[e("li",[o._v("redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。")]),o._v(" "),e("li",[o._v("redo log 是物理日志，记录的是【在某个数据页上做了什么修改】；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如【给 ID = 2 这一行的 c 字段加 1】。")]),o._v(" "),e("li",[o._v("redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。【追加写】是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。")])])]),o._v(" "),e("h2",{attrs:{id:"redo-log-和-binlog-的重要性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-和-binlog-的重要性"}},[o._v("#")]),o._v(" redo log 和 binlog 的重要性")]),o._v(" "),e("h3",{attrs:{id:"redo-log-实现崩溃恢复"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#redo-log-实现崩溃恢复"}},[o._v("#")]),o._v(" redo log 实现崩溃恢复")]),o._v(" "),e("p",[e("mark",[o._v("binlog 不能做崩溃恢复，redo log能，所以 InnoDB 必须要有 redo log。")])]),o._v(" "),e("p",[o._v("redo log 中记录的是【做了什么改动但还没更新到数据库磁盘的内容】，InnoDB 在空闲的时候会将 redo log 的内容去更新到数据库磁盘，然后在 redo log 中抹去这一记录。")]),o._v(" "),e("p",[o._v("binlog 记录sql语句或内容，但是没有标志哪些操作已经写入数据库磁盘、哪些没有写入数据库磁盘，所以不能做崩溃恢复。")]),o._v(" "),e("blockquote",[e("p",[o._v("binlog 有两种模式，statement 格式的话是记sql语句，row 格式会记录行的内容，记两条，更新前和更新后都有")])]),o._v(" "),e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[o._v("Note")]),o._v(" "),e("p",[o._v("找到之前某一时刻的数据库备份，然后读取binlog恢复数据库不也能做到恢复吗？")]),o._v(" "),e("p",[o._v("虽然效率来看，会差很多很多，但也不能说是不能做崩溃恢复吧？")])]),o._v(" "),e("h3",{attrs:{id:"binlog-做归档"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#binlog-做归档"}},[o._v("#")]),o._v(" binlog 做归档")]),o._v(" "),e("p",[e("mark",[o._v("binlog 能够将数据库恢复到任意时刻的状态（只有有记录），而 redo log 不能，所以必须要有 binlog。")])]),o._v(" "),e("p",[o._v("因为 binlog 是追加写的，文件写满了就新建文件，所以你只要一直保留文件和某一时刻的数据库备份，你就能恢复从备份时刻起到当前过程中任意时刻的数据库状态。")]),o._v(" "),e("p",[o._v("redo log 是循环写的，会覆盖掉/抹除已经写入数据库磁盘的内容，因此不能持久保存，也就不具备归档的功能。")]),o._v(" "),e("h2",{attrs:{id:"两阶段提交"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#两阶段提交"}},[o._v("#")]),o._v(" 两阶段提交")]),o._v(" "),e("p",[o._v("既然 redo log 和 binlog 都要保留，就涉及到了两者一致性的问题。")]),o._v(" "),e("p",[o._v("有点模糊不清，虽然确定了 "),e("mark",[o._v("binlog只有在事务提交以后才会记录")]),o._v("，但是关于 redo log 是在什么具体时间去记录什么，查不到太好的内容，于是就不太能理清两阶段提交。保留以后再查。")])])}),[],!1,null,null,null);t.default=r.exports},952:function(o,t,l){o.exports=l.p+"assets/img/733013-20180508101949424-938931340.dd0030de.png"},953:function(o,t,l){o.exports=l.p+"assets/img/733013-20180508104623183-690986409.c0ff0982.png"}}]);