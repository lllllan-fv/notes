(window.webpackJsonp=window.webpackJsonp||[]).push([[120],{1121:function(a,t,v){"use strict";v.r(t);var s=v(1),_=Object(s.a)({},(function(){var a=this,t=a.$createElement,s=a._self._c||t;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("div",{staticClass:"custom-block warning"},[s("p",{staticClass:"custom-block-title"},[a._v("转载声明")]),a._v(" "),s("ul",[s("li",[a._v("《深入理解Java虚拟机》")]),a._v(" "),s("li",[s("a",{attrs:{href:"https://blog.csdn.net/u010312474/article/details/91046318",target:"_blank",rel:"noopener noreferrer"}},[a._v("双亲委派模式的优点"),s("OutboundLink")],1)])])]),a._v(" "),s("p",[a._v("Java虚拟机设计团队有意把类加载阶段中的【通过一个类的全限定名来获取描述该类的二进制字节流】这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为【类加载器】（Class Loader）。")]),a._v(" "),s("h2",{attrs:{id:"一、类与类加载器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、类与类加载器"}},[a._v("#")]),a._v(" 一、类与类加载器")]),a._v(" "),s("p",[a._v("类加载器用于实现类的加载动作。")]),a._v(" "),s("div",{staticClass:"custom-block note"},[s("p",{staticClass:"custom-block-title"},[a._v("Note")]),a._v(" "),s("p",[a._v("对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间。")]),a._v(" "),s("p",[a._v("即：比较两个类是否【相等】，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个 Class 文件、被同一个 Java 虚拟机加载，只要加载他们的类加载器不同，那么这两个类就必定不相等。")]),a._v(" "),s("blockquote",[s("p",[a._v("这里所指的【相等】，包括代表类的 Class 对象的 "),s("code",[a._v("equals(), isAssignableFrom(), isInstance()")]),a._v(" 的返回结果，也包括了使用 "),s("code",[a._v("instanceof")]),a._v(" 关键字做对象所属关系判定等各种情况。")])])]),a._v(" "),s("h2",{attrs:{id:"二、双亲委派模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、双亲委派模型"}},[a._v("#")]),a._v(" 二、双亲委派模型")]),a._v(" "),s("p",[a._v("站在 Java 虚拟机的角度来看，只有两种不同的类加载器：")]),a._v(" "),s("ol",[s("li",[a._v("启动类加载器，使用 C++ 语言实现，是虚拟机自身的一部分")]),a._v(" "),s("li",[a._v("其他所有类加载器，由 Java 语言实现，独立存在于虚拟机外部，并且全部继承自抽象类 "),s("code",[a._v("java.lang.ClassLoader")])])]),a._v(" "),s("p",[a._v("站在 Java 开发人员的角度来看，Java 一直保持着三层类加载器、双亲委派的类加载架构")]),a._v(" "),s("h3",{attrs:{id:"三层类加载器"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三层类加载器"}},[a._v("#")]),a._v(" 三层类加载器")]),a._v(" "),s("ol",[s("li",[s("strong",[a._v("启动类加载器")]),a._v("：这个加载器负责加载放在 "),s("code",[a._v("<JAVA_HOME>\\lib")]),a._v(" 目录，或者被 "),s("code",[a._v("-Xbootclasspath")]),a._v(" 参数指定的路径中存放的、而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。")]),a._v(" "),s("li",[s("strong",[a._v("扩展类加载器")]),a._v("：负责加载 "),s("code",[a._v("<JAVA_HOME>\\lib\\ext")]),a._v(" 目录中，或者被 "),s("code",[a._v("java.ext.dirs")]),a._v(" 系统变量所指定的路径中的所有类库。允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能")]),a._v(" "),s("li",[s("strong",[a._v("应用程序类加载器")]),a._v("：负责加载用户类路径上的所有类库，开发者同样可以直接在代码中使用这个类加载器。")])]),a._v(" "),s("p",[s("img",{attrs:{src:v(935),alt:"image-20220325151231771",loading:"lazy"}})]),a._v(" "),s("p",[a._v("JDK 9 之前的 Java 应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可以加入自定义的类加载器来进行扩展。")]),a._v(" "),s("h3",{attrs:{id:"双亲委派模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派模型"}},[a._v("#")]),a._v(" 双亲委派模型")]),a._v(" "),s("p",[a._v("上图各种类加载器之间的层次关系被称为类加载器的【双亲委派模型】。")]),a._v(" "),s("p",[a._v("双亲委派模型要求出了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里的父子关系一般不是以继承的关系来实现，而是通常使用组合关系来复用父加载器的代码。")]),a._v(" "),s("div",{staticClass:"custom-block note"},[s("p",{staticClass:"custom-block-title"},[a._v("双亲委派模型的工作过程：")]),a._v(" "),s("p",[a._v("如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个类加载请求时（它的搜索范围中没有找到所需要的类）时，子加载器才会尝试自己去完成加载。")])]),a._v(" "),s("div",{staticClass:"custom-block tip"},[s("p",{staticClass:"custom-block-title"},[a._v("双亲委派模型的好处")]),a._v(" "),s("p",[s("strong",[a._v("避免重复加载 + 避免核心类篡改")])]),a._v(" "),s("p",[a._v("采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。")]),a._v(" "),s("p",[a._v("其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为 "),s("code",[a._v("java.lang.Integer")]),a._v(" 的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的 "),s("code",[a._v("java.lang.Integer")]),a._v(" ，而直接返回已加载过的 "),s("code",[a._v("Integer.class")]),a._v(" ，这样便可以防止核心API库被随意篡改。")])]),a._v(" "),s("h2",{attrs:{id:"三、破坏双亲委派模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、破坏双亲委派模型"}},[a._v("#")]),a._v(" 三、破坏双亲委派模型")]),a._v(" "),s("p",[a._v("双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。")]),a._v(" "),s("blockquote",[s("p",[s("img",{attrs:{src:v(936),alt:"image-20220325153606566",loading:"lazy"}})])])])}),[],!1,null,null,null);t.default=_.exports},935:function(a,t,v){a.exports=v.p+"assets/img/image-20220325151231771.17a201f3.png"},936:function(a,t,v){a.exports=v.p+"assets/img/image-20220325153606566.91745ac1.png"}}]);