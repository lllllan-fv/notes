(window.webpackJsonp=window.webpackJsonp||[]).push([[104],{1087:function(t,a,v){"use strict";v.r(a);var _=v(1),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,_=t._self._c||a;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[t._v("转载声明")]),t._v(" "),_("ul",[_("li",[_("a",{attrs:{href:"https://github.com/RedSpider1/concurrent/tree/develop/article/02/6.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入浅出多线程 - 第六章 - GitHub"),_("OutboundLink")],1)]),t._v(" "),_("li",[_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/29881777",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java内存模型（JMM）总结"),_("OutboundLink")],1)])])]),t._v(" "),_("h2",{attrs:{id:"一、并发编程模型的两个关键问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#一、并发编程模型的两个关键问题"}},[t._v("#")]),t._v(" 一、并发编程模型的两个关键问题")]),t._v(" "),_("ul",[_("li",[t._v("线程间如何通信？即：线程之间以何种机制来交换信息")]),t._v(" "),_("li",[t._v("线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序")])]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}}),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("如何通信")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("如何同步")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("消息传递并发模型")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("线程之间"),_("strong",[t._v("没有公共状态")]),t._v("，线程间的通信必须通过发送消息来显示进行通信")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("发送消息天然同步，因为发送消息总是在接收消息之前，因此同步是隐式的")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("共享内存并发模型")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("线程之间共享程序的公共状态，通过"),_("strong",[t._v("写-读内存中的公共状态")]),t._v("进行隐式通信")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[_("strong",[t._v("必须显式指定代码需要在线程之间互斥执行")])])])])]),t._v(" "),_("p",[_("mark",[t._v("在Java中，使用的是共享内存并发模型")])]),t._v(" "),_("h2",{attrs:{id:"二、java内存模型的抽象结构"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、java内存模型的抽象结构"}},[t._v("#")]),t._v(" 二、Java内存模型的抽象结构")]),t._v(" "),_("h3",{attrs:{id:"_2-1-运行时内存的划分"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-运行时内存的划分"}},[t._v("#")]),t._v(" 2.1 运行时内存的划分")]),t._v(" "),_("p",[_("img",{attrs:{src:v(878),alt:"Java运行时数据区",loading:"lazy"}})]),t._v(" "),_("p",[t._v("对于每一个线程来说，栈都是私有的，而堆是共有的。")]),t._v(" "),_("p",[t._v("也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。")]),t._v(" "),_("p",[t._v("所以，"),_("strong",[t._v("内存可见性是针对的共享变量。")])]),t._v(" "),_("h3",{attrs:{id:"_2-2-既然堆是共享的-为什么在堆中会有内存不可见问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-既然堆是共享的-为什么在堆中会有内存不可见问题"}},[t._v("#")]),t._v(" 2.2 既然堆是共享的，为什么在堆中会有内存不可见问题？")]),t._v(" "),_("blockquote",[_("p",[t._v("这是因为现代计算机为了高效，"),_("strong",[t._v("往往会在高速缓存区中缓存共享变量")]),t._v("，因为 cpu 访问缓存区比访问内存要快得多。")])]),t._v(" "),_("p",[_("mark",[t._v("线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本")]),t._v("。本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。")]),t._v(" "),_("p",[t._v("Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主内存之间的抽象关系。JMM 的抽象示意图如图所示：")]),t._v(" "),_("div",{staticClass:"custom-block info"},[_("p",{staticClass:"custom-block-title"},[t._v("JMM")]),t._v(" "),_("p",[t._v("我们常说的 JVM 内存模式指的是 JVM 的内存分区；而 Java 内存模式是一种 "),_("mark",[t._v("虚拟机规范")]),t._v("。")]),t._v(" "),_("p",[t._v("Java 虚拟机规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以 "),_("strong",[t._v("实现让Java程序在各种平台下都能达到一致的并发效果")]),t._v("，JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。")])]),t._v(" "),_("p",[_("img",{attrs:{src:v(879),alt:"JMM抽象示意图",loading:"lazy"}})]),t._v(" "),_("p",[t._v("从图中可以看出：")]),t._v(" "),_("ol",[_("li",[t._v("所有的共享变量都存在主内存中。")]),t._v(" "),_("li",[t._v("每个线程 "),_("strong",[t._v("都保存了一份该线程使用到的共享变量的副本")]),t._v("。")]),t._v(" "),_("li",[t._v("如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤：\n"),_("ol",[_("li",[t._v("线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去。")]),t._v(" "),_("li",[t._v("线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。")])])])]),t._v(" "),_("p",[_("strong",[t._v("所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主内存。")])]),t._v(" "),_("p",[t._v("注意，根据 JMM 的规定，"),_("strong",[t._v("线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取")]),t._v("。")]),t._v(" "),_("p",[t._v("所以线程 B 并不是直接去主内存中读取共享变量的值，而是先在本地内存 B 中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存 B 中的新值。")]),t._v(" "),_("p",[t._v("那么怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。"),_("strong",[t._v("JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证")]),t._v("。")]),t._v(" "),_("div",{staticClass:"custom-block info"},[_("p",{staticClass:"custom-block-title"},[t._v("Info")]),t._v(" "),_("p",[t._v("Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。")]),t._v(" "),_("p",[t._v("更底层，JMM通过"),_("strong",[t._v("内存屏障")]),t._v("来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了 happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。")])]),t._v(" "),_("h3",{attrs:{id:"_2-3-jmm与java内存区域划分的区别与联系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-jmm与java内存区域划分的区别与联系"}},[t._v("#")]),t._v(" 2.3 JMM与Java内存区域划分的区别与联系")]),t._v(" "),_("ul",[_("li",[_("p",[t._v("区别")]),t._v(" "),_("p",[t._v("两者是不同的概念层次。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时，必要的内存划分。")])]),t._v(" "),_("li",[_("p",[t._v("联系")]),t._v(" "),_("p",[t._v("都存在私有数据区域和共享数据区域。一般来说，JMM 中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。")])])]),t._v(" "),_("p",[_("strong",[t._v("实际上，他们表达的是同一种含义，这里不做区分。")])])])}),[],!1,null,null,null);a.default=e.exports},878:function(t,a,v){t.exports=v.p+"assets/img/Java运行时数据区.912f2dae.png"},879:function(t,a,v){t.exports=v.p+"assets/img/JMM抽象示意图.ad26397b.jpg"}}]);