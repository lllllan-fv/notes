(window.webpackJsonp=window.webpackJsonp||[]).push([[93],{1092:function(t,s,a){"use strict";a.r(s);var v=a(1),n=Object(v.a)({},(function(){var t=this,s=t.$createElement,v=t._self._c||s;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("转载声明")]),t._v(" "),v("ul",[v("li",[v("a",{attrs:{href:"https://github.com/RedSpider1/concurrent/tree/develop/article/02/9.md",target:"_blank",rel:"noopener noreferrer"}},[t._v("深入浅出多线程 - 第九章 - GitHub"),v("OutboundLink")],1)])])]),t._v(" "),v("p",[v("strong",[t._v("Java 多线程的锁都是基于对象的")]),t._v("，Java 中的每一个对象都可以作为一个锁。")]),t._v(" "),v("p",[t._v("还有一点需要注意的是，我们常听到的 "),v("strong",[t._v("类锁")]),t._v(" 其实也是对象锁。")]),t._v(" "),v("p",[t._v("Java 类只有一个 Class 对象（可以有多个实例对象，多个实例共享这个 Class 对象），而 Class 对象也是特殊的Java 对象。所以我们常说的类锁，其实就是 Class 对象的锁。")]),t._v(" "),v("h2",{attrs:{id:"一、synchronized关键字"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、synchronized关键字"}},[t._v("#")]),t._v(" 一、Synchronized关键字")]),t._v(" "),v("p",[t._v("说到锁，我们通常会谈到 "),v("code",[t._v("synchronized")]),t._v(" 这个关键字。它翻译成中文就是【同步】的意思。")]),t._v(" "),v("p",[t._v("我们通常使用 "),v("code",[t._v("synchronized")]),t._v("关键字来给一段代码或一个方法上锁。它通常有以下三种形式：")]),t._v(" "),v("ul",[v("li",[t._v("关键字在实例方法上，锁为当前实例")]),t._v(" "),v("li",[t._v("关键字在静态方法上，锁为当前 Class 对象")]),t._v(" "),v("li",[t._v("关键字在代码块上，锁为括号里面的对象")])]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("div",{staticClass:"highlight-lines"},[v("div",{staticClass:"highlighted"},[t._v(" ")]),v("br"),v("br"),v("br"),v("br"),v("div",{staticClass:"highlighted"},[t._v(" ")]),v("br"),v("br"),v("br"),v("br"),v("br"),v("br"),v("br"),v("div",{staticClass:"highlighted"},[t._v(" ")]),v("br"),v("br"),v("br"),v("br")]),v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关键字在实例方法上，锁为当前实例")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("instanceLock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// code")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关键字在静态方法上，锁为当前Class对象")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("classLock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// code")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n\n"),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// 关键字在代码块上，锁为括号里面的对象")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("void")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("blockLock")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),t._v(" o "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Object")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("synchronized")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("o"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v("\n        "),v("span",{pre:!0,attrs:{class:"token comment"}},[t._v("// code")]),t._v("\n    "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br"),v("span",{staticClass:"line-number"},[t._v("12")]),v("br"),v("span",{staticClass:"line-number"},[t._v("13")]),v("br"),v("span",{staticClass:"line-number"},[t._v("14")]),v("br"),v("span",{staticClass:"line-number"},[t._v("15")]),v("br"),v("span",{staticClass:"line-number"},[t._v("16")]),v("br"),v("span",{staticClass:"line-number"},[t._v("17")]),v("br")])]),v("div",{staticClass:"custom-block info"},[v("p",{staticClass:"custom-block-title"},[t._v("临界区")]),t._v(" "),v("p",[t._v("指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果 "),v("code",[t._v("synchronized")]),t._v(" 关键字在方法上，那临界区就是整个方法内部。而如果是使用 synchronized 代码块，那临界区就指的是代码块内部的区域。")])]),t._v(" "),v("p",[t._v("通过上面的例子我们可以看到，下面这两个写法其实是等价的作用：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("// 关键字在实例方法上，锁为当前实例\npublic synchronized void instanceLock() {\n    // code\n}\n\n// 关键字在代码块上，锁为括号里面的对象\npublic void blockLock() {\n    synchronized (this) {\n        // code\n    }\n}\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br")])]),v("p",[t._v("同理，下面这两个方法也应该是等价的：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("// 关键字在静态方法上，锁为当前Class对象\npublic static synchronized void classLock() {\n    // code\n}\n\n// 关键字在代码块上，锁为括号里面的对象\npublic void blockLock() {\n    synchronized (this.getClass()) {\n        // code\n    }\n}\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br"),v("span",{staticClass:"line-number"},[t._v("7")]),v("br"),v("span",{staticClass:"line-number"},[t._v("8")]),v("br"),v("span",{staticClass:"line-number"},[t._v("9")]),v("br"),v("span",{staticClass:"line-number"},[t._v("10")]),v("br"),v("span",{staticClass:"line-number"},[t._v("11")]),v("br")])]),v("h2",{attrs:{id:"二、锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、锁"}},[t._v("#")]),t._v(" 二、锁")]),t._v(" "),v("p",[t._v("Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了【偏向锁】和【轻量级锁】。在Java 6 以前，所有的锁都是【重量级】锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：")]),t._v(" "),v("ol",[v("li",[t._v("无锁状态")]),t._v(" "),v("li",[t._v("偏向锁状态")]),t._v(" "),v("li",[t._v("轻量级锁状态")]),t._v(" "),v("li",[t._v("重量级锁状态")])]),t._v(" "),v("p",[t._v("无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。")]),t._v(" "),v("p",[t._v("几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻， "),v("mark",[t._v("锁降级发生在 Stop The World 期间，当 JVM 进入安全点的时候，会检查是否有闲置的锁，然后进行降级")]),t._v(" 。")]),t._v(" "),v("blockquote",[v("p",[t._v("关于锁降级有两点说明：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的 - "),v("a",{attrs:{href:"https://www.jianshu.com/p/9932047a89be",target:"_blank",rel:"noopener noreferrer"}},[t._v("Java锁优化--JVM锁降级"),v("OutboundLink")],1)])]),t._v(" "),v("li",[v("p",[t._v("上面提到的 Stop The World 期间，以及安全点，这些知识是属于 JVM 的知识范畴，本文不做细讲。")])])])]),t._v(" "),v("p",[t._v("下面分别介绍这几种锁以及它们之间的升级。")]),t._v(" "),v("h2",{attrs:{id:"三、java对象头"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#三、java对象头"}},[t._v("#")]),t._v(" 三、Java对象头")]),t._v(" "),v("p",[t._v("前面我们提到，Java 的锁都是基于对象的。首先我们来看看一个对象的【锁】的信息是存放在什么地方的。")]),t._v(" "),v("p",[t._v("每个 Java 对象都有对象头。如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。在 32 位处理器中，一个字宽是 32 位；在 64 位虚拟机中，一个字宽是 64 位。对象头的内容如下表：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("长度")]),t._v(" "),v("th",[t._v("内容")]),t._v(" "),v("th",[t._v("说明")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("32/64bit")]),t._v(" "),v("td",[t._v("Mark Word")]),t._v(" "),v("td",[t._v("存储对象的 hashCode 或锁信息等")])]),t._v(" "),v("tr",[v("td",[t._v("32/64bit")]),t._v(" "),v("td",[t._v("Class Metadata Address")]),t._v(" "),v("td",[t._v("存储到对象类型数据的指针")])]),t._v(" "),v("tr",[v("td",[t._v("32/64bit")]),t._v(" "),v("td",[t._v("Array length")]),t._v(" "),v("td",[t._v("数组的长度（如果是数组）")])])])]),t._v(" "),v("p",[t._v("我们主要来看看Mark Word的格式：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("锁状态")]),t._v(" "),v("th",[t._v("29 bit 或 61 bit")]),t._v(" "),v("th",[t._v("1 bit 是否是偏向锁？")]),t._v(" "),v("th",[t._v("2 bit 锁标志位")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("无锁")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("0")]),t._v(" "),v("td",[t._v("01")])]),t._v(" "),v("tr",[v("td",[t._v("偏向锁")]),t._v(" "),v("td",[t._v("线程ID")]),t._v(" "),v("td",[t._v("1")]),t._v(" "),v("td",[t._v("01")])]),t._v(" "),v("tr",[v("td",[t._v("轻量级锁")]),t._v(" "),v("td",[t._v("指向栈中锁记录的指针")]),t._v(" "),v("td",[t._v("此时这一位不用于标识偏向锁")]),t._v(" "),v("td",[t._v("00")])]),t._v(" "),v("tr",[v("td",[t._v("重量级锁")]),t._v(" "),v("td",[t._v("指向互斥量（重量级锁）的指针")]),t._v(" "),v("td",[t._v("此时这一位不用于标识偏向锁")]),t._v(" "),v("td",[t._v("10")])]),t._v(" "),v("tr",[v("td",[t._v("GC标记")]),t._v(" "),v("td"),t._v(" "),v("td",[t._v("此时这一位不用于标识偏向锁")]),t._v(" "),v("td",[t._v("11")])])])]),t._v(" "),v("p",[t._v("可以看到，当对象状态为偏向锁时，"),v("code",[t._v("Mark Word")]),t._v(" 存储的是偏向的线程ID；当状态为轻量级锁时，"),v("code",[t._v("Mark Word")]),t._v(" 存储的是指向线程栈中 "),v("code",[t._v("Lock Record")]),t._v(" 的指针；当状态为重量级锁时，"),v("code",[t._v("Mark Word")]),t._v(" 为指向堆中的 monitor 对象的指针。")]),t._v(" "),v("h2",{attrs:{id:"四、偏向锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#四、偏向锁"}},[t._v("#")]),t._v(" 四、偏向锁")]),t._v(" "),v("p",[v("mark",[t._v("Hotspot 的作者经过以往的研究发现大多数情况下 "),v("strong",[t._v("锁不仅不存在多线程竞争，而且总是由同一线程多次获得")]),t._v("，于是引入了偏向锁。")])]),t._v(" "),v("p",[t._v("偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，"),v("strong",[t._v("偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。")])]),t._v(" "),v("blockquote",[v("p",[t._v("大白话就是对锁置个变量，如果发现为 true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为 false，代表存在其他线程竞争资源，那么就会走后面的流程。")])]),t._v(" "),v("h3",{attrs:{id:"实现原理"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#实现原理"}},[t._v("#")]),t._v(" 实现原理")]),t._v(" "),v("p",[t._v("一个线程在第一次进入同步块时，"),v("strong",[t._v("会在对象头和栈帧中的锁记录里存储锁的偏向的线程")]),t._v("ID。当下次该线程进入这个同步块时，会去检查锁的 "),v("mark",[t._v("Mark Word")]),t._v(" 里面是不是放的自己的线程ID。")]),t._v(" "),v("p",[t._v("如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：")]),t._v(" "),v("ul",[v("li",[t._v("成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；")]),t._v(" "),v("li",[t._v("失败，表示之前的线程仍然存在，那么暂停之前的线程，"),v("strong",[t._v("设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁")]),t._v("。")])]),t._v(" "),v("div",{staticClass:"custom-block info"},[v("p",{staticClass:"custom-block-title"},[t._v("CAS: Compare and Swap")]),t._v(" "),v("p",[v("a",{attrs:{href:"http://localhost:8080/java/concurrent/2/10/",target:"_blank",rel:"noopener noreferrer"}},[t._v("第十章、CAS与原子操作 | lllllan"),v("OutboundLink")],1)]),t._v(" "),v("p",[t._v("比较并交换。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令 cmpxchg 实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。")])]),t._v(" "),v("p",[t._v("线程竞争偏向锁的过程如下：")]),t._v(" "),v("p",[v("img",{attrs:{src:a(883),alt:"偏向锁2",loading:"lazy"}})]),t._v(" "),v("p",[t._v("图中涉及到了 lock record 指针指向当前堆栈中的最近一个 lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。")]),t._v(" "),v("h3",{attrs:{id:"撤销偏向锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#撤销偏向锁"}},[t._v("#")]),t._v(" 撤销偏向锁")]),t._v(" "),v("p",[t._v("偏向锁使用了一种 "),v("strong",[t._v("等到竞争出现才释放锁的机制")]),t._v("，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。")]),t._v(" "),v("p",[t._v("偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：")]),t._v(" "),v("ol",[v("li",[t._v("在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。")]),t._v(" "),v("li",[t._v("遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word，使其变成无锁状态。")]),t._v(" "),v("li",[t._v("唤醒被停止的线程，将当前锁升级成轻量级锁。")])]),t._v(" "),v("p",[t._v("所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：")]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),t._v("XX"),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("UseBiasedLocking")]),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),v("span",{pre:!0,attrs:{class:"token boolean"}},[t._v("false")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br")])]),v("p",[t._v("下面这个经典的图总结了偏向锁的获得和撤销：")]),t._v(" "),v("p",[v("img",{attrs:{src:a(884),alt:"偏向锁",loading:"lazy"}})]),t._v(" "),v("h2",{attrs:{id:"五、轻量级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#五、轻量级锁"}},[t._v("#")]),t._v(" 五、轻量级锁")]),t._v(" "),v("p",[v("mark",[t._v("多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。")])]),t._v(" "),v("h3",{attrs:{id:"轻量级锁的加锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁的加锁"}},[t._v("#")]),t._v(" 轻量级锁的加锁")]),t._v(" "),v("p",[t._v("JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为【Displaced Mark Word】。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。")]),t._v(" "),v("p",[t._v("然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，"),v("mark",[t._v("当前线程就尝试使用 "),v("strong",[t._v("自旋")]),t._v(" 来获取锁")]),t._v("。")]),t._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[t._v("自旋")]),t._v(" "),v("p",[t._v("不断尝试去获取锁，一般用循环来实现。")])]),t._v(" "),v("p",[v("strong",[t._v("自旋是需要消耗 CPU 的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费 CPU 资源")]),t._v("。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环 10 次，如果还没获取到锁就进入阻塞状态。")]),t._v(" "),v("p",[t._v("但是 JDK 采用了更聪明的方式——适应性自旋")]),t._v(" "),v("div",{staticClass:"custom-block note"},[v("p",{staticClass:"custom-block-title"},[t._v("适应性自旋")]),t._v(" "),v("p",[t._v("简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。")])]),t._v(" "),v("p",[t._v("自旋也不是一直进行下去的，如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。"),v("mark",[t._v("同时这个锁就会升级成重量级锁")]),t._v("。")]),t._v(" "),v("h3",{attrs:{id:"轻量级锁的释放"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#轻量级锁的释放"}},[t._v("#")]),t._v(" 轻量级锁的释放")]),t._v(" "),v("p",[t._v("在释放锁时，当前线程会使用 CAS 操作将 Displaced Mark Word 的内容复制回锁的 Mark Word 里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时会释放锁并唤醒被阻塞的线程。")]),t._v(" "),v("p",[t._v("一张图说明加锁和释放锁的过程：")]),t._v(" "),v("p",[v("img",{attrs:{src:a(885),alt:"轻量级锁流程图",loading:"lazy"}})]),t._v(" "),v("h2",{attrs:{id:"六、重量级锁"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#六、重量级锁"}},[t._v("#")]),t._v(" 六、重量级锁")]),t._v(" "),v("p",[v("mark",[t._v("重量级锁依赖于操作系统的【互斥量（mutex）】实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。")])]),t._v(" "),v("p",[t._v("前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：")]),t._v(" "),v("div",{staticClass:"language- line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-text"}},[v("code",[t._v("Contention List：所有请求锁的线程将被首先放置到该竞争队列\nEntry List：Contention List中那些有资格成为候选人的线程被移到Entry List\nWait Set：那些调用wait方法被阻塞的线程被放置到Wait Set\nOnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck\nOwner：获得锁的线程称为Owner\n!Owner：释放锁的线程\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br"),v("span",{staticClass:"line-number"},[t._v("5")]),v("br"),v("span",{staticClass:"line-number"},[t._v("6")]),v("br")])]),v("p",[t._v("当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个 "),v("code",[t._v("ObjectWaiter")]),t._v(" 对象插入到 Contention List 的队列的队首，然后调用 "),v("code",[t._v("park")]),t._v(" 函数挂起当前线程。")]),t._v(" "),v("p",[t._v("当线程释放锁时，会从 Contention List 或 Entry List 中挑选一个线程唤醒，被选中的线程叫做 "),v("code",[t._v("Heir presumptive")]),t._v(" 即假定继承人，假定继承人被唤醒后会尝试获得锁，但 "),v("mark",[v("code",[t._v("synchronized")]),t._v("是非公平的，所以假定继承人不一定能获得锁")]),t._v(" 。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了 Ready 线程的锁。")]),t._v(" "),v("p",[t._v("如果线程获得锁后调用 "),v("code",[t._v("Object.wait")]),t._v(" 方法，则会将线程加入到 WaitSet 中，当被 "),v("code",[t._v("Object.notify")]),t._v(" 唤醒后，会将线程从 WaitSet 移动到 Contention List 或 EntryList 中去。需要注意的是，"),v("mark",[t._v("当调用一个锁对象的"),v("code",[t._v("wait")]),t._v("或"),v("code",[t._v("notify")]),t._v("方法时，"),v("strong",[t._v("如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁")]),t._v("。")])]),t._v(" "),v("h2",{attrs:{id:"七、总结锁的升级流程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#七、总结锁的升级流程"}},[t._v("#")]),t._v(" 七、总结锁的升级流程")]),t._v(" "),v("p",[t._v("每一个线程在准备获取共享资源时：")]),t._v(" "),v("ol",[v("li",[v("p",[t._v("检查 MarkWord 里面是不是放的自己的ThreadId，如果是，表示当前线程是处于 "),v("mark",[t._v("【偏向锁】")])])]),t._v(" "),v("li",[v("p",[t._v("如果 MarkWord 不是自己的 ThreadId，"),v("strong",[t._v("锁升级")]),t._v("，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空。")])]),t._v(" "),v("li",[v("p",[t._v("两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord。成功执行 CAS 的获得资源，失败的则进入自旋 。")])]),t._v(" "),v("li",[v("p",[t._v("自旋的线程在自旋过程中，成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 "),v("mark",[t._v("轻量级锁")]),t._v(" 的状态.")])]),t._v(" "),v("li",[v("p",[t._v("如果自旋失败，进入 "),v("mark",[t._v("重量级锁")]),t._v(" 的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。")])])]),t._v(" "),v("h2",{attrs:{id:"八、-各种锁的优缺点对比"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#八、-各种锁的优缺点对比"}},[t._v("#")]),t._v(" 八、 各种锁的优缺点对比")]),t._v(" "),v("p",[t._v("下表来自《Java并发编程的艺术》：")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("锁")]),t._v(" "),v("th",[t._v("优点")]),t._v(" "),v("th",[t._v("缺点")]),t._v(" "),v("th",[t._v("适用场景")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("偏向锁")]),t._v(" "),v("td",[t._v("加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。")]),t._v(" "),v("td",[t._v("如果线程间存在锁竞争，会带来额外的锁撤销的消耗。")]),t._v(" "),v("td",[t._v("适用于只有一个线程访问同步块场景。")])]),t._v(" "),v("tr",[v("td",[t._v("轻量级锁")]),t._v(" "),v("td",[t._v("竞争的线程不会阻塞，提高了程序的响应速度。")]),t._v(" "),v("td",[t._v("如果始终得不到锁竞争的线程使用自旋会消耗CPU。")]),t._v(" "),v("td",[t._v("追求响应时间。同步块执行速度非常快。")])]),t._v(" "),v("tr",[v("td",[t._v("重量级锁")]),t._v(" "),v("td",[t._v("线程竞争不使用自旋，不会消耗CPU。")]),t._v(" "),v("td",[t._v("线程阻塞，响应时间缓慢。")]),t._v(" "),v("td",[t._v("追求吞吐量。同步块执行时间较长。")])])])])])}),[],!1,null,null,null);s.default=n.exports},883:function(t,s,a){t.exports=a.p+"assets/img/偏向锁2.db23beda.png"},884:function(t,s,a){t.exports=a.p+"assets/img/偏向锁.cec59238.png"},885:function(t,s,a){t.exports=a.p+"assets/img/轻量级锁流程图.10dfcad4.png"}}]);