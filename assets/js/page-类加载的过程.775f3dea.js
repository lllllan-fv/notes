(window.webpackJsonp=window.webpackJsonp||[]).push([[122],{1119:function(v,_,a){"use strict";a.r(_);var t=a(1),s=Object(t.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[t("div",{staticClass:"custom-block warning"},[t("p",{staticClass:"custom-block-title"},[v._v("转载声明")]),v._v(" "),t("ul",[t("li",[v._v("《深入理解Java虚拟机》")])])]),v._v(" "),t("h2",{attrs:{id:"一、加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、加载"}},[v._v("#")]),v._v(" 一、加载")]),v._v(" "),t("blockquote",[t("p",[v._v("加载阶段，是整个类加载过程中的其中一个阶段")])]),v._v(" "),t("ol",[t("li",[v._v("通过一个类的全限定名来获取此类的二进制字节流")]),v._v(" "),t("li",[v._v("将这个字节流的静态存储结构转化为方法区的运行时数据结构")]),v._v(" "),t("li",[v._v("在内存中生成一个代表这个类的 "),t("code",[v._v("java.lang.Class")]),v._v(" 对象，作为方法区这个类的各种数据的访问入口")])]),v._v(" "),t("h3",{attrs:{id:"灵活度大"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#灵活度大"}},[v._v("#")]),v._v(" 灵活度大")]),v._v(" "),t("p",[v._v("《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的")]),v._v(" "),t("p",[v._v("例如【通过一个类的全限定名来获取定义此类的二进制字节流】这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。")]),v._v(" "),t("ul",[t("li",[v._v("从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。")]),v._v(" "),t("li",[v._v("从网络中获取，这种场景最典型的应用就是Web Applet。")]),v._v(" "),t("li",[v._v("由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("h3",{attrs:{id:"非数组类型的加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#非数组类型的加载"}},[v._v("#")]),v._v(" 非数组类型的加载")]),v._v(" "),t("p",[v._v("非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的 "),t("code",[v._v("findClass()")]),v._v(" 或 "),t("code",[v._v("loadClass()")]),v._v(" 方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。")]),v._v(" "),t("h3",{attrs:{id:"数组类型的加载"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#数组类型的加载"}},[v._v("#")]),v._v(" 数组类型的加载")]),v._v(" "),t("p",[v._v("数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。")]),v._v(" "),t("p",[v._v("但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：")]),v._v(" "),t("ul",[t("li",[v._v("如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上")]),v._v(" "),t("li",[v._v("如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。")]),v._v(" "),t("li",[v._v("数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。")])]),v._v(" "),t("h2",{attrs:{id:"二、验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、验证"}},[v._v("#")]),v._v(" 二、验证")]),v._v(" "),t("p",[v._v("验证是连接阶段的第一步，这一阶段的目的是 "),t("mark",[v._v("确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全")])]),v._v(" "),t("h3",{attrs:{id:"_2-1-文件格式验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-文件格式验证"}},[v._v("#")]),v._v(" 2.1 文件格式验证")]),v._v(" "),t("p",[v._v("第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。")]),v._v(" "),t("ul",[t("li",[v._v("是否以魔数 "),t("code",[v._v("0xCAFEBABE")]),v._v(" 开头")]),v._v(" "),t("li",[v._v("主、次版本号是否在当前Java虚拟机接受范围之内")]),v._v(" "),t("li",[v._v("常量池的常量中是否有不被支持的常量类型（检查常量tag标志）")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("p",[v._v("这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储")]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"_2-2-元数据验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-元数据验证"}},[v._v("#")]),v._v(" 2.2 元数据验证")]),v._v(" "),t("p",[v._v("第二阶段是对字节码描述的信息进行语义分析")]),v._v(" "),t("ul",[t("li",[v._v("这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）")]),v._v(" "),t("li",[v._v("这个类的父类是否继承了不允许被继承的类（被final修饰的类）")]),v._v(" "),t("li",[v._v("如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("p",[v._v("第二阶段的主要目的是 "),t("strong",[v._v("对类的元数据信息进行语义校验")]),v._v("，保证不存在与《Java语言规范》定义相悖的元数据信息。")]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"_2-3-字节码验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-字节码验证"}},[v._v("#")]),v._v(" 2.3 字节码验证")]),v._v(" "),t("p",[v._v("第三阶段是整个验证过程中最复杂的一个阶段，主要目的是 "),t("strong",[v._v("通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的")]),v._v("。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，"),t("strong",[v._v("保证被校验类的方法在运行时不会做出危害虚拟机安全的行为")])]),v._v(" "),t("ul",[t("li",[v._v("保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况")]),v._v(" "),t("li",[v._v("保证任何跳转指令都不会跳转到方法体以外的字节码指令上")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("p",[v._v("如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。")]),v._v(" "),t("hr"),v._v(" "),t("h3",{attrs:{id:"_2-4-符号引用验证"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-符号引用验证"}},[v._v("#")]),v._v(" 2.4 符号引用验证")]),v._v(" "),t("p",[v._v("最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源")]),v._v(" "),t("ul",[t("li",[v._v("符号引用中通过字符串描述的全限定名是否能找到对应的类。")]),v._v(" "),t("li",[v._v("在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。")]),v._v(" "),t("li",[v._v("...")])]),v._v(" "),t("p",[v._v("符号引用验证的主要目的是 "),t("strong",[v._v("确保解析行为能正常执行")]),v._v("，如果无法通过符号引用验证，Java虚拟机 将会抛出一个 "),t("code",[v._v("java.lang.IncompatibleClassChangeError")]),v._v(" 的子类异常")]),v._v(" "),t("h2",{attrs:{id:"三、准备"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#三、准备"}},[v._v("#")]),v._v(" 三、准备")]),v._v(" "),t("p",[v._v("准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量） "),t("mark",[v._v("分配内存并设置类变量初始值的阶段")])]),v._v(" "),t("div",{staticClass:"custom-block info"},[t("p",{staticClass:"custom-block-title"},[v._v("误区")]),v._v(" "),t("p",[v._v("这时候进行内存分配的仅包括类变量，而不包括实例变量；实例变量会在对象实例化时随着对象一起分配在 Java 堆中")]),v._v(" "),t("p",[v._v("设置初始值通常情况下是数据类型的零值。")])]),v._v(" "),t("p",[t("img",{attrs:{src:a(927),alt:"image-20220323155214025",loading:"lazy"}})]),v._v(" "),t("h2",{attrs:{id:"四、解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#四、解析"}},[v._v("#")]),v._v(" 四、解析")]),v._v(" "),t("p",[v._v("解析阶段是Java虚拟机 "),t("mark",[v._v("将常量池内的符号引用替换为直接引用的过程")])]),v._v(" "),t("div",{staticClass:"custom-block info"},[t("p",{staticClass:"custom-block-title"},[v._v("符号引用")]),v._v(" "),t("p",[v._v("符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。")]),v._v(" "),t("p",[v._v("符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。")])]),v._v(" "),t("div",{staticClass:"custom-block info"},[t("p",{staticClass:"custom-block-title"},[v._v("直接引用")]),v._v(" "),t("p",[v._v("直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。")]),v._v(" "),t("p",[v._v("直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。")])]),v._v(" "),t("h3",{attrs:{id:"_4-1-类或接口的解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-1-类或接口的解析"}},[v._v("#")]),v._v(" 4.1 类或接口的解析")]),v._v(" "),t("p",[v._v("假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：")]),v._v(" "),t("ol",[t("li",[v._v("如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。")]),v._v(" "),t("li",[v._v("如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似 "),t("code",[v._v("[Ljava/lang/Integer")]),v._v(" 的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是 "),t("code",[v._v("java.lang.Integer")]),v._v(" ，接着由虚拟机生成一个代表该数组维度和元素的数组对象。")]),v._v(" "),t("li",[v._v("如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出 "),t("code",[v._v("java.lang.IllegalAccessError")]),v._v(" 异常。")])]),v._v(" "),t("h3",{attrs:{id:"_4-2-字段解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-2-字段解析"}},[v._v("#")]),v._v(" 4.2 字段解析")]),v._v(" "),t("ol",[t("li",[v._v("如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。")]),v._v(" "),t("li",[v._v("否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。")]),v._v(" "),t("li",[v._v("否则，如果C不是 "),t("code",[v._v("java.lang.Object")]),v._v(" 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。")]),v._v(" "),t("li",[v._v("否则，查找失败，抛出 "),t("code",[v._v("java.lang.NoSuchFieldError")]),v._v(" 异常。")])]),v._v(" "),t("p",[v._v("如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出 "),t("code",[v._v("java.lang.IllegalAccessError")]),v._v(" 异常。")]),v._v(" "),t("h3",{attrs:{id:"_4-3-方法解析"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-3-方法解析"}},[v._v("#")]),v._v(" 4.3 方法解析")]),v._v(" "),t("ol",[t("li",[v._v("与类的方法解析相反，如果在接口方法表中发现 "),t("code",[v._v("class_index")]),v._v(" 中的索引C是个类而不是接口，那么就直接抛出 "),t("code",[v._v("java.lang.IncompatibleClassChangeError")]),v._v(" 异常")]),v._v(" "),t("li",[v._v("否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。")]),v._v(" "),t("li",[v._v("否则，在接口C的父接口中递归查找，直到 "),t("code",[v._v("java.lang.Object")]),v._v(" 类（接口方法的查找范围也会包括 "),t("code",[v._v("Object")]),v._v(" 类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束")]),v._v(" "),t("li",[v._v("对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。")]),v._v(" "),t("li",[v._v("否则，宣告方法查找失败，抛出 "),t("code",[v._v("java.lang.NoSuchMethodError")]),v._v(" 异常")])]),v._v(" "),t("h2",{attrs:{id:"五、初始化"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#五、初始化"}},[v._v("#")]),v._v(" 五、初始化")]),v._v(" "),t("p",[v._v("进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。")])])}),[],!1,null,null,null);_.default=s.exports},927:function(v,_,a){v.exports=a.p+"assets/img/image-20220323155214025.d15e94fa.png"}}]);