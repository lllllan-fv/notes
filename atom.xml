<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://notes.lllllan.cn/</id>
  <title>lllllan</title>
  <author>
    <name>lllllan</name>
  </author>
  <updated>2022-05-13T14:26:32.073Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://notes.lllllan.cn/atom.xml"/>
  <link rel="alternate" href="https://notes.lllllan.cn/"/>
  <category term="计算机基础"/>
  <category term="数据结构和算法"/>
  <category term="Java"/>
  <category term="面经"/>
  <category term="数据库"/>
  <contributor>
    <name>lllllan</name>
  </contributor>
  <entry>
    <title type="html">计算机基础</title>
    <id>https://notes.lllllan.cn/cs-basic/</id>
    <link href="https://notes.lllllan.cn/cs-basic/"/>
    <updated>2022-03-16T10:37:26.000Z</updated>
    <content type="html"><![CDATA[<div><p>重要声明</p>
<p>既然作为笔记，就存在着大量的摘抄（也就是俗话说的copy）。为了尊重原作者的劳动，此处以及每篇文章都会列出原文出处。如有遗漏，欢迎指出</p>
</div>
<h2 id="参考"> 参考</h2>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://blog.csdn.net/qq_34827674/article/details/119809480" target="_blank" rel="noopener noreferrer">被问懵逼了：TCP 握手没成功怎么办？</a></li>
<li>《网络是怎样连接的》</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第一章、Web及网络基础</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/1/"/>
    <updated>2022-04-07T02:33:05.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、使用http协议访问web"> 一、使用HTTP协议访问Web</h2>
<p>Web使用一种名为 HTTP(HyperText Transfer Protocal，超文本传输协议)的协议作为规范，完成从客户端到服务器等一系列运作流程。</p>
<p><img src="./README.assets/image-20220226153648943.png" alt="image-20220226153648943" loading="lazy"></p>
<h2 id="三、网络基础-tcp-ip"> 三、网络基础 TCP/IP</h2>
<p>通常使用的网络是在 TCP/IP 协议族的基础上运作的，而 HTTP 属于它内部的一个子集。</p>
<h3 id="_3-1-tcp-ip-协议族"> 3.1 TCP/IP 协议族</h3>
<p>TCP/IP 协议族规定了通信双方必须遵守的一些规则。</p>
<p><img src="./README.assets/image-20220226154458019.png" alt="image-20220226154458019" loading="lazy"></p>
<h3 id="_3-2-tcp-ip-的分层管理"> 3.2 TCP/IP 的分层管理</h3>
<p>TCP/IP 协议族按层次分别为： <strong>应用层、传输层、网络层、数据链路层</strong></p>
<div><p>分层的好处</p>
<p>如果互联网只由一个协议统筹，某个地方需要改变设计时，就必须把所有部分整体替换掉。而分层之后只需把变动的层替换掉即可。</p>
<p>设计也变得相对简单。处于应用层上的应用可以只考虑分派给自己的任务，而不需要弄清对方在地球上哪个地方、对方的传输路线是怎么样的、是否能确保传输送达等问题</p>
</div>
<h4 id="_3-2-1-应用层"> 3.2.1 应用层</h4>
<p>应用层决定了向用户提供应用服务时通信的活动。HTTP、FTP</p>
<h4 id="_3-2-2-传输层"> 3.2.2 传输层</h4>
<p>传输层对上层应用层，提供处于网络连接中的两台计算机之间的数据传输。TCP、UDP</p>
<h4 id="_3-2-3-网络层-网际层"> 3.2.3 网络层（网际层）</h4>
<p>网络层用来处理在网络上流动的数据包。数据包时网络传输的最小数据单位。 <strong>该层规定了通过怎样的路径（所谓的传输路线）到达对方计算机，并把数据传送给对方。</strong></p>
<p>与对方计算机之间通过多台计算机或网络设备传输时，网络层的作用就是在众多的选项内选择一条传输路线。</p>
<h4 id="_3-2-4-数据链路层-网络接口层"> 3.2.4 数据链路层（网络接口层）</h4>
<p>用来处理连接网络的硬件部分。操作系统、设备驱动、网卡、光纤等物理课件部分。</p>
<h3 id="_3-3-tcp-ip通信传输流"> 3.3 TCP/IP通信传输流</h3>
<p><img src="./README.assets/image-20220226161431264.png" alt="image-20220226161431264" loading="lazy"></p>
<ol>
<li>客户端在应用层（HTTP协议）发出 HTTP 请求</li>
<li>为了传输方便，在传输层（TCP协议）把从应用层收到的数据（HTTP请求报文）进行分割，并在各个报文打上标记序号及端口号后转发给网络层</li>
<li>网络层（IP协议）增加作为通信目的地的 MAC 地址后转发给链路层</li>
</ol>
<p><img src="./README.assets/image-20220226161739401.png" alt="image-20220226161739401" loading="lazy"></p>
<p>发送端在层与层之间传输数据时，每经过一层必定会被打上一个该层所属的首部信心。反之，接收端在层与层传输数据时，每经过一层时会把对应的首部消去</p>
<div><p>封装</p>
<p>把数据信息包装起来的做法叫做封装</p>
</div>
<h2 id="四、ip、tcp、dns"> 四、IP、TCP、DNS</h2>
<h3 id="_4-1-负责传输的-ip-协议"> 4.1 负责传输的 IP 协议</h3>
<p>IP 网际协议属于网络层。</p>
<p>IP 协议作用就是把各种数据包传送给对方，而要确保确实传送到对方那里，需要满足各类条件，其中最重要的两个条件是 <strong>IP地址和MAC地址</strong></p>
<p><strong>IP地址指明了节点被分配到的地址，MAC地址是指网卡所属的固定地址。IP地址可以和MAC地址进行配对，IP地址可以变换，但MAC地址基本上不会更改。</strong></p>
<h4 id="_4-1-1-使用arp协议凭借mac地址进行通信"> 4.1.1 使用ARP协议凭借MAC地址进行通信</h4>
<p>IP间的通信依赖MAC。</p>
<p>通信的双方在同一局域网的情况较少，通常需要经过多台计算机和网络设备中转才能连接到对方。而在进行中转时，会利用下一站中转设备MAC地址来搜索下一个中转目标。</p>
<p>采用ARP协议用以解析地址，根据通信方的IP地址就可以反查除对应的MAC地址。</p>
<h4 id="_4-1-2-没人能够全面掌握互联网中的传输状况"> 4.1.2 没人能够全面掌握互联网中的传输状况</h4>
<p>在到达通信目标前的中转过程中，计算机和路由器等网络被只能获悉粗略的传输路线。</p>
<p><img src="./README.assets/image-20220226163246226.png" alt="image-20220226163246226" loading="lazy"></p>
<h3 id="_4-2-确保可靠性的tcp协议"> 4.2 确保可靠性的TCP协议</h3>
<p>TCP位于传输层，提供可靠的字节流服务。</p>
<p>所谓字节流服务，是指为了方便传输，将大块数据分割成以报文段为单位的数据包进行管理。可靠的传输是指能够把数据准确可靠地传给对方。</p>
<h4 id="确保数据能到达目标"> 确保数据能到达目标</h4>
<p>为了准确无误地将数据发送到目标出，TCP协议采用了三次握手策略。</p>
<p><img src="./README.assets/image-20220226164018205.png" alt="image-20220226164018205" loading="lazy"></p>
<h3 id="_4-3-负责域名解析的dns服务"> 4.3 负责域名解析的DNS服务</h3>
<p>DNS 和 HTTP 位于应用层。提供域名到IP地址之间的解析服务。</p>
<p><img src="./README.assets/image-20220226164211923.png" alt="image-20220226164211923" loading="lazy"></p>
<h2 id="五、各种协议和http协议的关系"> 五、各种协议和HTTP协议的关系</h2>
<p><img src="./README.assets/image-20220226164305673.png" alt="image-20220226164305673" loading="lazy"></p>
<h2 id="六、uri和url"> 六、URI和URL</h2>
<ul>
<li>URI 统一资源标识符</li>
<li>URL 统一资源定位符</li>
</ul>
<h3 id="_6-1-统一资源标识符"> 6.1 统一资源标识符</h3>
<p>URI Uniform Resource Identifier。URI是某个协议方案表示的资源的定位标识符。</p>
<p><img src="./README.assets/image-20220226164525768.png" alt="image-20220226164525768" loading="lazy"></p>
<p>URI用字符串标识某一互联网资源，而URL表示资源的地点（互联网上的位置），可以见URL是URI的子集。</p>
<p>URI的例子：</p>
<p><img src="./README.assets/image-20220226164641201.png" alt="image-20220226164641201" loading="lazy"></p>
<h3 id="_6-2-uri格式"> 6.2 URI格式</h3>
<p><img src="./README.assets/image-20220226164739984.png" alt="image-20220226164739984" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">路由器和交换机</title>
    <id>https://notes.lllllan.cn/cs-basic/network/def/router-and-switch/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/def/router-and-switch/"/>
    <updated>2022-04-20T07:20:15.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>
<p>《网络是怎样连接的》</p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_21187515/article/details/119375576" target="_blank" rel="noopener noreferrer">计算机网络-学习交换机_新林。的博客-CSDN博客_计算机网络交换机</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_21187515/article/details/119383038" target="_blank" rel="noopener noreferrer">计算机网络-学习路由器_新林。的博客-CSDN博客_计算机网络路由器</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/qq_21187515/article/details/119416934" target="_blank" rel="noopener noreferrer">计算机网络-路由器和交换机的区别_新林。的博客-CSDN博客_计算机网络路由器和交换机的区别</a></p>
</li>
</ul>
</div>
<h2 id="集线器"> 集线器</h2>
<blockquote>
<p>有交换机之前，我们都是用集线器连接成一个局域网的。集线器将信号发送给所有连接在它上面的线路。</p>
</blockquote>
<p>集线器的工作原理是把接收到的数据包直接广播给插入集线器的所有计算机，在这个局域网的计算机都能接收到这个数据包，然后判断这个数据包发送的MAC（物理地址）是否发送给自己，是给自己的就接收，不是就丢掉</p>
<h2 id="交换机"> 交换机</h2>
<blockquote>
<p>交换机是一种用于电(光)信号转发的网络设备，能连接多台设备形成一个局域网，简单来说就是可以把多台计算机连接起来，形成一个局域网。交换机是用于连接多台设备，让这些设备相互具备网络互通。</p>
</blockquote>
<p><img src="./readme.assets/af5447402dbc4f5ba19e36bcd17e461b.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><mark>交换机端口的MAC模块不具有MAC地址</mark></p>
<p>交换机的端口不核对接收方MAC地址，直接接收所有的包并存放到缓冲区中。</p>
<p>接下来查询MAC地址表，对于接收方的MAC地址在表中有记录的包会直接从对应的端口发送出去，没有记录的包则需要通过广播找到对应计算机连接的端口，将信息记录到表中并把包沿对应端口发送出去。</p>
<h3 id="mac地址表"> MAC地址表</h3>
<p>交换机中有一个MAC地址表，用于记录局域网中不同MAC地址连接着交换机的对应端口。</p>
<ul>
<li>当收到计算机发送的包时，会将发送方的MAC地址和经过的输入端口写入/更新到MAC地址表</li>
<li>定时将MAC地址表中的信息删除，防止设备移动时产生问题</li>
<li>当表中找不到接收方的MAC地址时，需要给所有端口发送广播，接收到响应之后记录到表中</li>
</ul>
<h2 id="路由器"> 路由器</h2>
<blockquote>
<p>路由器是连接两个或多个网络的硬件设备，在网络间起网关的作用。简单来说，路由器就是用来连接两个或多个不同的局域网的。即一个局域网里面的网络请求要访问外面，就需要路由器作为网关，通过路由器访问出去。</p>
</blockquote>
<p><img src="./readme.assets/20dc2460c6da436d94e097e49b1bb2c9.png" alt="在这里插入图片描述" loading="lazy"></p>
<p><mark>路由器的各个端口都具有MAC地址和IP地址。</mark></p>
<p>路由器在接收到包之后，会核对MAC头部的接收方MAC地址，如果是发送给自己的则放到缓冲区中，否则丢弃这个包。</p>
<div><p>路由器的端口都具有MAC地址，只接收与自身地址匹配的包</p>
</div>
<p>接下来路由器根据MAC头部后方的IP头部中的内容进行包的转发操作。从路由表中找到匹配的记录，在数据包前加上MAC头部再转发出去；如果路由表中无法找到匹配的记录则直接丢弃这个包，并通过ICMP消息告知发送方。</p>
<div><p>路由器工作的网络规模远大于交换机，广播的方式会产生大量的网络包从而造成网络拥塞</p>
</div>
<div><p>MAC头部</p>
<p>此时MAC地址就是用来找到路由器的，当一个包正确到达一个路由器的时候，这个MAC头部就已经完成它的使命了，可以丢弃了。</p>
<p>当还需要再转发给下一个路由器的时候，从路由表中查询记录，将下一个路由器的MAC地址添加到数据包签名，形成新的MAC头部，继续发送出去。</p>
</div>
<h3 id="路由表"> 路由表</h3>
<p>路由器中的路由表对应交换机中的MAC地址表，拥有相似的功能。</p>
<p>交换机是通过MAC头部中的接收方MAC地址来判断转发目标的，而路由器是根据IP头部中的IP地址来判断的。</p>
<p><mark>路由器在转发时会忽略主机号、只匹配网络号部分。</mark></p>
<blockquote>
<p>打个比方，路由器在转发包的时候只看接收方地址属于哪个区，XX区发往这一边，XX区发往那一边。</p>
</blockquote>
<hr>
<h4 id="路由表维护"> 路由表维护</h4>
<p>路由表记录维护的方式和交换机也有所不同。交换机中对 MAC 地址表的维护是包转发操作中的记录 MAC 地址，而路由器中对路由表的维护是与包转发操作相互独立的，也就是说，在转发包的过程中不需要对路由表的内容进行维护。</p>
<ul>
<li>人手动维护路由记录</li>
<li>根据路由协议机制，通过路由器之间的信息交换由路由器自行维护路由表中的记录。RIP、OSPC、BGP协议</li>
</ul>
<h3 id="ip地址匹配"> IP地址匹配</h3>
<p>子网是用来区分我们的IP地址的网络号和主机号的
例如我们查看IP地址，我们的IP地址是192.168.1.20，子网掩码：255.255.255.0，即192.168.1.20/24，那么就表示192.168.1是IP段【网络号】，后面的20是这个IP段的【主机号】。</p>
<p>匹配数据包和路由器的目标地址对上的网络号的记录即可。</p>
<blockquote>
<p>就好比寄快递一样，得写明哪个小区哪个房间号，小区就像网络号，房间号就像主机号。写明了快递员就可以把东西寄到相应的小区，再由小区转发到房间号，这样分类效率大幅提高。所以我们在路由器也是这样，找到对应网络号的就转出去就可以了，如果没有网络号，路由器就要保存大量主机号的IP，数据量多时每次查询效率就会很低，如果有网络号路由器保存的记录就会减少很多。</p>
</blockquote>
<hr>
<h4 id="路由聚合"> 路由聚合</h4>
<p>路由聚合会将几个子网合并成一个子网，并在路由表中只产生一条记录。</p>
<p>有些时候，发往子网A、子网B、子网C都要经过路由器X，此时干脆将 ABC 合并成一个子网，路由表中也只记录路由器X的信息，从而减少路由表中的记录数量。</p>
<p><img src="./readme.assets/image-20220420130107399.png" alt="image-20220420130107399" loading="lazy"></p>
<hr>
<h4 id="匹配到多条记录"> 匹配到多条记录</h4>
<p>如果匹配符合的记录有多个，例如 192.168.1.10 匹配到路由表的目标地址的两行记录：192.168.1.0/24，192.168.1.10/32。这种情况，路由器首先寻找网络号比特数最长的一条记录 。网络号比特数越长，说明主机号比特数越短，也就意味着该子网内可分配的主机数量越少，即子网中可能存在的主机数量越少，这一规则的目的是尽量缩小范围，所以根据这条记录判断的转发目标就会更加准确。</p>
<p>然而，有时候路由表中会存在网络号长度相同的多条记录，例如考虑到路由器或网线的故障而设置的备用路由就属于这种情况。这时，需要根据跃点计数的值来进行判断。跃点计数越小说明该路由越近，因此应选择跃点计数较小的记录。</p>
<div><p>跳跃点计数</p>
<p>跃点计数，它表示距离目标 IP 地址的距离是远还是近。这个数字越小，表示距离目的地越近；数字越大，表示距离目的地越远 。一般情况下，如果有多条到达相同目的地的路由记录，路由器会采用metric值小的那条路由</p>
</div>
<hr>
<h4 id="默认路由"> 默认路由</h4>
<p>路由表还有一行默认路由（发往更高层级的路由），目标地址为 0.0.0.0，子网掩码为 0.0.0.0 的记录，即匹配所有 IP，如果找不到其他网络号更长的记录，就会把数据包转发到默认的路由记录上去。</p>
<h3 id="转发"> 转发</h3>
<p>根据包里面发送的目的地IP地址，在路由表中进行匹配，匹配到的记录，</p>
<ul>
<li>如果网关IP不为空，则网关IP是发往下一个的地址</li>
<li>如果网关为空，则目标地址的IP是发往下一个的地址。</li>
</ul>
<p>知道对方的 IP 地址之后，路由器首先会在 ARP 缓存中查询该 IP 对用的 MAC 地址。如果找不到记录就需要通过 ARP 根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方MAC 地址。</p>
<p>把查询到的MAC头部加入数据包（上一个MAC地址包被丢掉），最后网络包封装完成后，接下来会将其转换成电信号并通过端口发送出去。</p>
<p><img src="./readme.assets/20210405220142454.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="包的有效期"> 包的有效期</h3>
<p>数据包的 IP 头部中记录一个 TTL（time to live，生存时间）字段，每经过一个路由器该值就会减1，当这个值变为 0 的时候，就表示超过了有限期，这个包就会被丢弃。</p>
<p>这个机制是为了防止包在一个地方陷入死循环。</p>
<blockquote>
<p>TTL 一般会设为 64 或 128，正常的通信一个包只需要经过几十个路由器就能被正确的转发；如果转发过程 TTL 减少为零，就认为他在某处陷入了死循环。</p>
</blockquote>
<h3 id="拆分大网络包"> 拆分大网络包</h3>
<p>路由器连接着的不同局域网允许的最大包长度可能不同，可能出现接收到一个包，但是包的长度超出了接下来要转发的局域网允许的最大包长度。遇到这种情况，可以使用 IP 协议中定义的分片功能对包进行拆分，缩短每个包的长度。</p>
<div><p>IP协议分片 & TCP拆分</p>
<p>TCP拆分数据的操作是在将数据装到包里之前进行的。IP分片是对一个完整的包进行拆分。</p>
</div>
<div><p>IP头部有标志字段表示是否允许对数据包进行分片，如果不允许只好丢弃这个包，并通过ICMP消息通知发送方</p>
</div>
<p><img src="./readme.assets/image-20220420150735618.png" alt="image-20220420150735618" loading="lazy"></p>
<h2 id="路由器和交换机的区别"> 路由器和交换机的区别</h2>
<ul>
<li>路由器是基于IP协议设计的，交换机是基于以太网设计的</li>
<li>交换机用于连接局域网，数据包在局域网内部转发；路由器用于连接局域网和外网，数据包可以在不同局域网之间转发</li>
<li>交换机工作于数据链路层，路由器工作与网络层</li>
<li>（纯粹的）交换机没有MAC地址和IP地址，（纯粹的）的路由器有MAC地址和IP地址</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-20T07:20:07.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十一章、Web的攻击技术</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/11/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/11/"/>
    <updated>2022-04-07T02:20:31.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、针对web的攻击技术"> 一、针对Web的攻击技术</h2>
<p><img src="./README.assets/image-20220407100501696.png" alt="image-20220407100501696" loading="lazy"></p>
<h3 id="_1-1-http不具备必要的安全功能"> 1.1 HTTP不具备必要的安全功能</h3>
<p>从整体上看，HTTP就是一个通用的单纯协议机制。因此它具备较多优势，但是在安全性方面则呈劣势。</p>
<p>就拿远程登录时会用到的SSH协议来说，SSH具备协议级别的认证及会话管理等功能，HTTP协议则没有。另外在架设SSH服务方面，任何人都可以轻易地创建安全等级高的服务，而HTTP即使已架设好服务器，但若想提供服务器基础上的Web应用，很多情况下都需要重新开发。</p>
<p>因此，开发者需要自行设计并开发认证及会话管理功能来满足Web应用的安全。</p>
<h3 id="_1-2-在客户端即可篡改请求"> 1.2 在客户端即可篡改请求</h3>
<p>在Web应用中，从浏览器那接收到的HTTP请求的全部内容，都可以在客户端自由地变更、篡改。所以Web应用可能会接收到与预期数据不相同的内容。</p>
<p><img src="./README.assets/image-20220407101251811.png" alt="image-20220407101251811" loading="lazy"></p>
<h3 id="_1-3-针对web应用的攻击模式"> 1.3 针对Web应用的攻击模式</h3>
<p><strong>以服务器为目标的主动攻击</strong></p>
<p>主动攻击(activeattack)是指攻击者通过直接访问Web应用，把攻击代码传 人的攻击模式。由于该模式是直接针对服务器上的资源进行攻击，因此攻击者需要能够访问到那些资源。</p>
<p>主动攻击模式里具有代表性的攻击是 <mark>SQL注人攻击</mark> 和 <mark>OS命令注人攻击</mark></p>
<p><img src="./README.assets/image-20220407101433605.png" alt="image-20220407101433605" loading="lazy"></p>
<hr>
<p><strong>以服务器为目标的被动攻击</strong></p>
<p>被动攻击( passive attack )是指利用圈套策略执行攻击代码的攻击模式。在被动攻击过程中，攻击者不直接对目标Web应用访问发起攻击。</p>
<blockquote>
<p>步骤1：攻击者诱使用户触发已设置好的陷阱，而陷阱会启动发送已嵌人攻击代码的HTTP请求。</p>
<p>步骤2：当用户不知不觉中招之后，用户的浏览器或邮件客户端就会触发这个陷阱。</p>
<p>步骤3：中招后的用户浏览器会把含有攻击代码的HTTP请求发送给作为攻击目标的Web应用，运行攻击代码。</p>
<p>步骤4：执行完攻击代码，存在安全漏洞的Web应用会成为攻击者的跳板，可能导致用户所持的Cookie等个人信息被窃取，登录状态中的用户权限遭恶意滥用等后果。被动攻击模式中具有代表性的攻击是跨站脚本攻击和跨站点请求伪造。</p>
</blockquote>
<p><img src="./README.assets/image-20220407101651134.png" alt="image-20220407101651134" loading="lazy"></p>
<p><img src="./README.assets/image-20220407101712334.png" alt="image-20220407101712334" loading="lazy"></p>
<h2 id="二、因输出值转义不完全引发的安全漏洞"> 二、因输出值转义不完全引发的安全漏洞</h2>
<p><img src="./README.assets/image-20220407101827386.png" alt="image-20220407101827386" loading="lazy"></p>
<h3 id="_2-1-跨站脚本攻击"> 2.1 跨站脚本攻击</h3>
<p>跨站脚本攻击(Cross Site Scripting, XSS)是指通过存在安全漏洞的Web网站注册用户的浏览器内运行非法的HTML标签或JavaScript进行的一种攻击。动态创建的HTML部分有可能隐藏着安全漏洞。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-07T02:20:31.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">计算机网络-常见面试题</title>
    <id>https://notes.lllllan.cn/cs-basic/network/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/"/>
    <updated>2022-04-25T03:00:45.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自以下文章，略有改动。</p>
<ul>
<li><a href="https://www.jianshu.com/p/576dbf44b2ae" target="_blank" rel="noopener noreferrer">什么是 JWT -- JSON WEB TOKEN - 简书 (jianshu.com)</a></li>
<li><a href="https://www.jianshu.com/p/e4d9dcda0558" target="_blank" rel="noopener noreferrer">JWT如何实现登录、鉴权 - 简书 (jianshu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/356225028" target="_blank" rel="noopener noreferrer">面试题：聊聊TCP的粘包、拆包以及解决方案 - 知乎 (zhihu.com)</a></li>
<li><a href="https://bbs.csdn.net/topics/40099566" target="_blank" rel="noopener noreferrer">服务器端一个端口可以响应很多客户端的请求吗？-CSDN社区</a></li>
<li><a href="https://www.cnblogs.com/yinbiao/p/11014863.html" target="_blank" rel="noopener noreferrer">使用TCP的协议有哪些？使用UDP的协议有哪些？ - 西*风 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/Emperor10/article/details/123179056" target="_blank" rel="noopener noreferrer">HTTP请求协议格式详解_Emperor10的博客-CSDN博客_http请求协议</a></li>
</ul>
</div>
<h2 id="ip地址和mac地址"> IP地址和MAC地址</h2>
<blockquote>
<p>网上看到的一些区别和联系，感觉总结的有点无关痛痒。我觉得最重要的一点是，两个都是地址，那共存的必要和意义在哪里。下面是我的一些口胡，不一定对。</p>
</blockquote>
<p>IP地址的划分是基于网络的拓扑结构、基于地理区域，这样的好处是，我能很快地找到某个IP地址。比如我想和 <code>192.168.1.20</code> 取得通信，我可以先找到 <code>192.0.0.0</code> 的位置，进而再找到 <code>192.168.0.0</code> 的位置，最后摸索到 <code>192.168.1.20</code> 的位置（当然，这是路由器干的活）。</p>
<p>IP地址的意义在于，根据地理区域划分；具有相同网络号的（就当是ip地址的前缀）的IP地址会被划分到一起。这样的划分下，我们能够较快地找到某个IP地址。</p>
<p><s>那好了，有IP地址就够了咯。再整一个MAC地址多烦人</s></p>
<p>IP地址是方便了，但是基于地理区域划分之后的问题是，你带不走他。如果你的电子设备从上海带到了北京，哪怕只是换了个小区，都会离开原来的IP地址。但是一个设备又必须拥有自己的【唯一标识】，于是需要MAC地址。</p>
<p>通过IP地址与MAC地址的捆绑，想要和某一台主机进行通信。则需要通过IP地址快速定位到该主机所在的区域，尽可能地缩小范围之后，通过MAC地址去确认主机的【身份】。</p>
<div><p>比喻</p>
<p>把网络通信当作是寄快递，IP地址就是你的家庭住址，MAC地址是你的身份证。</p>
<p>通过家庭住址&lt;国家-省份-城市-区-街-小区-楼幢-楼层-门牌号&gt;一步一步找到你家里来，然后签收的时候核验一下你的身份证，确认接收方无误之后把快递交给你。</p>
</div>
<h2 id="http请求格式"> HTTP请求格式</h2>
<p>请求行 + 请求头部 + 空行 + 请求主体。</p>
<p><img src="./README.assets/image-20220315081628361.45a076a6-16506218004142.png" alt="image-20220315081628361" loading="lazy"></p>
<h3 id="请求方法"> 请求方法</h3>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">GET</td>
<td style="text-align:center">获取资源</td>
</tr>
<tr>
<td style="text-align:center">POST</td>
<td style="text-align:center">传输实体主体</td>
</tr>
<tr>
<td style="text-align:center">PUT</td>
<td style="text-align:center">传输文件</td>
</tr>
<tr>
<td style="text-align:center">HEAD</td>
<td style="text-align:center">获得报文首部</td>
</tr>
<tr>
<td style="text-align:center">DELETE</td>
<td style="text-align:center">删除文件</td>
</tr>
<tr>
<td style="text-align:center">OPTIONS</td>
<td style="text-align:center">询问支持的方法</td>
</tr>
<tr>
<td style="text-align:center">TRACE</td>
<td style="text-align:center">追踪路径</td>
</tr>
<tr>
<td style="text-align:center">CONNECT</td>
<td style="text-align:center">要求用隧道协议链接代理</td>
</tr>
<tr>
<td style="text-align:center">LINK</td>
<td style="text-align:center">建立和资源之间的联系</td>
</tr>
<tr>
<td style="text-align:center">UNLINE</td>
<td style="text-align:center">断开连接关系</td>
</tr>
</tbody>
</table>
<h3 id="首部字段"> 首部字段</h3>
<p><strong>通用首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">首部字段名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Cache-Control</td>
<td style="text-align:center">控制缓存的行为</td>
</tr>
<tr>
<td style="text-align:center">Connection</td>
<td style="text-align:center">逐跳首部、连接的管理</td>
</tr>
<tr>
<td style="text-align:center">Date</td>
<td style="text-align:center">创建报文的日期时间</td>
</tr>
<tr>
<td style="text-align:center">Pragma</td>
<td style="text-align:center">报文指令</td>
</tr>
<tr>
<td style="text-align:center">Trailer</td>
<td style="text-align:center">报文末端的首部一览</td>
</tr>
<tr>
<td style="text-align:center">Transfer-Encoding</td>
<td style="text-align:center">指定报文主体的传输编码方式</td>
</tr>
</tbody>
</table>
<p><strong>请求首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept</td>
<td style="text-align:center">用户代理可处理的媒体类型</td>
</tr>
<tr>
<td style="text-align:center">Accept-Charset</td>
<td style="text-align:center">优先的字符集</td>
</tr>
<tr>
<td style="text-align:center">Accept-Encoding</td>
<td style="text-align:center">优先的内容编码</td>
</tr>
<tr>
<td style="text-align:center">Accept-Language</td>
<td style="text-align:center">优先的语言</td>
</tr>
<tr>
<td style="text-align:center">From</td>
<td style="text-align:center">用户的电子邮箱地址</td>
</tr>
<tr>
<td style="text-align:center">Host</td>
<td style="text-align:center">请求资源所在服务器</td>
</tr>
<tr>
<td style="text-align:center">Range</td>
<td style="text-align:center">实体的字节范围请求</td>
</tr>
</tbody>
</table>
<p><strong>响应首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Accept-Ranges</td>
<td style="text-align:center">是否接受字节范围请求</td>
</tr>
<tr>
<td style="text-align:center">Location</td>
<td style="text-align:center">令客户重定向至指定URI</td>
</tr>
</tbody>
</table>
<p><strong>实体首部字段</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center">方法</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Allow</td>
<td style="text-align:center">资源可支持的HTTP方法</td>
</tr>
<tr>
<td style="text-align:center">Content-Encoding</td>
<td style="text-align:center">实体主体适用的编码方式</td>
</tr>
<tr>
<td style="text-align:center">Content-Language</td>
<td style="text-align:center">实体主体的自然语言</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">实体主体的大小（字节）</td>
</tr>
<tr>
<td style="text-align:center">Content-Length</td>
<td style="text-align:center">替代对应资源的URI</td>
</tr>
<tr>
<td style="text-align:center">Content-Range</td>
<td style="text-align:center">实体主体的位置范围</td>
</tr>
<tr>
<td style="text-align:center">Content-Type</td>
<td style="text-align:center">实体主体的媒体类型</td>
</tr>
</tbody>
</table>
<h2 id="tcp、udp协议的区别"> TCP、UDP协议的区别</h2>
<p><img src="./README.assets/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别" loading="lazy"></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="使用tcp、udp的协议"> 使用TCP、UDP的协议</h2>
<p><strong>运行于TCP协议之上的协议：</strong></p>
<p>HTTP协议：超文本传输协议，用于普通浏览</p>
<p>HTTPS协议：安全超文本传输协议，身披SSL外衣的HTTP协议</p>
<p>FTP协议：文件传输协议，用于文件传输</p>
<p>POP3协议：邮局协议，收邮件使用</p>
<p>SMTP协议：简单邮件传输协议，用来发送电子邮件</p>
<p>Telent协议：远程登陆协议，通过一个终端登陆到网络</p>
<p>SSH协议：安全外壳协议，用于加密安全登陆，替代安全性差的Telent协议</p>
<p><strong>运行于UDP协议之上的协议：</strong></p>
<p>DNS协议：用于域名解析服务</p>
<p>DHCP协议：动态主机配置协议，动态配置IP地址</p>
<p>NTP协议：网络时间协议，用于网络时间同步</p>
<p>BOOTP协议：引导程序协议，DHCP协议的前身，用于无盘工作站从中心服务器上获取IP地址</p>
<h2 id="状态码"> 状态码</h2>
<p>下面是常见的 HTTP 状态码：</p>
<ul>
<li>200 - 请求成功</li>
<li>301 - 资源（网页等）被永久转移到其它URL</li>
<li>404 - 请求的资源（网页等）不存在</li>
<li>500 - 内部服务器错误</li>
</ul>
<p><img src="./README.assets/状态码.png" alt="状态码" loading="lazy"></p>
<h2 id="如何保存用户状态"> 如何保存用户状态</h2>
<p>**HTTP 是一种不保存状态，即无状态（stateless）协议。**也就是说 HTTP 协议自身不对请求和响应之间的通信状态进行保存。</p>
<p>Session 机制的存在就是为了解决这个问题，Session 的主要作用就是<strong>通过服务端记录用户的状态</strong>。典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了（一般情况下，服务器会在一定时间内保存这个 Session，过了时间限制，就会销毁这个 Session）。</p>
<p>在服务端保存 Session 的方法很多，最常用的就是内存和数据库(比如是使用内存数据库 redis 保存)。既然 Session 存放在服务器端，那么我们如何实现 Session 跟踪呢？大部分情况下，我们都是<strong>通过在 Cookie 中附加一个 Session ID 来方式来跟踪</strong>。</p>
<h3 id="cookie被禁用怎么办"> Cookie被禁用怎么办</h3>
<p>最常用的就是利用 URL 重写把 Session ID 直接附加在 URL 路径的后面。</p>
<h3 id="cookie-和-session"> Cookie 和 Session</h3>
<p>Cookie 和 Session 都是用来跟踪浏览器用户身份的会话方式，但是两者的应用场景不太一样。</p>
<p><strong>Cookie 一般用来保存用户信息</strong> ：</p>
<ol>
<li>我们在 Cookie 中保存已经登录过的用户信息，下次访问网站的时候页面可以自动帮你把登录的一些基本信息给填了；</li>
<li>一般的网站都会有保持登录，也就是说下次你再访问网站的时候就不需要重新登录了，这是因为用户登录的时候我们可以存放了一个 Token 在 Cookie 中，下次登录的时候只需要根据 Token 值来查找用户即可(为了安全考虑，重新登录一般要将 Token 重写)；</li>
<li>登录一次网站后访问网站其他页面不需要重新登录。</li>
</ol>
<p><strong>Session 的主要作用就是通过服务端记录用户的状态。</strong> 典型的场景是购物车，当你要添加商品到购物车的时候，系统不知道是哪个用户操作的，因为 HTTP 协议是无状态的。服务端给特定的用户创建特定的 Session 之后就可以标识这个用户并且跟踪这个用户了。</p>
<p>Cookie 存储在客户端中，而 Session 存储在服务器上，相对来说 Session 安全性更高。如果要在 Cookie 中存储一些敏感信息，不要直接写入 Cookie 中，最好能将 Cookie 信息加密，然后使用到的时候再去服务器端解密。</p>
<h2 id="uri-和-url-的区别"> URI 和 URL 的区别</h2>
<ul>
<li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li>
<li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li>
</ul>
<p>URI 的作用像身份证号一样，URL 的作用更像家庭住址一样。URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息</p>
<h2 id="json-web-token"> Json Web Token</h2>
<p>Json web token（JWT）是为了网络应用环境间传递声明而执行的一种基于JSON的开发标准（RFC 7519），该token被设计为紧凑且安全的，特别适用于分布式站点的单点登陆（SSO）场景。</p>
<div><p>传统的session认证</p>
<p>客户端向服务器发送用户信息，服务器验证之后向客户端发放 sessionid。客户端将 sessionid 保存在cookie 中，需要用时将 sessionid 发给服务器验证即可。</p>
<p>基于session认证的问题</p>
<ul>
<li>session：通常而言 session 都是保存在内存中，而随着认证用户的增多，服务端的开销会明显增大</li>
<li>扩展性：用户认证之后，服务端做认证记录，如果认证的记录被保存在内存中的话，这意味着用户下次请求还必须要请求在这台服务器上，这样才能拿到授权的资源，这样在分布式的应用上，相应的限制了负载均衡器的能力。这也意味着限制了应用的扩展能力。</li>
<li>安全性：信息如果被截获，用户就会很容易受到跨站请求伪造的攻击</li>
</ul>
</div>
<h3 id="jwt-认证流程"> JWT 认证流程</h3>
<ol>
<li>浏览器发起请求登陆，携带用户名和密码；</li>
<li>服务端验证身份，根据算法，将用户标识符打包生成 token</li>
<li>服务器返回 JWT 信息给浏览器，JWT不包含敏感信息；</li>
<li>浏览器发起请求获取用户资料，把刚刚拿到的 token 一起发送给服务器；</li>
<li>服务器发现数据中有 token，验明正身；</li>
<li>服务器返回该用户的用户资料；</li>
</ol>
<p><img src="./README.assets/jwt.png" alt="img" loading="lazy"></p>
<h3 id="jwt-优缺点"> JWT 优缺点</h3>
<p>优点：</p>
<ul>
<li>json 的通用性，可以跨语言</li>
<li>组成简单，字节占用笑，便于传输</li>
<li>服务端无需保存会话信息，便于扩展</li>
</ul>
<p>缺点：</p>
<ul>
<li>payload 部分进行简单编码，不宜存放敏感信息</li>
</ul>
<h3 id="jwt-构成"> JWT 构成</h3>
<p>JSON Web Token由【头部(Header)、载荷(Payload)、签证(Signature)】三部分组成，它们之间用圆点(.)连接。</p>
<ul>
<li>头部。头部承载两部分信息：声明类型，这里是jwt；声明加密的算法，通常直接使用 HMAC SHA256</li>
<li>载荷。Payload 部分也是一个 JSON 对象，用来存放实际需要传递的数据。</li>
<li>签证。Signature 部分是对前两部分的签名，防止数据篡改。</li>
</ul>
<p>首先，需要指定一个密钥（secret）。这个密钥只有服务器才知道，不能泄露给用户。然后，使用 Header 里面指定的签名算法（默认是 HMAC SHA256），按照下面的公式产生签名。</p>
<blockquote>
<p>HMACSHA256(  base64UrlEncode(header) + &quot;.&quot; +  base64UrlEncode(payload),   secret)</p>
</blockquote>
<p>算出签名以后，把 Header、Payload、Signature 三个部分拼成一个字符串，每个部分之间用&quot;点&quot;（.）分隔，就构成整个JWT对象TOKEN， 就可以返回给用户。</p>
<h2 id="服务端一个端口响应多个客户端请求"> 服务端一个端口响应多个客户端请求</h2>
<p>服务端至少要有一个SOCKET处于监听状态（Listen），负责监听针对某个端口（Port）的连接请求；
当客户端的请求到达时，动态创建（new）一个SOCKET用于连接，此时，用于监听的SOCKET再次进入监听状态（调用Listen），此后，由参与连接的SOCKET完成与客户端的通信过程。
通常，创建几百个连接是可以，但不会同时启动上百个线程同时处理所有的请求；如果同时请求的客户端比较多（比如＞50），则通常启动固定数目（低于请求）的线程，请求排队等待处理。
线程的数目参考处理的速度，如果是瞬间完成的，则可以少，如果处理较慢，则可以多</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:03:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十章、构建Web内容的技术</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/10/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/10/"/>
    <updated>2022-03-21T10:34:27.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、html"> 一、HTML</h2>
<h3 id="_1-1-web-页面几乎全由-html-构建"> 1.1 Web 页面几乎全由 HTML 构建</h3>
<p>HTML（HyperText Markup Language，超文本标记语言）是为了发送 Web 上的超文本而开发的标记语言。</p>
<p><strong>超文本</strong></p>
<p>超文本是一种文档系统，可将文档中任意位置的信息与其他信息（文本或图片）简历关联，即超链接文本</p>
<p><strong>标记语言</strong></p>
<p>通过在文档的某部分穿插特别的字符串标签，用来修饰文档的语言。</p>
<p><img src="./README.assets/image-20220321175942615.png" alt="image-20220321175942615" loading="lazy"></p>
<h3 id="_1-2-html-版本"> 1.2 HTML 版本</h3>
<h3 id="_1-3-css"> 1.3 CSS</h3>
<p>CSS（Cascading Style Sheets，层叠样式表）可以指定如何展现 HTML 内的各种元素，属于央视表标准之一。</p>
<h2 id="二、动态-html"> 二、动态 HTML</h2>
<h3 id="_2-1-html"> 2.1 HTML</h3>
<p>动态语言，使用客户端脚本语言将静态的 HTML 语言内容变成动态的技术的总称。</p>
<p>动态 HTML 技术是通调用客户端脚本语言 JavaScript，实现对 HTML 的 Web 页面的动态改造。利用 DOM（Document Object Model，文档对象模型）可指定欲发生动态变化的 HTML 元素。</p>
<h3 id="_2-2-dom"> 2.2 DOM</h3>
<p>DOM 是用以操作 HTML 文档和 XML 文档的 API(ApplicationProgramming Interface，应用编程接口)。使用 DOM 可以将 HTML 内的元素当作对象操作，如取出元素内的字符串、改变那个 CSS 的属性等，使页面的设计发生改变。</p>
<h2 id="三、web-应用"> 三、Web 应用</h2>
<h3 id="_3-1-web-应用"> 3.1 Web 应用</h3>
<p>Web应用是指通过Web功能提供的应用程序。</p>
<p><img src="./README.assets/image-20220321180721578.png" alt="image-20220321180721578" loading="lazy"></p>
<h3 id="_3-2-cgi"> 3.2 CGI</h3>
<p>CGI( Common Gateway Interface,，通用网关接口)是指Web服务器在接收到客户端发送过来的请求后转发给程序的一-组机制。</p>
<p><img src="./README.assets/image-20220321180847399.png" alt="image-20220321180847399" loading="lazy"></p>
<h3 id="_3-3-servlet"> 3.3 Servlet</h3>
<p>Servlet 是一种能在服务器上创建动态内容的程序。Servlet 是用 Java 语言实现的一个接口，属于面向企业级Java ( JavaEE，Java Enterprise Edition)的一部分。</p>
<p>之前提及的CGI，由于每次接到请求，程序都要跟着启动一次。因此一旦访问量过大，Web服务器要承担相当大的负载。而 Servlet 运行在与 Web 服务器相同的进程中，因此受到的负载较小。Servlet 的运行环境叫做 Web 容器或 Servlet 容器。</p>
<p><img src="./README.assets/image-20220321181109933.png" alt="image-20220321181109933" loading="lazy"></p>
<h2 id="四、数据发布的格式及语言"> 四、数据发布的格式及语言</h2>
<h3 id="_4-1-可扩展标记语言"> 4.1 可扩展标记语言</h3>
<p>XML ( eXtensible Markup Language，可扩展标记语言)是一种可按应用目标进行扩展的通用标记语言。旨在通过使用XML，使互联网数据共享变得更容易。</p>
<div><pre><code>&lt;研讨会编号="TR001" 主题="Web应用程序脆弱性诊断讲座">
    <span><span><span>&lt;</span>类别</span><span>></span></span>安全<span><span><span>&lt;/</span>类别</span><span>></span></span>
    <span><span><span>&lt;</span>概要</span><span>></span></span>为深入研究Web应用程序脆弱性诊断必要的-<span><span><span>&lt;/</span>概要</span><span>></span></span>
<span><span><span>&lt;/</span>研讨会</span><span>></span></span>
&lt;研讨会编号="TR002”主题=”网络系统脆弱性诊断讲座">
    <span><span><span>&lt;</span>类别</span><span>></span></span>安全<span><span><span>&lt;/</span>类别</span><span>></span></span>
    <span><span><span>&lt;</span>概要</span><span>></span></span>为深入研究网络系统脆弱性诊断必要的-<span><span><span>&lt;/</span>概要</span><span>></span></span>
<span><span><span>&lt;/</span>研讨会</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>XML和HTML一样，使用标签构成树形结构，并且可自定义扩展标签。
从XML文档中读取数据比起HTML更为简单。由于XML的结构基本上都是用标签分割而成的树形结构，因此通过语法分析器( Parser )的解析功能解析XML结构并取出数据元素，可更容易地对数据进行读取。</p>
<h3 id="_4-2-rss-atom"> 4.2 RSS/Atom</h3>
<p>RSS(简易信息聚合，也叫聚合内容 ) 和 Atom 都是发布新闻或博客日志等更新信息文档的格式的总称。两者都用到了XML。</p>
<h3 id="_4-3-json"> 4.3 JSON</h3>
<p>JSON ( JavaScript Object Notation)是-种以JavaScript ( ECMAScript )的对象表示法为基础的轻量级数据标记语言</p>
<div><pre><code><span>{</span>name<span>:</span> <span>"Web Application Security"</span><span>,</span> <span>"num"</span><span>:</span> <span>"TR001"</span> <span>}</span>
</code></pre>
<div><span>1</span><br></div></div><p>JSON 让数据更轻更纯粹，并且 JSON 的字符串形式可被JavaScript 轻易地读人。当初配合 XML 使用的 Ajax 技术也让 JSON 的应用变得更为广泛。另外，其他各种编程语言也提供丰富的库类，以达到轻便操作 JSON 的目的。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-21T10:34:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第二章、简单的HTTP协议</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/2/"/>
    <updated>2022-03-17T15:18:20.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、http-协议用于客户端和服务器之间的通信"> 一、HTTP 协议用于客户端和服务器之间的通信</h2>
<p><img src="./README.assets/image-20220227091206726.png" alt="image-20220227091206726" loading="lazy"></p>
<h2 id="二、通过请求和响应的交换达成信息"> 二、通过请求和响应的交换达成信息</h2>
<h3 id="_2-1-由客户端发出请求"> 2.1 由客户端发出请求</h3>
<p>HTTP 协议规定，请求从客户端发出，最后服务器端响应该请求并返回。即肯定是先从客户端开始建立通信，服务器端在没有接收到请求之前不会发送响应。</p>
<p><img src="./README.assets/image-20220227091444975.png" alt="image-20220227091444975" loading="lazy"></p>
<h3 id="_2-2-请求报文和响应报文"> 2.2 请求报文和响应报文</h3>
<p><img src="./README.assets/image-20220227091739545.png" alt="image-20220227091739545" loading="lazy"></p>
<p><img src="./README.assets/image-20220227091905174.png" alt="image-20220227091905174" loading="lazy"></p>
<p><img src="./README.assets/image-20220227091954558.png" alt="image-20220227091954558" loading="lazy"></p>
<h2 id="三、http-是不保存状态的协议"> 三、HTTP 是不保存状态的协议</h2>
<p><strong>HTTP 是一种不保存状态，即无状态协议。</strong></p>
<p>HTTP 协议自身不对请求和响应之间的通信状态进行保存，也就是说在 HTTP 这个级别，协议对于发送过的请求或处理都不做持久化处理。</p>
<p><img src="./README.assets/image-20220227092619787.png" alt="image-20220227092619787" loading="lazy"></p>
<p>HTTP 协议本身并不保留之前一切的请求或响应报文的信息，是为了更快地处理大量事务，确保协议的可伸缩性。而特意把HTTP协议设计成如此简单。</p>
<p>随着 Web 的发展，网站为了能够掌握是谁发出的请求，需要爆粗你用户的状态，于是引入了 Cookie  技术。</p>
<h2 id="四、请求-uri-定位资源"> 四、请求 URI 定位资源</h2>
<p><img src="./README.assets/image-20220227093559141.png" alt="image-20220227093559141" loading="lazy"></p>
<h2 id="五、告知服务器意图的-http-方法"> 五、告知服务器意图的 HTTP 方法</h2>
<h3 id="_5-1-get-获取资源"> 5.1 GET 获取资源</h3>
<p><strong>GET 方法用来请求访问已被 URI 识别的资源。</strong></p>
<p><img src="./README.assets/image-20220227093903573.png" alt="image-20220227093903573" loading="lazy"></p>
<h3 id="_5-2-post-传输实体主体"> 5.2 POST 传输实体主体</h3>
<p><strong>POST 方法用来传输实体的主体。</strong></p>
<p><img src="./README.assets/image-20220227094258190.png" alt="image-20220227094258190" loading="lazy"></p>
<p><img src="./README.assets/image-20220227094312733.png" alt="image-20220227094312733" loading="lazy"></p>
<p>虽然 POST 的功能和 GET 相似，但是 POST 的主要目的不是获取响应的主体内容。</p>
<h3 id="_5-3-put-传输文件"> 5.3 PUT 传输文件</h3>
<p><strong>PUT 方法用来传输文件。</strong></p>
<div><p>鉴于 `HTTP/1.1` 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 Web 网站不适用该方法。</p>
</div>
<p><img src="./README.assets/image-20220227094641387.png" alt="image-20220227094641387" loading="lazy"></p>
<h3 id="_5-4-head-获得报文首部"> 5.4 HEAD 获得报文首部</h3>
<p><strong>HEAD 方法用于确认 URI 的有效性及资源更新的日期时间等</strong></p>
<p><img src="./README.assets/image-20220227101248661.png" alt="image-20220227101248661" loading="lazy"></p>
<h3 id="_5-5-delete-删除文件"> 5.5 DELETE 删除文件</h3>
<p><strong>DELETE 方法按请求 URI 删除指定的资源</strong></p>
<p><img src="./README.assets/image-20220227101428213.png" alt="image-20220227101428213" loading="lazy"></p>
<p><img src="./README.assets/image-20220227101441751.png" alt="image-20220227101441751" loading="lazy"></p>
<div><p>HTTP/1.1 的 DELETE 方法本身和 PUT 方法一样不带验证机制，同样有安全性问题，所以一般的 Web 网站也不使用 DELETE 方法</p>
</div>
<h3 id="_5-6-options-询问支持的方法"> 5.6 OPTIONS 询问支持的方法</h3>
<p><strong>OPTIONS 方法用来查询针对请求 URI 指定的资源支持的方法。</strong></p>
<p><img src="./README.assets/image-20220227101655531.png" alt="image-20220227101655531" loading="lazy"></p>
<h3 id="_5-7-trace-追踪路径"> 5.7 TRACE 追踪路径</h3>
<p><strong>TRACE 方法是让 Web 服务器端将之前的请求通信环会给客户端的方法。</strong></p>
<p><img src="./README.assets/image-20220227101820954.png" alt="image-20220227101820954" loading="lazy"></p>
<h3 id="_5-8-connect-要求用隧道协议连接代理"> 5.8 CONNECT 要求用隧道协议连接代理</h3>
<p><strong>CONNECT 方法要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。</strong></p>
<p>主要使用 SSL（Secure Sockets Layer，安全套接层） 和 TLS（Transport Layer Security，传输层安全）协议把通信内容加密后经网络隧道传输。</p>
<p><img src="./README.assets/image-20220227102117671.png" alt="image-20220227102117671" loading="lazy"></p>
<h2 id="六、使用方法下达命令"> 六、使用方法下达命令</h2>
<p>向请求 URI 指定的资源发送请求报文时，采用称为方法的命令。</p>
<p><img src="./README.assets/image-20220227102408569.png" alt="image-20220227102408569" loading="lazy"></p>
<p><img src="./README.assets/image-20220227102152508.png" alt="image-20220227102152508" loading="lazy"></p>
<h2 id="七、持久连接节省通信量"> 七、持久连接节省通信量</h2>
<p><img src="./README.assets/image-20220227102638351.png" alt="image-20220227102638351" loading="lazy"></p>
<p>HTTP 协议的初始版本中，每进行一次 HTTP 通信就要断开一次 TCP 连接。但在浏览一个包含多张图片的页面时，在发送请求访问页面资源的同时还要请求该页面中包含的其他资源，就需要多次请求，从而造成无谓的 TCP 连接和断开，增加通信量的开销。</p>
<p><img src="./README.assets/image-20220227103013072.png" alt="image-20220227103013072" loading="lazy"></p>
<h3 id="_7-1-持久连接"> 7.1 持久连接</h3>
<p><strong>持久连接：只要任意一段没有明确提出断开连接，就保持TCP连接状态</strong></p>
<p><img src="./README.assets/image-20220227103148019.png" alt="image-20220227103148019" loading="lazy"></p>
<p><strong>好处：</strong></p>
<ol>
<li>减少了TCP连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。</li>
<li>减少开销的那部分时间，使HTTP请求和响应能够更早结束，让Web页面的显示速度相应提高</li>
</ol>
<h3 id="_7-2-管线化"> 7.2 管线化</h3>
<p><strong>管线化技术：发送请求后不需要等待响应就可以直接发送下一个请求。</strong></p>
<p><img src="./README.assets/image-20220227103647845.png" alt="image-20220227103647845" loading="lazy"></p>
<h2 id="八、使用-cookie-的状态管理"> 八、使用 Cookie 的状态管理</h2>
<p><img src="./README.assets/image-20220227103740244.png" alt="image-20220227103740244" loading="lazy"></p>
<p>Cookie 技术通过在请求和响应报文中写入 Cookie 信息来控制客户端的状态。</p>
<p>Cookie 会根据从服务器端发送的响应报文内的一个叫做 <code>Set-Cookie</code> 的首部字段信息，通知客户端保存 Cookie。</p>
<p><img src="./README.assets/image-20220227104335267.png" alt="image-20220227104335267" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第三章、HTTP报文</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/3/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/3/"/>
    <updated>2022-04-07T02:41:17.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、http-报文"> 一、HTTP 报文</h2>
<p>用于HTTP协议交互的信息称为HTTP报文，大致可以分为<strong>报文首部和报文主体</strong>两部分。</p>
<p><img src="./README.assets/image-20220301083127607.png" alt="image-20220301083127607" loading="lazy"></p>
<h2 id="二、报文结构"> 二、报文结构</h2>
<p><img src="./README.assets/image-20220301083301985.png" alt="image-20220301083301985" loading="lazy"></p>
<ul>
<li><strong>请求行</strong>：包含用于请求的方法，请求URI和HTTP版本</li>
<li><strong>状态行</strong>：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li><strong>首部字段</strong>：包含表示请求和响应的各种条件和属性的各类首部（通用、请求、响应、实体）</li>
</ul>
<p><img src="./README.assets/image-20220301083322587.png" alt="image-20220301083322587" loading="lazy"></p>
<h2 id="三、编码提升传输速率"> 三、编码提升传输速率</h2>
<h3 id="_3-1-报文主体和实体主体的差异"> 3.1 报文主体和实体主体的差异</h3>
<ul>
<li><strong>报文</strong>：HTTP通信中的基本单位，由8位组字节流组成，通过HTTP通信传输</li>
<li><strong>实体</strong>：作为请求或响应的有效载荷数据被传输，其内容由实体首部和实体主体组成</li>
</ul>
<p>HTTP报文的主体用于传输请求或响应的实体主体。</p>
<h3 id="_3-2-压缩传输的内容编码"> 3.2 压缩传输的内容编码</h3>
<p><mark>内容编码</mark> 指明应用在实体内容上的编码格式，并保持实体信息原样压缩。内容编码后的实体由客户端接收并负责解码</p>
<p><img src="./README.assets/image-20220301084356564.png" alt="image-20220301084356564" loading="lazy"></p>
<p>常用的内容编码：</p>
<ul>
<li>gzip（GNU zip）</li>
<li>compress（NUIX 系统的压缩标准）</li>
<li>deflate（zlib）</li>
<li>identity（不进行编码）</li>
</ul>
<h3 id="_3-3-分割发送的分块传输编码"> 3.3 分割发送的分块传输编码</h3>
<p>在传输大容量数据时，通过把数据分割成多块，能够让页面逐步显示页面。这种把实体主体分块的功能称为 <mark>分块传输编码</mark>。</p>
<p><img src="./README.assets/image-20220301084748093.png" alt="image-20220301084748093" loading="lazy"></p>
<h2 id="四、发送多种数据的多部分对象集合"> 四、发送多种数据的多部分对象集合</h2>
<p><mark>多部分对象集合</mark> 用来容纳多份不同类型的数据。</p>
<h2 id="五、获取部分内容的范围请求"> 五、获取部分内容的范围请求</h2>
<p>在下载资源的过程中如果遇到网络中断的情况，那就必须重新开始。为了解决这种问题，需要一种恢复的机制（从之前下载中断处恢复下载）。</p>
<p>要实现该功能需要指定下载的实体范围，即 <mark>范围请求</mark></p>
<p><img src="./README.assets/image-20220301090212047.png" alt="image-20220301090212047" loading="lazy"></p>
<p>针对范围请求，响应会范围状态码为 <code>206 Partial Content</code> 的响应报文。如果服务器无法响应范围请求，则会返回状态码 <code>200 OK</code> 和完整的内容实体。</p>
<h2 id="六、内容协商后返回最合适的内容"> 六、内容协商后返回最合适的内容</h2>
<p><mark>内容协商</mark>：当浏览器的默认语言是中文或者英文时，访问相同URI的Web页面会显示对应的语言。</p>
<p><img src="./README.assets/image-20220301090657994.png" alt="image-20220301090657994" loading="lazy"></p>
<p>内容协商机制是指客户端和服务器端就响应的资源内容进行交涉，然后提供客户端最为合适的内容。内容协商会以<strong>响应资源的语言、字符集、编码方式</strong>等作为判断的基准。</p>
<h3 id="_6-1-服务器驱动协商-server-driven-negotitaion"> 6.1 服务器驱动协商 Server-driven Negotitaion</h3>
<p>由服务器进行内容协商。以请求的首部字段为参考，在服务器端自动处理。</p>
<h3 id="_6-2-客户端驱动协商-agent-driven-negotiation"> 6.2 客户端驱动协商 Agent-driven Negotiation</h3>
<p>由客户端进行内容协商的方式。用户从浏览器显示的可选项列表中手动选择。</p>
<h3 id="_6-3-透明协商-transparent-negotiation"> 6.3 透明协商 Transparent Negotiation</h3>
<p>是服务器驱动和客户端驱动的结合体，由服务器和客户端各自进行内容协商的一种方法。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第五章、Web服务器</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/5/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/5/"/>
    <updated>2022-04-07T03:04:47.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
<li><a href="https://blog.csdn.net/sjailjq/article/details/82287345" target="_blank" rel="noopener noreferrer">代理、网关与隧道</a></li>
</ul>
</div>
<h2 id="一、用单台虚拟主机实现多个域名"> 一、用单台虚拟主机实现多个域名</h2>
<p>HTTP/1.1 规范允许一台 HTTP 服务器搭建多个 Web 站点。</p>
<p><img src="./README.assets/image-20220314003115572.png" alt="image-20220314003115572" loading="lazy"></p>
<blockquote>
<p>举例来说，客户端使用HTTP协议访问服务器时，会经常采用类似www.hacker.jp这样的域名。   在互联网上，域名通过DNS服务映射到IP地址（域名解析）之后访问目标网站。由此可见，当请求发送到服务器时，已经是以IP地址形式访问了。那么问题就来了：如果一台服务器内托管了www.hacker.jp和www.tricoder.jp这两个域名，而两个域名经解析后的IP地址又是相同的，当服务器收到请求时就要弄清究竟要访问那个域名。</p>
</blockquote>
<p><img src="./README.assets/image-20220314003258065.png" alt="image-20220314003258065" loading="lazy"></p>
<h2 id="二、通信数据转发程序-代理、网关、隧道"> 二、通信数据转发程序：代理、网关、隧道</h2>
<h3 id="_2-1-代理"> 2.1 代理</h3>
<div><p>代理</p>
<p><mark>代理</mark> 是一种具有转发功能的 <strong>应用程序</strong>。</p>
</div>
<p><img src="./README.assets/image-20220314003636306.png" alt="image-20220314003636306" loading="lazy"></p>
<div><p>代理的特点</p>
<ol>
<li>客户端不知道真正的服务器是谁，服务器也不知道客户端是什么样的</li>
<li>客户端同代理服务器，代理服务器同服务器， <mark>这两者之间使用的通讯协议是一样的</mark></li>
<li><strong>代理服务器会对接收的请求进行解析，重新封装后再发送给服务器</strong>；在服务器响应后，对响应进行解析，重新封装后再发送给客户端。</li>
</ol>
</div>
<div><p>代理是否使用缓存、是否修改报文</p>
<ul>
<li><strong>缓存代理：</strong> 缓存代理会预先将资源的副本保存到代理服务器上，当代理再次接收到对相同资源的请求时，就可以将之前缓存的资源作为响应返回。</li>
<li><strong>透明代理：</strong> 不对报文做任何加工</li>
</ul>
</div>
<h3 id="_2-2-网关"> 2.2 网关</h3>
<div><p>网关</p>
<p><mark>网关</mark> 是转发其他服务器通信数据的 <strong>服务器</strong></p>
</div>
<p><img src="./README.assets/image-20220314004426802.png" alt="image-20220314004426802" loading="lazy"></p>
<p><img src="./README.assets/70-16471902360702.png" alt="img" loading="lazy"></p>
<div><p>网关的特点</p>
<ol>
<li>客户端不知道真正的服务器是谁，服务器也不知道客户端是什么样的</li>
<li>客户端同代理服务器，代理服务器同服务器， <mark>这两者之间使用的通讯协议或者协议的版本是不一样的</mark></li>
<li>代理服务器会对接收的请求进行解析，转换协议后再发送给服务器；在服务器响应后，对响应进行解析，转换协议后再发送给客户端。</li>
</ol>
</div>
<h3 id="_2-3-隧道"> 2.3 隧道</h3>
<div><p>隧道</p>
<p><mark>隧道</mark> 是在相隔甚远的客户端和服务器两者之间进行中转、并保持双方通信连接的 <strong>应用程序</strong></p>
</div>
<p><img src="./README.assets/image-20220314004621387.png" alt="image-20220314004621387" loading="lazy"></p>
<div><p>隧道</p>
<ol>
<li>该协议是为承载协议自身以外的流量而编写的协议</li>
<li>允许数据从一个网络移动到另一个网络</li>
<li>只关心流量的传输， <mark>不对承载的流量进行解析</mark></li>
</ol>
</div>
<h3 id="_2-4-代理和网关"> 2.4 代理和网关</h3>
<p>代理连接的是两个或者多个使用相同协议的应用程序，而网关连接的则是两个或多个使用不同协议的端点。网关扮演的是 <mark>协议转换器</mark> 的角色，即使客户端和服务器使用的是不同的协议，客户端也可以通过它完成与服务器之间的事务处理。</p>
<h3 id="_2-5-隧道和网关"> 2.5 隧道和网关</h3>
<p>简单来说，如果使用网关，服务器与客户端是相互不知道的，因为数据是网关 <strong>转发</strong> 的；但是如果使用隧道，服务器与客户端是 <strong>直接通信</strong> 的。</p>
<p><img src="./README.assets/70-16471904544676.png" alt="img" loading="lazy"></p>
<p><img src="./README.assets/70-16471904586258.png" alt="img" loading="lazy"></p>
<h2 id="三、保存资源的缓存"> 三、保存资源的缓存</h2>
<p>缓存是指代理服务器或客户端本地磁盘内保存的资源副本。利用缓存可以减少对服务器的访问，因此页节省了通信流量和通信时间。</p>
<p><img src="./README.assets/image-20220314005634376.png" alt="image-20220314005634376" loading="lazy"></p>
<h3 id="_3-1-缓存的有效期限"> 3.1 缓存的有效期限</h3>
<p>当遇上源服务器上的资源更新时，如果还是使用不变的缓存，那就会演变成返回更新前的旧资源了。</p>
<p><img src="./README.assets/image-20220314005811016.png" alt="image-20220314005811016" loading="lazy"></p>
<h3 id="_3-2-客户端的缓存"> 3.2 客户端的缓存</h3>
<p>缓存不仅可以存在于缓存服务器内，还可以存在于客户端浏览器中。</p>
<p><img src="./README.assets/image-20220314005922537.png" alt="image-20220314005922537" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第四章、Http状态码</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/4/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/4/"/>
    <updated>2022-03-19T00:49:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、状态码告知从服务器返回的请求结果"> 一、状态码告知从服务器返回的请求结果</h2>
<p><img src="./README.assets/image-20220312143535794.png" alt="image-20220312143535794" loading="lazy"></p>
<p><img src="./README.assets/image-20220312143606430.png" alt="image-20220312143606430" loading="lazy"></p>
<h2 id="二、2xx-成功"> 二、2XX 成功</h2>
<h3 id="_200-ok"> 200 OK</h3>
<p><img src="./README.assets/image-20220312143852661.png" alt="image-20220312143852661" loading="lazy"></p>
<h3 id="_204-no-content"> 204 No Content</h3>
<p><img src="./README.assets/image-20220312144027275.png" alt="image-20220312144027275" loading="lazy"></p>
<h3 id="_206-partical-content"> 206 Partical Content</h3>
<p><img src="./README.assets/image-20220312144154578.png" alt="image-20220312144154578" loading="lazy"></p>
<h2 id="三、3xx-重定向"> 三、3XX 重定向</h2>
<h3 id="_301-moved-permanently"> 301 Moved Permanently</h3>
<p><img src="./README.assets/image-20220312144429807.png" alt="image-20220312144429807" loading="lazy"></p>
<h3 id="_302-found"> 302 Found</h3>
<p><img src="./README.assets/image-20220312144620679.png" alt="image-20220312144620679" loading="lazy"></p>
<h3 id="_303-see-other"> 303 See Other</h3>
<p><img src="./README.assets/image-20220312144755166.png" alt="image-20220312144755166" loading="lazy"></p>
<div><p>Tips</p>
<p><img src="./README.assets/image-20220312144816542.png" alt="image-20220312144816542" loading="lazy"></p>
</div>
<h3 id="_304-not-modified"> 304 Not Modified</h3>
<p><img src="./README.assets/image-20220312145005364.png" alt="image-20220312145005364" loading="lazy"></p>
<h3 id="_307-temporary-redirect"> 307 Temporary Redirect</h3>
<p><img src="./README.assets/image-20220312145120022.png" alt="image-20220312145120022" loading="lazy"></p>
<h2 id="四、客户端错误"> 四、客户端错误</h2>
<h3 id="_400-bad-request"> 400 Bad Request</h3>
<p><img src="./README.assets/image-20220312145224621.png" alt="image-20220312145224621" loading="lazy"></p>
<h3 id="_401-unauthorized"> 401 Unauthorized</h3>
<p>表示发送的请求需要有通过 Http 认证的认证信息。如果之前请求过一次，则表示用户认证失败</p>
<p><img src="./README.assets/image-20220312145322171.png" alt="image-20220312145322171" loading="lazy"></p>
<h3 id="_403-forbidden"> 403 Forbidden</h3>
<p><img src="./README.assets/image-20220312145525501.png" alt="image-20220312145525501" loading="lazy"></p>
<h3 id="_404-not-found"> 404 Not Found</h3>
<p><img src="./README.assets/image-20220312145618848.png" alt="image-20220312145618848" loading="lazy"></p>
<h2 id="五、5xx-服务器错误"> 五、5XX 服务器错误</h2>
<h3 id="_500-internal-server-error"> 500 Internal Server Error</h3>
<p><img src="./README.assets/image-20220312145810119.png" alt="image-20220312145810119" loading="lazy"></p>
<h3 id="_503-service-unavailable"> 503 Service Unavailable</h3>
<p><img src="./README.assets/image-20220312145905292.png" alt="image-20220312145905292" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第八章、确认用户身份</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/8/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/8/"/>
    <updated>2022-03-19T00:49:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、何为认证"> 一、何为认证</h2>
<p>计算机本身无法判断坐在显示器前的使用者的身份。</p>
<p>为确认使用者的身份，是否真的具有访问系统的权限，就需要核对登陆者本人才知道的信息。</p>
<p>但即便对方是假冒的用户，只要能通过用户验证，那么计算机就会默认是出自本人的行为。因此掌控机密信息的密码绝不能让他人得到。</p>
<div><p>HTTP 使用的认证方式</p>
<ul>
<li>BASIC 认证（基本认证）</li>
<li>DIGEST 认证（摘要认证）</li>
<li>SSL 客户端认证</li>
<li>FormBase 认证（基于表单认证）</li>
</ul>
</div>
<h2 id="二、basic-认证"> 二、BASIC 认证</h2>
<p>BASIC 认证是从HTTP/1.0 就定义的认证方式。是Web服务器与通信客户端之间进行的认证方式</p>
<p><img src="./README.assets/image-20220318235117083.png" alt="image-20220318235117083" loading="lazy"></p>
<div><p>Base64编码不是加密</p>
<p>BASIC 认证虽然采用 Base64 编码方式，但这不是加密处理。在非加密通信的线路上进行认证的过程中，如果被人窃听，被盗的可能性极高。</p>
</div>
<h2 id="三、digest-认证"> 三、DIGEST 认证</h2>
<p>DIGEST 认证同样使用 <strong>质询/响应</strong> 的方式，但不会像 BASIC 认证那样直接发送明文密码。</p>
<div><p>质询/响应</p>
<p>一开始一方会先发送认证要求给另一方，接着使用从另一方那接收到的质询码计算生成响应码。最后将响应码返回给对方进行认证的方式。</p>
</div>
<p><img src="./README.assets/image-20220318235522595.png" alt="image-20220318235522595" loading="lazy"></p>
<h2 id="四、ssl-客户端认证"> 四、SSL 客户端认证</h2>
<p>SSL 客户端认证是借由 HTTPS 的客户端证书完成认证的方式。凭借客户端证书认证，服务器可确认访问是否来自已登录的客户端。</p>
<h3 id="认证步骤"> 认证步骤</h3>
<ol>
<li>接收到需要认证资源的请求，服务器会发送 <code>Certificate Request</code> 报文，要求客户端提供客户端证书</li>
<li>用户选择将发送的客户端证书后，客户端会把客户端证书信息以 <code>Client Certificate</code> 报文方式发送给服务器</li>
<li>服务器验证客户端证书验证通过后方可领取证书内客户端的公开密钥，然后开始 HTTPS 加密通信</li>
</ol>
<h3 id="双因素认证"> 双因素认证</h3>
<p>SSL 客户端认证一般会依靠证书和基于表单认证组合形成一种双因素认证。</p>
<div><p>双因素认证</p>
<p>认证过程中不仅需要密码这一个因素，还需要申请认证者提供其他持有信息，从而作为另一个因素，与其组合使用的认证方式</p>
</div>
<h3 id="ssl-客户端认证必要的费用"> SSL 客户端认证必要的费用</h3>
<p>SSL 客户端认证需要从认证机构购买。</p>
<h2 id="五、基于表单认证"> 五、基于表单认证</h2>
<p>客户端会向服务器上的Web应用程序发送登录信息，按登录信息的验证结果认证</p>
<h3 id="认证多半基于表单认证"> 认证多半基于表单认证</h3>
<ul>
<li>BASIC和DEGEST存在便利性及安全性问题，几乎不怎么使用。</li>
<li>SSL客户端认证因为费用问题，还尚未普及。</li>
</ul>
<p>对于Web网站的认证功能，能够满足其安全使用级别的标准规范并不存在，所以只好使用由Web应用程序各自实现基于表单的认证方式。</p>
<h3 id="session-管理及-cookie-应用"> Session 管理及 Cookie 应用</h3>
<p>鉴于 HTTP 是无状态协议，已成功认证的用户状态无法通过协议层面保存下来。因此使用 Cookie 来管理 Session，以弥补 HTTP 协议中不存在的状态管理功能</p>
<p><img src="./README.assets/image-20220319000915260.png" alt="image-20220319000915260" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T16:10:21.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第七章、HTTPS</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/7/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/7/"/>
    <updated>2022-03-19T00:49:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、http-的缺点"> 一、HTTP 的缺点</h2>
<div><p>HTTP 的不足</p>
<ul>
<li>通信使用明文（不加密），内容可能被窃听</li>
<li>不验证通信方的身份，因此有可能遭遇伪装</li>
<li>无法证明报文的完整性，所以有可能遭篡改</li>
</ul>
</div>
<h3 id="_1-1-通信使用明文可能会被窃听"> 1.1 通信使用明文可能会被窃听</h3>
<h4 id="http-本身不具备加密的功能。"> <strong>HTTP 本身不具备加密的功能。</strong></h4>
<p>即使已经加密处理过的通信，也会被窥视到通信内容，这点和未加密的通信是相同的。只是说如果通信经过加密，就有可能让人无法破解报文信息的含义，但加密处理后的报文信息本事还是会被看到的。</p>
<p><img src="./README.assets/image-20220317233150677.png" alt="image-20220317233150677" loading="lazy"></p>
<p>窃听相同段上的通信并非难事，只需要收集在互联网上流动的数据包（帧）就行了。</p>
<hr>
<h4 id="通信的加密"> <strong>通信的加密</strong></h4>
<p>HTTP 协议中没有加密机制，但可以通过和 <mark>SSL(Secure Socket Layer，安全套接层)</mark> 或 <mark>TLS(Transport Layer Security，安全层传输协议)</mark> 的组合使用，加密HTTP的通信内容。</p>
<p>用 SSL 简历安全通信线路之后，就可以在这条线路上进行 HTTP 通信了。与 SSL 组合使用的 HTTP 被称为 HTTPS（HTTP Secure，超文本传输安全协议）或 HTTP over SSL</p>
<p><img src="./README.assets/image-20220317233828262.png" alt="image-20220317233828262" loading="lazy"></p>
<hr>
<h4 id="内容的加密"> <strong>内容的加密</strong></h4>
<p>内容加密即对 HTTP 报文里所含的内容进行加密处理再发送请求。但是这么做的前提是要求客户端和服务器同时具备加密和解密机制。</p>
<div><p>Note</p>
<p>该方式不同于 SSL 或 TLS 将整个通信线路加密处理，所以内容仍然有被篡改的风险。</p>
</div>
<p><img src="./README.assets/image-20220317234242566.png" alt="image-20220317234242566" loading="lazy"></p>
<h3 id="_1-2-不验证通信方的身份就可能遭遇伪装"> 1.2 不验证通信方的身份就可能遭遇伪装</h3>
<p><strong>HTTP协议中的请求和响应不会对通信方进行确认。</strong> 也就是说存在 &quot;服务器是否就是发送请求中URI真正指定的主机、返回的响应是否真的返回到实际提出请求的客户端&quot; 等类似问题</p>
<hr>
<h4 id="任何人都可以发起请求"> <strong>任何人都可以发起请求</strong></h4>
<p>由于不存在确认通信方的处理步骤，任何人都可以发起请求。并且服务器只要接收到请求，不管对方是谁都会返回一个响应。</p>
<p><img src="./README.assets/image-20220317234949537.png" alt="image-20220317234949537" loading="lazy"></p>
<div><p>隐患</p>
<ul>
<li>无法确定请求发送至目标的 Web 服务器是否按真实意图返回响应的那台服务器. 有可能是伪装的服务器</li>
<li>无法确定响应返回到的客户端是否是按真实意图接收响应的那个客户端. 有可能是伪装的客户端</li>
<li>无法确定正在通信的对方是否具备访问权限. 因为某些 Web 服务器上保存着重要的信息, 只想发给特定用户通信的权限</li>
<li>无法判定请求是来自何方、出自谁手</li>
<li>即使是无意义的请求也会照单全收。无法组织海量请求下的 DoS 攻击（Deinal of Service，拒绝服务攻击）</li>
</ul>
</div>
<hr>
<h4 id="查明对手的证书"> <strong>查明对手的证书</strong></h4>
<p>SSL 不仅提供加密处理，而且还使用了一种被称为证书的手段，可用于确定方。</p>
<div><p>证书</p>
<p>是值得信任的第三方机构颁发，用以证明服务器和客户端是实际存在的。伪造证书从技术角度来说异常困难，所以只要能够确认通信放持有的证书即可判断通信方的真实意图</p>
</div>
<p><img src="./README.assets/image-20220317235751663.png" alt="image-20220317235751663" loading="lazy"></p>
<h3 id="_1-3-无法证明报文完整性-可能已遭篡改"> 1.3 无法证明报文完整性，可能已遭篡改</h3>
<p>由于 HTTP 协议无法证明通信的报文完整性，因此即使报文内容在传输过程中遭到篡改，也没办法获悉。</p>
<p><img src="./README.assets/image-20220317235950364.png" alt="image-20220317235950364" loading="lazy"></p>
<div><p>中间人攻击</p>
<p>像这样在请求或响应的传输途中，遭攻击者拦截并篡改内容的攻击称为 中间人攻击（Man-in-the-Middle attack，MITM）</p>
</div>
<p><img src="./README.assets/image-20220318000110804.png" alt="image-20220318000110804" loading="lazy"></p>
<hr>
<h4 id="如何防止篡改"> <strong>如何防止篡改</strong></h4>
<p>虽然有 MD5 和 SHA-1 等散列值校验的方法，以及用来确认文件的数字签名方法。但是这些依然不能百分百保证结果正确。</p>
<p>为了有效防止这些弊端，有必要使用 HTTPS</p>
<h2 id="二、http-加密-认证-完整性保护-https"> 二、HTTP + 加密 + 认证 + 完整性保护 = HTTPS</h2>
<h3 id="_2-1-https"> 2.1 HTTPS</h3>
<p><strong>我们把添加了加密及认证机制的 HTTP 称为 HTTPS（HTTP Secure）</strong></p>
<p><img src="./README.assets/image-20220318000544456.png" alt="image-20220318000544456" loading="lazy"></p>
<h3 id="_2-2-身披-ssl-外壳的-http"> 2.2 身披 SSL 外壳的 HTTP</h3>
<p>HTTPS 并非是应用层的一种新协议，只是 HTTP 通信接口部分用 SSL和TLS 协议代替而已。</p>
<p><img src="./README.assets/image-20220318000715322.png" alt="image-20220318000715322" loading="lazy"></p>
<p>SSL 独立于 HTTP，所以其他运行在应用层的 SMTP、Telnet 等协议都可以配合 SSL 协议使用。</p>
<h3 id="_2-3-公开密钥加密技术"> 2.3 公开密钥加密技术</h3>
<p><strong>SSL 采用一种叫做 <mark>公开密钥加密</mark> 的加密处理方式</strong></p>
<div><p>密钥</p>
<p>密钥是一种参数，它是在明文转换为密文或将密文转换为明文的算法中输入的参数</p>
</div>
<p>近代的加密方法中加密算法是公开的，而密钥确实保密的。通过这种方式得以保持加密方法的安全性。</p>
<p>加密和解密都会用到密钥。没有密钥就无法对密码解密，任何人只要持有密钥就能解密。如果密钥被攻击者获得，那加密就是去了意义。</p>
<hr>
<h4 id="共享密钥加密的困境"> <strong>共享密钥加密的困境</strong></h4>
<div><p>共享密钥加密</p>
<p>加密和解密同用一个密钥的方法称为共享密钥加密，也被叫做 <strong>对称密钥加密</strong>。</p>
</div>
<p><img src="./README.assets/image-20220318001223029.png" alt="image-20220318001223029" loading="lazy"></p>
<p>以共享密钥方式加密时必须将密钥也发给对方。可要怎样才能安全的转交密钥？</p>
<p><img src="./README.assets/image-20220318001320583.png" alt="image-20220318001320583" loading="lazy"></p>
<hr>
<h4 id="公开密钥加密"> <strong>公开密钥加密</strong></h4>
<div><p>公开密钥</p>
<p>公开密钥加密使用一对非对称的密钥。一把叫做私有密钥、另一把叫做公开密钥。</p>
</div>
<p>使用公开密钥的加密方式，发送密文的一方使用对方的公开密钥进行加密处理，对方收到被加密的信息后，在使用自己的私有密钥进行解密。</p>
<p><img src="./README.assets/image-20220318001755201.png" alt="image-20220318001755201" loading="lazy"></p>
<hr>
<h4 id="https-采用混合加密机制"> <strong>HTTPS 采用混合加密机制</strong></h4>
<p><strong>HTTPS 采用共享密钥加密和公开密钥加密两者并用的混合加密机制。</strong></p>
<p>若密钥能够实现安全交换，那么有可能会考虑仅使用公开密钥加密来通信。但是公开密钥加密与共享密钥加密相比，处理速度要稍慢。</p>
<p><img src="./README.assets/image-20220318002059018.png" alt="image-20220318002059018" loading="lazy"></p>
<h3 id="_2-4-证明公开密钥正确性的证书"> 2.4 证明公开密钥正确性的证书</h3>
<p>公开密钥无法证明本身是货真价实的。可能存在公开密钥传输的过程中，真正的公开密钥以及被攻击者替换掉了。</p>
<p>为了解决上述问题，可以使用由数字证书认证机构和其他相关机关颁发的公开密钥证书。</p>
<ol>
<li>服务器的运营人员向数字证书认证机构提出公开密钥的申请</li>
<li>数字证书认证机构在判明提出申请的身份之后，对已申请的公开密钥做数字签名。然后分配这个已签名的公开密钥，并将该公开密钥放入公钥证书后绑定在一起</li>
<li>服务器将这份由数字证书认证机构颁发的公钥证书发送给客户端</li>
<li>客户端对证书上的数字签名进行验证</li>
</ol>
<div><p>公开密钥必须安全转交</p>
<p>认证机关的公开密钥必须安全地转交给客户端，多数浏览器开发商发布版本时，会事先在内部植入常用认证机关的公开密钥。</p>
</div>
<p><img src="./README.assets/image-20220318002951764.png" alt="image-20220318002951764" loading="lazy"></p>
<hr>
<h4 id="可证明组织真实性的ev-ssl证书"> <strong>可证明组织真实性的EV SSL证书</strong></h4>
<div><p>证书的作用</p>
<ul>
<li>证明作为通信一方的服务是否规范</li>
<li>确认对方服务器背后运营的企业是否真实存在。</li>
</ul>
</div>
<hr>
<p><strong>用以确认客户端的客户端证书</strong></p>
<p>客户端证书进行客户端认证，证明服务器正在通信的对方始终是预料之内的客户端。</p>
<ol>
<li>
<p>证书的获取和发布</p>
<blockquote>
<p>客户端需要付费购买。安全性极高的认证机构可颁发客户端证书但仅用于特殊用途的业务。</p>
</blockquote>
</li>
<li>
<p>客户端证书只能证明客户端实际存在，不能证明用户本人的真实有效性</p>
<blockquote>
<p>只要获得了安装有客户端证书的计算机的使用权限，就意味着同时拥有了客户端证书的使用权限。</p>
</blockquote>
</li>
</ol>
<h3 id="_2-5-https-的安全通信机制"> 2.5 HTTPS 的安全通信机制</h3>
<p><img src="./README.assets/image-20220318005646738.png" alt="image-20220318005646738" loading="lazy"></p>
<p>在以上流程中，应用层发送数据时会附加一种叫做 <mark>MAC</mark> 的报文摘要。<strong>能够查知报文是否遭到篡改，从而保护报文的完整性</strong></p>
<p><img src="./README.assets/image-20220318005815319.png" alt="image-20220318005815319" loading="lazy"></p>
<hr>
<h4 id="ssl-和-tls"> <strong>SSL 和 TLS</strong></h4>
<div><p>HTTPS 的问题</p>
<ol>
<li>使用 HTTPS 处理速度会变慢
<ol>
<li>通信慢</li>
<li>大量消耗 CPU及内存等资源，处理速度变慢</li>
</ol>
</li>
<li>SSL 必须进行加密处理，消耗更多的硬件资源、导致负载增强</li>
</ol>
<p><img src="./README.assets/image-20220318005850132.png" alt="image-20220318005850132" loading="lazy"></p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T17:03:37.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第九章、追加协议</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/9/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/9/"/>
    <updated>2022-04-07T04:41:31.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、基于http协议"> 一、基于HTTP协议</h2>
<p>目前基于 HTTP 的 Web 浏览器的使用环境已经遍布全球，因此无法完全抛弃 HTTP。</p>
<div><p>SPDY</p>
<p>SPDY（读作“SPeeDY”）是<a href="https://baike.baidu.com/item/Google" target="_blank" rel="noopener noreferrer">Google</a>开发的基于<a href="https://baike.baidu.com/item/TCP/33012" target="_blank" rel="noopener noreferrer">TCP</a>的会话层协议，用以最小化网络延迟，提升网络速度，优化用户的网络使用体验。SPDY并不是一种用于替代HTTP的协议，而是对<a href="https://baike.baidu.com/item/HTTP" target="_blank" rel="noopener noreferrer">HTTP</a>协议的增强。新协议的功能包括数据流的多路复用、请求优先级以及HTTP报头压缩。谷歌表示，引入<a href="https://baike.baidu.com/item/SPDY%E5%8D%8F%E8%AE%AE/15652060" target="_blank" rel="noopener noreferrer">SPDY协议</a>后，在实验室测试中页面加载速度比原先快64%</p>
</div>
<h2 id="二、spdy"> 二、SPDY</h2>
<p>SPDY 的开服目标旨在解决 HTTP 的性能瓶颈，缩短 Web 页面的加载时间。</p>
<h3 id="_2-1-http-的瓶颈"> 2.1 HTTP 的瓶颈</h3>
<p>使用 HTTP 协议探知服务器上是否有内容更新，就必须频繁地从客户端到服务器进行确认。如果服务器上内容没有更新，那么就会产三徒劳的通信。</p>
<div><p>制约因素</p>
<ul>
<li>一条连接上只可以发送一个请求</li>
<li>请求只能从客户端开始，客户端不可以接收除响应意外的指令</li>
<li>请求/响应首部未经压缩就发送，首部信息越大延迟越大</li>
<li>每次互相发送相同的、冗长的首部造成很多浪费</li>
<li>可任意选择数据压缩格式</li>
</ul>
</div>
<p><img src="./README.assets/image-20220319101940140.png" alt="image-20220319101940140" loading="lazy"></p>
<hr>
<h4 id="ajax的解决办法"> <strong>Ajax的解决办法</strong></h4>
<p>Ajax 是一种有效利用 JavaScript 和 DOM的操作，以达到局部 Web 页面替换加载的异步通信手段。</p>
<p><img src="./README.assets/image-20220319102245723.png" alt="image-20220319102245723" loading="lazy"></p>
<hr>
<h4 id="comet的解决办法"> <strong>Comet的解决办法</strong></h4>
<p>通过延迟应答，模拟实现服务器端向客户端推送的功能。</p>
<p>通常服务器端接收到请求，在处理完毕后就会立即返回响应，但为了实现推送功能，Comet会先将响应置于挂起状态，当服务器端有内容更新时，再返回该响应。</p>
<p><img src="./README.assets/image-20220319102538258.png" alt="image-20220319102538258" loading="lazy"></p>
<h3 id="_2-2-spdy-的设计和功能"> 2.2 SPDY 的设计和功能</h3>
<p>SPDY 没有完全改写 HTTP 协议，而是在 TCP/IP 的 <mark>应用层与运输层之间通过新加会话层的形式运作，并且使用SSL</mark>。</p>
<p><img src="./README.assets/image-20220319103029003.png" alt="image-20220319103029003" loading="lazy"></p>
<hr>
<h4 id="多路复用流"> <strong>多路复用流</strong></h4>
<p>通过单一的TCP连接，可以无限制处理多个HTTP请求。</p>
<hr>
<h4 id="赋予请求优先级"> <strong>赋予请求优先级</strong></h4>
<p>可以给请求逐个分配优先级顺序，是为了在发送多个请求时，解决因带宽低而导致响应变慢</p>
<hr>
<h4 id="压缩http首部"> <strong>压缩HTTP首部</strong></h4>
<p>通过压缩HTTP首部，减少数据包中的字节数。</p>
<hr>
<h4 id="推送功能"> <strong>推送功能</strong></h4>
<p>支持服务器主动向客户端推送数据的功能。</p>
<hr>
<h4 id="服务器提示功能"> <strong>服务器提示功能</strong></h4>
<p>服务器可以主动提示客户端请求所需的资源。由于在客户端发现资源之前就可以获知资源的存在，因此在资源已缓存等情况下，可以避免发送不必要的请求</p>
<h3 id="_2-3-spdy-消除web瓶颈了吗"> 2.3 SPDY 消除Web瓶颈了吗</h3>
<p>SPDY 的确是一种可以有效消除 HTTP 瓶颈的技术，但很多 Web 网站存在的问题并非仅仅是由 HTTP 瓶颈所导致</p>
<h2 id="三、全双工通信的-websocket"> 三、全双工通信的 WebSocket</h2>
<p>利用 Ajax 和 Comet 技术进行通信可以提升 Web 的浏览速度，但问题在于通信如果使用 HTTP就无法彻底解决瓶颈问题</p>
<div><p>WebSocket</p>
<p><strong>WebSocket</strong>是一种在单个<a href="https://baike.baidu.com/item/TCP" target="_blank" rel="noopener noreferrer">TCP</a>连接上进行<a href="https://baike.baidu.com/item/%E5%85%A8%E5%8F%8C%E5%B7%A5" target="_blank" rel="noopener noreferrer">全双工</a>通信的协议。</p>
<p>WebSocket使得客户端和服务器之间的数据交换变得更加简单，允许服务端主动向客户端推送数据。在WebSocket API中，浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接，并进行双向数据传输。</p>
</div>
<h3 id="_3-1-websocket-的设计和功能"> 3.1 WebSocket 的设计和功能</h3>
<p><img src="./README.assets/image-20220319104140774.png" alt="image-20220319104140774" loading="lazy"></p>
<h3 id="_3-2-websocket-协议"> 3.2 WebSocket 协议</h3>
<p>一旦 Web 服务器和客户端之间建立起 WebSocket 协议的通信连接，之后所有的通信都依靠这个协议进行传输。</p>
<h4 id="推送功能-2"> <strong>推送功能</strong></h4>
<p>支持由服务器向客户端发送数据的推送功能</p>
<hr>
<h4 id="减少通信量"> <strong>减少通信量</strong></h4>
<p>只要建立起 WebSocket 连接，就希望一直保持连接状态。和 HTTP 相比，每次连接的总开销更小，并且首部信息量也很小，减少了通信量</p>
<h3 id="_3-3-握手-请求"> 3.3 握手-请求</h3>
<p>为了实现 WebSocket 通信，在 HTTP 连接建立之后，需要完成一次握手的步骤</p>
<p><img src="./README.assets/image-20220319104652205.png" alt="image-20220319104652205" loading="lazy"></p>
<h3 id="_3-4-握手-响应"> 3.4 握手-响应</h3>
<p>成功握手确立 WebSocket 连接之后，通信时不再使用 HTTP 的数据帧，而采用 WebSocket 独立的数据帧</p>
<p><img src="./README.assets/image-20220319104758214.png" alt="image-20220319104758214" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T02:52:30.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第二章、用电信号传输 TCP/IP 数据</title>
    <id>https://notes.lllllan.cn/cs-basic/network/how-is-the-network-connected/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/how-is-the-network-connected/2/"/>
    <updated>2022-04-07T05:59:34.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《网络是怎样连接的》</li>
<li><a href="https://www.cnblogs.com/jiangzhaowei/p/9273854.html" target="_blank" rel="noopener noreferrer">TCP 、UDP、IP包的最大长度 - 江召伟</a></li>
</ul>
</div>
<h2 id="零、前情提要"> 零、前情提要</h2>
<ol>
<li>创建套接字。</li>
<li>连接服务器。</li>
<li>收发数据。</li>
<li>断开连接并删除套接字。</li>
<li>IP与以太网的包收发操作。</li>
<li>用UDP协议收发数据的操作。</li>
</ol>
<p><img src="./README.assets/image-20211226140619512.png" alt="image-20211226140619512" loading="lazy"></p>
<h2 id="一、创建套接字"> 一、创建套接字</h2>
<h3 id="_1-1-协议栈的内部结构"> 1.1 协议栈的内部结构</h3>
<p><img src="./README.assets/image-20211226140825219.png" alt="image-20211226140825219" loading="lazy"></p>
<blockquote>
<p>浏览器、邮件等<strong>一般应用程序收发数据时用TCP</strong>；</p>
<p><strong>DNS查询等收发较短的控制数据时用UDP</strong>。</p>
</blockquote>
<blockquote>
<p><strong>ICMP用于告知网络包传送过程中产生的错误以及各种控制消息</strong>；</p>
<p><strong>ARP用于根据IP地址查询相应的以太网MAC地址</strong>。</p>
</blockquote>
<h3 id="_1-2-套接字的实体就是通信控制信息"> 1.2 套接字的实体就是通信控制信息</h3>
<blockquote>
<p>协议栈是根据套接字中记录的控制信息来工作的。</p>
</blockquote>
<p><img src="./README.assets/image-20211226141825503.png" alt="image-20211226141825503" loading="lazy"></p>
<p><img src="./README.assets/image-20211226141937848.png" alt="image-20211226141937848" loading="lazy"></p>
<h3 id="_1-3-调用-socket-时的操作"> 1.3 调用 socket 时的操作</h3>
<blockquote>
<p>创建套接字时，首先分配一个套接字所需的内存空间，让后向其中写入初始状态。</p>
</blockquote>
<p><img src="./README.assets/image-20211226142213413.png" alt="image-20211226142213413" loading="lazy"></p>
<h2 id="二、连接服务器"> 二、连接服务器</h2>
<h3 id="_2-1-连接"> 2.1 连接</h3>
<blockquote>
<p>连接实际上是通信双方交换控制信息，在套接字中记录一些必要信息并准备数据收发的一连串操作。</p>
</blockquote>
<ul>
<li>把服务器的IP地址和端口号等信息告知协议栈</li>
<li>客户端向服务器传达开始通信的请求</li>
<li>开辟一个空间作为缓冲区</li>
</ul>
<h3 id="_2-2-负责保存控制信息的头部"> 2.2 负责保存控制信息的头部</h3>
<p>通信操作中使用的控制信息分为两类：</p>
<ul>
<li>头部中记录的信息</li>
<li>套接字中记录的信息</li>
</ul>
<p><img src="./README.assets/image-20220225172706601.png" alt="image-20220225172706601" loading="lazy"><img src="./README.assets/image-20211227214507743.png" alt="image-20211227214507743" loading="lazy"></p>
<h3 id="_2-3-连接操作的实际过程"> 2.3 连接操作的实际过程</h3>
<ul>
<li>在TCP模块处创建表示连接控制信息的头部</li>
<li>通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字
<ul>
<li>TCP模块将信息发送给IP模块并委托它进行发送</li>
<li>IP模块执行网络包发送到达服务器</li>
<li>服务器上的IP模块将接收的信息传递给TCP模块</li>
<li>服务器上的TCP模块根据TCP头部中的信息找到端口号对应的套接字</li>
<li>在套接字中写入相应信息，修改状态为正在连接，并向客户端返回响应</li>
</ul>
</li>
<li>客户端接收到服务器的套接字信息，向服务器再次发回消息表示接收成功</li>
</ul>
<h2 id="三、收发数据"> 三、收发数据</h2>
<h3 id="_3-1-将-http-请求交给协议栈"> 3.1 将 HTTP 请求交给协议栈</h3>
<p>协议栈接收到数据后，先将数据存到内部的发送缓冲区。根据以下两个维度的判断，再将HTTP请求发送出去：</p>
<ul>
<li>当从应用程序收到的数据长度超过或接近MSS时再发送出去，可以避免发送大量小包的问题。
<ul>
<li><strong>MTU</strong>：一个网络包的最大长度，一般是1500字节</li>
<li><strong>MSS</strong>：除去头部之后，一个网络包所能容纳的TCP数据的最大长度</li>
</ul>
</li>
<li>协议栈内部有一个计时器，当经过一定时间以后，就会把网络包发送出去。</li>
</ul>
<blockquote>
<p>应用程序在发送数据时可以指定一些选项，比如指定【不等待填满缓冲区直接发送】，协议栈就会按照要求直接发送。</p>
</blockquote>
<div><p>Note</p>
<ol>
<li>在链路层，由以太网的物理特性决定了数据帧的长度为(46＋18)－(1500＋18)，其中的18是数据帧的头和尾，也就是说数据帧的内容最大为1500(不包括帧头和帧尾)，即MTU(Maximum Transmission Unit)为1500；</li>
<li>在网络层，因为IP包的首部要占用20字节，所以这的MTU为1500－20＝1480</li>
<li>在传输层，对于UDP包的首部要占用8字节，所以这的MTU为1480－8＝1472；</li>
</ol>
<p>UDP 包的大小就应该是 1500 - IP头(20) - UDP头(8) = 1472(Bytes)</p>
<p>TCP 包的大小就应该是 1500 - IP头(20) - TCP头(20) = 1460 (Bytes)</p>
</div>
<h3 id="_3-2-对较大数据进行拆分"> 3.2 对较大数据进行拆分</h3>
<p>当一个HTTP请求的长度，超过了网络包的最大长度，就需要对该请求进行拆分。</p>
<p><img src="./README.assets/image-20211228205521676.png" alt="image-20211228205521676" loading="lazy"></p>
<h3 id="_3-3-使用ack号确认网络包收到"> 3.3 使用ACK号确认网络包收到</h3>
<ul>
<li>发送方：从第xxx字节开始，共有xxx字节</li>
<li>接收方：收到到第xxx字节之前的全部数据</li>
</ul>
<p><img src="./README.assets/image-20211229180218040.png" alt="" loading="lazy"></p>
<p><img src="./README.assets/image-20211229181203165.png" alt="image-20211229181203165" loading="lazy"><img src="./README.assets/image-20211229181227356.png" alt="image-20211229181227356" loading="lazy"></p>
<blockquote>
<p>在得到对方的确认之前，发送过的包会保存在发送缓存区。如果对方一直没有返回某些包的ACK号，就会重新发送这些包。</p>
</blockquote>
<h3 id="_3-4-根据网络包平均往返时间调整ack号等待时间"> 3.4 根据网络包平均往返时间调整ACK号等待时间</h3>
<p>TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；如果ACK号马上就能返回，则相应缩短等待时间。</p>
<h3 id="_3-5-使用窗口有效管理ack号"> 3.5 使用窗口有效管理ACK号</h3>
<blockquote>
<p>滑动窗口：在发送一个包之后，不等待ACK号返回，直接发送后续的一系列包。</p>
<p>接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口的基本思路。</p>
</blockquote>
<p><img src="./README.assets/image-20211229190220706.png" alt="image-20211229190220706" loading="lazy"></p>
<p>如果不等待ACK号返回一直自顾自地持续发送，就可能出现发送包的频率超过接收方的处理能力的情况。</p>
<p>接收方收到包之后会保存在接收缓冲区中，计算ACK号并返回给发送方，还要将数据传递给应用程序。如果这些操作还未完成，就有新的数据包到达，都会暂存早接收缓冲区中。但是当接收缓冲区中已经存满，再发送数据包也不可能存的下，这时候发送方的发送频率就超出了接收方的处理能力。</p>
<p>因此接收方会实现告知发送方自己的处理能力（接收缓冲区的大小），发送方会根据已发送的数据包、接收方的缓冲区计算，判断是否还可以继续发送数据。</p>
<p><img src="./README.assets/image-20211229190610804.png" alt="image-20211229190610804" loading="lazy"></p>
<h3 id="_3-6-ack与窗口的合并"> 3.6 ACK与窗口的合并</h3>
<p><strong>问题描述：</strong></p>
<p>当接收方接收到一个数据包，计算好ACK号返回给发送方。假设接收方的接收缓冲区中就只够保存一个数据包，返回了ACK号并不代表他可以继续接收新的数据包。因为还需要将这个数据传递给应用程序，到这个时候才可以从缓冲区将数据包删除，腾出空间来接收新的数据包。</p>
<p>从这个角度出发，接收方收到一个数据包，分别要返回一个ACK号和更新窗口的信息。如果是这样的话，要返回的包就太多了，会导致网络效率的下降。</p>
<p><strong>解决：</strong></p>
<p>接收方计算好ACK号时、窗口更新时，不会马上把包发送出去。</p>
<p>而是等ACK号和窗口更新，或者多个ACK号一起合并发送，以此来减少包的数量。</p>
<h3 id="_3-7-接收http响应消息"> 3.7 接收HTTP响应消息</h3>
<p><img src="./README.assets/image-20211229200045483.png" alt="image-20211229200045483" loading="lazy"></p>
<h2 id="四、从服务器断开并删除套接字"> 四、从服务器断开并删除套接字</h2>
<h3 id="_4-1-断开连接"> 4.1 断开连接</h3>
<blockquote>
<ul>
<li>协议栈在设计上允许<strong>任何一方</strong>（客户端/服务器端）先发起断开过程</li>
<li>无论哪种，完成数据发送的一方都会发起断开过程。（无非谁先谁后而已）</li>
</ul>
</blockquote>
<p>eg：</p>
<ul>
<li>服务器端先断开连接：
<ul>
<li>调用 Socket 库中的 close</li>
<li>生成一个包含断开信息的 TCP 头部，控制位中 <strong>FIN</strong> 比特位为1</li>
<li>协议栈委托 IP 模块向客户端发送数据</li>
<li>套接字中记录断开操作的信息</li>
</ul>
</li>
<li>客户端接收断开信息：
<ul>
<li>收到服务器发来的 <strong>FIN</strong> 为1的 TCP 头部</li>
<li>协议栈将套接字标记为断开操作状态</li>
<li>向服务器返回一个 <strong>ACK</strong> 号</li>
</ul>
</li>
<li>客户端断开连接：
<ul>
<li>执行和服务器相同的操作</li>
<li>服务器也向客户端返回一个 <strong>ACK</strong> 号</li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20220107205801563.png" alt="image-20220107205801563" loading="lazy"></p>
<h3 id="_4-2-删除套接字"> 4.2 删除套接字</h3>
<div><p>通信结束以后，会等待一段时间再删除套接字</p>
</div>
<p>服务器完成数据发送，向客户端发送 <code>FIN</code>，客户端向服务器返回 <code>ACK</code> 号。但这时如果 <code>ACK</code> 号丢失了，那么服务器将重新发送一次 <code>FIN</code>。而客户端没有等待就套接字删除了。</p>
<p>再假设，这个时候客户端中的应用程序需要创建套接字，新套接字碰巧被分配到了同一个端口号，而这个时候服务器发送的 <code>FIN</code> 正好到达，那这个新的套接字就会被误删。</p>
<h3 id="_4-3-数据收发小结"> 4.3 数据收发小结</h3>
<p><img src="./README.assets/image-20220107214550624.png" alt="image-20220107214550624" loading="lazy"></p>
<h2 id="五、ip-与以太网的包的收发操作"> 五、IP 与以太网的包的收发操作</h2>
<h3 id="_5-1-包的基本知识"> 5.1 包的基本知识</h3>
<p><img src="./README.assets/image-20220108091227641.png" alt="image-20220108091227641" loading="lazy"></p>
<p>数据收发过程中的双方，在不同时刻可能互为接收方和发送方，因此统称为 <strong>终端节点</strong></p>
<p>数据包会经过一个个的网络转发设备，最后到达接收方。</p>
<ul>
<li>发送方将接收方的IP地址写入IP头部</li>
<li>IP协议根据这一IP地址查找包的传输方向，从而确定下一个路由器的位置</li>
<li><strong>IP协议查出下一个路由器的以太网地址（MAC地址）</strong>，并将地址写入MAC头部</li>
<li>IP协议委托以太网协议将包传输</li>
</ul>
<blockquote>
<ul>
<li>路由器根据目标地址判断下一个路由器的位置 —— IP协议</li>
<li>集线器在子网中将网络包传输到下一个路由 —— 以太网协议</li>
</ul>
</blockquote>
<p><img src="./README.assets/image-20220108093602850.png" alt="image-20220108093602850" loading="lazy"></p>
<h3 id="_5-2-包收发操作概览"> 5.2 包收发操作概览</h3>
<ol>
<li>TCP模块委托IP模块发送包：
<ul>
<li>TCP模块在数据块前面加上TCP头部</li>
<li><strong>指定通信对象的IP地址</strong></li>
<li>整个传递给IP模块</li>
</ul>
</li>
<li>IP模块封装数据包：
<ul>
<li><strong>IP模块会添加IP头部和MAC头部</strong></li>
<li>转交给网络硬件</li>
</ul>
</li>
<li>网络包在网卡间传递</li>
<li>接收方接收网络包：
<ul>
<li>网卡将包转化为数字信息传递给IP模块</li>
<li>IP模块解除IP头部和MAC头部，将TCP头部和数据块传递给TCP模块</li>
<li>TCP模块处理数据</li>
</ul>
</li>
</ol>
<p><img src="./README.assets/image-20220108105125589.png" alt="image-20220108105125589" loading="lazy"></p>
<blockquote>
<p><strong>IP模块的职责就是将委托的东西打包送到对方手里。不关心TCP头部和数据内容，也不关心TCP的操作。</strong></p>
</blockquote>
<h3 id="_5-3-ip头部"> 5.3 IP头部</h3>
<p><img src="./README.assets/image-20220108124243007.png" alt="" loading="lazy"></p>
<p><img src="./README.assets/image-20220108124706189.png" alt="image-20220108124706189" loading="lazy"></p>
<h3 id="_5-4-mac头部"> 5.4 MAC头部</h3>
<p>IP模块根据路由表 Gateway 栏的内容判断应该把包发送给谁。</p>
<p>再根据IP地址查询MAC地址</p>
<p><img src="./README.assets/image-20220108161553247.png" alt="image-20220108161553247" loading="lazy"></p>
<h3 id="_5-5-arp查询目标路由器的mac地址"> 5.5 ARP查询目标路由器的MAC地址</h3>
<ul>
<li>ARP利用广播对所有设备问 <code>XX这个IP地址是谁的，请把你的MAC地址告诉我</code>，然后等待目标路由器将MAC地址返回</li>
</ul>
<p><img src="./README.assets/image-20220108162056855.png" alt="image-20220108162056855" loading="lazy"></p>
<ul>
<li>ARP缓存</li>
</ul>
<p><img src="./README.assets/image-20220108163905777.png" alt="image-20220108163905777" loading="lazy"></p>
<ul>
<li>MAC地址</li>
</ul>
<p><img src="./README.assets/image-20220108163921704.png" alt="image-20220108163921704" loading="lazy"></p>
<ul>
<li>ARP缓存过几分钟就会将原记录删除，以防因为IP地址的改变而导致通信异常</li>
</ul>
<h3 id="_5-6-以太网基本知识"> 5.6 以太网基本知识</h3>
<p><img src="./README.assets/image-20220108164652863.png" alt="" loading="lazy"></p>
<h3 id="_5-7-发送光电信号"> 5.7 发送光电信号</h3>
<blockquote>
<p>网卡的ROM中保存着全世界唯一的MAC地址，这是在生产网卡时写入的</p>
<p>网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块</p>
</blockquote>
<p><img src="./README.assets/image-20220108165951786.png" alt="image-20220108165951786" loading="lazy"></p>
<h3 id="_5-8-给网络包添加控制数据"> 5.8 给网络包添加控制数据</h3>
<blockquote>
<p>MAC模块将网络包从缓存中取出，并在开头加上 <strong>报头</strong> 和 <strong>起始帧分节符</strong>，在末尾加上 <strong>帧校验序列(FCS)</strong></p>
</blockquote>
<p><img src="./README.assets/image-20220109091031789.png" alt="image-20220109091031789" loading="lazy"></p>
<ul>
<li>用电信号来表达数字信息，让0和1分别对应特定的电压和电流
<ul>
<li><strong>数据信号如果出现连续的1或0，由于电流和电压没有变化，我们没办法判断其中每个比特从哪里切分</strong></li>
</ul>
</li>
<li>再发送一组用来区分比特间隔的时钟信号
<ul>
<li><strong>当距离较远、网线较长时，两条线路的长度可能会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会偏移</strong></li>
</ul>
</li>
<li>将数据信号和时钟信号叠加在一起
<ul>
<li><strong>由于时钟信号是按固定频率变化的，只要找到这个变化的周期就能从中提取出时钟信号，进而计算出数据信号</strong></li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20220109091740442.png" alt="image-20220109091740442" loading="lazy"></p>
<h3 id="_5-9-向集线器发送网络包"> 5.9 向集线器发送网络包</h3>
<blockquote>
<p>发送信号的两种操作：使用集线器的<strong>半双工模式</strong>、使用交换机的<strong>全双工模式</strong></p>
</blockquote>
<p>​	半双工模式中，需要先判断网线中是否存在其他设备发送的信号。如果有，需要等待信号传输完毕才能发送，否则两组信号会发生碰撞。</p>
<ol>
<li>
<p><strong>MAC 模块将数字信号按每个比特转换成电信号</strong></p>
</li>
<li>
<p><strong>PHY（MAU）模块将该信号进行格式转换</strong>并通过网线发送出去、监控接受线路中有无信号进来</p>
</li>
</ol>
<blockquote>
<p>协议栈的TCP会负责搞定可能发生的错误，因此发送信号是没有必要检查错误</p>
</blockquote>
<h3 id="_5-10-接受返回包"> 5.10 接受返回包</h3>
<p><strong>接受步骤：</strong></p>
<ol>
<li>把通过接受线路的所有信号都接收进来</li>
<li>PHY（MAU）模块将信号转换成通用格式并发送给 MAC 模块</li>
<li>MAC 模块从头开始将信号转换成数字信息，并存放到缓冲区</li>
<li>检查 FCS 和 MAC 地址，将数据受污染和地址不一致的包直接丢弃</li>
<li>网卡通过 <strong>中断机制</strong> 通知计算机收到一个包
<ol>
<li>网卡向扩展总线中的中断信号发送信号</li>
<li>该信号通过中断控制器连接到CPU</li>
<li>CPU暂时挂起正在处理的任务，切换到中断处理程序</li>
<li>中断处理程序调用网卡驱动</li>
<li>网卡执行接收操作</li>
</ol>
</li>
<li>网卡根据包中不同协议类型，将包发送给不同的栈</li>
</ol>
<h3 id="_5-11-将服务器的响应包从ip传递给tcp"> 5.11 将服务器的响应包从IP传递给TCP</h3>
<p><strong>IP模块的任务：</strong></p>
<ol>
<li>检查IP头部，确认格式是否正确</li>
<li>查看接收方IP地址，如果有误通过ICMP消息告知对方</li>
<li>分片重组：如果原始的包被分成了多个小包，需要将他们还原成原始的包</li>
</ol>
<p><img src="./README.assets/image-20220111144946393.png" alt="image-20220111144946393" loading="lazy"></p>
<p><strong>TCP模块的任务：</strong></p>
<ol>
<li>找到对应套接字，根据通信记录执行操作：
<ul>
<li>如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取</li>
<li>如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立或断开连接的操作状态</li>
</ul>
</li>
</ol>
<h2 id="六、udp-协议的收发操作"> 六、UDP 协议的收发操作</h2>
<h3 id="_6-1-不需要重发的数据用-udp-更高效"> 6.1 不需要重发的数据用 UDP 更高效</h3>
<blockquote>
<p>TCP为了实现可靠性和高效传输，需要将数据分片发送，并将对方未接收的数据包重新发送。</p>
</blockquote>
<h3 id="_6-2-控制用的短数据"> 6.2 控制用的短数据</h3>
<p>像DNS查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种场景既可以用UDP来代替TCP</p>
<blockquote>
<p>UDP只负责发送包，不管任何可能出现的错误</p>
</blockquote>
<p><img src="./README.assets/image-20220111153930637.png" alt="image-20220111153930637" loading="lazy"></p>
<h3 id="_6-3-音频和视频数据"> 6.3 音频和视频数据</h3>
<p>音频和视频数据必须在规定时间内送达，（一旦错过播放时间，重发数据也没用）因此无需重发数据。这种情况下使用UDP发送数据的效率更高</p>
<h2 id="七、本章回顾"> 七、本章回顾</h2>
<ul>
<li>表示网络包收件人的接收方IP地址是位于IP头部还是TCP头部？</li>
</ul>
<blockquote>
<p>**IP头部。**接收方IP地址最初从应用程序获得， 经由TCP模块告知IP模块</p>
</blockquote>
<ul>
<li>端口号所用来指定服务器程序的种类，那么他位于TCP头部还是IP头部？</li>
</ul>
<blockquote>
<p>**TCP头部。**连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。</p>
</blockquote>
<ul>
<li>会对包是否正确送达进行确认的是TCP还是IP呢？</li>
</ul>
<blockquote>
<p>TCP</p>
</blockquote>
<ul>
<li>根据IP地址查询MAC地址的机制叫什么？</li>
</ul>
<blockquote>
<p>ARP</p>
<p>在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就是利用广播对所有设备提问：“××这个IP地址是谁的？请把你的MAC地址告诉我。”然后就会有人回答：“这个IP地址是我的，我的MAC地址是××××。”</p>
</blockquote>
<ul>
<li>在收到ACK号之前继续发送下一个包的方式叫什么？</li>
</ul>
<blockquote>
<p>滑动窗口方式</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第六章、Http 首部</title>
    <id>https://notes.lllllan.cn/cs-basic/network/diagram-http/6/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/diagram-http/6/"/>
    <updated>2022-04-07T03:07:53.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《图解HTTP》</li>
</ul>
</div>
<h2 id="一、http-报文首部"> 一、HTTP 报文首部</h2>
<p><strong>HTTP协议的请求报文和响应报文中必定包含HTTP首部</strong></p>
<p><img src="./README.assets/image-20220315081406241.png" alt="image-20220315081406241" loading="lazy"></p>
<h3 id="请求报文"> 请求报文</h3>
<p>HTTP 请求报文中报文首部由 <strong>方法、URI、HTTP版本、HTTP首部字段等部分</strong> 构成</p>
<p><img src="./README.assets/image-20220315081628361.png" alt="image-20220315081628361" loading="lazy"></p>
<h3 id="响应报文"> 响应报文</h3>
<p>HTTP 响应报文中报文首部由 <strong>HTTP版本、状态码（数字和原因短语）、HTTP首部</strong> 三部分构成</p>
<p><img src="./README.assets/image-20220315081816767.png" alt="image-20220315081816767" loading="lazy"></p>
<h2 id="二、http-首部字段"> 二、HTTP 首部字段</h2>
<h3 id="_2-1-http-首部字段传递重要信息"> 2.1 HTTP 首部字段传递重要信息</h3>
<p><img src="./README.assets/image-20220315082122552.png" alt="image-20220315082122552" loading="lazy"></p>
<h3 id="_2-2-http-首部字段结构"> 2.2 HTTP 首部字段结构</h3>
<p>HTTP 首部字段是由首部字段名和字段值构成，中间用冒号分隔。</p>
<div><pre><code><span>// 首部字段名:字段值</span>
    
<span>Content</span><span>-</span><span>Type</span><span>:</span> text<span>/</span>html
<span>Keep</span><span>-</span><span>Alive</span><span>:</span> timeout<span>=</span><span>15</span><span>,</span> max<span>=</span><span>100</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>HTTP 首部字段重复会怎么样</p>
<p>这种情况在规范内尚未明确，根据浏览器内部逻辑不同，结果可能不同。</p>
</div>
<h3 id="_2-3-四种http首部字段类型"> 2.3 四种HTTP首部字段类型</h3>
<p><strong>通用首部字段</strong></p>
<p>请求和响应报文都会使用的首部</p>
<hr>
<p><strong>请求首部字段</strong></p>
<p>从客户端向服务器发送请求报文时使用的首部。</p>
<hr>
<p><strong>响应首部字段</strong></p>
<p>从服务器向客户端返回响应报文时使用的首部。</p>
<hr>
<p><strong>实体首部字段</strong></p>
<p>针对请求报文和响应报文的实体部分使用的首部。</p>
<h3 id="_2-4-首部字段一览"> 2.4 首部字段一览</h3>
<p>HTTP/1.1 规范定义了47种首部字段。太多了自行百度。</p>
<h3 id="_2-5-非首部字段"> 2.5 非首部字段</h3>
<p>比如 Cookie、Set-Cookie、Content-Disposition等</p>
<h3 id="_2-6-end-to-end-首部和-hop-by-hop-首部"> 2.6 End-to-end 首部和 Hop-by-hop 首部</h3>
<p>HTTP首部字段将定义成缓存代理和非缓存代理的行为，分成两种类型：</p>
<p><strong>端到端首部 End-to-end</strong></p>
<p>此类别中的首部会转发给请求/响应对应的 <mark>最终接收目标，且必须保存在由缓存生成的响应中，另外规定他必须被转发</mark></p>
<hr>
<p><strong>逐跳首部</strong></p>
<p>此类别的首部 <mark>只对单次转发有效</mark> ，会因为通过缓存和代理而不再转发。HTTP/1.1 和之后的版本要求提供 Connection 首部字段</p>
<h2 id="三、通用首部字段"> 三、通用首部字段</h2>
<h3 id="_3-1-cache-control"> 3.1 Cache-Control</h3>
<p><img src="./README.assets/image-20220315084027826.png" alt="image-20220315084027826" loading="lazy"></p>
<p>表示是否能缓存的指令：</p>
<div><pre><code><span>Cache</span><span>-</span><span>Control</span><span>:</span> <span>public</span>   <span>// 可以缓存</span>
<span>Cache</span><span>-</span><span>Control</span><span>:</span> <span>private</span>  <span>// 只以特定用户为对象。缓存服务器会对该特定用户提供缓存资源的服务、其他用户不行</span>
    
<span>Cache</span><span>-</span><span>Control</span><span>:</span> no<span>-</span>cache <span>// 客户端的no-cache表示不接受缓存</span>
    					<span>// 服务器端的no-cache表示不允许缓存</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>其他很多指令，暂略。</p>
<h3 id="_3-2-connection"> 3.2 Connection</h3>
<ul>
<li>控制不再转发给代理的首部字段</li>
<li>管理持久连接</li>
</ul>
<p><img src="./README.assets/image-20220315085019624.png" alt="image-20220315085019624" loading="lazy"></p>
<hr>
<p><img src="./README.assets/image-20220315085052151.png" alt="image-20220315085052151" loading="lazy"></p>
<hr>
<p><img src="./README.assets/image-20220315085144036.png" alt="image-20220315085144036" loading="lazy"></p>
<h3 id="_3-3-其他字段概览"> 3.3 其他字段概览</h3>
<p><strong>Date</strong></p>
<p><img src="./README.assets/image-20220315085254170.png" alt="image-20220315085254170" loading="lazy"></p>
<hr>
<p><strong>Pragma</strong></p>
<p><img src="./README.assets/image-20220315085355485.png" alt="image-20220315085355485" loading="lazy"></p>
<hr>
<p><strong>Trailer</strong></p>
<p><img src="./README.assets/image-20220315085439849.png" alt="image-20220315085439849" loading="lazy"></p>
<hr>
<p><strong>Transfer-Encoding</strong></p>
<p><img src="./README.assets/image-20220315085517992.png" alt="image-20220315085517992" loading="lazy"></p>
<hr>
<p><strong>Upgrade</strong></p>
<p><img src="./README.assets/image-20220315085700533.png" alt="image-20220315085700533" loading="lazy"></p>
<hr>
<p><strong>Via</strong></p>
<p><img src="./README.assets/image-20220315085753639.png" alt="image-20220315085753639" loading="lazy"></p>
<hr>
<p><strong>Warning</strong></p>
<p><img src="./README.assets/image-20220315090210633.png" alt="image-20220315090210633" loading="lazy"></p>
<h2 id="四、其他首部"> 四、其他首部</h2>
<p>太多了先不管</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HTTP 传输大文件</title>
    <id>https://notes.lllllan.cn/cs-basic/network/http/http-big-data/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/http/http-big-data/"/>
    <updated>2022-04-25T01:10:50.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://juejin.cn/post/7005347768491311134" target="_blank" rel="noopener noreferrer">HTTP 传输大文件有哪些方案？ - 掘金 (juejin.cn)</a></li>
<li><a href="https://blog.csdn.net/song_hai_lei/article/details/120976608" target="_blank" rel="noopener noreferrer">HTTP传输大文件的方法_宋同学shl的博客-CSDN博客_传大文件</a></li>
<li><a href="https://blog.csdn.net/fanyun_01/article/details/80211799" target="_blank" rel="noopener noreferrer">深入解析数据压缩算法_Geek.Fan的博客-CSDN博客_数据压缩算法</a></li>
<li><a href="https://www.jianshu.com/p/9c1889be3d14" target="_blank" rel="noopener noreferrer">HTTP CHUNK分块传输 - 简书 (jianshu.com)</a></li>
</ul>
</div>
<p>如标题所见，http在面临传输大文件的时候，也就是如何在有限带宽下高效快捷地传输这些大文件。</p>
<h2 id="数据压缩"> 数据压缩</h2>
<blockquote>
<p>是指在不丢失信息的前提下，缩减数据量以减少存储空间，提高传输、存储和处理效率的一种技术方法。或者是按照一定的算法对数据进行重新组织，减少数据的冗余和存储的空间。</p>
<p>更多介绍：<a href="https://blog.csdn.net/fanyun_01/article/details/80211799" target="_blank" rel="noopener noreferrer">深入解析数据压缩算法_Geek.Fan的博客-CSDN博客_数据压缩算法</a></p>
</blockquote>
<p>通常浏览器在发送请求时都会带着 <code>Accept-Encoding</code> 头字段，里面是浏览器支持的压缩格式列表，例如  gzip、deflate、br 等，这样服务器就可以从中选择一种压缩算法，放进 <code>Content-Encoding</code> 响应头里，再把原数据压缩后发给浏览器。</p>
<CodeGroup>
<CodeGroupItem title="客户端请求">
<div><pre><code><span><span>accept</span><span>:</span> <span>*/*</span></span>
<span><span>accept-encoding</span><span>:</span> <span>gzip, deflate, br</span></span>
<span><span>accept-language</span><span>:</span> <span>zh-CN,zh;q=0.9</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="服务器响应">
<div><pre><code><span><span>cache-control</span><span>:</span> <span>max-age=2592000</span></span>
<span><span>content-encoding</span><span>:</span> <span>gzip</span></span>
<span><span>content-type</span><span>:</span> <span>application/x-javascript</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></CodeGroupItem>
</CodeGroup>
<h2 id="分块传输"> 分块传输</h2>
<blockquote>
<p>分块传输编码（Chunked transfer encoding）是超文本传输协议（HTTP）中的一种数据传输机制，允许HTTP由应用服务器发送给客户端应用（ 通常是网页浏览器）的数据可以分成多个部分。分块传输编码只在HTTP协议1.1版本（HTTP/1.1）中提供。</p>
<p>通常，持久链接需要服务器在开始发送消息体前发送Content-Length消息头字段，但是对于动态生成的内容来说，在内容创建完之前是不可知的。</p>
<p>使用分块传输能很好的应对这种问题，分块传输编码允许服务器在最后发送消息头字段。</p>
</blockquote>
<p>响应头 <code>Transfer-Encoding</code> 字段的值为 <code>chunked</code>，表示数据以一系列分块的形式进行发送。需要注意的是 <code>Transfer-Encoding</code> 和 <code>Content-Length</code> 这两个字段是互斥的，也就是说响应报文中这两个字段不能同时出现</p>
<p>分块传输的编码规则：</p>
<ul>
<li>每个分块包含分块长度和数据块两个部分；</li>
<li>分块长度使用 16 进制数字表示，以 <code>\r\n</code> 结尾；</li>
<li>数据块紧跟在分块长度后面，也使用 <code>\r\n</code> 结尾，但数据不包含 <code>\r\n</code>；</li>
<li>终止块是一个常规的分块，表示块的结束。不同之处在于其长度为 0，即 <code>0\r\n\r\n</code></li>
</ul>
<div><pre><code><span><span>Transfer-Encoding</span><span>:</span> <span>chunked</span></span>
<span><span>Transfer-Encoding</span><span>:</span> <span>gzip, chunked</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><img src="./README.assets/block.png" alt="img" loading="lazy"></p>
<h2 id="范围请求"> 范围请求</h2>
<blockquote>
<p>Range 头是在 HTTP/1.1 协议中新增的一个请求头。包含 Range 头的请求通常称为范围请求，因为 Range 头允许服务器只发送部分响应到客户端。范围请求可以满足以下一些场景：</p>
<ul>
<li>断网重连之后，可以从下载中断处恢复下载</li>
<li>将大文件拆分后多线程下载</li>
<li>大文件中只想获取其中的一部分</li>
</ul>
</blockquote>
<p>如果在响应中存在 <code>Accept-Ranges</code> 首部（并且它的值不为 “none”），那么表示该服务器支持范围请求。</p>
<ul>
<li><code>unit</code>：范围请求所采用的单位，通常是字节（bytes）。</li>
<li><code>&lt;range-start&gt;</code>：一个整数，表示在特定单位下，范围的起始值。</li>
<li><code>&lt;range-end&gt;</code>：一个整数，表示在特定单位下，范围的结束值。<strong>这个值是可选的，如果不存在，表示此范围一直延伸到文档结束。</strong></li>
</ul>
<CodeGroup>
<CodeGroupItem title="单一范围">
<div><pre><code>curl http://i.imgur.com/z4d4kWk.jpg -i -H &quot;Range: bytes=0-1023&quot;
</code></pre>
<div><span>1</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="多重范围">
<div><pre><code>curl http://www.example.com -i -H &quot;Range: bytes=0-50, 100-150&quot;
</code></pre>
<div><span>1</span><br></div></div></CodeGroupItem>
</CodeGroup>
<CodeGroup>
<CodeGroupItem title="客户端请求">
<div><pre><code><span><span>GET</span> <span>/big-file.txt</span> <span>HTTP/1.1</span></span>
<span><span>Host</span><span>:</span> <span>localhost:3000</span></span>
<span><span>Connection</span><span>:</span> <span>keep-alive</span></span>
<span><span>Referer</span><span>:</span> <span>http://localhost:3000/index.html</span></span>
<span><span>Accept-Encoding</span><span>:</span> <span>identity</span></span>
<span><span>Accept-Language</span><span>:</span> <span>zh-CN,zh;q=0.9,en;q=0.8,id;q=0.7</span></span>
<span><span>Range</span><span>:</span> <span>bytes=0-100</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="服务器响应">
<div><pre><code><span><span>HTTP/1.1</span> <span>206</span> <span>Partial Content</span></span>
<span><span>Vary</span><span>:</span> <span>Origin</span></span>
<span><span>Accept-Ranges</span><span>:</span> <span>bytes</span></span>
<span><span>Last-Modified</span><span>:</span> <span>Sun, 06 Jun 2021 01:40:19 GMT</span></span>
<span><span>Cache-Control</span><span>:</span> <span>max-age=0</span></span>
<span><span>Content-Type</span><span>:</span> <span>text/plain; charset=utf-8</span></span>
<span><span>Date</span><span>:</span> <span>Sun, 06 Jun 2021 03:01:01 GMT</span></span>
<span><span>Connection</span><span>:</span> <span>keep-alive</span></span>
<span><span>Content-Range</span><span>:</span> <span>bytes 0-100/5243</span></span>
<span><span>Content-Length</span><span>:</span> <span>101</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div></CodeGroupItem>
</CodeGroup>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-25T01:10:50.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第一章、浏览器生成消息</title>
    <id>https://notes.lllllan.cn/cs-basic/network/how-is-the-network-connected/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/how-is-the-network-connected/1/"/>
    <updated>2022-04-07T05:25:11.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《网络是怎样连接的》</li>
</ul>
</div>
<h2 id="一、生成-http-请求消息"> 一、生成 HTTP 请求消息</h2>
<h3 id="_1-1-网址-url-uniform-resource-locator"> 1.1 网址（URL, Uniform Resource Locator）</h3>
<p>URL (Uniform Resource Locator，统一资源定位符)。就像每家每户都有一个门牌地址一样，每个网页也都有一个Internet地址。</p>
<p><img src="./README.assets/image-20211217214228466.png" alt="image-20211217214228466" loading="lazy"></p>
<h3 id="_1-2-解析-url"> 1.2 解析 URL</h3>
<p><img src="./README.assets/image-20211217214541708.png" alt="image-20211217214541708" loading="lazy"></p>
<p><img src="./README.assets/image-20211217214555087.png" alt="image-20211217214555087" loading="lazy"></p>
<h3 id="_1-3-文件名省略"> 1.3 文件名省略</h3>
<ul>
<li>当 URL 以 <code>/</code> 结尾时，服务器会默认访问该路径下的 <code>index.html</code> 或 <code>default.html</code> 文件</li>
<li>当 URL 连 <code>/</code> 和文件类型都省略的时候：</li>
</ul>
<p><img src="./README.assets/image-20211217215354653.png" alt="image-20211217215354653" loading="lazy"></p>
<p>（实测：当一个文件没有文件类型的时候，不允许和一个同名文件夹同时存在。而当这个文件有后缀时，应该会访问同名文件夹）</p>
<h3 id="_1-4-http-基本思路"> 1.4 HTTP 基本思路</h3>
<ul>
<li>对什么 + 进行怎样的操作</li>
</ul>
<p><img src="./README.assets/image-20211217215856796.png" alt="image-20211217215856796" loading="lazy"></p>
<p><img src="./README.assets/image-20211217215922575.png" alt="image-20211217215922575" loading="lazy"></p>
<h3 id="_1-5-生成-http-请求信息"> 1.5 生成 HTTP 请求信息</h3>
<blockquote>
<p><strong>一条请求消息中只能写一个URI</strong>。如果需要获取多个文件，必须对每个文件单独发送一条请求</p>
</blockquote>
<p><img src="./README.assets/image-20211217223257489.png" alt="image-20211217223257489" loading="lazy"></p>
<p><img src="./README.assets/image-20220225141810741.png" alt="image-20220225141810741" loading="lazy"></p>
<p>更多字段信息见文档 44 页。</p>
<h3 id="_1-6-服务器响应"> 1.6 服务器响应</h3>
<p><img src="./README.assets/image-20211217223257489.png" alt="image-20211217223257489" loading="lazy"></p>
<blockquote>
<p>状态码时一个数字，主要用来向程序告知执行的结果</p>
<p>响应短语是一段文字，用来向人们告知执行的结果</p>
</blockquote>
<p><img src="./README.assets/image-20211217224050584.png" alt="image-20211217224050584" loading="lazy"></p>
<p><img src="./README.assets/image-20211217224916808.png" alt="image-20211217224916808" loading="lazy"></p>
<h2 id="二、向-dns-服务器查询-web-服务器的-ip-地址"> 二、向 DNS 服务器查询 Web 服务器的 IP 地址</h2>
<h3 id="_2-1-ip-地址的基本知识"> 2.1 IP 地址的基本知识</h3>
<p><img src="./README.assets/image-20220225143658392.png" alt="image-20220225143658392" loading="lazy"></p>
<p><img src="./README.assets/image-20211219221243726.png" alt="image-20211219221243726" loading="lazy"></p>
<p><img src="./README.assets/image-20211219221343432.png" alt="image-20211219221343432" loading="lazy"></p>
<ul>
<li>IP 地址是 32 比特的数字，被分成了4组</li>
<li>子网掩码也是 32 比特的数字
<ul>
<li><strong>左边全1的部分表示网络号</strong></li>
<li><strong>右边全0的部分表示主机号</strong></li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20211219222137630.png" alt="image-20211219222137630" loading="lazy"></p>
<p><img src="./README.assets/image-20211219222245701.png" alt="image-20211219222245701" loading="lazy"></p>
<h3 id="_2-2-域名和ip地址并用的理由"> 2.2 域名和IP地址并用的理由</h3>
<ul>
<li>域名比IP地址更容易记忆</li>
<li>IP地址的传输比域名更高效（IP地址只是4字节的数字，域名最长可以是255字节的字符）</li>
</ul>
<p>于是让人来使用域名，让路由器来使用IP地址，这个机制就是<strong>DNS</strong>。</p>
<h3 id="_2-3-socket-库提供查询-ip-地址的功能"> 2.3 Socket 库提供查询 IP 地址的功能</h3>
<blockquote>
<p><strong>域名解析</strong>：通过DNS查询IP地址的操作。</p>
</blockquote>
<blockquote>
<p><strong>解析器</strong>：负责执行域名解析的DNS客户端。（解析器实际上是一段程序。）</p>
</blockquote>
<p>​	库是一堆通用程序组件的集合，他们具有诸多好处：</p>
<ul>
<li>节省编程工作量</li>
<li>实现程序的标准化</li>
</ul>
<p>​	Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。</p>
<h3 id="_2-4-通过解析器向dns服务器发出查询"> 2.4 通过解析器向DNS服务器发出查询</h3>
<ul>
<li>调用解析器</li>
<li>解析器向DNS服务器发送查询消息</li>
<li>DNS服务器返回响应消息</li>
<li>解析器从响应消息中取出IP地址并写入内存</li>
</ul>
<p><img src="./README.assets/image-20211223215500444.png" alt="image-20211223215500444" loading="lazy"></p>
<p>根据域名查询IP地址时，浏览器会使用Socket库中的解析器。</p>
<h3 id="_2-5-解析器的内部原理"> 2.5 解析器的内部原理</h3>
<div><p>控制流程转移</p>
<p>由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行。</p>
</div>
<ul>
<li>从上往下顺序执行应用程序编写的操作内容，当到达需要调用解析器的部分时</li>
<li>控制流程转移到<strong>解析器</strong>，解析器会生成要发送给DNS服务器的查询消息</li>
<li>委托操作系统内部的<strong>协议栈</strong>来发送这个消息（因为解析器本身并不具备使用网络收发数据的功能</li>
</ul>
<p><img src="./README.assets/image-20211224205322811.png" alt="image-20211224205322811" loading="lazy"></p>
<p>向DNS服务器发送消息时，也需要知道DNS服务器的IP地址。这是这个地址实现设置好了，不需要再查询。</p>
<p><img src="./README.assets/image-20211224213701480.png" alt="image-20211224213701480" loading="lazy"></p>
<h2 id="三、dns-服务器"> 三、DNS 服务器</h2>
<h3 id="_3-1-dns-服务器的基本工作"> 3.1 DNS 服务器的基本工作</h3>
<p>DNS 服务器的基本工作就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。</p>
<ul>
<li>域名：服务器、邮件服务器（邮件地址@后面的部分）的名称</li>
<li>Class：代表互联网的IN</li>
<li>记录类型：表示域名对应何种类型的记录。</li>
</ul>
<p><img src="./README.assets/image-20211224215024279.png" alt="image-20211224215024279" loading="lazy"></p>
<h3 id="_3-2-域名的层次结构"> 3.2 域名的层次结构</h3>
<p>由于存在着不计其数的服务器，不可能将所有服务器的信息保存在一台DNS服务器中，只能是将这些信息分布保存在多台DNS服务器中。</p>
<ul>
<li>按域名以分层次的结构来保存</li>
<li>域名中越靠右的位置表示气层级越高</li>
<li>每个域都是作为一个整体存放在DNS服务器中的</li>
</ul>
<h3 id="_3-3-寻找相应的-dns-服务器并获取-ip-地址"> 3.3 寻找相应的 DNS 服务器并获取 IP 地址</h3>
<ul>
<li>负责管理下级域的 DNS 服务器的 IP 地址注册到他们的上级 DNS 服务器中</li>
<li><code>com</code> 和 <code>jp</code> 的上面存在一个 根域</li>
<li>所有 DNS 服务器中都保存有根域的 DNS 服务器信息</li>
</ul>
<p><img src="./README.assets/image-20211224220739596.png" alt="image-20211224220739596" loading="lazy"></p>
<p><img src="./README.assets/image-20211224220802400.png" alt="image-20211224220802400" loading="lazy"></p>
<h3 id="_3-4-通过缓存加快-dns-服务器的响应"> 3.4 通过缓存加快 DNS 服务器的响应</h3>
<p>DNS 服务器有一个缓存功能，可以记住之前查询过的域名</p>
<ul>
<li>如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应。</li>
<li>当查询的域名不存在时，“不存在”这一响应结果也会被缓存</li>
<li>缓存信息设置有一个有效期，当信息超过有效期后，数据会从缓存中删除</li>
<li>DNS服务器返回响应时，会告知这一响应结果是来自缓存还是来自负责管理该域名的DNS服务器</li>
</ul>
<h2 id="四、委托协议栈发送消息"> 四、委托协议栈发送消息</h2>
<h3 id="_4-1-数据收发操作概览"> 4.1 数据收发操作概览</h3>
<blockquote>
<p>委托操作系统内部的协议栈发送HTTP消息，适用于<strong>任何</strong>网络应用程序。</p>
</blockquote>
<p><img src="./README.assets/image-20211225120920801.png" alt="image-20211225120920801" loading="lazy"></p>
<ul>
<li>创建套接字（出入口） —— <strong>创建套接字阶段</strong></li>
<li>【客户端】向【服务器端】套接字连接管道 —— <strong>连接阶段</strong></li>
<li>收发数据 —— <strong>通信阶段</strong></li>
<li>断开管道并删除套接字 —— <strong>断开阶段</strong></li>
</ul>
<div><p>这个管道中，数据流动是双向的</p>
</div>
<h3 id="_4-2-创建套接字阶段"> 4.2 创建套接字阶段</h3>
<blockquote>
<p>创建套接字需要调用 Socket 库中的 <strong>socket 程序组件</strong></p>
</blockquote>
<p>客户端创建套接字：</p>
<ul>
<li>调用 Socket 库中的 socket 程序组件</li>
<li>控制流程转移到 socket 内部并执行创建套接字操作</li>
<li>控制流程交回应用程序</li>
</ul>
<p><img src="./README.assets/image-20211225122553775.png" alt="image-20211225122553775" loading="lazy"></p>
<blockquote>
<p>套接字创建完成以后，协议栈返回一个<strong>描述符</strong>，用来标识该套接字</p>
</blockquote>
<h3 id="_4-3-连接阶段"> 4.3 连接阶段</h3>
<blockquote>
<p>连接阶段需要调用 Socket 库中的 <strong>connect 程序组件</strong></p>
</blockquote>
<p>调用 connect 时需要指定三个参数：描述符、服务器IP地址、端口号</p>
<p><img src="./README.assets/image-20211225130205613.png" alt="image-20211225130205613" loading="lazy"></p>
<h3 id="_4-4-通信阶段"> 4.4 通信阶段</h3>
<blockquote>
<p>通信阶段需要调用 Socket 库中的 <strong>write 程序组件</strong>、<strong>read 程序组件</strong></p>
</blockquote>
<p>发送数据：</p>
<ul>
<li>生成 HTTP 请求消息</li>
<li>指定描述符和要发送的数据，由协议栈将数据发送到服务器</li>
</ul>
<p>接收数据：</p>
<ul>
<li>指定存放响应消息的内存地址（称为接收缓冲区）</li>
<li>read 将接收到的响应消息存放到接收缓冲区中</li>
</ul>
<h3 id="_4-5-断开阶段"> 4.5 断开阶段</h3>
<blockquote>
<p>断开阶段需要调用 Socket 库中的 <strong>close 程序组件</strong></p>
</blockquote>
<ul>
<li>Web服务器在发送完响应消息之后，会首先调用 close 来断开连接</li>
<li>客户端中 read 执行接收数据时，会告知浏览器通信阶段已结束</li>
<li>浏览器调用 close 进入断开阶段</li>
</ul>
<h3 id="_4-6-各阶段功能和调用组件"> 4.6 各阶段功能和调用组件</h3>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:center">组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建套接字</td>
<td style="text-align:center">socket</td>
</tr>
<tr>
<td style="text-align:center">连接</td>
<td style="text-align:center">connect</td>
</tr>
<tr>
<td style="text-align:center">通信</td>
<td style="text-align:center">发送：write<br>接收：read</td>
</tr>
<tr>
<td style="text-align:center">断开</td>
<td style="text-align:center">close</td>
</tr>
</tbody>
</table>
<h2 id="五、本章回顾"> 五、本章回顾</h2>
<ul>
<li>网址前的 <code>http</code> 代表什么意思</li>
</ul>
<blockquote>
<p>HTTP，即超文本传输协议，是 HyperText Transfer Protocol的缩写。</p>
</blockquote>
<ul>
<li>用来识别连接在互联网上的计算机和服务器的地址叫什么</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<ul>
<li>根据Web服务器的域名来查询IP地址时所用的服务器叫什么</li>
</ul>
<blockquote>
<p>DNS 服务器</p>
</blockquote>
<ul>
<li>向DNS服务器发送请求消息的程序叫什么</li>
</ul>
<blockquote>
<p>协议栈</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第三章、从网线到网络设备</title>
    <id>https://notes.lllllan.cn/cs-basic/network/how-is-the-network-connected/3/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/how-is-the-network-connected/3/"/>
    <updated>2022-04-07T07:10:05.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《网络是怎样连接的》</li>
</ul>
</div>
<h2 id="一、信号在网线和集线器中传输"> 一、信号在网线和集线器中传输</h2>
<h3 id="_1-1-每个包都是独立传输的"> 1.1 每个包都是独立传输的</h3>
<p><img src="./README.assets/image-20220113145717884.png" alt="image-20220113145717884" loading="lazy"></p>
<h3 id="_1-2-网线中的信号衰减"> 1.2 网线中的信号衰减</h3>
<p>以太网信号的本质是正负变化的电压。</p>
<p>信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。</p>
<p>同时噪声也会进一步加剧信号的失真。</p>
<h3 id="_1-3-双绞线抑制噪声"> 1.3 双绞线抑制噪声</h3>
<blockquote>
<p>产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。信号和噪声的电流混杂在一起之后，导致信号的波形发生失真。</p>
</blockquote>
<p>影响网线的电磁波分为两种：</p>
<h4 id="来自网线之外的其他设备"> 来自网线之外的其他设备：</h4>
<p>当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流。</p>
<p>如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线产生的噪声电流方向就会相反，从而使得噪声电流相互抵消。</p>
<p><img src="./README.assets/image-20220113150630538.png" alt="image-20220113150630538" loading="lazy"></p>
<p><img src="./README.assets/image-20220113150651814.png" alt="image-20220113150651814" loading="lazy"></p>
<h4 id="相邻信号线泄露出来"> 相邻信号线泄露出来：</h4>
<p>这种内部产生的噪声称为 <strong>串扰</strong></p>
<p><img src="./README.assets/image-20220113151240119.png" alt="image-20220113151240119" loading="lazy"></p>
<p><img src="./README.assets/image-20220113151203170.png" alt="image-20220113151203170" loading="lazy"></p>
<h3 id="_1-4-集线器将信号发往所有线路"> 1.4 集线器将信号发往所有线路</h3>
<blockquote>
<p>集线器将信号发送给所有连接在它上面的线路。</p>
</blockquote>
<p><img src="./README.assets/image-20220113151435359.png" alt="image-20220113151435359" loading="lazy"></p>
<h6 id=""> <img src="./README.assets/image-20220113151613603.png" alt="image-20220113151613603" loading="lazy"></h6>
<h2 id="二、交换机的包转发操作"> 二、交换机的包转发操作</h2>
<h3 id="_2-1-交换机根据地址表进行转发"> 2.1 交换机根据地址表进行转发</h3>
<ol>
<li>信号到达网线接口，由 <code>PHY(MAU)</code> 模块进行接收</li>
<li><code>PHY(MAU)</code> 模块将网线中的信号转换为通用格式，并传递给 <code>MAC</code> 模块</li>
<li><code>MAC</code> 模块将信号转换为数字信息，并进行 <code>FCS</code> 校验错误，没有问题的放到缓冲区中</li>
<li>查询 <code>MAC</code> 地址表，找到对应端口并通过交换电路将包发送到该端口</li>
</ol>
<p><img src="./README.assets/image-20220226100418996.png" alt="image-20220226100418996" loading="lazy"></p>
<p><img src="./README.assets/image-20220226095221451.png" alt="image-20220226095221451" loading="lazy"></p>
<p>信号线排列成网格状，每一个交叉点都有一个交换开关，交换开关是电子控制的，通过切换开关的状态就可以改变信号的流向。</p>
<p><img src="./README.assets/image-20220226100830499.png" alt="image-20220226100830499" loading="lazy"></p>
<p>当网络包通过交换电路到达发送端口时，端口中的 <code>MAC</code> 模块和 <code>PHY(MAU)</code> 模块会执行发送操作，将信号发送到网线中。</p>
<ol>
<li>首先确认没有其他设备再发送信号，即确认信号收发模块中的接收线路没有信号进来
<ol>
<li>如果监测到其他设备正在发送信号，则需要等待信号发送完毕</li>
<li>如果没有其他信号，或者其他信号已经发送完毕，这是就可以将包的数字信息转换为电信号发送出去</li>
</ol>
</li>
<li>发送过程中还需要对接收信号进行监控
<ol>
<li>如果发送过程中检测到其他设备发送信号，就意味着出现了信号碰撞，这是需要发送阻塞信号以停止网络中所有的发送操作，等待一段时间后再尝试重新发送</li>
</ol>
</li>
</ol>
<h3 id="_2-2-mac地址表的维护"> 2.2 MAC地址表的维护</h3>
<ol>
<li>收到包时，将发送方的 MAC 地址以及其输入端口的号码写入 MAC 地址表中</li>
<li>删除地址表中某条记录，防止设备移动时产生问题</li>
</ol>
<p>eg：开会时把笔记本电脑从办公室拿到会议室，这是设备就发生了移动。只要笔记本电脑连接到会议室的交换机，这台交换就会根据笔记本电脑发出的包来更新它的地址表。而对于目的地的交换机来说，不需要什么特别的措施就能正常工作。</p>
<h3 id="_2-3-特殊操作"> 2.3 特殊操作</h3>
<p>发现某个包的目标端口和源端口相同，即某台计算机给自己发送了一个包：</p>
<ul>
<li>计算机A发送的包到达集线器后会被集线器转发到所有端口上，因此交换机和计算机B都会收到</li>
<li>交换机接收到之后查看地址表，将该包原路返回集线器</li>
<li>集线器接收到之后再次转发给所有端口，因此计算机AB都会收到</li>
</ul>
<p>这种情况下计算机B就会收到两个相同的包，会导致无法正常通信。</p>
<p><strong>因此当交换机发现一个包要发回到源端口时，就会直接丢弃这个包。</strong></p>
<p><img src="./README.assets/image-20220226104414300.png" alt="image-20220226104414300" loading="lazy"></p>
<p>如果交换机的地址表中找不到指定的 MAC 地址，有可能是因为具有该地址的设备还没有向交换机发送过包、或者这个设备一段时间内没有工作导致地址被从地址表中删除。</p>
<p>这种情况下交换机只能将包转发到除了源端口以外的所有端口，这样做不会出现什么问题，因为只有相应的接收者才接受包，其他设备会忽略这个包。</p>
<div><p>发送多余的包会不会造成网络拥塞？</p>
<p>发送了包之后设备会作出响应，只要返回了响应包，交换机就可以将它写入地址表，下次就不需要转发给所有端口了。局域网中每秒可以传输上千个包，多出一两个并无大碍</p>
</div>
<div><p>如果接收方 MAC地址是一个广播地址，那么交换机会将包转发给除源端口以外的所有端口</p>
</div>
<h3 id="_2-4-全双工模式可以同时进行发送和接收"> 2.4 全双工模式可以同时进行发送和接收</h3>
<div><p>Note</p>
<p>全双工模式是交换机特有的工作模式，它可以同时进行发送和接收操作，集线器不具备这样的特性</p>
</div>
<h3 id="_2-5-自动协商-确定最优的传输速率"> 2.5 自动协商：确定最优的传输速率</h3>
<p>自动协商：能够再全双工和半双工模式之间进行切换，还能探测对方的传输速率并进行自动切换。</p>
<p><img src="./README.assets/image-20220226111852275.png" alt="image-20220226111852275" loading="lazy"></p>
<div><p>连接脉冲</p>
<p>在以太网中，当没有数据在传输时，网络中会填充一种被称为连接脉冲的脉冲信号。</p>
<p>在没有数据信号时就填充连接脉冲，使得网络中一直都有一定的信号流过，从而能够检测对方是否在正常工作。</p>
</div>
<p><img src="./README.assets/image-20220226112514774.png" alt="image-20220226112514774" loading="lazy"></p>
<h3 id="_2-6-交换机可以同时执行多个转发操作"> 2.6 交换机可以同时执行多个转发操作</h3>
<p>交换机只将包转发到具有特定 MAC 地址的设备连接的端口，其他端口都是空闲的，这些空闲的端口可以传输其他的包，因此交换机可以同时转发多个包。</p>
<p>集线器会将输入的信号广播到所有的端口，如果同时输入多个信号就会发生碰撞，无法同时传输多路信号。</p>
<h2 id="三、路由器的包转发操作"> 三、路由器的包转发操作</h2>
<h3 id="_3-1-路由器的基本知识"> 3.1 路由器的基本知识</h3>
<p><mark>路由器是基于IP设计的，交换机是基于以太网设计的</mark></p>
<p>路由器的内部结构中，转发模块负责判断包的转发目的地，端口模块负责包的收发操作。</p>
<p><img src="./README.assets/image-20220407140825589.png" alt="image-20220407140825589" loading="lazy"></p>
<div><p>路由器的工作原理</p>
<ol>
<li>通过端口将发过来的包接收进来</li>
<li>转发模块会根据接收到的包的IP头部中记录的接收方IP地址，在路由表中进行查询，以此判断转发目标</li>
<li>转发模块将包转移到转发目标对应的端口，端口再按照硬件的规则将包发送出去</li>
</ol>
</div>
<div><p>路由器的各个端口都具有MAC地址和IP地址</p>
</div>
<h3 id="_3-2-路由表中的信息"> 3.2 路由表中的信息</h3>
<p><mark>交换机是通过MAC头部中的接收方的MAC地址来判断转发目标的，而路由器是根据IP头部中的IP地址来判断的</mark></p>
<blockquote>
<p>打个比方，路由器在转发包的时候只看接收方地址属于哪个区，XX区发往这一边，XX区发往那一边</p>
</blockquote>
<p><img src="./README.assets/image-20220407141705674.png" alt="image-20220407141705674" loading="lazy"></p>
<p><mark>路由器会忽略主机号，只匹配网络号</mark></p>
<div><p>路由聚合</p>
<p>路由聚合会将几个子网合并成一个子网，并在路由表中只产生一条记录。</p>
<blockquote>
<p>路由器B的路由表中原本应该有对应三个子网的3条记录。但是在这个例子中，不论是发往任何一个子网，都一定会经过路由器A。因此我们可以在路由表中将这三个子网合并成一个，从而较少路由表B中的记录数量。</p>
</blockquote>
<p><img src="./README.assets/image-20220407142019054.png" alt="image-20220407142019054" loading="lazy"></p>
</div>
<h3 id="_3-3-路由器的包接收操作"> 3.3 路由器的包接收操作</h3>
<ol>
<li>信号到达网线接口部分</li>
<li>PHY（MAU）模块和MAC模块将信号转换为数字信号，通过包末尾的FCS进行错误校验</li>
<li>校验没问题则检查MAC头部中的接收方MAC地址，是发送给自己的就放到接收缓冲区、否则就丢弃</li>
</ol>
<p><mark>路由器的端口都具有MAC地址，只接收与自身地址匹配的包，遇到不匹配的则直接丢弃</mark></p>
<h3 id="_3-4-查询路由表确定输出端口"> 3.4 查询路由表确定输出端口</h3>
<p><mark>通过路由器转发的网络包，其接收方MAC地址为路由器端口的MAC地址</mark></p>
<p>MAC头部的作用就是将包送达路由器，其中的接收方MAC地址就是路由器端口的MAC地址。因此当包到达路由器之后，MAC头部的任务就完成了，于是MAc头部就会被丢弃。</p>
<p>接下来路由器会根据MAC头部后方的IP头部中的内容进行包的转发操作。去路由表中查询判断转发目标。<strong>如果路由表中无法找到匹配的记录，路由器就会丢弃这个包，并通过ICMP消息告知发送方。</strong></p>
<blockquote>
<p>路由器工作的网络环境是互联网，规模太大，如果将包转发给所有的端口会产生大量的包，造成网络拥塞</p>
</blockquote>
<h3 id="_3-5-找不到匹配路由时选怎默认路由"> 3.5 找不到匹配路由时选怎默认路由</h3>
<p>路由表中子网掩码为 0.0.0.0 的记录表示【默认路由】</p>
<p>当匹配不到其他路由时，网络包就会被转发到互联网接入路由器。因此这条记录被称为默认路由，这一行配置的网关地址被称为默认网关。</p>
<h3 id="_3-6-包的有效期"> 3.6 包的有效期</h3>
<p>路由器会更新网络包的IP头部中的TTL字段，TTL字段表示包的有效期，没经过一个路由器的转发，这个值就会减一，当这个值变成零时就表示超过了有效期，这个包就会被丢弃。</p>
<blockquote>
<p>这个机制是为了防止包在一个地方陷入死循环。</p>
</blockquote>
<h3 id="_3-7-通过分片功能拆分大网络包"> 3.7 通过分片功能拆分大网络包</h3>
<p>路由器的端口可以支持其他局域网或者专线通信技术，但是不同的线路和局域网类型各自能传输 的最大包长度不同，因此输出端口的最大包长度可能会小于输入端口。一旦转发的包长度超过了输出端口能传输的最大长度，就无法直接发送这个包了。</p>
<p><strong>可以使用IP协议中定义的分片功能对包进行拆分，缩短每个包的长度。</strong></p>
<div><p>区别TIP的拆分</p>
<p>TCP拆分数据的操作是在将数据装到包里之前进行的，拆分好的一个数据块正好装进一个包里。</p>
<p>从IP分片的角度来看，这样一个包其实是一个未拆分的整体，分片是对一个完整的包再进行拆分的过程。</p>
</div>
<p><img src="./README.assets/image-20220407145006165.png" alt="image-20220407145006165" loading="lazy"></p>
<p><strong>拆分之前需要查看IP头部中的标志字段，确认是否可以分片。</strong>　如果查询标志字段发现不能分片，那么就只能丢弃这个包，并通过ICMP消息通知发送方。</p>
<h3 id="_3-8-路由器的发送操作和计算机相同"> 3.8 路由器的发送操作和计算机相同</h3>
<ol>
<li>根据路由表的网关列判断对方的地址。
<ul>
<li>如果网关是一个IP地址，则这个IP地址就是我们要转发到的目标地址</li>
<li>如果网关为空，则IP头部中的接收方IP就是我们要转发到的目标地址</li>
</ul>
</li>
<li>通过ARP根据IP地址查询MAC地址，并将查询结果作为接收方的MAC地址
<ul>
<li>路由器中有ARP缓存，首先会在ARP缓存中查询</li>
<li>如果找不到则发送ARP查询请求</li>
</ul>
</li>
<li>将网络包转换成电信号并通过端口发送出去
<ul>
<li>半双工模式，先确认线路中没有其他信号才能发送，如果检测到碰撞则需要等待一段时间后重发</li>
<li>全双工模式，不需要确认线路中的信号，可以直接发送</li>
</ul>
</li>
</ol>
<h3 id="_3-9-路由器和交换机的关系"> 3.9 路由器和交换机的关系</h3>
<p><mark>IP协议本身没有传输包的功能，因此包的实际传输要委托以太网来进行</mark></p>
<p><img src="./README.assets/image-20220407150543133.png" alt="image-20220407150543133" loading="lazy"></p>
<p>路由器将包的传输工作委托给交换机来进行。</p>
<blockquote>
<p>这里的内容适用于纯粹从路由器和纯粹的交换机。实际情况中路由器有内置的交换机功能</p>
</blockquote>
<p>IP并不是委托以太网将包传输到最红目的地，而是传到下一个路由器。当包到达下一个路由器后，下一个路由器又会重新委托以太网将包传输到再下一个路由器。如此反复包就会最终到达IP的目的地。</p>
<div><p>Info</p>
<p>IP本身不负责包的传输，而是委托各种通信技术将包传输到下一个路由器。</p>
<p>这样的设计可以根据需要灵活运用各种通信技术，这也是IP的最大特点。</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HTTP 常见面试题</title>
    <id>https://notes.lllllan.cn/cs-basic/network/http/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/http/"/>
    <updated>2022-04-24T00:12:15.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://xiaolincoding.com/network/2_http/http_interview.html" target="_blank" rel="noopener noreferrer">3.1 HTTP 常见面试题 | 小林coding (xiaolincoding.com)</a></li>
</ul>
</div>
<h2 id="get-与-post"> GET 与 POST</h2>
<h3 id="get"> GET</h3>
<p><mark>GET 的语义是从服务器获取指定的资源</mark></p>
<ul>
<li>GET 请求的参数位置一般是写在 URL 中</li>
<li>URL 规定只能支持 ASCII，所以 GET 请求的参数只允许 ASCII 字符</li>
<li>而且浏览器会对 URL 的长度有限制（HTTP协议本身对 URL长度并没有做任何规定）。</li>
</ul>
<div>
<p><img src="./README.assets/12-Get请求.png" alt="GET 请求" loading="lazy"></p>
</div>
<h3 id="post"> POST</h3>
<p><mark>POST 的语义是根据请求负荷（报文body）对指定的资源做出处理</mark></p>
<ul>
<li>POST 请求携带数据的位置一般是写在报文 body 中，</li>
<li>body 中的数据可以是任意格式的数据，只要客户端与服务端协商好即可</li>
<li>而且浏览器不会对 body 大小做限制</li>
</ul>
<div>
<p><img src="./README.assets/13-Post请求.png" alt="POST 请求" loading="lazy"></p>
</div>
<h3 id="get-和-post-方法都是安全和幂等的吗"> GET 和 POST 方法都是安全和幂等的吗？</h3>
<ul>
<li>在 HTTP 协议里，所谓的「安全」是指请求方法不会「破坏」服务器上的资源。</li>
<li>所谓的「幂等」，意思是多次执行相同的操作，结果都是「相同」的。</li>
</ul>
<p>如果从 RFC 规范定义的语义来看：</p>
<ul>
<li><mark>GET 方法就是安全且幂等的</mark> ，因为它是「只读」操作，无论操作多少次，服务器上的数据都是安全的，且每次的结果都是相同的。所以，<strong>可以对 GET 请求的数据做缓存，这个缓存可以做到浏览器本身上（彻底避免浏览器发请求），也可以做到代理上（如nginx），而且在浏览器中 GET 请求可以保存位书签</strong>。</li>
<li><mark>POST 方法不安全也不幂等</mark> ，因为是「新增或提交数据」的操作，会修改服务器上的资源，所以是不安全的，且多次提交数据就会创建多个资源，所以不是幂等的。所以，<strong>浏览器一般不会缓存 POST 请求，也不能把 POST 请求保存为书签</strong>。</li>
</ul>
<div><p>url 和 body</p>
<p>RFC 规范并没有规定 GET 请求不能带 body 的。理论上，任何请求都可以带 body 的。只是因为 RFC 规范定义的 GET 请求是获取资源，所以根据这个语义不需要用到 body。</p>
<p>另外，URL 中的查询参数也不是 GET 所独有的，POST 请求的 URL 中也可以有参数的。</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-23T15:30:13.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HTTP和HTTPS</title>
    <id>https://notes.lllllan.cn/cs-basic/network/http/https/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/http/https/"/>
    <updated>2022-04-23T16:34:36.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.runoob.com/w3cnote/http-vs-https.html" target="_blank" rel="noopener noreferrer">HTTP 与 HTTPS 的区别 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="./../diagram-http/7/">《图解HTTP》HTTPS</a></li>
<li><a href="https://www.jianshu.com/p/e30a8c4fa329" target="_blank" rel="noopener noreferrer">HTTPS加密（握手）过程</a></li>
<li><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-%E4%B8%8E-https" target="_blank" rel="noopener noreferrer">3.1 HTTP 常见面试题 | 小林coding (xiaolincoding.com)</a></li>
</ul>
</div>
<h2 id="基本概念"> 基本概念</h2>
<h3 id="http"> HTTP</h3>
<p>HTTP（HyperText Transfer Protocol：超文本传输协议）。HTTP 是一个在计算机世界里专门在「两点」之间「传输」文字、图片、音频、视频等「超文本」数据的「约定和规范」。</p>
<p>HTTP 默认工作在 TCP 协议 80 端口，用户访问网站 <strong>http://</strong> 打头的都是标准 HTTP 服务。</p>
<p>HTTP 协议以明文方式发送内容，不提供任何方式的数据加密，如果攻击者截取了Web浏览器和网站服务器之间的传输报文，就可以直接读懂其中的信息，因此，HTTP协议不适合传输一些敏感信息，比如：信用卡号、密码等支付信息。</p>
<h3 id="https"> HTTPS</h3>
<p>HTTPS（Hypertext Transfer Protocol Secure：超文本传输安全协议）是一种透过计算机网络进行安全通信的传输协议。HTTPS 经由 HTTP 进行通信，但利用 SSL/TLS 来加密数据包。HTTPS 开发的主要目的，是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<h2 id="http-与-https-区别"> HTTP 与 HTTPS 区别</h2>
<ul>
<li>HTTP 是超文本传输协议，信息是明文传输，存在安全风险的问题。HTTPS 则解决 HTTP 不安全的缺陷，在 TCP 和 HTTP 网络层之间加入了 SSL/TLS 安全协议，使得报文能够加密传输。</li>
<li>HTTP 连接建立相对简单， TCP 三次握手之后便可进行 HTTP 的报文传输。而 HTTPS 在 TCP 三次握手之后，还需进行 SSL/TLS 的握手过程，才可进入加密报文传输。</li>
<li>HTTP 的端口号是 80，HTTPS 的端口号是 443。</li>
<li>HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了 TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。</li>
<li>HTTPS 协议需要向 CA（证书权威机构）申请数字证书，来保证服务器的身份是可信的。</li>
</ul>
<p><img src="./README.assets/19-HTTPS与HTTP.png" alt="HTTP 与 HTTPS 网络层" loading="lazy"></p>
<h2 id="https-解决了什么问题"> HTTPS 解决了什么问题</h2>
<div><p>HTTP 不安全</p>
<ul>
<li><strong>窃听风险</strong>，比如通信链路上可以获取通信内容，用户号容易没。</li>
<li><strong>篡改风险</strong>，比如强制植入垃圾广告，视觉污染，用户眼容易瞎。</li>
<li><strong>冒充风险</strong>，比如冒充淘宝网站，用户钱容易没。</li>
</ul>
</div>
<p>HTTPS 在 HTTP 与 TCP 层之间加入了 <code>SSL/TLS</code> 协议，可以很好的解决了上述的风险：</p>
<ul>
<li><strong>信息加密</strong>：交互信息无法被窃取，但你的号会因为「自身忘记」账号而没。</li>
<li><strong>校验机制</strong>：无法篡改通信内容，篡改了就不能正常显示，但百度「竞价排名」依然可以搜索垃圾广告。</li>
<li><strong>身份证书</strong>：证明淘宝是真的淘宝网，但你的钱还是会因为「剁手」而没。</li>
</ul>
<h3 id="混合加密"> 混合加密</h3>
<ul>
<li>对称加密。加密和解密使用相同的密钥。优点是相对高效，但是密钥被窃取就不安全了。</li>
<li>非对称加密。加密方使用公开的公钥进行加密，解密方用只有自己保持的私钥进行解密。优点是更加安全，但是效率相对较低</li>
</ul>
<p>因此采用「混合加密」的方式：</p>
<ul>
<li>在通信建立前采用 <strong>非对称加密</strong> 的方式交换「会话秘钥」，后续就不再使用非对称加密。</li>
<li>在通信过程中全部使用 <strong>对称加密</strong> 的「会话秘钥」的方式加密明文数据。</li>
</ul>
<h3 id="摘要算法"> 摘要算法</h3>
<p><mark>摘要算法用来实现完整性</mark> ，能够为数据生成独一无二的「指纹」，用于校验数据的完整性，解决了篡改的风险。</p>
<p><img src="./README.assets/21-校验完整性.png" alt="校验完整性" loading="lazy"></p>
<p>客户端在发送明文之前会通过摘要算法算出明文的「指纹」，发送的时候把「指纹 + 明文」一同加密成密文后，发送给服务器，服务器解密后，用相同的摘要算法算出发送过来的明文，通过比较客户端携带的「指纹」和当前算出的「指纹」做比较，若「指纹」相同，说明数据是完整的。</p>
<blockquote>
<p>如果你想要成功篡改某次通信的数据包还不被发现，你需要同时达成一下几个条件</p>
<ul>
<li>你能够窃听到通信双方使用的「会话秘钥」，这步在混合加密的时候就单防你了</li>
<li>还要窃听到通信双方使用的「摘要算法」</li>
</ul>
<p>如果你想要偷偷篡改数据，你需要拦截下发送方的数据包，修改数据之后用相同的「摘要算法」算出假明文的「指纹」，再整个使用相同的「会话秘钥」，然后发送给接收方。</p>
</blockquote>
<h3 id="数字证书"> 数字证书</h3>
<p>双方安全确定「会话秘钥」和「摘要算法」之后，才能保证传输数据不被篡改。但是在这之前，传输公钥的过程中仍有被篡改的风险。</p>
<p>这时候就需要借助第三方权威机构 <code>CA</code> （数字证书认证机构），将 <strong>服务器公钥放在数字证书</strong> （由数字证书认证机构颁发）中，只要证书是可信的，公钥就是可信的。</p>
<div><p>敲重点</p>
<p>服务器提前向 CA 申请证书：</p>
<ol>
<li>服务器将自己的公钥发给 CA，申请一个证书来保护自己的公钥</li>
<li>CA 使用散列算法对「服务器公钥」计算出「摘要」，用自己的私钥对「摘要」进行加密</li>
<li>CA 向服务器返回一个数字证书：「服务器公钥」 +  <mark>「数字签名」（加密过的摘要）</mark></li>
</ol>
<p><strong>CA 非常可靠，大部分浏览器中都提起那内置了 CA 的公钥。</strong></p>
<p>客户端和服务器双方建立安全连接：</p>
<ol>
<li>服务器向客户端发送提前申请好的「数字证书」</li>
<li>客户端收到「数字证书」，使用浏览器内置的「CA 公钥」对证书中的「数字签名」进行解密获得「摘要 A」</li>
<li>客户端使用和 CA 相同的散列算法对证书中的「服务器公钥」计算出「摘要 B」，如果前后两个摘要完全相等，证明该公钥是安全可靠的</li>
</ol>
</div>
<p><img src="./README.assets/22-数字证书工作流程.png" alt="数子证书工作流程" loading="lazy"></p>
<h2 id="https-握手流程"> HTTPS 握手流程</h2>
<p><img src="./README.assets/23-HTTPS工作流程.png" alt="HTTPS 连接建立过程" loading="lazy"></p>
<ol>
<li>
<p><mark>客户端发送 client_hello</mark></p>
<p>首先，由客户端向服务器发起加密通信请求，也就是 <code>ClientHello</code> 请求。以明文传输请求信息，包含</p>
<ul>
<li>客户端支持的 SSL/TLS 协议版本</li>
<li>客户端生产的随机数（<code>Client Random</code>），后面用于生成「会话秘钥」条件之一。</li>
<li>加密套件候选列表</li>
<li>压缩算法候选列表</li>
<li>扩展字段等信息</li>
</ul>
</li>
<li>
<p><mark>服务器发送 SeverHello</mark></p>
<p>服务器收到客户端请求后，向客户端发出响应，也就是 <code>SeverHello</code>。服务器回应的内容有如下内容：</p>
<ul>
<li>确认 SSL/ TLS 协议版本，如果浏览器不支持，则关闭加密通信</li>
<li>服务器生产的随机数（<code>Server Random</code>），也是后面用于生产「会话秘钥」条件之一。</li>
<li>选择的加密套件 cipher suite</li>
<li>选择的压缩算法 compression method</li>
</ul>
</li>
<li>
<p><mark>服务端发送证书</mark></p>
<p>服务器端配置对应的证书链，用于身份验证和密钥交换</p>
</li>
<li>
<p><mark>服务端发送Server Hello Done</mark></p>
<p>通知客户端 server_hello 信息发送结束</p>
</li>
<li>
<p><mark>客户端回应</mark></p>
<p>客户端收到服务器的回应之后，首先通过浏览器或者操作系统中的 CA 公钥，确认服务器的数字证书的真实性。</p>
<p>如果证书没有问题，客户端会从数字证书中取出服务器的公钥，然后使用它加密报文，向服务器发送如下信息：</p>
<ul>
<li>
<p>一个随机数（<code>pre-master key</code>）。该随机数会被服务器公钥加密。</p>
</li>
<li>
<p>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</p>
</li>
<li>
<p>客户端握手结束通知，表示客户端的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供服务端校验。</p>
</li>
</ul>
<p><strong>服务器和客户端有了这三个随机数（Client Random、Server Random、pre-master key），接着就用双方协商的加密算法，各自生成本次通信的「会话秘钥」</strong>。</p>
</li>
<li>
<p><mark>服务端回应</mark></p>
<p>服务器收到客户端的第三个随机数（<code>pre-master key</code>）之后，通过协商的加密算法，计算出本次通信的「会话秘钥」。</p>
<p>然后，向客户端发送最后的信息：</p>
<ul>
<li>加密通信算法改变通知，表示随后的信息都将用「会话秘钥」加密通信。</li>
<li>服务器握手结束通知，表示服务器的握手阶段已经结束。这一项同时把之前所有内容的发生的数据做个摘要，用来供客户端校验。</li>
</ul>
</li>
</ol>
<h2 id="ssl-tls"> SSL/TLS</h2>
<p><a href="https://cloud.tencent.com/developer/article/1115445" target="_blank" rel="noopener noreferrer">SSL/TLS原理详解 - 云+社区 - 腾讯云 (tencent.com)</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/133375078" target="_blank" rel="noopener noreferrer">一篇文章让你彻底弄懂SSL/TLS协议 - 知乎 (zhihu.com)</a></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-23T15:29:19.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HTTP 各版本</title>
    <id>https://notes.lllllan.cn/cs-basic/network/http/version/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/http/version/"/>
    <updated>2022-04-24T10:12:43.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/43787334" target="_blank" rel="noopener noreferrer">HTTP/1.0、HTTP/1.1、HTTP/2、HTTPS - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/26559480" target="_blank" rel="noopener noreferrer">一文读懂 HTTP/2 特性 - 知乎 (zhihu.com)</a></li>
<li><a href="https://xiaolincoding.com/network/2_http/http_interview.html#http-1-1%E3%80%81http-2%E3%80%81http-3-%E6%BC%94%E5%8F%98" target="_blank" rel="noopener noreferrer">3.1 HTTP 常见面试题 | 小林coding (xiaolincoding.com)</a></li>
</ul>
</div>
<h2 id="http-1-1"> HTTP/1.1</h2>
<ol>
<li>长连接</li>
<li>管道网络传输</li>
<li>范围请求</li>
<li>Host 头</li>
<li>更多缓存策略</li>
<li>更多的状态码</li>
</ol>
<h3 id="长连接"> 长连接</h3>
<p>HTTP1.0 默认使用短连接，每次发送一个 HTTP 请求都会单独进行一次 TCP 连接，使用完马上断开。</p>
<p>为了解决资源浪费的问题，HTTP1.1 默认使用长连接。</p>
<h3 id="管道网络传输"> 管道网络传输</h3>
<p>HTTP/1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>
<p>即可在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。</p>
<p><img src="./README.assets/17-管道网络传输.png" alt="管道网络传输" loading="lazy"></p>
<div><p>「队头阻塞」</p>
<p>HTTP1.1 可以连续发送请求，解决了请求的「队头阻塞」。</p>
<p><mark>但是服务器必须按照接收请求的顺序发送对这些管道化请求的响应。</mark> 因此并没有饥饿绝响应的「队头阻塞」。</p>
</div>
<h3 id="范围请求"> 范围请求</h3>
<p>HTTP/1.1 引入了范围请求（range request）机制，以避免带宽的浪费。</p>
<p>当客户端想请求一个文件的一部分，或者需要继续下载一个已经下载了部分但被终止的文件，HTTP/1.1 可以在请求中加入 <code>Range</code> 头部，以请求（并只能请求字节型数据）数据的一部分。服务器端可以忽略 <code>Range</code> 头部，也可以返回若干 <code>Range</code> 响应。</p>
<p>在范围响应中，<code>Content-Range</code> 头部标志指示出了该数据块的偏移量和数据块的长度。</p>
<h3 id="host-头"> Host 头</h3>
<p>域名系统（DNS）允许多个主机名绑定到同一个IP地址上，通过 host 头的域名，可以访问到同一台服务器上的不同应用。</p>
<div><pre><code><span><span>GET</span> <span>/home.html</span> <span>HTTP/1.1</span></span>
<span><span>Host</span><span>:</span> <span>example1.org</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="http-2"> HTTP/2</h2>
<p>HTTP/2 协议是基于 HTTPS 的，所以 HTTP/2 的安全性也是有保障的。</p>
<ol>
<li>头部压缩</li>
<li>二进制格式</li>
<li>数据流</li>
<li>多路复用</li>
<li>服务器推送</li>
</ol>
<p><img src="./README.assets/25-HTTP2.png" alt="HTT/1 ~ HTTP/2" loading="lazy"></p>
<h3 id="头部压缩"> 头部压缩</h3>
<p>如果你同时发出多个请求，他们的头是一样的或是相似的，那么，协议会帮你消除重复的部分。</p>
<p>这就是所谓的 <code>HPACK</code> 算法：在客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就提高速度了。</p>
<h3 id="二进制格式"> 二进制格式</h3>
<p>HTTP/2 不再像 HTTP/1.1 里的纯文本形式的报文，而是全面采用了 <strong>二进制格式</strong>，头信息和数据体都是二进制，并且统称为帧（frame）：「头信息帧（Headers Frame）」和「数据帧（Data Frame）」。</p>
<p>接收方收到报文后，无需再将明文的报文转成二进制，而是直接解析二进制报文，提升了数据传输的效率。</p>
<h3 id="数据流"> 数据流</h3>
<p>HTTP/2 的数据包不是按顺序发送的，同一个连接里面连续的数据包，可能属于不同的回应。因此，必须要对数据包做标记，指出它属于哪个回应。</p>
<p>在 HTTP/2 中每个请求或相应的所有数据包，称为一个「数据流（<code>Stream</code>）」。每个数据流都标记着一个独一无二的编号（Stream ID）。</p>
<p><mark>在 HTTP/2 连接上，不同 Stream 的帧是可以乱序发送的（因此可以并发不同的 Stream ），因为每个帧的头部会携带 Stream ID 信息，所以接收端可以通过 Stream ID 有序组装成 HTTP 消息，而同一 Stream 内部的帧必须是严格有序的。</mark></p>
<p>客户端和服务器双方都可以建立 Stream， Stream ID 也是有区别的，客户端建立的 Stream 必须是奇数号，而服务器建立的 Stream 必须是偶数号。</p>
<p>客户端还可以指定数据流的优先级。优先级高的请求，服务器就先响应该请求。</p>
<h3 id="多路复用"> 多路复用</h3>
<p>HTTP/2 是可以在一个连接中并发多个请求或回应，而不用按照顺序一一对应。</p>
<p>移除了 HTTP/1.1 中的串行请求，不需要排队等待，也就不会再出现「队头阻塞」问题，降低了延迟，大幅度提高了连接的利用率。</p>
<h3 id="服务器推送"> 服务器推送</h3>
<p>HTTP/2 还在一定程度上改善了传统的「请求 - 应答」工作模式，服务不再是被动地响应，也可以主动向客户端发送消息。</p>
<h2 id="http-3"> HTTP/3</h2>
<p>我直接阿巴阿巴 <a href="https://xiaolincoding.com/network/2_http/http3.html" target="_blank" rel="noopener noreferrer">3.7 HTTP/3 强势来袭 | 小林coding (xiaolincoding.com)</a></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-23T15:29:19.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">keep-alive</title>
    <id>https://notes.lllllan.cn/cs-basic/network/http/keep-alive/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/http/keep-alive/"/>
    <updated>2022-04-25T01:10:50.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/224595048" target="_blank" rel="noopener noreferrer">HTTP keep-alive和TCP keepalive的区别，你了解吗？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/wangjq19920210/p/8440824.html" target="_blank" rel="noopener noreferrer">keepalive 原理讲解 - salami-china - 博客园 (cnblogs.com)</a></li>
</ul>
</div>
<h2 id="tcp-keepalive"> TCP keepalive</h2>
<p>keepalive 是 TCP 连接的双方，在长时间未通信的时候确认对方还活着的保活机制。</p>
<p>开启保活机制的一段，每隔一段时间会向灵一段发送一个保活探测报文。</p>
<ul>
<li>如果能够收到响应报文，证明对方还活着。重置计时器，过段时间继续发送。</li>
<li>如果不能接收到响应报文，可能是因为网络等诸多原因。隔断时间重新发送。</li>
<li>如果一直接收不到响应报文，说明连接不可达。</li>
</ul>
<p><img src="./README.assets/v2-837ba2a1eb7beb10c036ca468f7db69f_720w.jpg" alt="img" loading="lazy"></p>
<h2 id="http-keep-alive"> HTTP keep-alive</h2>
<p>keep-alive 是 HTTP 建立长连接的一个机制。</p>
<p>在 HTTP/1.0 的时候，每次请求资源，都会建立一次 TCP 连接，服务器响应之后将会断开连接。下次再有资源的请求，将重新建立连接。</p>
<p>为了减少建立连接的消耗，HTTP/1.1 引入了 keep-alive，在不主动断开的情况下，将会一直保持 TCP 连接。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-25T01:10:50.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">OSI 和 TCP/IP 网络分层模型详解</title>
    <id>https://notes.lllllan.cn/cs-basic/network/osi&amp;tcp/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/osi&amp;tcp/"/>
    <updated>2022-04-20T07:36:25.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自以下文章，略有改动。</p>
<ul>
<li><a href="https://javaguide.cn/cs-basics/network/osi&amp;tcp-ip-model.html" target="_blank" rel="noopener noreferrer">OSI 和 TCP/IP 网络分层模型详解（基础） | JavaGuide</a></li>
</ul>
</div>
<h2 id="osi-七层模型"> OSI 七层模型</h2>
<p><strong>OSI 七层模型</strong> 是国际标准化组织提出一个网络分层模型，其大体结构以及每一层提供的功能如下图所示：</p>
<p><img src="./README.assets/osi七层模型.png" alt="osi七层模型" loading="lazy"></p>
<p>每一层都专注做一件事情，并且每一层都需要使用下一层提供的功能比如传输层需要使用网络层提供的路由和寻址功能，这样传输层才知道把数据传输到哪里去。</p>
<p><strong>OSI 的七层体系结构概念清楚，理论也很完整，但是它比较复杂而且不实用，而且有些功能在多个层中重复出现。</strong></p>
<h2 id="tcp-ip-四层模型"> TCP/IP 四层模型</h2>
<p><strong>TCP/IP 四层模型</strong> 是目前被广泛采用的一种模型，我们可以将 TCP / IP 模型看作是 OSI 七层模型的精简版本，由以下 4 层组成：</p>
<ol>
<li>应用层</li>
<li>传输层</li>
<li>网络层</li>
<li>网络接口层</li>
</ol>
<blockquote>
<p>我们并不能将 TCP/IP 四层模型 和 OSI 七层模型完全精确地匹配起来，不过可以简单将两者对应起来，如下图所示：</p>
</blockquote>
<p><img src="./README.assets/TCP-IP-4-model.6ae180f1.png" alt="TCP-IP-4-model" loading="lazy"></p>
<h3 id="应用层-application-layer"> 应用层（Application layer）</h3>
<p>应用层位于传输层之上， <mark>主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输</mark> 。 我们把应用层交互的数据单元称为报文。</p>
<p><img src="./README.assets/5971-2-7I1-20220111095024771-20220111201807861.png" alt="img" loading="lazy"></p>
<p>应用层协议定义了网络通信规则，对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如支持 Web 应用的 HTTP 协议，支持电子邮件的 SMTP 协议等等。</p>
<p><img src="./README.assets/application-layer.a60c27d2.png" alt="application-layer" loading="lazy"></p>
<h3 id="传输层-transport-layer"> 传输层（Transport layer）</h3>
<p>传输层的主要任务就是 <mark>负责向两台终端设备进程之间的通信提供通用的数据传输服务</mark> 。 应用进程利用该服务传送应用层报文。【通用的】是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。</p>
<p>运输层主要使用以下两种协议：</p>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmisson Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<p><img src="./README.assets/transport-layer.3d064ed5.png" alt="transport-layer" loading="lazy"></p>
<h3 id="网络层-network-layer"> 网络层（Network layer）</h3>
<p><mark>网络层负责为分组交换网上的不同主机提供通信服务</mark> 。 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 IP 协议，因此分组也叫 IP 数据报，简称数据报。</p>
<p><mark>网络层的还有一个任务就是选择合适的路由，使源主机运输层所传下来的分株，能通过网络层中的路由器找到目的主机。</mark></p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Intert Prococol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p>
<p><img src="./README.assets/nerwork-layer.688b8282.png" alt="img" loading="lazy"></p>
<h3 id="网络接口层-network-interface-layer"> 网络接口层（Network interface layer）</h3>
<p>我们可以把网络接口层看作是数据链路层和物理层的合体。</p>
<ol>
<li>数据链路层(data link layer)通常简称为链路层（ 两台主机之间的数据传输，总是在一段一段的链路上传送的）。 <mark>数据链路层的作用是将网络层交下来的 IP 数据报组装成帧，在两个相邻节点间的链路上传送帧。</mark> 每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</li>
<li><mark>物理层的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异</mark></li>
</ol>
<p><img src="./README.assets/network-interface-layer.c1c4efcc.png" alt="network-interface-layer" loading="lazy"></p>
<h2 id="为什么网络要分层"> 为什么网络要分层？</h2>
<p>复杂的系统需要分层，因为每一层都需要专注于一类事情。网络分层的原因也是一样，每一层只专注于做一类事情。</p>
<ol>
<li><strong>各层之间相互独立</strong>：各层之间相互独立，各层之间不需要关心其他层是如何实现的，只需要知道自己如何调用下层提供好的功能就可以了（可以简单理解为接口调用）<strong>。这个和我们对开发时系统进行分层是一个道理。</strong></li>
<li><strong>提高了整体灵活性</strong> ：每一层都可以使用最适合的技术来实现，你只需要保证你提供的功能以及暴露的接口的规则没有改变就行了。<strong>这个和我们平时开发系统的时候要求的高内聚、低耦合的原则也是可以对应上的。</strong></li>
<li><strong>大问题化小</strong> ： 分层可以将复杂的网络间题分解为许多比较小的、界线比较清晰简单的小问题来处理和解决。这样使得复杂的计算机网络系统变得易于设计，实现和标准化。 <strong>这个和我们平时开发的时候，一般会将系统功能分解，然后将复杂的问题分解为容易理解的更小的问题是相对应的，这些较小的问题具有更好的边界（目标和接口）定义。</strong></li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-20T07:36:25.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">三次握手</title>
    <id>https://notes.lllllan.cn/cs-basic/network/tcp/3-handshake/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/tcp/3-handshake/"/>
    <updated>2022-04-23T15:04:20.000Z</updated>
    <content type="html"><![CDATA[<p>三次握手：为了对每次发送的数据量进行跟踪与协商，<strong>确保数据段的发送和接收同步</strong>，根据所接收到的数据量而确认数据发送、接收完毕后何时撤销联系，并建立虚连接。</p>
<p>所谓三次握手(Three-way Handshake)，是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。</p>
<h2 id="tcp-三次握手漫画图解"> TCP 三次握手漫画图解</h2>
<ul>
<li>客户端 → 发送带有 SYN 标志的数据包 → 服务端</li>
<li>服务端 → 发送带有 SYN/ACK 标志的数据包 → 客户端</li>
<li>客户端 → 发送带有带有 ACK 标志的数据包 → 服务端</li>
</ul>
<p><img src="./README.assets/三次握手.png" alt="TCP三次握手" loading="lazy"></p>
<h2 id="三次握手流程"> 三次握手流程</h2>
<blockquote>
<p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p>
</blockquote>
<ol>
<li><strong>服务器进入监听状态 - LISTEN</strong>：TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li><strong>客户发送连接请求 - SYN-SENT</strong>：TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位 <code>SYN = 1</code>，同时选择一个初始序列号 <code>seq = x</code> ，此时，TCP客户端进程进入了 <code>SYN-SENT</code>（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li><strong>服务器返回确认报文 - SYN-RCVD</strong>：TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <code>ACK = 1，SYN = 1</code>，确认号是 <code>ack = x+1</code>，同时也要为自己初始化一个序列号 <code>seq = y</code>，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li><strong>客户再次发送确认 - ESTABLSHED</strong>：TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<code>ACK = 1，ack = y + 1</code>，自己的序列号 <code>seq = x + 1</code>，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li><strong>开始通信 - ESTABLISHED</strong>：当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<div>
<table>
<thead>
<tr>
<th style="text-align:center">客户端</th>
<th style="text-align:center">服务器</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">创建传输控制块TCB<br/>进入监听状态 - LISTEN</td>
</tr>
<tr>
<td style="text-align:center">创建传输控制块TCB<br/>发送请求报文，<code>SYN=1, seq=x</code><br/>进入同步已经发送状态 - SYN-SENT</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">发送确认报文，<code>ACK=1, SYN=1, ack=x+1, seq=y</code><br/>进入同步收到状态 - SYN-RCVD</td>
</tr>
<tr>
<td style="text-align:center">发送确认把稳，<code>ACK=1, ack=y+1, seq=x+1</code><br/>进入已建立连接状态 - ESTABLISHED</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">进入已建立连接状态 - ESTABLISHED</td>
</tr>
</tbody>
</table>
<p><img src="./README.assets/0c9f470819684156cfdc27c682db4def.png" alt="img" loading="lazy"></p>
</div>
<h2 id="为什么要三次握手-⭐"> 为什么要三次握手 ⭐</h2>
<p><strong>三次握手的目的是建立可靠的通信信道，就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<ol>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<h2 id="第二次握手传回了ack-为什么还要传syn"> 第二次握手传回了ACK，为什么还要传SYN？</h2>
<blockquote>
<p>发送ACK是对客户端请求的确认。</p>
<p>回传SYN是服务器对客户端的连接请求。</p>
</blockquote>
<p><strong>SYN 同步序列编号</strong>(Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递</p>
<h2 id="为什么还需要第三次握手-⭐"> 为什么还需要第三次握手？⭐</h2>
<p><strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h2 id="tcp-三次握手期间的异常"> TCP 三次握手期间的异常</h2>
<h3 id="第一次握手丢失"> 第一次握手丢失</h3>
<p>当客户端想和服务端建立 TCP 连接的时候，首先第一个发的就是 SYN 报文，然后进入到 <code>SYN-SENT</code> 状态。</p>
<p>如果这份报文丢失了，服务端就接收不到，自然就不会向客户端返回确认报文；而客户端迟迟都接收不到确认报文，就会触发超时重传机制。</p>
<p>不同版本的操作系统可能超时时间不同，这个超时时间是写死在内核里的。当客户端在 1 秒后没收到服务端的 SYN-ACK 报文后，客户端就会重发 SYN 报文。</p>
<p>在 Linux 里，客户端的 SYN 报文最大重传次数由 <code>tcp_syn_retries</code> 内核参数控制，这个参数是可以自定义的，默认值一般是 5。</p>
<p>通常，第一次超时重传是在 1 秒后，第二次超时重传是在 2 秒，第三次超时重传是在 4 秒后，第四次超时重传是在 8 秒后，第五次是在超时重传 16 秒后。没错，每次超时的时间是上一次的 2 倍。</p>
<p>当第五次超时重传后，会继续等待 32 秒，如果服务端仍然没有回应 ACK，客户端就不再发送 SYN 包，然后断开 TCP 连接。</p>
<p>所以，总耗时是 1+2+4+8+16+32=63 秒，大约 1 分钟左右。</p>
<h3 id="第二次握手丢失"> 第二次握手丢失</h3>
<p>当服务端收到客户端的第一次握手后，就会回 <code>SYN-ACK</code> 报文给客户端，这个就是第二次握手，此时服务端会进入 <code>SYN-RCVD</code> 状态。</p>
<p>第二次握手的 SYN-ACK 报文其实有两个目的 ：</p>
<ul>
<li>ACK， 是对第一次握手的确认报文</li>
<li>SYN，是服务端发起建立 TCP 连接的报文</li>
</ul>
<p>因为第二次握手报文里是包含对客户端的第一次握手的 ACK 确认报文，所以，如果客户端迟迟没有收到第二次握手，那么客户端就觉得可能自己的 SYN 报文（第一次握手）丢失了，于是<strong>客户端就会触发超时重传机制，重传 SYN 报文</strong>。</p>
<p>因为第二次握手中包含服务端的 SYN 报文，所以当客户端收到后，需要给服务端发送 ACK 确认报文（第三次握手），服务端才会认为该 SYN 报文被客户端收到了。那么，如果第二次握手丢失了，服务端就收不到第三次握手，于是<strong>服务端这边会触发超时重传机制，重传 SYN-ACK 报文</strong>。</p>
<p>因此，当第二次握手丢失了，客户端和服务端都会重传：</p>
<ul>
<li>客户端会重传 <code>SYN</code> 报文，也就是第一次握手，最大重传次数由 <code>tcp_syn_retries</code> 内核参数决定。；</li>
<li>服务端会重传 <code>SYN-ACK</code> 报文，也就是第二次握手，最大重传次数由 <code>tcp_synack_retries</code> 内核参数决定。</li>
</ul>
<h3 id="第三次握手丢失"> 第三次握手丢失</h3>
<p>客户端收到服务端的 SYN-ACK 报文后，就会给服务端回一个 ACK 报文，也就是第三次握手，此时客户端状态进入到 ESTABLISH 状态。</p>
<p>因为这个第三次握手的 ACK 是对第二次握手的 SYN 的确认报文，所以当第三次握手丢失了，如果服务端那一方迟迟收不到这个确认报文，就会触发超时重传机制，重传 SYN-ACK 报文，直到收到第三次握手，或者达到最大重传次数。</p>
<p>注意，ACK 报文是不会有重传的，当 ACK 丢失了，就由对方重传对应的报文。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-23T15:04:20.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">四次挥手</title>
    <id>https://notes.lllllan.cn/cs-basic/network/tcp/4-wave/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/tcp/4-wave/"/>
    <updated>2022-04-23T15:04:20.000Z</updated>
    <content type="html"><![CDATA[<h2 id="为什么要四次挥手"> 为什么要四次挥手</h2>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p><img src="./README.assets/TCP四次挥手.png" alt="TCP四次挥手" loading="lazy"></p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h2 id="四次挥手流程"> 四次挥手流程</h2>
<blockquote>
<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，<strong>然后客户端主动关闭，服务器被动关闭</strong>。</p>
</blockquote>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<code>FIN = 1</code>，其序列号为 <code>seq = u</code>（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入 <code>FIN-WAIT-1</code>（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，<code>ACK = 1，ack = u + 1</code>，并且带上自己的序列号 <code>seq = v</code>，此时，服务端就进入了 <code>CLOSE-WAIT</code>（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入 <code>FIN-WAIT-2</code>（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<code>FIN = 1，ack = u+ 1</code>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的序列号为 <code>seq = w</code>，此时，服务器就进入了 <code>LAST-ACK</code>（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，<code>ACK = 1，ack = w + 1</code>，而自己的序列号是<code>seq = u + 1</code>，此时，客户端就进入了TIME-WAIT（时间等待）状态。<span style="color:red"><strong>注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</strong></span>。</li>
<li>服务器只要收到了客户端发出的确认，立即进入 <code>CLOSED</code> 状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<p><img src="./README.assets/format,png.png" alt="四次挥手" loading="lazy"></p>
<h2 id="为什么客户端最后还要等待2msl-⭐"> 为什么客户端最后还要等待2MSL？⭐</h2>
<p>MSL（Maximum Segment Lifetime）（最长报文段寿命），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了 <code>FIN + ACK</code> 报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h2 id="为什么建立连接是三次握手-关闭连接确是四次挥手呢"> 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h2>
<p>客户端和服务端未必能同时结束通信，存在一方发送完全部数据、而另一方还有数据要继续发送的情况。所以双方都必须分别发送连接释放报文和ACK</p>
<h2 id="如果已经建立了连接-但是客户端突然出现故障了怎么办"> 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h2>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-23T15:04:20.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">TCP可靠传输</title>
    <id>https://notes.lllllan.cn/cs-basic/network/tcp/tcp-reliable-transmission/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/tcp/tcp-reliable-transmission/"/>
    <updated>2022-04-25T02:32:58.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://blog.csdn.net/liuchenxia8/article/details/80428157" target="_blank" rel="noopener noreferrer">网络基础：TCP协议-如何保证传输可靠性_ricardoleo的博客-CSDN博客_tcp如何保证可靠传输</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/112317245" target="_blank" rel="noopener noreferrer">TCP的可靠性传输是如何保证的 - 知乎 (zhihu.com)</a></li>
<li><a href="https://www.cnblogs.com/tuyang1129/p/12439862.html" target="_blank" rel="noopener noreferrer">计算机网络——TCP的拥塞控制（超详细） - 特务依昂 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://www.cnblogs.com/hongdada/p/11206679.html" target="_blank" rel="noopener noreferrer">TCP拥塞避免 - hongdada - 博客园 (cnblogs.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_feature.html" target="_blank" rel="noopener noreferrer">4.2 TCP 重传、滑动窗口、流量控制、拥塞控制 | 小林coding (xiaolincoding.com)</a></li>
</ul>
</div>
<ol>
<li>连接管理</li>
<li>校验和</li>
<li>序列号/确认应答</li>
<li>超时重传</li>
<li>滑动窗口/流量控制</li>
<li>拥塞控制</li>
</ol>
<h2 id="连接管理"> 连接管理</h2>
<p>三次握手和四次挥手，保证可靠的连接</p>
<h2 id="校验和"> 校验和</h2>
<p>通过检验和的方式，接收端可以检测出来数据是否有差错和异常，假如有差错就会直接丢弃TCP段，重新发送。</p>
<h2 id="序列号-确认应答"> 序列号/确认应答</h2>
<p>序列号：TCP传输时将每个字节的数据都进行了编号。
确认应答：TCP传输的过程中，每次接收方收到数据后，都会对传输方进行确认应答。也就是发送ACK报文。这个ACK报文当中带有对应的确认序列号，告诉发送方，接收到了哪些数据，下一次的数据从哪里发。</p>
<p><img src="./readme.assets/70.png" alt="这里写图片描述" loading="lazy"></p>
<h2 id="重传机制"> 重传机制</h2>
<h3 id="超时重传"> 超时重传</h3>
<p>在进行TCP传输时，由于确认应答与序列号机制，也就是说发送方发送一部分数据后，都会等待接收方发送的 ACK 报文，并解析 ACK 报文，判断数据是否传输成功。如果发送方发送完数据后，迟迟没有等到接收方的 ACK 报文，原因可能有两点：</p>
<ol>
<li>数据在传输过程中由于网络原因等直接全体丢包，接收方根本没有接收到。</li>
<li>接收方接收到了响应的数据，但是发送的ACK报文响应却由于网络原因丢包了。</li>
</ol>
<p><img src="./readme.assets/5.jpg" alt="超时重传的两种情况" loading="lazy"></p>
<p>只要发送方在规定时间内没有接收到对方的 ACK 报文，就会认为对方没有接收到数据，需要重新发送。</p>
<ol>
<li>如果之后能收到对方的 ACK 报文，则进行下一步的发送</li>
<li>如果重复几次之后仍然不能收到回复，就认为 TCP 连接失效了，会关闭连接。</li>
</ol>
<div><p>超时时间</p>
<ul>
<li>RTT，Round-Trip Time 往返时延。数据从网络一端发送到另一端、并且得到响应所需要的时间。</li>
<li>RTO，Retransmission Timeout 超时重传时间。</li>
</ul>
<p><img src="./readme.assets/7.jpg" alt="超时时间较长与较短" loading="lazy"></p>
<ul>
<li>当超时时间 <strong>RTO 较大</strong>时，重发就慢，丢了老半天才重发，没有效率，性能差；</li>
<li>当超时时间 <strong>RTO 较小</strong>时，会导致可能并没有丢就重发，于是重发的就快，会增加网络拥塞，导致更多的超时，更多的超时导致更多的重发。</li>
</ul>
<p><mark>超时重传时间 RTO 的值应该略大于报文往返 RTT 的值</mark></p>
</div>
<h3 id="快速重传"> 快速重传</h3>
<p>当发送方连续收到三个 ACK 包（<code>ack = 2</code>）的时候，就知道有数据包（<code>seq = 2</code>）丢失了，就会在定时器国企之间，直接重传该包。</p>
<blockquote>
<p>超时重传，是为了保证接收方能接收到数据，设定超时时间是防止发生网络拥塞。</p>
<p>而当连续收到三个相同的 ACK 包时，就可以认为，网络拥塞已经好转了，并且接收方已经有段时间没有收到数据包了，可以立刻重传。</p>
</blockquote>
<p><img src="./readme.assets/10.jpg" alt="快速重传机制" loading="lazy"></p>
<h2 id="滑动窗口-流量控制"> 滑动窗口/流量控制</h2>
<blockquote>
<p>滑动窗口就是维护了一个缓冲区。</p>
</blockquote>
<p>发送方可以连续发送一个缓冲区能够接纳的数据，而不用每发送一个包就等待一个响应，从而提升了效率。</p>
<p>但接收方不是一直都能接收那么多的数据，因此 TCP 双方都有一个缓冲区，接收方在返回 ACK 包的时候，附带窗口字段向发送方确认窗口大小，从而约束发送方的发送速率。</p>
<p><mark>窗口大小是由接收端告诉发送端自己还有多少缓冲区可以接收数据</mark></p>
<h3 id="收缩窗口"> 收缩窗口</h3>
<p>滑动窗口是一个逻辑上的概念，窗口大小也是由接收方告知发送方的，发送方会根据窗口大小来决定发送多少数据。</p>
<p>接收方的缓冲区就是一个真实存在的、物理意义上的滑动窗口，接收方接收到的数据会暂时存放在缓冲区中，等到程序需要或者处理得过来的时候会过来取数据。</p>
<p>操作系统在繁忙的时候，可能会缩减缓冲区的大小，如果这时候发送方不知道缓冲区的变化，继续发送大量的数据，在超出接收方的承受范围的时候可能会直接丢弃数据包。</p>
<p>所以一般需要 <mark>先通过 ACK 包告知发送方滑动窗口的收缩，过段时间再缩减缓区的大小，避免出现丢包</mark></p>
<h3 id="窗口关闭"> 窗口关闭</h3>
<p>如果窗口大小为零，就会阻止发送方发送数据。</p>
<p>如果这个时候接收方在返回 ACK 包（携带滑动窗口变大的信息）的时候，发生了数据包丢失。发送方仍然认为窗口是关闭的，不会发送数据，继而造成了【死锁】</p>
<p><img src="./readme.assets/24.jpg" alt="窗口关闭潜在的危险" loading="lazy"></p>
<p>TCP 会定时发送一个 <mark>窗口探测报文</mark> ，如果能收到回复就能及时知道滑动窗口的大小，如果长时间得不到回复，就会断开这次 TCP 连接。</p>
<h3 id="糊涂窗口综合症"> 糊涂窗口综合症</h3>
<p>只要窗口大小不为零，发送方就会义无反顾地继续发送数据。但是 TCP + IP 的头部就占了 40 个字节，当窗口比较小的时候，就使得数据的发送不太划算。</p>
<ul>
<li>让接收方不通告小窗口给发送方</li>
<li>让发送方避免发送小数据</li>
</ul>
<h2 id="拥塞控制"> 拥塞控制</h2>
<p>如果网络非常拥堵，此时再发送数据就会加重网络负担，那么发送的数据段很可能超过了最大生存时间也没有到达接收方，就会产生丢包问题。</p>
<p>拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>
<ul>
<li><strong>MSS</strong>：最大报文段长度，<code>TCP</code> 双方发送的报文段中，包含的数据部分的最大字节数；</li>
<li><strong>cwnd</strong>：拥塞窗口，<code>TCP</code> 发送但还没有得到确认的报文的序号都在这个区间；</li>
<li><strong>RTT</strong>：往返时间，发送方发送一个报文，到接收这个报文的确认报文所经历的时间；</li>
<li><strong>ssthresh</strong>：慢启动阈值，慢启动阶段，若 <code>cwnd</code> 的大小达到这个值，将转换到拥塞避免模式；</li>
</ul>
<h3 id="慢启动"> 慢启动</h3>
<p>慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。</p>
<p>慢开始算法的思路就是， <mark>不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是说由小到大逐渐增加拥塞窗口的大小</mark></p>
<p><img src="./readme.assets/image-20220425102616227.png" alt="image-20220425102616227" loading="lazy"></p>
<h3 id="拥塞避免"> 拥塞避免</h3>
<p>当拥塞窗口增长到一定值，到达了设定的阈值「慢启动门限 <code>ssthresh</code>」的时候，就认为大概率快要发生网络拥塞了，这时候就要减缓一下窗口增长的速度。</p>
<p><mark>拥塞避免算法让拥塞窗口缓慢增长，即每经过一个往返时间RTT就把发送方的拥塞窗口 cwnd 加 1，而不是加倍。</mark> 这样拥塞窗口按线性规律缓慢增长。</p>
<p>无论是在 <strong>慢开始阶段</strong> 还是在 <strong>拥塞避免阶段</strong>，只要发送方判断网络出现拥塞（其根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理），就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。</p>
<p><img src="./readme.assets/28.jpg" alt="拥塞避免" loading="lazy"></p>
<h3 id="拥塞发生"> 拥塞发生</h3>
<p>当网络出现拥塞，也就是会发生数据包重传，重传机制主要有两种：</p>
<ul>
<li>超时重传</li>
<li>快速重传</li>
</ul>
<p>接着，就重新开始慢启动，慢启动是会突然减少数据流的。</p>
<p><img src="./readme.assets/image-20220425102858714.png" alt="image-20220425102858714" loading="lazy"></p>
<h3 id="快速恢复"> 快速恢复</h3>
<p>快速重传和快速恢复算法一般同时使用，快速恢复算法是认为，你还能收到 3 个重复 ACK 说明网络也不那么糟糕，所以没有必要像 <code>RTO</code> 超时那么强烈。</p>
<p>当发生网络拥塞的时候，没必要重新开始「慢启动」，而是缩小拥塞窗口的和慢启动门限的大小</p>
<ul>
<li>拥塞窗口 <code>cwnd = ssthresh + 3</code> （ 3 的意思是确认有 3 个数据包被收到了）；</li>
<li>重传丢失的数据包；</li>
<li>如果再收到重复的 ACK，那么 cwnd 增加 1；</li>
<li>如果收到新数据的 ACK 后，把 cwnd 设置为第一步中的 ssthresh 的值，原因是该 ACK 确认了新的数据，说明从 duplicated ACK 时的数据都已收到，该恢复过程已经结束，可以回到恢复之前的状态了，也即再次进入拥塞避免状态；</li>
</ul>
<p><img src="./readme.assets/443934-20190718132020300-1269239957.6f2447b1.png" alt="img" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-25T01:10:50.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">操作系统</title>
    <id>https://notes.lllllan.cn/cs-basic/os/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/"/>
    <updated>2022-04-21T12:44:44.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/home.html#%E5%BF%85%E7%9C%8B%E4%B8%93%E6%A0%8F" target="_blank" rel="noopener noreferrer">JavaGuide（Java学习&amp;&amp;面试指南） | JavaGuide</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/105945721" target="_blank" rel="noopener noreferrer">什么是操作系统？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://juejin.cn/post/6942686874301857800#heading-1" target="_blank" rel="noopener noreferrer">2021-Java后端工程师必会知识点-(操作系统) - 掘金 (juejin.cn)</a></li>
<li><a href="https://blog.51cto.com/luminous/1832114" target="_blank" rel="noopener noreferrer">细说select、poll和epoll之间的区别与优缺点_七月朔风的技术博客_51CTO博客</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/80672073" target="_blank" rel="noopener noreferrer">程序优化：CPU缓存基础知识 - 知乎 (zhihu.com)</a></li>
</ul>
</div>
<h2 id="操作系统基础"> 操作系统基础</h2>
<p><a href="https://zhuanlan.zhihu.com/p/105945721" target="_blank" rel="noopener noreferrer">什么是操作系统？ - 知乎 (zhihu.com)</a></p>
<p><strong>操作系统(Operation System, OS) 是指控制和管理整个计算机系统的硬件和软件资源的系统软件。</strong></p>
<h3 id="系统调用"> 系统调用</h3>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/1/3/#_2-3-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%A4%84%E7%90%86%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener noreferrer">操作系统运行环境 | lllllan</a></p>
<p>用户程序通过调用操作系统提供的一些接口，去只能在内核态运行的子程序。</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
<h3 id="硬链接和软链接"> 硬链接和软链接</h3>
<ul>
<li>硬链接就是在目录下创建一个条目，记录着文件名与 <code>inode</code> 编号，这个 <code>inode</code> 就是源文件的 <code>inode</code>。删除任意一个条目，文件还是存在，只要引用数量不为 <code>0</code>。但是硬链接有限制，它不能跨越文件系统，也不能对目录进行链接。</li>
<li>符号链接文件保存着源文件所在的绝对路径，在读取时会定位到源文件上，可以理解为 <code>Windows</code> 的快捷方式。当源文件被删除了，链接文件就打不开了。因为记录的是路径，所以可以为目录建立符号链接。</li>
</ul>
<h3 id="中断的处理过程"> 中断的处理过程</h3>
<ol>
<li>保护现场：将当前执行程序的相关数据保存在寄存器中，然后入栈。</li>
<li>开中断：以便执行中断时能响应较高级别的中断请求。</li>
<li>中断处理</li>
<li>关中断：保证恢复现场时不被新中断打扰</li>
<li>恢复现场：从堆栈中按序取出程序数据，恢复中断前的执行状态。</li>
</ol>
<h3 id="中断和轮询"> 中断和轮询</h3>
<ul>
<li>轮询：CPU对<strong>特定设备</strong>轮流询问。中断：通过<strong>特定事件</strong>提醒CPU。</li>
<li>轮询：效率低等待时间长，CPU利用率不高。中断：容易遗漏问题，CPU利用率不高。</li>
</ul>
<h3 id="用户态切换到内核态-★"> 用户态切换到内核态 ★</h3>
<p>三种方式：</p>
<ol>
<li>系统调用。用户进程主动要求切换到内核态的一种方式</li>
<li>异常。程序运行过程遇到了事先不可知的异常，转由内核相关程序来处理</li>
<li>外围设备的中断。</li>
</ol>
<h2 id="虚拟内存"> 虚拟内存</h2>
<blockquote>
<p>虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能
——维基百科</p>
</blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/96098896" target="_blank" rel="noopener noreferrer">如何理解虚拟内存 - 知乎 (zhihu.com)</a></p>
<p>虚拟内存就是说，让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。虚拟内存使用部分加载的技术，让一个进程或者资源的某些页面加载进内存，从而能够加载更多的进程，甚至能加载比内存大的进程，这样看起来好像内存变大了，这部分内存其实包含了磁盘或者硬盘，并且就叫做虚拟内存。</p>
<h3 id="虚拟内存的技术实现"> 虚拟内存的技术实现</h3>
<ol>
<li>请求分页存储管理</li>
<li>请求分段存储管理</li>
<li>请求段页式存储管理</li>
</ol>
<div><p>请求分页和分页存储管理的区别</p>
<p>请求分页建立在分页管理之上。他们的根本区别是是否将程序所需要的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。请求分页不要求将作业全部地址同时装入主存，基于这一点，请求分页可以提供虚存，而分页管理不能。</p>
</div>
<p>不管是上面哪种实现方式，我们一般都需要：</p>
<ol>
<li>一定容量的内存和外存：在载入程序的时候，只需要将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了。</li>
<li><strong>缺页中断：</strong> 如果需要执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序</li>
<li><strong>虚拟地址空间：</strong> 逻辑地址到物理地址的变换</li>
</ol>
<h3 id="页面置换算法"> 页面置换算法</h3>
<p><strong>缺页中断：</strong> 要访问的页不在主存中，需要操作系统将其调入主存再进行访问。在这个时候，被内存映射的文件实际上称为了一个分页交换文件。</p>
<p>当发生缺页中断时，如果当前内存中没有空闲的页面，操作系统就必须在内存中选择一个页面移出内存，以便为即将调入的页面让出空间。用来选择淘汰哪一页的规则就叫页面置换算法。</p>
<ul>
<li><strong>OPT 最佳页面置换算法：</strong> 该算法所选择的被淘汰的页面将是以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。</li>
<li><strong>FIFO 先进先出页页面置换算法：</strong> 总是淘汰最先进入内存的页面，即选择在内存中驻留时间最久的页面进行淘汰</li>
<li><strong>LRU 最近最久未使用页面置换算法：</strong> LRU算法赋予每个页面一个访问字段，用来记录一个页面自上次被访问依赖所经历的时间T，当需淘汰一个页面时，选择现有页面中其 T 值最大的，即最近最久未使用的页面予以淘汰</li>
<li><strong>LFU 最少使用页面置换算法：</strong> 选择在之前时期内使用最少的页面淘汰</li>
</ul>
<h3 id="进程切换后虚拟地址的转换会变慢-★"> 进程切换后虚拟地址的转换会变慢 ★</h3>
<p>进程都有自己的虚拟地址空间，把虚拟地址转换为物理地址需要查找页表，页表查找是一个很慢的过程，因此通常使用 Cache 来缓存常用的地址映射，这样可以加速页表查找，这个 Cache 就是 TLB（translation Lookaside Buffer，TLB本质上就是一个Cache，是用来加速页表查找的）。</p>
<p>由于每个进程都有自己的虚拟地址空间，那么显然每个进程都有自己的页表，那么<strong>当进程切换后页表也要进行切换，页表切换后TLB就失效了</strong>，Cache 失效导致命中率降低，那么虚拟地址转换为物理地址就会变慢，表现出来的就是程序运行会变慢，而线程切换则不会导致 TLB 失效，因为线程无需切换地址空间，因此我们通常说线程切换要比较进程切换块，原因就在这里。</p>
<h3 id="缺页中断处理流程"> 缺页中断处理流程</h3>
<ul>
<li>保护 CPU 环境</li>
<li>分析中断原因</li>
<li>转入缺页中断处理程序</li>
<li>恢复 CPU 环境</li>
</ul>
<h2 id="io管理"> IO管理</h2>
<h3 id="io多路复用"> IO多路复用</h3>
<p><a href="http://blog.lllllan.cn/cs-basic/os/def/multiplexing/" target="_blank" rel="noopener noreferrer">IO 多路复用 | lllllan</a></p>
<h3 id="缓冲区"> 缓冲区</h3>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/5/2/#%E4%BA%8C%E3%80%81%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E4%B8%8E%E7%BC%93%E5%86%B2%E5%8C%BA" target="_blank" rel="noopener noreferrer">设备独立性软件 | lllllan</a></p>
<p><img src="./README.assets/image-20220409091519840.png" alt="image-20220409091519840" loading="lazy"></p>
<div><p>缓冲区溢出的危害</p>
<p>缓冲区溢出是指当计算机向缓冲区填充数据时超出了缓冲区本身的容量，溢出的数据覆盖在合法数据上。</p>
<p>危害有以下两点：</p>
<ul>
<li>程序崩溃，导致拒绝服务</li>
<li>跳转并且执行一段恶意代码</li>
</ul>
<p>造成缓冲区溢出的主要原因是程序中没有仔细检查用户输入。</p>
</div>
<h3 id="unix常见的io模型-★"> Unix常见的IO模型 ★</h3>
<p>IO模型的详细说明见：<a href="https://juejin.cn/post/6942686874301857800#heading-13" target="_blank" rel="noopener noreferrer">2021-Java后端工程师必会知识点-(操作系统) - 掘金 (juejin.cn)</a></p>
<p>对于一次IO访问（以read举例），数据会先被拷贝到操作系统内核的缓冲区中，然后才会从操作系统内核的缓冲区拷贝到应用程序的地址空间。所以说，当一个read操作发生时，它会经历两个阶段：</p>
<blockquote>
<ul>
<li>等待数据准备就绪 (Waiting for the data to be ready)</li>
<li>将数据从内核拷贝到进程中 (Copying the data from the kernel to the process)</li>
</ul>
</blockquote>
<p>正式因为这两个阶段，linux系统产生了下面五种网络模式的方案：</p>
<blockquote>
<ul>
<li>阻塞式IO模型(blocking IO model)</li>
<li>非阻塞式IO模型(noblocking IO model)</li>
<li>IO复用式IO模型(IO multiplexing model)</li>
<li>信号驱动式IO模型(signal-driven IO model)</li>
<li>异步IO式IO模型(asynchronous IO model)</li>
</ul>
</blockquote>
<h3 id="select、poll-和-epoll-之间的区别-★"> select、poll 和 epoll 之间的区别 ★</h3>
<p><a href="https://zhuanlan.zhihu.com/p/272891398" target="_blank" rel="noopener noreferrer">一文搞懂select、poll和epoll区别 - 知乎 (zhihu.com)</a>，有代码，看不懂</p>
<p><a href="https://blog.51cto.com/luminous/1832114" target="_blank" rel="noopener noreferrer">细说select、poll和epoll之间的区别与优缺点_七月朔风的技术博客_51CTO博客</a></p>
<p>（1）select：时间复杂度 O(n)</p>
<p>select 仅仅知道有 I/O 事件发生，但并不知道是哪几个流，所以只能无差别轮询所有流，找出能读出数据或者写入数据的流，并对其进行操作。所以 select 具有 O(n) 的无差别轮询复杂度，同时处理的流越多，无差别轮询时间就越长。</p>
<p>（2）poll：时间复杂度 O(n)</p>
<p>poll 本质上和 select 没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个 fd 对应的设备状态， 但是它没有最大连接数的限制，原因是它是基于链表来存储的。</p>
<p>（3）epoll：时间复杂度 O(1)</p>
<p>epoll 可以理解为 event poll，不同于忙轮询和无差别轮询，epoll 会把哪个流发生了怎样的 I/O 事件通知我们。所以说 epoll 实际上是事件驱动（每个事件关联上 fd）的。</p>
<blockquote>
<p>select，poll，epoll 都是 IO 多路复用的机制。I/O 多路复用就是通过一种机制监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），就通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步 I/O 则无需自己负责进行读写，异步 I/O 的实现会负责把数据从内核拷贝到用户空间。</p>
</blockquote>
<ol>
<li>select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll其实也需要调用epoll_wait不断轮询就绪链表，期间也可能多次睡眠和唤醒交替，但是它是设备就绪时，调用回调函数，把就绪fd放入就绪链表中，并唤醒在epoll_wait中进入睡眠的进程。虽然都要睡眠和交替，但是select和poll在“醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间。这就是回调机制带来的性能提升。</li>
<li>select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把current往设备等待队列中挂一次，而epoll只要一次拷贝，而且把current往等待队列上挂也只挂一次（在epoll_wait的开始，注意这里的等待队列并不是设备等待队列，只是一个epoll内部定义的等待队列）。这也能节省不少的开销。</li>
</ol>
<p><img src="./README.assets/wKiom1ecee_SajTcAABB7-ZTUR0253.png" alt="细说select、poll和epoll之间的区别与优缺点_poll" loading="lazy"></p>
<h2 id="文件管理"> 文件管理</h2>
<h3 id="inode"> inode</h3>
<p>硬盘的最小存储单位是扇区(Sector)，块(block)由多个扇区组成。文件数据存储在块中。块的最常见的大小是 4kb，约为 8 个连续的扇区组成（每个扇区存储 512 字节）。一个文件可能会占用多个 block，但是一个块只能存放一个文件。</p>
<p>虽然，我们将文件存储在了块(block)中，但是我们还需要一个空间来存储文件的 元信息 metadata ：如某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等。这种 存储文件元信息的区域就叫 inode，译为索引节点：i（index）+node。 每个文件都有一个 inode，存储文件的元信息。</p>
<p>可以使用 stat 命令可以查看文件的 inode 信息。每个 inode 都有一个号码，Linux/Unix 操作系统不使用文件名来区分文件，而是使用 inode 号码区分不同的文件。</p>
<p>简单来说：inode 就是用来维护某个文件被分成几块、每一块在的地址、文件拥有者，创建时间，权限，大小等信息。</p>
<p>简单总结一下：</p>
<ul>
<li>inode ：记录文件的属性信息，可以使用 stat 命令查看 inode 信息。</li>
<li>block ：实际文件的内容，如果一个文件大于一个块时候，那么将占用多个 block，但是一个块只能存放一个文件。（因为数据是由 inode 指向的，如果有两个文件的数据存放在同一个块中，就会乱套了）</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:03:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">CPU 缓存</title>
    <id>https://notes.lllllan.cn/cs-basic/os/def/cpu-cache/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/def/cpu-cache/"/>
    <updated>2022-04-25T13:14:51.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.cnblogs.com/xiaolincoding/p/13886559.html" target="_blank" rel="noopener noreferrer">10 张图打开 CPU 缓存一致性的大门 - 小林coding - 博客园 (cnblogs.com)</a></li>
</ul>
</div>
<h2 id="cpu-cache"> CPU Cache</h2>
<blockquote>
<p>CPU 和内存的访问性能相差较大，而 CPU Cache 离 CPU 核心相当近，访问速度特别快。为了能够提升读写数据的效率， 基于局部性原理，采用 CPU Cache 来充当 CPU 和内存之间的缓存角色。</p>
</blockquote>
<p>CPU Cache 通常分为三级缓存：L1 Cache、L2 Cache、L3 Cache，级别越低的离 CPU 核心越近，访问速度也快，但是存储容量相对就会越小。</p>
<p><img src="./README.assets/CPU-Cache.png" alt="img" loading="lazy"></p>
<h3 id="缓存行"> 缓存行</h3>
<p>CPU Cache 是由很多个 Cache Line 组成的，CPU Line 是 CPU 从内存读取数据的基本单位，而 CPU Line 是由各种标志（Tag）+ 数据块（Data Block）组成。</p>
<p><img src="./README.assets/Cache的数据结构.png" alt="img" loading="lazy"></p>
<p>事实上，数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。</p>
<h2 id="缓存和内存的一致性"> 缓存和内存的一致性</h2>
<p>数据不光是只有读操作，还有写操作，那么如果数据写入 Cache 之后，内存与 Cache 相对应的数据将会不同，这种情况下 Cache 和内存数据都不一致了，于是我们肯定是要把 Cache 中的数据同步到内存里的。</p>
<h3 id="写直达"> 写直达</h3>
<p>保持内存与 Cache 一致性最简单的方式是，<strong>把数据同时写入内存和 Cache 中</strong>，这种方法称为<strong>写直达（Write Through）</strong>。</p>
<p><img src="./README.assets/写直达.png" alt="img" loading="lazy"></p>
<p>在这个方法里，写入前会先判断数据是否已经在 CPU Cache 里面了：</p>
<ul>
<li>如果数据已经在 Cache 里面，先将数据更新到 Cache 里面，再写入到内存里面；</li>
<li>如果数据没有在 Cache 里面，就直接把数据更新到内存里面。</li>
</ul>
<p><mark>写直达法很直观，也很简单，但是问题明显，无论数据在不在 Cache 里面，每次写操作都会写回到内存，这样写操作将会花费大量的时间，无疑性能会受到很大的影响。</mark></p>
<h3 id="写回"> 写回</h3>
<p>在写回机制中，<strong>当发生写操作时，新的数据仅仅被写入 Cache Block 里，只有当修改过的 Cache Block「被替换」时才需要写到内存中</strong>，减少了数据写回内存的频率，这样便可以提高系统的性能。</p>
<p><img src="./README.assets/写回1.png" alt="img" loading="lazy"></p>
<p>当发生写操作时：</p>
<ul>
<li>如果数据已经在 CPU Cache 里的话，则把数据更新到 CPU Cache 里，同时标记这个 Cache Block 为脏（Dirty）</li>
<li>如果数据所对应的 Cache Block 里存放的是「别的内存地址的数据」的话
<ul>
<li>就要检查这个 Cache Block 里的数据有没有被标记为脏的，如果是脏的话，我们就要把这个 Cache Block 里的数据写回到内存，然后再把当前要写入的数据，写入到这个 Cache Block 里，同时也把它标记为脏的</li>
<li>如果 Cache Block 里面的数据没有被标记为脏，则就直接将数据写入到这个 Cache Block 里，然后再把这个 Cache Block 标记为脏的就好了。</li>
</ul>
</li>
</ul>
<p>只有在缓存不命中，同时数据对应的 Cache 中的 Cache Block 为脏标记的情况下，才会将数据写到内存中，而在缓存命中的情况下，则在写入后 Cache 后，只需把该数据对应的 Cache Block 标记为脏即可，而不用写到内存里。</p>
<p>这样的好处是，如果我们大量的操作都能够命中缓存，那么大部分时间里 CPU 都不需要读写内存，自然性能相比写直达会高很多。</p>
<h2 id="缓存之间的一致性"> 缓存之间的一致性</h2>
<p>现在 CPU 都是多核的，由于 L1/L2 Cache 是多个核心各自独有的，那么会带来多核心的<strong>缓存一致性（Cache Coherence）</strong> 的问题，如果不能保证缓存一致性的问题，就可能造成结果错误。</p>
<ul>
<li>第一点，某个 CPU 核心里的 Cache 数据更新时，必须要传播到其他核心的 Cache，这个称为 <mark>写传播（Wreite Propagation）</mark></li>
<li>第二点，某个 CPU 核心里对数据的操作顺序，必须在其他核心看起来顺序是一样的，这个称为 <mark>事务的串形化（Transaction Serialization）</mark></li>
</ul>
<h3 id="总线嗅探"> 总线嗅探</h3>
<p><mark>某个 CPU 核心对缓存的修改，会通过总线把这个事件通知给其他所有的核心，然后每个 CPU 核心都会监听总线的广播事件。</mark></p>
<p>线嗅探只是保证了某个 CPU 核心的 Cache 更新数据这个事件能被其他 CPU 核心知道，但是并不能保证事务串形化。</p>
<h3 id="mesi协议"> MESI协议</h3>
<p>MESI 协议其实是 4 个状态单词的开头字母缩写，分别是：</p>
<ul>
<li><em>Modified</em>，「已修改」状态就是我们前面提到的脏标记，代表该 Cache Block 上的数据已经被更新过，但是还没有写到内存里。</li>
<li><em>Exclusive</em>，「独占」状态的下数据只存储在一个 CPU 核心的 Cache 里，而其他 CPU 核心的 Cache 没有该数据。并且的数据是干净的。</li>
<li><em>Shared</em>，「共享」状态代表着相同的数据在多个 CPU 核心的 Cache 里都有，并且数据是干净的。</li>
<li><em>Invalidated</em>，「已失效」状态，表示的是这个 Cache Block 里的数据被别的 CPU 核心修改了，这里的数据并不是最新的、已经失效了，不可以读取该状态的数据。</li>
</ul>
<p>举个栗子：</p>
<ol>
<li>当 A 号 CPU 核心从内存读取变量 i 的值，数据被缓存在 A 号 CPU 核心自己的 Cache 里面， <mark>此时其他 CPU 核心的 Cache 没有缓存该数据，于是标记 Cache Line 状态为「独占」，此时其 Cache 中的数据与内存是一致的</mark></li>
<li>然后 B 号 CPU 核心也从内存读取了变量 i 的值，此时会发送消息给其他 CPU 核心，由于 A 号 CPU 核心已经缓存了该数据，所以会把数据返回给 B 号 CPU 核心。在这个时候， A 和 B 核心缓存了相同的数据， <mark>Cache Line 的状态就会变成「共享」，并且其 Cache 中的数据与内存也是一致的</mark></li>
<li>当 A 号 CPU 核心要修改 Cache 中 i 变量的值，发现数据对应的 Cache Line 的状态是共享状态，则要向所有的其他 CPU 核心广播一个请求， <mark>要求先把其他核心的 Cache 中对应的 Cache Line 标记为「无效」状态，然后 A 号 CPU 核心才更新 Cache 里面的数据，同时标记 Cache Line 为「已修改」状态，此时 Cache 中的数据就与内存不一致了</mark></li>
<li>如果 A 号 CPU 核心「继续」修改 Cache 中 i 变量的值，由于此时的 <mark>Cache Line 是「已修改」状态，因此不需要给其他 CPU 核心发送消息，直接更新数据即可</mark></li>
<li>如果 A 号 CPU 核心的 Cache 里的 i 变量对应的 Cache Line 要被「替换」，发现 Cache Line 状态是「已修改」状态，就会在替换前先把数据同步到内存。</li>
<li>如果 B 号 CPU 核心想要修改 Cache 中 i 变量的值，由于此时的 <mark>Cache Line 是「无效」状态，需要从内存中读取数据（因为 A 号 CPU 核心已经把 i 变量替换掉了）</mark></li>
</ol>
<p>当 Cache Line 状态是「已修改」或者「独占」状态时，修改更新其数据不需要发送广播给其他 CPU 核心，这在一定程度上减少了总线带宽压力。</p>
<p>![img](README.assets/ MESI状态转换表格.png)</p>
<h2 id="伪共享"> 伪共享</h2>
<ul>
<li>缓存行，CPU读取数据以行为基本单位</li>
<li>一致性，为了保证多核之间的缓存一致性，在读写某行数据时会让其他核心的缓存行失效</li>
</ul>
<p><mark>多线程同时读写同一个 Cache Line 的不同变量时，导致 CPU Cache 失效的现象称为伪共享</mark></p>
<p>避免伪共享是让一个变量独占一行，浪费一部分空间来提升性能。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-22T06:06:32.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">TCP 常见面试题</title>
    <id>https://notes.lllllan.cn/cs-basic/network/tcp/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/tcp/"/>
    <updated>2022-04-25T07:42:39.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_stream.html" target="_blank" rel="noopener noreferrer">4.6 如何理解是 TCP 面向字节流协议？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/isn_deff.html" target="_blank" rel="noopener noreferrer">4.7 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/challenge_ack.html" target="_blank" rel="noopener noreferrer">4.9 已建立连接的TCP，收到SYN会发生什么？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/out_of_order_fin.html" target="_blank" rel="noopener noreferrer">4.10 四次挥手中收到乱序的 FIN 包会如何处理？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/time_wait_recv_syn.html" target="_blank" rel="noopener noreferrer">4.11 在 TIME_WAIT 状态的 TCP 连接，收到 SYN 后会发生什么？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_down_and_crash.html" target="_blank" rel="noopener noreferrer">4.12 TCP 连接，一端断电和进程崩溃有什么区别？ | 小林coding (xiaolincoding.com)</a></li>
<li><a href="https://xiaolincoding.com/network/3_tcp/tcp_unplug_the_network_cable.html" target="_blank" rel="noopener noreferrer">4.13 拔掉网线后， 原本的 TCP 连接还存在吗？ | 小林coding (xiaolincoding.com)</a></li>
</ul>
</div>
<h2 id="tcp-面向字节流"> TCP 面向字节流</h2>
<p><mark>TCP 是面向字节流的协议，UDP 是面向报文的协议</mark></p>
<div><p>UDP</p>
<p>当用户消息通过 UDP 协议传输时，<strong>操作系统不会对消息进行拆分</strong>，在组装好 UDP 头部后就交给网络层来处理，所以发出去的 UDP 报文中的数据部分就是完整的用户消息，也就是每个 UDP 报文就是一个用户消息的边界，这样接收方在接收到 UDP 报文后，读一个 UDP 报文就能读取到完整的用户消息。</p>
</div>
<p>当用户消息通过 TCP 协议传输时，<strong>消息可能会被操作系统分组成多个的 TCP 报文</strong>，也就是一个完整的用户消息被拆分成多个 TCP 报文进行传输。这时，接收方的程序如果不知道发送方发送的消息的长度，也就是不知道消息的边界时，是无法读出一个有效的用户消息的。</p>
<blockquote>
<p>至于什么时候真正被发送，<strong>取决于发送窗口、拥塞窗口以及当前发送缓冲区的大小等条件</strong>。也就是说，我们不能认为每次 send 调用发送的数据，都会作为一个整体完整地消息被发送出去。</p>
</blockquote>
<h3 id="粘包"> 粘包</h3>
<p>当两个消息的某个部分内容被分到同一个 TCP 报文时，就是我们常说的 TCP 粘包问题，这时接收方不知道消息的边界的话，是无法读出有效的消息。</p>
<p>一般有三种方式分包的方式：</p>
<ul>
<li>固定长度的消息；</li>
<li>特殊字符作为边界；</li>
<li>自定义消息结构。</li>
</ul>
<h4 id="固定长度的消息"> 固定长度的消息</h4>
<p>这种是最简单方法，即每个用户消息都是固定长度的，比如规定一个消息的长度是 64 个字节，当接收方接满 64 个字节，就认为这个内容是一个完整且有效的消息。</p>
<p>但是这种方式灵活性不高，实际中很少用。</p>
<h4 id="特殊字符作为边界"> 特殊字符作为边界</h4>
<p>我们可以在两个用户消息之间插入一个特殊的字符串，这样接收方在接收数据时，读到了这个特殊字符，就把认为已经读完一个完整的消息。</p>
<p>HTTP 是一个非常好的例子。</p>
<p><img src="./README.assets/a49a6bb8cd38ae1738d9c00aec68b444.png" alt="图片" loading="lazy"></p>
<p>HTTP 通过设置回车符、换行符作为 HTTP 报文协议的边界。</p>
<p>有一点要注意，这个作为边界点的特殊字符，如果刚好消息内容里有这个特殊字符，我们要对这个字符转义，避免被接收方当作消息的边界点而解析到无效的数据。</p>
<h4 id="自定义消息结构"> 自定义消息结构</h4>
<p>我们可以自定义一个消息结构，由包头和数据组成，其中包头包是固定大小的，而且包头里有一个字段来说明紧随其后的数据有多大。</p>
<p>比如这个消息结构体，首先 4 个字节大小的变量来表示数据长度，真正的数据则在后面。</p>
<div><pre><code><span>struct</span> <span>{</span> 
    <span>u_int32_t</span> message_length<span>;</span> 
    <span>char</span> message_data<span>[</span><span>]</span><span>;</span> 
<span>}</span> message<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>当接收方接收到包头的大小（比如 4 个字节）后，就解析包头的内容，于是就可以知道数据的长度，然后接下来就继续读取数据，直到读满数据的长度，就可以组装成一个完整到用户消息来处理了。</p>
<h2 id="不同的初始化序列号"> 不同的初始化序列号</h2>
<p>TCP 每次建立连接时，初始化序列号都要不一样。 <mark>主要原因是为了防止历史报文被下一个相同四元组的连接接收。</mark></p>
<p>假如我某次连接中某个数据包被网络阻塞了。而当这个数据包达到接收方的时候，此时已经不是原来的连接了，而是断开以后、重新建立的新的 TCP 连接，只是恰巧双方的 IP 地址和端口号都和上一次连接相同。</p>
<p>此时这个数据包到达接收方以后，如果使用序列号，和当前通信过程中的某个数据包的序列号重叠，将发生数据错乱。</p>
<p>详细的看 <a href="https://xiaolincoding.com/network/3_tcp/isn_deff.html" target="_blank" rel="noopener noreferrer">4.7 为什么 TCP 每次建立连接时，初始化序列号都要不一样呢？ | 小林coding (xiaolincoding.com)</a></p>
<h2 id="syn-报文什么情况会被丢弃"> SYN 报文什么情况会被丢弃</h2>
<p>没有很懂 <a href="https://xiaolincoding.com/network/3_tcp/syn_drop.html" target="_blank" rel="noopener noreferrer">4.8 SYN 报文什么时候情况下会被丢弃？ | 小林coding (xiaolincoding.com)</a></p>
<h2 id="已经建立连接的tcp收到syn"> 已经建立连接的TCP收到SYN</h2>
<p>一个已经建立的 TCP 连接，客户端中途宕机了，而服务端此时也没有数据要发送，一直处于 establish 状态，客户端恢复后，向服务端建立连接，此时服务端会怎么处理？</p>
<ul>
<li>如果端口号和历史连接不相同，就会建立一个新的连接</li>
<li>如果端口号和历史连接相同，服务器返回一个携带正确 ack 的报文，客户端检查发现序列号对不上，回复 RST 报文断开连接</li>
</ul>
<h3 id="端口号和历史连接不相同"> 端口号和历史连接不相同</h3>
<p>如果客户端恢复后发送的 SYN 报文中的源端口号跟上一次连接的源端口号不一样，此时服务端会认为是新的连接要建立，于是就会通过三次握手来建立新的连接。</p>
<p>对于旧的 TCP 连接，如果服务端一直没有发送数据包给客户端，在超过一段时间后， TCP 保活机制就会启动，检测到客户端没有存活后，接着服务端就会释放掉该连接。</p>
<h3 id="端口号和历史连接相同"> 端口号和历史连接相同</h3>
<p>每次建立连接的时候，SYN 报文中的序列号是随机生成的。处于 establish 的服务器，在接收到这个随机的序列号之后，会回复一个携带正确学历好的 ACK 报文， <code>Challenge ACK</code></p>
<p>客户端收到 <code>Challenge ACK</code> 之后，发现序列号不是期望收到的，就会回复 RST 报文，服务器接收到后会释放连接。</p>
<p><img src="./README.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16.png" alt="img" loading="lazy"></p>
<h2 id="挥手过程中收到乱序的-fin"> 挥手过程中收到乱序的 FIN</h2>
<p>先明确一点，在握手过程中，双方第一个序列号是随机生成 的。通信过程中的序列号则是连续的。</p>
<p><mark>所以如果在挥手过程中，客户端收到了服务器的 FIN，但是发现序列号不连续，则认定存在发送但未到达的数据包，会等待数据接收完毕之后才会进入 <code>TIME_WAIT</code> 阶段。</mark></p>
<p><img src="./README.assets/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBA5bCP5p6XY29kaW5n,size_20,color_FFFFFF,t_70,g_se,x_16-16508607352363.png" alt="img" loading="lazy"></p>
<h2 id="time-wait-期间收到-syn"> TIME_WAIT 期间收到 SYN</h2>
<blockquote>
<ul>
<li>合法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>大</strong>，<strong>并且</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>大</strong>。</li>
<li>非法 SYN：客户端的 SYN 的「序列号」比服务端「期望下一个收到的序列号」要<strong>小</strong>，<strong>或者</strong> SYN 的「时间戳」比服务端「最后收到的报文的时间戳」要<strong>小</strong>。</li>
</ul>
</blockquote>
<ul>
<li>收到合法 SYN，重用此链接，跳过 TIME_WAIT，进入 SYN_RECV 状态</li>
<li>收到非法 SYN，回复第四次挥手的 ACK 报文，客户端接收后返回 RST 报文</li>
</ul>
<h3 id="收到合法-syn"> 收到合法 SYN</h3>
<p><img src="./README.assets/39d0d04adf72fe3d37623acff9ae2507.png" alt="图片" loading="lazy"></p>
<h3 id="收到非法-syn"> 收到非法 SYN</h3>
<p><img src="./README.assets/642a6699c0234da3444e96805dddcc09.png" alt="图片" loading="lazy"></p>
<h3 id="收到-rst"> 收到 RST</h3>
<p>处于 TIME_WAIT 状态的连接，收到 RST 会断开连接吗？</p>
<p>会不会断开，关键看 <code>net.ipv4.tcp_rfc1337</code> 这个内核参数（默认情况是为 0）：</p>
<ul>
<li>如果这个参数设置为 0， 收到 RST 报文会提前结束 TIME_WAIT 状态，释放连接。</li>
<li>如果这个参数设置为 1， 就会丢掉 RST 报文。</li>
</ul>
<h2 id="tcp连接中-电脑断电和进程崩溃"> TCP连接中，电脑断电和进程崩溃</h2>
<ul>
<li>TCP 连接的一方突然断电，另一方是不知道的。</li>
<li>TCP 连接的一方进程突然崩溃， <mark>操作系统可以感知得到，会向另一方发送 FIN 报文，进行四次挥手</mark></li>
</ul>
<h3 id="连接一方宕机以后-仍有数据传输"> 连接一方宕机以后，仍有数据传输</h3>
<ul>
<li>如果一方宕机以后又迅速重启，在接收到数据包以后， <mark>会向另一方发送 RST 报文，另一方接收到以后会断开连接</mark></li>
<li>如果宕机以后没有重启，发送方会进行超时重传，直到 <mark>达到「最大重传次数」或者「最大超时时间」这两个的其中一个条件后，就会停止重传</mark></li>
</ul>
<h2 id="拔网线对tcp连接的影响"> 拔网线对TCP连接的影响</h2>
<p><mark>拔掉网线并不会改变客户端的 TCP 连接状态，并且还是处于 ESTABLISHED 状态</mark></p>
<ul>
<li>如果有数据传输
<ul>
<li>网线不插回去，发送方会进行超时重传，当重传次数达到上限以后就会断开连接</li>
<li>网线插回去之后还是能够正常通信</li>
</ul>
</li>
<li>如果没有数据传输
<ul>
<li>如果开启了保活机制，在规定时间内一直没有响应，另一方就会断开连接</li>
<li>如果没有开启保活机制，将一直保持连接状态</li>
</ul>
</li>
</ul>
<h2 id="保活机制"> 保活机制</h2>
<p>定义一个时间段，在这个时间段内，如果没有任何连接相关的活动，TCP 保活机制会开始作用，每隔一个时间间隔，发送一个探测报文，该探测报文包含的数据非常少，如果连续几个探测报文都没有得到响应，则认为当前的 TCP 连接已经死亡，系统内核将错误信息通知给上层应用程序。</p>
<div><pre><code>net.ipv4.tcp_keepalive_time=7200
net.ipv4.tcp_keepalive_intvl=75  
net.ipv4.tcp_keepalive_probes=9
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ul>
<li>tcp_keepalive_time = 7200：表示保活时间是 7200 秒（2小时），也就 2 小时内如果没有任何连接相关的活动，则会启动保活机制</li>
<li>tcp_keepalive_intvl = 75：表示每次检测间隔 75 秒；</li>
<li>tcp_keepalive_probes = 9：表示检测 9 次无响应，认为对方是不可达的，从而中断本次的连接。</li>
</ul>
<p>也就是说在 Linux 系统中，最少需要经过 2 小时 11 分 15 秒才可以发现一个「死亡」连接。</p>
<h2 id="tcp-tw-reuse-为什么默认是关闭的"> tcp_tw_reuse 为什么默认是关闭的</h2>
<p>哈哈好难 <a href="https://xiaolincoding.com/network/3_tcp/tcp_tw_reuse_close.html" target="_blank" rel="noopener noreferrer">4.14 tcptwreuse 为什么默认是关闭的？ | 小林coding (xiaolincoding.com)</a></p>
<h2 id="https中tls和tcp能同时握手吗"> HTTPS中TLS和TCP能同时握手吗</h2>
<p><a href="https://xiaolincoding.com/network/3_tcp/tcp_tls.html" target="_blank" rel="noopener noreferrer">4.14 HTTPS 中 TLS 和 TCP 能同时握手吗？ | 小林coding (xiaolincoding.com)</a></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-25T01:10:50.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">输入url网址到页面显示</title>
    <id>https://notes.lllllan.cn/cs-basic/network/url-to-page/</id>
    <link href="https://notes.lllllan.cn/cs-basic/network/url-to-page/"/>
    <updated>2022-04-19T07:09:50.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener noreferrer">前端经典面试题: 从输入URL到页面加载发生了什么？ - SegmentFault 思否</a></li>
<li><a href="https://segmentfault.com/a/1190000017184701" target="_blank" rel="noopener noreferrer">从URL输入到页面展现到底发生什么？ - SegmentFault 思否</a></li>
<li><a href="https://blog.csdn.net/qinian8/article/details/99081105" target="_blank" rel="noopener noreferrer">从输入URL到页面展示的详细过程（从输入url到页面展示到底发生了什么）</a></li>
</ul>
</div>
<h2 id="从输入-url-到页面显示发生了什么"> 从输入 url 到页面显示发生了什么</h2>
<p>总体来说分为以下几个过程:</p>
<ol>
<li>DNS解析</li>
<li>TCP连接</li>
<li>发送HTTP请求</li>
<li>服务器处理请求并返回HTTP报文</li>
<li>浏览器解析渲染页面</li>
<li>断开连接</li>
</ol>
<h2 id="一、应用层进行dns-解析"> 一、应用层进行DNS 解析</h2>
<p><strong>DNS解析的过程就是寻找哪台机器上有你需要资源的过程。</strong></p>
<h3 id="_1-1-dns-解析过程"> 1.1 DNS 解析过程</h3>
<p><strong>DNS解析是一个递归查询的过程。</strong></p>
<p><img src="./README.assets/view.png" alt="preview" loading="lazy"></p>
<p>浏览器通过向DNS服务器发送域名，DNS服务器查询到与域名相对应的IP地址，然后返回给浏览器，浏览器再将IP地址和请求参数搭载在协议上，一并发送给对应的服务器。</p>
<h3 id="_1-2-dns-缓存"> 1.2 DNS 缓存</h3>
<p>DNS 服务器有一个缓存功能，可以记住之前查询过的域名</p>
<ul>
<li>如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应。</li>
<li>当查询的域名不存在时，【不存在】这一响应结果也会被缓存</li>
<li>缓存信息设置有一个有效期，当信息超过有效期后，数据会从缓存中删除</li>
<li>DNS服务器返回响应时，会告知这一响应结果是来自缓存还是来自负责管理该域名的DNS服务器</li>
</ul>
<h3 id="_1-3-dns-负载均衡"> 1.3 DNS 负载均衡</h3>
<p>真实的互联网世界背后存在成千上百台服务器，大型的网站甚至更多。但是在用户的眼中，它需要的只是处理他的请求，哪台机器处理请求并不重要。DNS可以返回一个合适的机器的IP给用户，例如可以根据每台机器的负载量，该机器离用户地理位置的距离等等，这种过程就是DNS负载均衡，又叫做DNS重定向。大家耳熟能详的CDN(Content Delivery Network)就是利用DNS的重定向技术，DNS服务器会返回一个跟用户最接近的点的IP地址给用户，CDN节点的服务器负责响应用户的请求，提供所需的内容。</p>
<h2 id="二、传输层建立tcp连接"> 二、传输层建立TCP连接</h2>
<p>简单地看，可以把TCP连接理解成三次握手：</p>
<ol>
<li>客户端向服务器端发送一个建立连接的请求 <code>SYN = 1, seq = x</code></li>
<li>服务器端同意客户端的请求，并且同样发送一个建立连接的请求 <code>ACK = 1, ack = x + 1, SYN = 1, seq = y</code></li>
<li>客户端同意服务器端的请求 <code>ACK = 1, ack = y + 1</code></li>
</ol>
<p><img src="./README.assets/0c9f470819684156cfdc27c682db4def.cf54da4f.png" alt="img" loading="lazy"></p>
<blockquote>
<p>为什么握手要三次？握手期间可能发生的异常？-&gt; <a href="http://blog.lllllan.cn/cs-basic/network/interview-questions/#%E4%BA%8C%E3%80%81tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></p>
</blockquote>
<h2 id="三、发送-http-请求"> 三、发送 HTTP 请求</h2>
<h3 id="_3-1-应用层生成http请求报文"> 3.1 应用层生成HTTP请求报文</h3>
<p>主要提供两个终端设备上的应用程序之间信息交换的服务，它定义了信息交换的格式，消息会交给下一层传输层来传输。应用层针对目标 Web 服务器生成 HTTP 请求报文，向服务器申请需要的资源。</p>
<h3 id="_3-2-传输层对报文进行封装"> 3.2 传输层对报文进行封装</h3>
<p>负责向两台终端设备进程之间的通信提供通用的数据传输服务。TCP 模块在报文前面加上 TCP 头部，指定目标服务器的 IP 地址委托给 IP 模块发送</p>
<h3 id="_3-3-网络层使用ip协议来选择路线"> 3.3 网络层使用IP协议来选择路线</h3>
<p>IP 模块接收到 TCP 模块委托过来的包，在其前面加上 IP 头部和 MAC 头部，其中 IP 头部中包含发送方和接收方的 IP 地址。</p>
<p>然后交给硬件发送出去，在数据传输的过程中，IP 协议负责选择传送的路线，称为路由功能</p>
<h3 id="_3-4-数据链路层实现网络相邻节点可靠的数据通信"> 3.4 数据链路层实现网络相邻节点可靠的数据通信</h3>
<p>为了保证数据的可靠传输，把数据包封装成帧，并按顺序传输各帧。</p>
<p>由于物理线路的不可靠，发出的数据帧有可能在线路上出错或丢失，于是每个数据分块计算出CRC（循环冗余校验），并把 CRC 添加到帧中，这样接收方就可以通过重新计算CRC并比对来判断数据的正确性。</p>
<h3 id="_3-5-物理层传输数据"> 3.5 物理层传输数据</h3>
<p>数据链路层的帧转换成二进制形式的比特流，从网卡发送出局，再把比特流转换成电子、光学信号在网络中传输。</p>
<h2 id="四、服务器处理并返回-http-报文"> 四、服务器处理并返回 HTTP 报文</h2>
<p>服务器接收到数据之后，</p>
<p>光电信号 → 比特流 → 帧 → 网络包 → 解除MAC头部 → 解除IP头部 → 接触TCP头部 → 获得请求报文的数据。</p>
<p>服务器内部对请求做出处理，生成响应报文，以相同的方式发送给客户端。</p>
<h2 id="五、浏览器解析渲染页面"> 五、浏览器解析渲染页面</h2>
<p>（前端内容，不管了）</p>
<h2 id="六、传输层断开tcp连接"> 六、传输层断开TCP连接</h2>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<blockquote>
<p><a href="http://blog.lllllan.cn/cs-basic/network/interview-questions/#%E4%B8%89%E3%80%81tcp%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">IO 多路复用</title>
    <id>https://notes.lllllan.cn/cs-basic/os/def/multiplexing/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/def/multiplexing/"/>
    <updated>2022-04-08T16:37:07.000Z</updated>
    <content type="html"><![CDATA[<p><mark>单进程/线程下同时关注多个文件描述符，哪个有空就处理哪个</mark></p>
<p><strong>IO多路复用是指内核一旦发现进程指定的一个或者多个IO条件准备读取，它就通知该进程。IO多路复用适用如下场合</strong>：</p>
<ul>
<li>当客户处理多个描述字时（一般是交互式输入和网络套接口），必须使用I/O复用。</li>
<li>当一个客户同时处理多个套接口时，而这种情况是可能的，但很少出现。</li>
<li>如果一个TCP服务器既要处理监听套接口，又要处理已连接套接口，一般也要用到I/O复用。</li>
<li>如果一个服务器即要处理TCP，又要处理UDP，一般要使用I/O复用。</li>
<li>如果一个服务器要处理多个服务或多个协议，一般要使用I/O复用。</li>
<li>与多进程和多线程技术相比，I/O多路复用技术的最大优势是系统开销小，系统不必创建进程/线程，也不必维护这些进程/线程，从而大大减小了系统的开销。</li>
</ul>
<p>更具体直接看</p>
<ul>
<li><a href="https://www.zhihu.com/question/32163005/answer/55772739" target="_blank" rel="noopener noreferrer">IO 多路复用是什么意思？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/115220699" target="_blank" rel="noopener noreferrer">一文看懂IO多路复用 - 知乎 (zhihu.com)</a></li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-08T09:23:30.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">进程间通信</title>
    <id>https://notes.lllllan.cn/cs-basic/os/def/process-communication/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/def/process-communication/"/>
    <updated>2022-04-18T15:53:00.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener noreferrer">进程间通信IPC (InterProcess Communication)</a></li>
<li><a href="https://www.cnblogs.com/zgq0/p/8780893.html" target="_blank" rel="noopener noreferrer">进程间的五种通信方式介绍 - moon-zhu</a></li>
</ul>
</div>
<div><p>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取</p>
</div>
<h2 id="一、管道-匿名管道"> 一、管道/匿名管道</h2>
<p><strong>用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</strong></p>
<blockquote>
<p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
</blockquote>
<p>特点和局限：</p>
<ul>
<li>只支持单向数据流</li>
<li>只能用于具有亲缘关系的进程之间</li>
<li>没有名字</li>
<li>管道的缓冲区是有限的（管道只 <mark>存在于内存中</mark> ，在管道创建时，为缓冲区分配一个页面大小）</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<p>源码看 <a href="https://blog.csdn.net/KUNPLAYBOY/article/details/123262361" target="_blank" rel="noopener noreferrer">linux进程间通信之管道通信底层实现源码分析_胡说嵌入式</a></p>
<h2 id="二、有名管道-fifo"> 二、有名管道 FIFO</h2>
<p><mark>有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</mark></p>
<blockquote>
<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。有名管道的名字存在于文件系统中，内容存放在内存中。</p>
</blockquote>
<p>管道总结：</p>
<ul>
<li>管道是特殊类型的文件，在满足<strong>先入先出</strong>的原则条件下可以进行读写，但不能进行定位读写。</li>
<li>管道都是单向的。其中匿名管道只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>匿名管道阻塞问题：</strong> 匿名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li>
<li><strong>有名管道阻塞问题：</strong> 有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li>
</ul>
<h2 id="三、信号"> 三、信号</h2>
<p><strong>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</strong></p>
<ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<p><img src="./README.assets/webp-16430301339574.png" alt="img" loading="lazy"></p>
<div><p>Linux系统中常用信号</p>
<p>（1）<strong>SIGHUP</strong>：用户从终端注销，所有已启动进程都将收到该进程。系统缺省状态下对该信号的处理是终止进程。</p>
<p>（2）<strong>SIGINT</strong>：程序终止信号。程序运行过程中，按<code>Ctrl+C</code>键将产生该信号。</p>
<p>（3）<strong>SIGQUIT</strong>：程序退出信号。程序运行过程中，按<code>Ctrl+\\</code>键将产生该信号。</p>
<p>（4）<strong>SIGBUS和SIGSEGV</strong>：进程访问非法地址。</p>
<p>（5）<strong>SIGFPE</strong>：运算中出现致命错误，如除零操作、数据溢出等。</p>
<p>（6）<strong>SIGKILL</strong>：用户终止进程执行信号。shell下执行<code>kill -9</code>发送该信号。</p>
<p>（7）<strong>SIGTERM</strong>：结束进程信号。shell下执行<code>kill 进程pid</code>发送该信号。</p>
<p>（8）<strong>SIGALRM</strong>：定时器信号。</p>
<p>（9）<strong>SIGCLD</strong>：子进程退出信号。如果其父进程没有忽略该信号也没有处理该信号，则子进程退出后将形成僵尸进程。</p>
</div>
<h2 id="四、消息队列"> 四、消息队列</h2>
<p><strong>消息队列是消息的链表，具有特定的格式，存放在 <mark>内存</mark> 中并由消息队列标识符标识。</strong></p>
<p>特点总结：</p>
<ul>
<li>消息队列是消息的链表，具有特定的格式，存放在内存中并由消息队列标识符标识</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则</li>
<li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取比FIFO更有优势</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字节流以及缓冲区大小受限等缺</li>
<li>目前主要有两种类型的消息队列：POSIX 消息队列以及 System V 消息队列，系统 V 消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ul>
<h2 id="五、共享内存和信号量"> 五、共享内存和信号量</h2>
<p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（信号量），对共享空间的写/读进行控制。</p>
<div><p>特点</p>
<ol>
<li><mark>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</mark></li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量 + 共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
</div>
<p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。注意，进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间，<strong>必须通过特殊的系统调用实现</strong>，而进程内的线程是自然共享进程空间的。</p>
<p><img src="./README.assets/v2-195b0cf5f101ed8c11910fea9b77559e_r.jpg" alt="preview" loading="lazy"></p>
<h2 id="六、套接字"> 六、套接字</h2>
<p><strong>主要用于在客户端和服务器之间通过网络进行通信</strong></p>
<blockquote>
<p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-07T11:17:33.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">内存管理</title>
    <id>https://notes.lllllan.cn/cs-basic/os/memory-manage/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/memory-manage/"/>
    <updated>2022-04-21T01:37:46.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/home.html#%E5%BF%85%E7%9C%8B%E4%B8%93%E6%A0%8F" target="_blank" rel="noopener noreferrer">JavaGuide（Java学习&amp;&amp;面试指南） | JavaGuide</a></li>
<li><a href="https://juejin.cn/post/6942686874301857800#heading-1" target="_blank" rel="noopener noreferrer">2021-Java后端工程师必会知识点-(操作系统) - 掘金 (juejin.cn)</a></li>
<li><a href="https://blog.csdn.net/ibless/article/details/81275009" target="_blank" rel="noopener noreferrer">为什么使用多级页表？_ibless的博客-CSDN博客_多级页表的好处</a></li>
</ul>
</div>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/1/" target="_blank" rel="noopener noreferrer">内存管理概念 | lllllan</a></p>
<h2 id="内存管理介绍"> 内存管理介绍</h2>
<ul>
<li>内存空间的分配与回收</li>
<li>地址转换：把逻辑地址转换成相应的物理地址</li>
<li>内存空间的扩充：利用虚拟技术或自动覆盖技术，从逻辑上扩充内存</li>
<li>存储保护：保证各道作业在各自的存储空间内运行，互不干扰</li>
</ul>
<h2 id="内存分配机制"> 内存分配机制</h2>
<p>简单分为 <strong>连续分配管理方式</strong> 和 <strong>非连续分配管理方式</strong> 两种。</p>
<ul>
<li>连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <u>块式管理</u></li>
<li>非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如 <u>页式管理</u>、<u>段式管理</u>、<u>段页式管理</u></li>
</ul>
<ol>
<li><strong>块式管理：</strong> 将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就会分配给它一块，如果程序运行只需要很小的空间的话，块中其余的部分将会被浪费。</li>
<li><strong>页式管理：</strong> 把主存分为大小相等的一页一页的形式，页较小，相对比块式管理的划分力度更大，提高了内存利用率，减少了碎片（块中没有被利用的空间）。页式管理通过页表对应逻辑地址和物理地址</li>
<li><strong>段式管理：</strong> 段式管理把主存分为一段段的，每个段定义了一组逻辑信息，例如有主程序的 Main、子程序段 X、数据段 D 及栈段 S 等。段式管理通过段表对应逻辑地址和物理地址，相对于页式管理赋予了段的实际意义。</li>
<li><strong>段页式管理：</strong> 把主存分成若干段，每个段分成若干页，结合了段式管理和页式管理的优点。</li>
</ol>
<h2 id="快表和多级页表"> 快表和多级页表</h2>
<h3 id="快表"> 快表</h3>
<p>为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础上引入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的 <mark>高速缓冲存储器（Cache）</mark> ，其中的内容是页表的一部分或者全部内容。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据 CPU 要访问两次主存。有了快表，有时只要访问一次告诉缓冲存储区，一次主存，这样可以加速查找并提高指令执行速度。</p>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/2/#_2-3-%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener noreferrer">虚拟内存管理 | lllllan</a></p>
<ol>
<li>根据虚拟地址中的页号查快表</li>
<li>如果该页在快表中，直接从快表中读取相应的物理地址</li>
<li>如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将该映射添加到快表中</li>
<li>当快表填满后，新添加时会按照一定的淘汰策略淘汰掉快表中的一页</li>
</ol>
<h3 id="多级页表"> 多级页表</h3>
<p><a href="https://blog.csdn.net/ibless/article/details/81275009" target="_blank" rel="noopener noreferrer">为什么使用多级页表？_ibless的博客-CSDN博客_多级页表的好处</a></p>
<ul>
<li>多级页表可以离散地存储页表。页帧可以离散，是因为有页表记录它们存在的位置。一级页表必须连续，当页帧较多的时候则需要占用较大的连续空间。使用多级页表可以离散地存储页表，通过某一级的页表记录下一级页表的存储位置。通过时间换取空间。</li>
<li>在虚拟存储技术中，可以节省页表的占用空间。因为局部性原理，暂时用不到的信息不会写到内存中，页表中就可以少一些记录。</li>
</ul>
<h3 id="总结"> 总结</h3>
<p>为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表的概念。</p>
<h2 id="分页"> 分页</h2>
<p>把内存空间划分为<strong>大小相等且固定的块</strong>，作为主存的基本单位。因为程序数据存储在不同的页面中，而页面又离散的分布在内存中，<strong>因此需要一个页表来记录映射关系，以实现从页号到物理块号的映射。</strong></p>
<p>访问分页系统中内存数据需要<strong>两次的内存访问</strong> (一次是从内存中访问页表，从中找到指定的物理块号，加上页内偏移得到实际物理地址；第二次就是根据第一次得到的物理地址访问内存取出数据)。</p>
<p><img src="./README.assets/image-20210610173249387.png" alt="" loading="lazy"></p>
<h2 id="分段"> 分段</h2>
<p><strong>分页是为了提高内存利用率，而分段是为了满足程序员在编写代码的时候的一些逻辑需求(比如数据共享，数据保护，动态链接等)。</strong></p>
<p>分段内存管理当中，<strong>地址是二维的，一维是段号，二维是段内地址；其中每个段的长度是不一样的，而且每个段内部都是从0开始编址的</strong>。由于分段管理中，每个段内部是连续内存分配，但是段和段之间是离散分配的，因此也存在一个逻辑地址到物理地址的映射关系，相应的就是段表机制。</p>
<p><img src="./README.assets/image-20210610173410509.png" alt="" loading="lazy"></p>
<h2 id="分页和分段的异同"> 分页和分段的异同</h2>
<p><strong>共同点：</strong></p>
<ul>
<li>都是为了提高内存利用率，减少内存碎片</li>
<li>都是离散分配内存的方式，但页和段中的内存都是连续的</li>
</ul>
<p><strong>区别：</strong></p>
<ul>
<li>页的大小是固定的，由操作系统决定；段的大小是不固定的，取决于当前运行的程序</li>
<li>分页仅仅是为了满足操作系统内存管理的需求；段是逻辑信息的单位，在程序中可以体现为代码段、数据段，能够更好满足用户的需求</li>
<li>分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。</li>
</ul>
<h2 id="逻辑地址和物理地址"> 逻辑地址和物理地址</h2>
<p>比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址</p>
<h2 id="cpu-寻址"> CPU 寻址</h2>
<p>现代处理器使用的是 <strong>虚拟寻址</strong> 的方式。<strong>使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。</strong> 实际上完成虚拟地址转换为物理地址的硬件是 CPU 中的 <strong>内存管理单元</strong></p>
<div><p>为什么要有虚拟地址空间？</p>
<p>在没有虚拟地址的时候，程序都是直接访问和操作物理内存的，存在以下问题：</p>
<ol>
<li>用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃</li>
<li>想要同时运行多个程序特别困难，困难会发生多个程序同时修改同个内存地址上的内容，从而导致程序的崩溃</li>
</ol>
<p><strong>如果直接把物理地址暴露出来的话会带来严重问题，可能会对操作系统和程序造成伤害和困难</strong></p>
<p>通过虚拟地址访问内存有以下优势：</p>
<ol>
<li>程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区</li>
<li>程序可以使用一系列虚拟地址访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘文件。数据或代码也会根据需要在物理内存与磁盘之间移动</li>
<li>不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存</li>
</ol>
</div>
<h2 id="覆盖于交换"> 覆盖于交换</h2>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/1/#%E4%BA%8C%E3%80%81%E8%A6%86%E7%9B%96%E4%B8%8E%E4%BA%A4%E6%8D%A2" target="_blank" rel="noopener noreferrer">内存管理概念 | lllllan</a></p>
<p>交换技术主要在不同进程(或作业)之间进行，而覆盖则用于同一个程序或进程中</p>
<h2 id="物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别-▲"> 物理地址、逻辑地址、有效地址、线性地址、虚拟地址的区别 ▲</h2>
<p><mark>物理地址</mark> 就是内存中真正的地址，具有唯一性。<strong>不管哪种地址，最终都会映射为物理地址</strong>。</p>
<p>在<code>实模式</code>下，段基址 + 段内偏移经过地址加法器的处理，经过地址总线传输，最终也会转换为<code>物理地址</code>。</p>
<p>但是在 <code>保护模式</code> 下，段基址 + 段内偏移被称为 <mark>线性地址</mark> ，不过此时的段基址不能称为真正的地址，而是会被称作为一个 <code>选择子</code> 的东西，选择子就是个索引，相当于数组的下标，通过这个索引能够在 GDT 中找到相应的段描述符，段描述符记录了<strong>段的起始、段的大小</strong>等信息，这样便得到了基地址。如果此时没有开启内存分页功能，那么这个线性地址可以直接当做物理地址来使用，直接访问内存。如果开启了分页功能，那么这个线性地址又多了一个名字，这个名字就是 <mark>虚拟地址</mark></p>
<p>不论在实模式还是保护模式下，段内偏移地址都叫做 <mark>有效地址</mark> 也是 <mark>逻辑地址</mark></p>
<p>线性地址可以看作是<code>虚拟地址</code>，虚拟地址不是真正的物理地址，但是虚拟地址会最终被映射为物理地址。下面是虚拟地址 -&gt; 物理地址的映射。</p>
<p><img src="./README.assets/image-20210807152300643.png" alt="image-20210807152300643" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-21T01:37:46.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">进程和线程</title>
    <id>https://notes.lllllan.cn/cs-basic/os/processes&amp;threads/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/processes&amp;threads/"/>
    <updated>2022-04-21T01:37:46.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/home.html#%E5%BF%85%E7%9C%8B%E4%B8%93%E6%A0%8F" target="_blank" rel="noopener noreferrer">JavaGuide（Java学习&amp;&amp;面试指南） | JavaGuide</a></li>
<li><a href="https://www.cnblogs.com/theRhyme/p/14061698.html" target="_blank" rel="noopener noreferrer">协程的原理以及与线程的区别 - rhyme - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/weixin_44575037/article/details/105513014" target="_blank" rel="noopener noreferrer">协程的概念，为什么要用协程，以及协程的使用_someone丶</a></li>
<li><a href="https://blog.csdn.net/qq_40861091/article/details/102601719" target="_blank" rel="noopener noreferrer">进程的切换过程_凝视阳光</a></li>
</ul>
</div>
<h2 id="进程和线程的区别"> 进程和线程的区别</h2>
<p><strong>概念：</strong></p>
<ul>
<li><strong>进程</strong>：是并发执行的程序在执行过程中<strong>分配和管理资源的基本单位</strong>，是一个动态概念，竞争计算机系统资源的基本单位。</li>
<li><strong>线程</strong>：是进程的一个执行单元，是进程内的调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</li>
</ul>
<p><strong>关系：</strong></p>
<ol>
<li>一个线程只属于一个进程，一个进程至少有一个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的资源</li>
<li>处理机分配给线程，真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
</ol>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">进程</th>
<th style="text-align:center">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">调度</td>
<td style="text-align:center">分配和管理资源的基本单位</td>
<td style="text-align:center">调度和分配的基本单位</td>
</tr>
<tr>
<td style="text-align:center">资源</td>
<td style="text-align:center">相互间独立</td>
<td style="text-align:center">共享本进程的资源</td>
</tr>
<tr>
<td style="text-align:center">健壮性</td>
<td style="text-align:center">一个进程的崩溃不会影响其他进程</td>
<td style="text-align:center">一个线程的崩溃会影响整个进程</td>
</tr>
<tr>
<td style="text-align:center">并发性</td>
<td style="text-align:center">可以并发执行</td>
<td style="text-align:center">可以并发执行</td>
</tr>
<tr>
<td style="text-align:center">系统开销</td>
<td style="text-align:center">大</td>
<td style="text-align:center">小</td>
</tr>
</tbody>
</table>
<h2 id="线程和协程的区别"> 线程和协程的区别</h2>
<p><a href="https://www.cnblogs.com/theRhyme/p/14061698.html" target="_blank" rel="noopener noreferrer">协程的原理以及与线程的区别 - rhyme - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_44575037/article/details/105513014" target="_blank" rel="noopener noreferrer">协程的概念，为什么要用协程，以及协程的使用_someone丶</a></p>
<p>协程（Coroutines）是一种比线程更加轻量级的存在。协程完全由程序所控制（在用户态执行），带来的好处是性能大幅度的提升。</p>
<ul>
<li>需要用户释放使用权切换到其他协程，因此 <mark>同一时间其实只有一个协程拥有运行权</mark>，相当于单线程的能力。</li>
<li>一个线程可以有多个协程，一个进程也可以有多个协程。</li>
<li>协程不被操作系统内核管理，而完全是 <mark>由程序控制</mark>。线程是被分割的CPU资源，协程是组织好的代码流程，线程是协程的资源。但协程不会直接使用线程，协程直接利用的是执行器关联任意线程或线程池。</li>
<li>协程能 <mark>保留上一次调用时的状态</mark></li>
<li>协程 <mark>无需系统内核的上下文切换</mark>，开销更小</li>
<li>协程无需原子操作锁定及同步的开销，不用担心资源共享的问题</li>
</ul>
<h2 id="进程的状态"> 进程的状态</h2>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p><img src="./README.assets/20160906192211991.png" alt="这里写图片描述" loading="lazy"></p>
<ul>
<li><strong>运行态→阻塞态</strong>：往往是由于等待外设，等待主存等资源分配或等待人工干预而引起的。</li>
<li><strong>阻塞态→就绪态</strong>：则是等待的条件已满足，只需分配到处理器后就能运行。</li>
<li><strong>运行态→就绪态</strong>：不是由于自身原因，而是由外界原因使运行状态的进程让出处理器，这时候就变成就绪态。例如时间片用完，或有更高优先级的进程来抢占处理器等。</li>
<li><strong>就绪态→运行态</strong>：系统按某种策略选中就绪队列中的一个进程占用处理器，此时就变成了运行态。</li>
</ul>
<h2 id="进程-线程的通信方式-★"> 进程/线程的通信方式 ★</h2>
<p><a href="http://blog.lllllan.cn/cs-basic/os/def/process-communication/" target="_blank" rel="noopener noreferrer">进程间通信 | lllllan</a></p>
<p>管道 | 有名管道 | 信号 | 消息队列 | 共享内存和信号量 | 套接字</p>
<hr>
<p><a href="http://blog.lllllan.cn/java/concurrent/1/5/" target="_blank" rel="noopener noreferrer">第五章、Java线程间的通信 | lllllan</a></p>
<p>共享内存 | 消息传递 | 管道</p>
<h2 id="进程-线程的同步方式-★"> 进程/线程的同步方式 ★</h2>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/2/3/" target="_blank" rel="noopener noreferrer">同步与互斥 | lllllan</a></p>
<p>信号量 | 互斥量 | 管程 | 进程间通信</p>
<hr>
<p>线程同步</p>
<p>信号量 | 互斥量 | 临界区 | 事件</p>
<p><img src="./README.assets/20171121130628916.png" alt="img" loading="lazy"></p>
<h2 id="进程的调度算法"> 进程的调度算法</h2>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/2/2/#%E5%9B%9B%E3%80%81%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener noreferrer">处理机调度 | lllllan</a></p>
<p>不论是在什么系统中，进程数量一般都会多于处理及数量，这将导致他们呢相互争夺处理机。这时就需要通过进程调度，来分配不同进程使用处理机的顺序，让这些进程<strong>高效、及时、公平</strong>地使用CPU，以提高CPU利用率。</p>
<ol>
<li><strong>先来先服务调度算法 FCFS：</strong> 所有进程按照 <u>先来后到</u> 的方式依次进入就绪队列，然后按照顺序为队列中的进程逐个分配资源，使他立即执行并且一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。</li>
<li><strong>短作业优先调度算法 SJF：</strong> 从就绪队列中选出一个 <u>估计运行时间最短</u> 的进程为止分配资源，使他立即执行并且一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。</li>
<li><strong>时间片轮转调度算法 RR：</strong> 所有进程按照 <u>先来后到</u> 的方式一次进入就绪队列，然后按照顺序为队列中的进程逐个 <u>分配固定时长的资源</u>，执行完成或时间结束都将放弃占用CPU，未执行完将重新调度。</li>
<li><strong>多级反馈队列调度算法：</strong> 根据先来先服务原则给就绪队列排序，为就绪队列赋予<u>不同的优先级数，不同的时间片</u>，按照优先级抢占CPU</li>
<li><strong>优先级调度：</strong> 为每个流程分配优先级，首先执行具有最高优先级的进程，以此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据 <u>内存、时间或任何其他资源要求来确定优先级</u>。</li>
</ol>
<h2 id="死锁"> 死锁</h2>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/2/4/" target="_blank" rel="noopener noreferrer">死锁 | lllllan</a></p>
<p>死锁是指多个进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去。</p>
<h3 id="死锁产生的原因"> 死锁产生的原因</h3>
<ul>
<li>系统资源不足</li>
<li>程序执行的顺序有问题</li>
<li>资源分配不当</li>
</ul>
<h3 id="死锁产生的条件"> 死锁产生的条件</h3>
<ul>
<li><strong>互斥：</strong> 指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直到占有资源的进程释放。</li>
<li><strong>请求和保持：</strong> 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对已获得的其他资源保持不放。</li>
<li><strong>不剥夺：</strong> 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。</li>
<li><strong>环路等待：</strong> 指在发生死锁时，必然存在一个进程-资源的环形链，即进程集合 <code>{P0, P1, P2, ... , Pn}</code> 中的 <code>P0</code> 正在等一个 <code>P1</code> 占用的资源； <code>P1</code> 正在等待 <code>P2</code> 占用的资源， ...... ，<code>Pn</code> 正在等待一个 <code>P0</code> 占用的资源。</li>
</ul>
<p><strong>只有四个条件同时成立时，死锁才会出现。</strong></p>
<h2 id="进程和线程切换-★"> 进程和线程切换 ★</h2>
<p><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/2/2/#%E4%BA%94%E3%80%81%E8%BF%9B%E7%A8%8B%E5%88%87%E6%8D%A2" target="_blank" rel="noopener noreferrer">处理机调度 | lllllan</a></p>
<p><a href="https://blog.csdn.net/qq_40861091/article/details/102601719" target="_blank" rel="noopener noreferrer">进程的切换过程_凝视阳光</a></p>
<p>进程切换的流程：</p>
<ol>
<li>挂起一个进程，保存 CPU 上下文，包括程序计数器和其他寄存器。</li>
<li>更新 PCB 信息（信息保存在进程控制块）</li>
<li>把进程的 PCB 移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其 PCB。</li>
<li>跳转到新进程 PCB 中的程序计数器所指向的位置执行。</li>
<li>恢复处理机上下文</li>
</ol>
<hr>
<ol>
<li>（进程）切换新的页表，然后使用新的虚拟地址空间</li>
<li>（进程、线程）切换内核栈和上下文</li>
</ol>
<blockquote>
<p>因为每个进程都有自己的虚拟地址空间，而线程是共享所在进程的虚拟地址空间的， 因此同一个进程中的线程切换时不涉及虚拟地址空间转换</p>
</blockquote>
<h2 id="线程分类"> 线程分类</h2>
<p>从线程的运行空间来说，分为用户级线程（user-level thread, ULT）和内核级线程（kernel-level, KLT）</p>
<p><strong>内核级线程</strong>：这类线程依赖于内核，又称为内核支持的线程或轻量级进程。无论是在用户程序中的线程还是系统进程中的线程，它们的创建、撤销和切换都由内核实现</p>
<p><strong>用户级线程</strong>：它仅存在于用户级中，这种线程是<strong>不依赖于操作系统核心</strong>的。应用进程利用<strong>线程库来完成其创建和管理</strong>，速度比较快，<strong>操作系统内核无法感知用户级线程的存在</strong>。</p>
<h2 id="什么是临界区-如何解决冲突-▲"> 什么是临界区，如何解决冲突？▲</h2>
<p>每个进程中访问临界资源的那段程序称为临界区，<strong>一次仅允许一个进程使用的资源称为临界资源。</strong></p>
<p>解决冲突的办法：</p>
<ul>
<li>如果有若干进程要求进入空闲的临界区，<strong>一次仅允许一个进程进入</strong>，如已有进程进入自己的临界区，则其它所有试图进入临界区的进程必须等待；</li>
<li>进入临界区的进程要在<strong>有限时间内退出</strong>。</li>
<li>如果进程不能进入自己的临界区，则应<strong>让出CPU</strong>，避免进程出现【忙等】现象。</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-21T01:37:46.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">操作系统的基本概念</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/1/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/1/1/"/>
    <updated>2022-04-03T01:17:09.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、操作系统的概念"> 一、操作系统的概念</h2>
<p><strong>操作系统(Operation System, OS) 是指控制和管理整个计算机系统的硬件和软件资源的系统软件。</strong></p>
<h2 id="二、操作系统特征"> 二、操作系统特征</h2>
<p>操作系统的基本特征包括并发、共享、虚拟和异步。</p>
<h3 id="_2-1-并发"> 2.1 并发</h3>
<p>并发是指多个事件在同一时间间隔内发生。</p>
<div><p>并发、并行</p>
<p>注意同一时间间隔（并发）和同一时刻（并行）的区别。</p>
<p>在多道程序环境下，一段时间内，宏观上有多道程序在同时执行，而在每个时刻，单处理机环境下实际仅能有一道程序执行， 因此微观上这些程序仍是分时交替执行的。操作系统的并发性是通过分时得以实现的。</p>
</div>
<h3 id="_2-2-共享"> 2.2 共享</h3>
<p>共享即资源共享，是指系统中的资源可供内存中多个并发执行的进程共同使用。</p>
<h4 id="互斥共享方式"> <strong>互斥共享方式</strong></h4>
<p>仅当进程A访问完并释放该资源后，才允许另一个进程对该资源进行访问。</p>
<div><p>临界资源</p>
<p>在一段时间内只允许一个进程访问的资源。</p>
<p>许多物理设备都属于临界资源，如输入机、打印机、磁带机等</p>
</div>
<hr>
<h4 id="同时访问方式"> <strong>同时访问方式</strong></h4>
<p>资源允许在一段时间内由多个进程【同时】访问。这里所说的同时通常是宏观上的，而在微观上，这些进程可能是交替地对该资源进行访问即【分时共享】的。</p>
<div><p>并发和共享是操作系统两个最基本的特征</p>
<p><mark>并发和共享互为存在的条件</mark></p>
<ol>
<li>资源共享是以程序的并发为条件的，若系统不允许程序并发执行，则自然不存在资源共享问题</li>
<li>若系统不能对资源共享实施有效的管理，则必将影响到程序的并发执行，甚至根本无法并发执行。</li>
</ol>
</div>
<h3 id="_2-3-虚拟"> 2.3 虚拟</h3>
<p>虚拟是指把一个个物理上的实体变为若干逻辑上的对应物。</p>
<div><p>虚拟处理器</p>
<p>利用多道程序设计技术把一个物理上的CPU虚拟为多个逻辑上的CPU。</p>
<p>虽然只有一个处理器，但它能同时为多个用户服务，使每个终端用户都感觉有一个中央处理器（CPU）在专门为它服务</p>
</div>
<p>操作系统的虚拟技术可以归纳为：时分复用技术（处理器的分时共享）、空分复用技术（虚拟存储器）</p>
<h3 id="_2-4-异步"> 2.4 异步</h3>
<p>多道程序环境允许多个程序并发执行，但由于资源有限，进程的执行并不是一贯到底的，而是走走停停，以不可预知的速度向前推进。</p>
<h2 id="三、操作系统的目标和功能"> 三、操作系统的目标和功能</h2>
<h3 id="_3-1-计算机系统资源的管理者"> 3.1 计算机系统资源的管理者</h3>
<ol>
<li>处理机管理。</li>
<li>存储器管理。</li>
<li>文件管理。</li>
<li>设备管理。</li>
</ol>
<h3 id="_3-2-用户与计算机硬件系统之间的接口"> 3.2 用户与计算机硬件系统之间的接口</h3>
<ol>
<li>命令接口。用户利用这些操作命令来组织和控制作业的执行</li>
<li>程序接口。编程人员使用他们来操作系统服务</li>
</ol>
<h3 id="_3-3-实现对计算机资源的扩充"> 3.3 实现对计算机资源的扩充</h3>
<p>操作系统所提供的资源管理功能和方便用户的各种服务功能</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-21T11:30:32.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">操作系统发展历程</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/1/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/1/2/"/>
    <updated>2022-04-03T01:20:59.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、手工操作阶段"> 一、手工操作阶段</h2>
<p>（此阶段无操作系统）</p>
<p>用户在计算机上算题的所有工作都要人工干预，如程序的装入、运行、结果的输出等。手工操作阶段有两个突出的缺点：</p>
<ol>
<li>用户独占全机，虽然不会出现因资源已被其他用户占用而等待的现象，但资源利用率低。</li>
<li>CPU等待手工操作，CPU的利用不充分。</li>
</ol>
<h2 id="二、批处理阶段"> 二、批处理阶段</h2>
<h3 id="_2-1-单道批处理系统"> 2.1 单道批处理系统</h3>
<p>系统对作业的处理是 <strong>成批进行的，但内存中始终保持一道作业</strong>。</p>
<ol>
<li>
<p>自动性。在顺利的情况下，磁带上的一批作业能自动地逐个运行，而无须人工干预。</p>
</li>
<li>
<p>顺序性。磁带上的各道作业顺序地进入内存，各道作业的完成顺序与它们进入内存的顺序在正常情况下应完全相同，亦即先调入内存的作业先完成。</p>
</li>
<li>
<p>单道性。内存中仅有一道程序运行，即监督程序每次从磁带上只调入一道程序进入内存运行，当该程序完成或发生异常情况时，才换入其后继程序进入内存运行。</p>
</li>
</ol>
<p>此时面临的问题是：每次主机内存中仅存放一道作业， 每当它在运行期间（注意这里是【运行时】而不是【完成后】）发出输入/输出请求后，高速的CPU便处于等待低速的I/O完成的状态。为了进一步提高资源的利用率和系统的吞吐量，引入了多道程序技术。</p>
<h3 id="_2-2-多道批处理系统"> 2.2 多道批处理系统</h3>
<p>多道程序设计的特点是 <strong>多道、宏观上并行、微观上串行</strong>。</p>
<p>多道程序设计技术允许多个程序同时进入内存并允许它们在CPU中交替地运行，这些程序共享系统中的各种硬/软件资源。当一道程序因I/O请求而暂停运行时，CPU便立即转去运行另一道程序。</p>
<ol>
<li>多道。计算机内存中同时存放多道相互独立的程序。</li>
<li>宏观上并行。同时进入系统的多道程序都处于运行过程中，即它们先后开始各自的运行，但都未运行完毕。</li>
<li>微观上串行。内存中的多道程序轮流占有CPU，交替执行。</li>
</ol>
<p>在批处理系统中采用多道程序设计技术就形成了多道批处理操作系统。该系统把用户提交的作业成批地送入计算机内存，然后由作业调度程序自动地选择作业运行。</p>
<p>优点：</p>
<ul>
<li>资源利用率高，多道程序共享计算机资源，从而使各种资源得到充分利用;</li>
<li>系统吞吐量大，CPU 和其他资源保持【忙碌】状态。</li>
</ul>
<p>缺点：</p>
<ul>
<li>用户响应的时间较长；</li>
<li>不提供人机交互能力，用户既不能了解自己的程序的运行情况，又不能控制计算机。</li>
</ul>
<h2 id="三、分时操作系统"> 三、分时操作系统</h2>
<p>所谓分时技术，是指把处理器的运行时间分成很短的时间片，<strong>按时间片轮流把处理器分配给各联机作业使用。</strong></p>
<blockquote>
<p>若某个作业在分配给它的时间片内不能完成其计算，则该作业暂时停止运行，把处理器让给其他作业使用，等待下一轮再继续运行。由于计算机速度很快，作业运行轮转得也很快，因此给每个用户的感觉就像是自己独占一台计算机。</p>
<p>分时系统也是支持多道程序设计的系统，但它不同于多道批处理系统。多道批处理是实现作业自动控制而无须人工干预的系统，而分时系统是实现人机交互的系统，这使得分时系统具有与批处理系统不同的特征。</p>
</blockquote>
<ol>
<li>同时性。同时性也称多路性，指允许多个终端用户同时使用一台计算机，即一台计算机与若干台终端相连接，终端上的这些用户可以同时或基本同时使用计算机。</li>
<li>交互性。用户能够方便地与系统进行人机对话，即用户通过终端采用人机对话的方式直接控制程序运行，与同程序进行交互。</li>
<li>独立性。系统中多个用户可以彼此独立地进行操作，互不干扰，单个用户感觉不到别人也在使用这台计算机，好像只有自己单独使用这台计算机一样。</li>
<li>及时性。用户请求能在很短时间内获得响应。分时系统采用时间片轮转方式使一台计算机同时为多个终端服务，使用户能够对系统的及时响应感到满意。</li>
</ol>
<p>虽然分时操作系统较好地解决了人机交互问题，但在一些应用场合，需要系统能对外部的信息在规定的时间（比时间片的时间还短）内做出处理（比如飞机订票系统或导弹制导系统），因此，实时操作系统应运而生。</p>
<h2 id="四、实时操作系统"> 四、实时操作系统</h2>
<p>为了能 <strong>在某个时间限制内完成某些紧急任务而不需要时间片排队</strong>，诞生了实时操作系统。这里的时间限制可以分为两种情况：</p>
<ul>
<li>硬实时系统：若某个动作必须绝对地在规定的时刻（或规定的时间范围）发生。如飞行器的飞行自动控制系统，这类系统必须提供绝对保证，让某个特定的动作在规定的时间内完成。</li>
<li>软实时系统：若能够接受偶尔违反时间规定且不会引起任何永久性的损害。如飞机订票系统、银行管理系统。</li>
</ul>
<p>在实时操作系统的控制下，计算机系统接收到外部信号后及时进行处理，并在严格的时限内处理完接收的事件。实时操作系统的主要特点是及时性和可靠性。</p>
<h2 id="五、网络操作系统和分布式计算机系统"> 五、网络操作系统和分布式计算机系统</h2>
<p>网络操作系统把计算机网络中的各台计算机有机地结合起来，提供一种统一 、经济而有效的使用各台计算机的方法，实现各台计算机之间数据的互相传送。<strong>网络操作系统最主要的特点是网络中各种资源的共享及各台计算机之间的通信。</strong></p>
<p>分布式计算机系统是由多台计算机组成并满足下列条件的系统：系统中任意两台计算机通过通信方式交换信息；系统中的每台计算机都具有同等的地位，即没有主机也没有从机；每台计算机上的资源为所有用户共享；系统中的任意台计算机都可以构成一个子系统，并且还能重构；任何工作都可以分布在几台计算机上，由它们并行工作、协同完成。用于管理分布式计算机系统的操作系统称为分布式计算机系统。该系统的主要特点是：分布性和并行性。分布式操作系统与网络操作系统的本质不同是，分布式操作系统中的若干计算机相互协同完成同一任务。</p>
<h2 id="六、个人计算机操作系统"> 六、个人计算机操作系统</h2>
<p>个人计算机操作系统是目前使用最广泛的操作系统,它广泛应用于文字处理、电子表格、游戏中，常见的有Windows、Linux和Macintosh等。</p>
<p><img src="./README.assets/image-20220321222954150.png" alt="image-20220321222954150" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-21T14:44:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">操作系统结构</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/1/4/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/1/4/"/>
    <updated>2022-04-03T02:09:53.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<p>随着操作系统功能的不断增多和代码规模的不断扩大，提供合理的结构，对于降低操作系统复杂度、提升操作系统安全与可靠性来说变得尤为重要。</p>
<h2 id="一、分层法"> 一、分层法</h2>
<p>分层法是将操作系统分为若干层，最底层（层0）为硬件，最高层（层N）为用户接口，每层只能调用紧邻它的低层的功能和服务（单向依赖）。这种分层结构如图1.4所示。</p>
<p><img src="./README.assets/image-20220326224711599.png" alt="image-20220326224711599" loading="lazy"></p>
<h3 id="_1-1-分层法的优点"> 1.1 分层法的优点</h3>
<ol>
<li><strong>便于系统的调试和验证，简化了系统的设计和实现</strong>。第1层可先调试而无须考虑系统的其他部分，因为它只使用了基本硬件。第1层调试完且验证正确之后，就可以调试第2层，如此向上。如果在调试某层时发现错误，那么错误应在这一层上，这是因为它的低层都调试好了。</li>
<li><strong>易扩充和易维护</strong>。在系统中增加、修改或替换一层中的模块或整层时，只要不改变相应层间的接口，就不会影响其他层。</li>
</ol>
<h3 id="_1-2-分层法的问题"> 1.2 分层法的问题</h3>
<ol>
<li><strong>合理定义各层比较困难</strong>。因为依赖关系固定后，往往就显得不够灵活。</li>
<li><strong>效率较差</strong>。操作系统每执行一个功能，通常要自上而下地穿越多层，各层之间都有相应的层间通信机制，这无疑增加了额外的开销，导致系统效率降低。</li>
</ol>
<h2 id="二、模块化"> 二、模块化</h2>
<p>模块化，是将操作系统按功能划分为若干具有一定独立性的模块。</p>
<p>每个模块具有某方面的管理功能，并规定好各模块间的接口，使各模块之间能够通过接口进行通信。还可以进一步将各模块细分为若干具有一定功能的子模块，同样也规定好各子模块之间的接口。这种设计方法被称为模块-接口法，图1.5 所示为由模块、子模块等组成的模块化操作系统结构。</p>
<p><img src="./README.assets/image-20220326224758824.png" alt="image-20220326224758824" loading="lazy"></p>
<p>在划分模块时，如果将模块划分得太小，虽然能降低模块本身的复杂性，但会使得模块之间的联系过多，造成系统比较混乱；如果模块划分得过大，又会增加模块内部的复杂性，显然应在两者间进行权衡。此外，在划分模块时，要充分考虑模块的独立性问题，因为模块独立性越高，各模块间的交互就越少，系统的结构也就越清晰。衡量模块的独立性主要有两个标准:</p>
<ul>
<li><strong>内聚性</strong>，模块内部各部分间联系的紧密程度。内聚性越高，模块独立性越好。</li>
<li><strong>耦合度</strong>， 模块间相互联系和相互影响的程度。耦合度越低，模块独立性越好。</li>
</ul>
<h3 id="_2-1-模块化的优点"> 2.1 模块化的优点</h3>
<ol>
<li>提高了操作系统设计的正确性、可理解性和可维护性</li>
<li>增强了操作系统的可适应性</li>
<li>加速了操作系统的开发过程。</li>
</ol>
<h3 id="_2-2-模块化的缺点"> 2.2 模块化的缺点</h3>
<ol>
<li>模块间的接口规定很难满足对接口的实际需求</li>
<li>各模块设计者齐头并进，每个决定无法建立在上一个已验证的正确决定的基础上，因此无法找到一个可靠的决定顺序。</li>
</ol>
<h2 id="三、宏内核"> 三、宏内核</h2>
<p>从操作系统的内核架构来划分，可分为宏内核和微内核。</p>
<p>宏内核，也称单内核或大内核，<strong>是指将系统的主要功能模块都作为一个紧密联系的整体运行在核心态</strong>，从而为用户程序提供高性能的系统服务。因为各管理模块之间共享信息，能有效利用相互之间的有效特性，所以具有无可比拟的性能优势。</p>
<p>随着体系结构和应用需求的不断发展，需要操作系统提供的服务越来越复杂，操作系统的设计规模急剧增长，操作系统也面临着“软件危机”困境。就像一个人，越胖活动起来就越困难。所以就出现了微内核技术，就是将一些非核心的功能移到用户空间，这种设计带来的好处是方便扩展系统，所有新服务都可以在用户空间增加，内核基本不用去做改动。</p>
<p>从操作系统的发展来看，宏内核获得了绝对的胜利，目前主流的操作系统，如Windows、Android、iOS、 macOS、 Linux 等，都是基于宏内核的构架。但也应注意到，微内核和宏内核一直是同步发展的，目前主流的操作系统早已不是当年纯粹的宏内核构架了，而是广泛吸取微内核构架的优点而后揉合而成的混合内核。当今宏内核构架遇到了越来越多的困难和挑战，而微内核的优势似乎越来越明显，尤其是谷歌的Fuchsia和华为的鸿蒙OS，都瞄准了微内核构架。</p>
<h2 id="四、微内核"> 四、微内核</h2>
<h3 id="_4-1-微内核的基本概念"> 4.1 微内核的基本概念</h3>
<p>微内核构架，<strong>是指将内核中最基本的功能保留在内核，而将那些不需要在核心态执行的功能移到用户态执行</strong>，从而降低内核的设计复杂性。那些移出内核的操作系统代码根据分层的原则被划分成若干服务程序，它们的执行相互独立，交互则都借助于微内核进行通信。</p>
<p>微内核结构将操作系统划分为两大部分：微内核和多个服务器。</p>
<p>微内核是指精心设计的、能实现操作系统最基本核心功能的小型内核，通常包含：</p>
<ol>
<li>与硬件处理紧密相关的部分</li>
<li>一些较基本的功能</li>
<li>客户和服务器之间的通信。</li>
</ol>
<p>这些部分只是为构建通用操作系统提供一个重要基础，这样就可以确保将内核做得很小。操作系统中的绝大部分功能都放在微内核外的一组服务器（进程）中实现，如用于提供对进程（线程）进行管理的进程（线程）服务器、提供虚拟存储器管理功能的虚拟存储器服务器等，它们都是作为进程来实现的，运行在用户态，客户与服务器之间是借助微内核提供的消息传递机制来实现交互的。图1.6展示了单机环境下的客户/服务器模式。</p>
<p><img src="./README.assets/image-20220326224907784.png" alt="image-20220326224907784" loading="lazy"></p>
<p>在微内核结构中，为了实现高可靠性，只有微内核运行在内核态，其余模块都运行在用户态，一个模块中的错误只会使这个模块崩溃，而不会使整个系统崩溃。例如，文件服务代码运行时出了问题，宏内核因为文件服务是运行在内核态的，系统直接就崩溃了。而微内核的文件服务是运行在用户态的，只要把文件服务功能强行停止，然后重启，就可以继续使用，系统不会崩溃。</p>
<h3 id="_4-2-微内核的基本功能"> 4.2 微内核的基本功能</h3>
<p>微内核结构通常利用【机制与策略分离】的原理来构造OS结构，将机制部分以及与硬件紧密相关的部分放入微内核。微内核通常具有如下功能：</p>
<ol>
<li>
<p><strong>进程（线程）管理</strong>。进程（线程）之间的通信功能是微内核OS最基本的功能，此外还有进程的切换、进程的调度，以及多处理机之间的同步等功能，都应放入微内核中。</p>
<blockquote>
<p>举个例子，为实现进程调度功能，需要在进程管理中设置一个或多个进程优先级队列，这部分属于调度功能的机制部分，应将它放入微内核中。</p>
<p>而对用户进程如何分类，以及优先级的确认方式，则属于策略问题，可将它们放入微内核外的进程管理服务器中。</p>
</blockquote>
</li>
<li>
<p><strong>低级存储器管理</strong>。在微内核中，只配置最基本的低级存储器管理机制.</p>
<blockquote>
<p>如用于实现将逻辑地址变换为物理地址等的页表机制和地址变换机制，这一部分是依赖于硬件的，因此放入微内核。</p>
<p>而实现虚拟存储器管理的策略，则包含应采取何种页面置换算法，采用何种内存分配与回收的策略，应将这部分放在微内核外的存储器管理服务器中。</p>
</blockquote>
</li>
<li>
<p><strong>中断和陷入处理</strong>。微内核OS将与硬件紧密相关的一小部分放入微内核，此时微内核的主要功能是捕获所发生的中断和陷入事件，并进行中断响应处理，在识别中断或陷入的事件后，再发送给相关的服务器来处理，故中断和陷入处理也应放入微内核。微内核操作系统将进程管理、存储器管理以及IO管理这些功能一分为二，属于机制的很小一部分放入微内核，而绝大部分放入微内核外的各种服务器实现，大多数服务器都要比微内核大。因此，在采用客户/服务器模式时，能把微内核做得很小。</p>
</li>
</ol>
<h3 id="_4-3-微内核的特点"> 4.3 微内核的特点</h3>
<p>微内核结构的优点主要有:</p>
<ol>
<li><strong>扩展性和灵活性</strong>。许多功能从内核中分离出米，当要修改某些功能或增加新功能时，只需在相应的服务器中修改或新增功能，或再增加一个专用的服务器，而无须改动内核代码。</li>
<li><strong>可靠性和安全性</strong>。</li>
<li><strong>可移植性</strong>。与CPU和I/O硬件有关的代码均放在内核中，而其他各种服务器均与硬件平台无关，因而将操作系统移植到另一个平台上所需做的修改是比较小的。</li>
<li><strong>分布式计算</strong>。客户和服务器之间、服务器和服务器之间的通信采用消息传递机制，这就使得微内核系统能很好地支持分布式系统和网络系统。</li>
</ol>
<p>微内核结构的主要问题是性能问题，因为需要频繁地在核心态和用户态之间进行切换，操作系统的执行开销偏大。为了改善运行效率，可以将那些频繁使用的系统服务移回内核，从而保证系统性能，但这又会使微内核的容量明显地增大。</p>
<p>虽然宏内核在桌面操作系统中取得了绝对的胜利，但是微内核在实时、工业、航空及军事应用中特别流行，这些领域都是关键任务，需要有高度的可靠性。</p>
<h2 id="五、外核"> 五、外核</h2>
<p>不同于虚拟机克隆真实机器，另一种策略是对机器进行分区，给每个用户整个资源的一个子集。这样，某个虚拟机可能得到磁盘的0至1023盘块，而另一台虚拟机会得到磁盘的1024至2047盘块，等等。在底层中，一种称为外核(exokernel) 的程序在内核态中运行。</p>
<p>它的任务是为虚拟机分配资源，并检查使用这些资源的企图，以确保没有机器会使用他人的资源。每个用户层的虚拟机可以运行自己的操作系统，但限制只能使用已经申请并且获得分配的那部分资源。</p>
<p>外核机制的优点是 <strong>减少了映射层</strong>。在其他的设计中，每个虛拟机都认为它有自己的磁盘，其盘块号从0到最大编号，这样虚拟机监控程序就必须维护-张表格以重映像磁盘地址（或其他资源），有了外核，这个重映射处理就不需要了。外核只需要记录已经分配给各个虚拟机的有关资源即可。这种方法还有一个优点，它将多道程序（在外核内）与用户操作系统代码（在用户空间内）加以分离，而且相应的负载并不重，因为外核所做的只是保持多个虚拟机彼此不发生冲突。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-26T15:22:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">虚拟机</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/1/6/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/1/6/"/>
    <updated>2022-04-14T02:45:22.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<p>虚拟机是一台【逻辑计算机】，<strong>利用特殊的虚拟化技术，通过隐藏特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境</strong>。有两类虚拟化方法。</p>
<h2 id="第一类虚拟机管理程序"> 第一类虚拟机管理程序</h2>
<p>从技术上讲，第一类虚拟机管理程序就像一个操作系统，因为它是唯一一个运行在最高特权级的程序。</p>
<p>它在裸机上运行并且具备多道程序功能。虚拟机管理程序向上层提供若干台虚拟机，这些虚拟机是裸机硬件的精确复制品。由于每台虚拟机都与裸机相同，所以在不同的虚拟机上可以运行任何不同的操作系统。</p>
<p><img src="./README.assets/image-20220403101411472.png" alt="image-20220403101411472" loading="lazy"></p>
<p><strong>虚拟机作为用户态的一个进程运行，不允许执行敏感指令。然而，虚拟机上的操作系统认为自己运行在内核态（实际上不是）</strong>，称为【虚拟内核态】。虚拟机中的用户进程认为自己运行在用户态（实际上确实是）。</p>
<p>当虚拟机操作系统执行了一条CPU处于内核态才允许执行的指令时，会陷入虚拟机管理程序。在支持虚拟化的CPU上，虚拟机管理程序检查这条指令是由虚拟机中的操作系统执行的还是由用户程序执行的。如果是前者，虚拟机管理程序将安排这条指令功能的正确执行。否则，虚拟机管理程序将模拟真实硬件面对用户态执行敏感指令时的行为。</p>
<p>在过去不支持虚拟化的CPU上， 真实硬件不会直接执行虚拟机中的敏感指令，这些敏感指令被转为对虚拟机管理程序的调用，由虚拟机管理程序模拟这些指令的功能。</p>
<h2 id="第二类虚拟机管理程序"> 第二类虚拟机管理程序</h2>
<p><img src="./README.assets/image-20220403101424923.png" alt="image-20220403101424923" loading="lazy"></p>
<p>它是一个依赖于Windows. Linux等操作系统分配和调度资源的程序，很像一个普通的进程。</p>
<p><strong>第二类虚拟机管理程序仍然伪装成具有</strong>CPU和各种设备的完整计算机。VMware Workstation是首个X86平台上的第二类虚拟机管理程序。运行在两类虚拟机管理程序上的操作系统都称为客户操作系统。对于第二类虚拟机管理程序，运行在底层硬件上的操作系统称为宿主操作系统。首次启动时，第二类虚拟机管理程序像一台刚启动的计算机那样运转，期望找到的驱动器可以是虚拟设备。然后将操作系统安装到虚拟磁盘上（其实只是宿主操作系统中的一一个文件）。客户操作系统安装完成后，就能启动并运行。</p>
<p>虚拟化在Web主机领域很流行。没有虚拟化，服务商只能提供共享托管（不能控制服务器的软件）和独占托管（成本较高）。当服务商提供租用虚拟机时，一台物理服务器就可以运行多个虚拟机，每个虚拟机看起来都是一台完整的服务器，客户可以在虚拟机上安装自己想用的操作系统和软件，但是只需支付较低的费用。这就是市面上常见的“云”主机。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-30T05:41:25.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">操作系统运行环境</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/1/3/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/1/3/"/>
    <updated>2022-04-14T01:40:30.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
<li><a href="https://blog.csdn.net/lidandan2016/article/details/53437273" target="_blank" rel="noopener noreferrer">可屏蔽中断和非屏蔽中断区别</a></li>
</ul>
</div>
<h2 id="一、处理器运行模式"> 一、处理器运行模式</h2>
<p>计算机系统中，通常CPU执行两种不同性质的程序：</p>
<ul>
<li>一种是操作系统内核程序，能够执行一些特权指令；</li>
<li>另一种是用户自编程序（即系统外层的应用程序，或简称“应用程序”），出于安全考虑不能执行这些指令。</li>
</ul>
<div><p>特权指令</p>
<p>特权指令是指不允许用户直接使用的指令，如I/O指令、置中断指令，存取用于内存保护的寄存器、送程序状态字到程序状态字寄存器等的指令。</p>
<p>非特权指令，是指允许用户直接使用的指令，它不能直接访问系统中的软硬件资源，仅限于访问用户的地址空间，这也是为了防止用户程序对系统造成破坏。</p>
</div>
<p>在具体实现上，将CPU的运行模式划分为 <mark>用户态</mark>（目态）和 <mark>核心态</mark>（又称管态、内核态）。</p>
<p>一些与硬件关联较紧密的模块，如时钟管理、中断处理、设备驱动等处于最低层。其次是运行频率较高的程序，如进程管理、存储器管理和设备管理等。这两部分内容构成了操作系统的内核。这部分内容的指令操作工作在核心态。</p>
<h3 id="_1-1-时钟管理"> 1.1 时钟管理</h3>
<p>在计算机的各种部件中，时钟是最关键的设备。</p>
<ul>
<li>计时，操作系统需要通过时钟管理，向用户提供标准的系统时间。</li>
<li>通过时钟中断的管理，实现进程的切换。</li>
</ul>
<h3 id="_1-2-中断机制"> 1.2 中断机制</h3>
<div><p>中断</p>
<p>中断是指计算机运行过程中，出现某些意外情况需主机干预时，机器能自动停止正在运行的程序并转入处理新情况的程序，处理完毕后又返回原被暂停的程序继续运行。</p>
</div>
<p>引入中断技术的初衷是 <strong>提高多道程序运行环境中CPU的利用率</strong>，而且主要是针对外部设备的。后来逐步得到发展，形成了多种类型，成为操作系统各项操作的基础。例如，键盘或鼠标信息的输入、进程的管理和调度、系统功能的调用、设备驱动、文件访问等，无不依赖于中断机制。可以说，现代操作系统是靠中断驱动的软件。</p>
<p><u>中断机制中，只有一小部分功能属于内核，它们负责保护和恢复中断现场的信息，转移控制权到相关的处理程序。这样可以减少中断的处理时间，提高系统的并行处理能力。</u></p>
<h3 id="_1-3-原语"> 1.3 原语</h3>
<div><p>原语</p>
<p>一般是指由若干条指令组成的程序段，用来实现某个特定功能，在执行过程中不可被中断</p>
</div>
<p>按层次结构设计的操作系统，底层必然是一些可被调用的公用小程序，它们各自完成一个规定的操作。它们的特点如下:</p>
<ol>
<li>处于操作系统的最低层，是最接近硬件的部分。</li>
<li>这些程序的运行具有原子性，其操作只能一气呵成（出于系统安全性和便于管理考虑）。</li>
<li>这些程序的运行时间都较短，而且调用频繁。</li>
</ol>
<h3 id="_1-4-系统控制的数据结构及处理"> 1.4 系统控制的数据结构及处理</h3>
<p>系统中用来登记状态信息的数据结构很多，如作业控制块、进程控制块（PCB）、 设备控制块、各类链表、消息队列、缓冲区、空闲区登记表、内存分配表等。为了实现有效的管理，系统需要一些基本的操作，常见的操作有以下3种:</p>
<ol>
<li>进程管理。进程状态管理、进程调度和分派、创建与撤销进程控制块等。</li>
<li>存储器管理。存储器的空间分配和回收、内存信息保护程序、代码对换程序等。</li>
<li>设备管理。缓冲区管理、设备分配和回收等。</li>
</ol>
<h2 id="二、中断和异常的概念"> 二、中断和异常的概念</h2>
<p>在操作系统中引入核心态和用户态这两种工作状态后，就需要考虑这两种状态之间如何切换。</p>
<blockquote>
<p>系统不允许用户程序实现核心态的功能，而它们又必须使用这些功能。因此，需要在核心态建立一些【门】，以便实现从用户态进入核心态。在实际操作系统中，CPU运行上层程序时唯一能进入这些 “门”的途径就是通过中断或异常。</p>
<p>发生中断或异常时，运行用户态的CPU会立即进入核心态，这是通过硬件实现的（例如，用一个特殊寄存器的一位来表示CPU所处的工作状态，0表示核心态，1表示用户态。若要进入核心态，则只需将该位置0即可）。</p>
</blockquote>
<h3 id="_2-1-中断和异常的定义"> 2.1 中断和异常的定义</h3>
<div><p>中断</p>
<p>中断是指CPU对系统发生某事件时的这样一种响应</p>
<p>CPU 暂停正在执行的程序，在保留现场后自动地转去执行该事件的中断处理程序；执行完后，再返回到原程序的断点处继续执行。</p>
</div>
<ul>
<li>外中断——就是我们指的 <strong>中断</strong>，是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；</li>
<li>内中断——就是 <strong>异常</strong>，是指由于 CPU 内部事件所引起的中断，如程序出错（非法指令、地址越界）。内中断(trap)也被译为【<strong>捕获</strong>】或【<strong>陷入</strong>】。</li>
</ul>
<h3 id="_2-2-中断和异常的分类"> 2.2 中断和异常的分类</h3>
<p><img src="./README.assets/image-20220322221030218.png" alt="image-20220322221030218" loading="lazy"></p>
<p>外中断可分为可屏蔽中断和不可屏蔽中断。</p>
<ul>
<li>可屏蔽中断。是指通过INTR线发出的中断请求，通过改变屏蔽字可以实现多重中断，从而使得中断处理更加灵活。</li>
<li>不可屏蔽中断。是指通过NMI线发出的中断请求，通常是紧急的硬件故障，如电源掉电等。此外，异常也是不能被屏蔽的。</li>
</ul>
<div><p>可屏蔽中断和非屏蔽中断</p>
<p><a href="https://blog.csdn.net/lidandan2016/article/details/53437273" target="_blank" rel="noopener noreferrer">可屏蔽中断和非屏蔽中断区别</a></p>
<p>按照是否可以被屏蔽，可将中断分为两大类：不可屏蔽中断（又叫非屏蔽中断）和可屏蔽中断。</p>
<p>不可屏蔽中断源一旦提出请求，cpu必须无条件响应，而对于可屏蔽中断源的请求，cpu可以响应，也可以不响应。cup一般设置两根中断请求输入线：可屏蔽中断请求INTR(Interrupt Require)和不可屏蔽中断请求NMI(Nonmaskable Interrupt)。对于可屏蔽中断，除了受本身的屏蔽位的控制外，还都要受一个总的控制，即CPU标志寄存器中的中断允许标志位IF(Interrupt Flag)的控制，IF位为1，可以得到CPU的响应，否则，得不到响应。IF位可以有用户控制，指令STI或Turbo c的Enable()函数，将IF位置1(开中断)，指令CLI或Turbo_c 的Disable()函数，将IF位清0(关中断)。</p>
<p>典型的非屏蔽中断源的例子是电源掉电，一旦出现，必须立即无条件地响应，否则进行其他任何工作都是没有意义的。典型的可屏蔽中断源的例子是打印机中断，CPU对打印机中断请求的响应可以快一些，也可以慢一些，因为让打印机等待儿是完全可以的。</p>
</div>
<hr>
<p>异常可分为故障、自陷和终止。</p>
<p><a href="https://blog.csdn.net/u011240016/article/details/53117093" target="_blank" rel="noopener noreferrer">中断和异常的再总结</a></p>
<ul>
<li>故障(Fault) 。通常是由 <strong>指令执行引起的异常</strong>，如非法操作码、缺页故障、除数为0、运算溢出等。</li>
<li>自陷(Trap) 。是一种 <strong>事先安排</strong> 的异常事件，用于在用户态下调用操作系统内核程序，如条件陷阱指令。</li>
<li>终止(Abort)。是指出现了使得CPU无法继续执行的 <strong>硬件故障</strong>，如控制器出错、存储器校验错等。</li>
</ul>
<p>故障异常和自陷异常属于软件中断（程序性异常），终止异常和外部中断属于硬件中断。</p>
<h3 id="_2-3-中断和异常的处理过程"> 2.3 中断和异常的处理过程</h3>
<p>中断和异常处理过程的大致描述如下：当CPU在执行用户程序的第i条指令时检测到一个异常事件，或在执行第 i 条指令后发现一个中断请求信号，则CPU打断当前的用户程序，然后转到相应的中断或异常处理程序去执行。</p>
<p>若中断或异常处理程序能够解决相应的问题，则在中断或异常处理程序的最后，CPU通过执行中断或异常返回指令，回到被打断的用户程序的第i条指令或第i + 1条指令继续执行；</p>
<p>若中断或异常处理程序发现是不可恢复的致命错误，则终止用户程序。通常情况下，对中断和异常的具体处理过程由操作系统（和驱动程序）完成。</p>
<h2 id="三、系统调用"> 三、系统调用</h2>
<p>所谓系统调用，是指用户在程序中调用操作系统所提供的一些子功能，系统调用可视为特殊的公共子程序。系统中的各种共享资源都由操作系统统一掌管，因此在用户程序中，凡是与资源有关的操作（如存储分配、进行I/O传输及管理文件等），都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及始址等功能。</li>
</ul>
<p>显然，系统调用相关功能涉及系统资源管理、进程管理之类的操作，对整个系统的影响非常大，因此必定需要使用某些特权指令才能完成，所以系统调用的处理需要由操作系统内核程序负责完成，要运行在核心态。</p>
<p><mark><strong>用户程序可以执行陷入指令（又称访管指令或trap指令）来发起系统调用，请求操作系统提供服务。</strong></mark></p>
<blockquote>
<p>可以这么理解，用户程序执行【陷入指令】，相当于把CPU的使用权主动交给操作系统内核程序（CPU状态会从用户态进入核心态），之后操作系统内核程序再对系统调用请求做出相应处理。处理完成后，操作系统内核程序又会把CPU的使用权还给用户程序（即CPU状态会从核心态回到用户态）。</p>
</blockquote>
<p>这么设计的目的是：用户程序不能直接执行对系统影响非常大的操作，必须通过系统调用的方式请求操作系统代为执行，以便保证系统的稳定性和安全性，防止用户程序随意更改或访问重要的系统资源，影响其他进程的运行。</p>
<blockquote>
<p>这样，操作系统的运行环境就可以理解为：用户通过操作系统运行上层程序（如系统提供的命令解释程序或用户自编程序），而这个上层程序的运行依赖于操作系统的底层管理程序提供服务支持，当需要管理程序服务时，系统则通过硬件中断机制进入核心态，运行管理程序；也可能是程序运行出现异常情况，被动地需要管理程序的服务，这时就通过异常处理来进入核心态。管理程序运行结束时，用户程序需要继续运行，此时通过相应的保存的程序现场退出中断处理程序或异常处理程序，返回断点处继续执行，如图1.3 所示。</p>
</blockquote>
<p><img src="./README.assets/image-20220322214557135.png" alt="image-20220322214557135" loading="lazy"></p>
<p>在操作系统这一层面 上，我们关心的是系统核心态和用户态的软件实现与切换，对于硬件层面的具体理解，可以结合“计算机组成原理”课程中有关中断的内容进行学习。下面列举一些由用户态转向核心态的例子:</p>
<ol>
<li>用户程序要求操作系统的服务，即系统调用。</li>
<li>发生一次中断。</li>
<li>用户程序中产生了一个错误状态。</li>
<li>用户程序中企图执行一条特权指令。</li>
<li>从核心态转向用户态由一条指令实现，这条指令也是特权命令，一般是中断返回指令。</li>
</ol>
<p>注意：由用户态进入核心态，不仅状态需要切换，而且所用的堆栈也可能需要由用户堆栈切换为系统堆栈，但这个系统堆栈也是属于该进程的。</p>
<p>若程序的运行由用户态转到核心态，则会用到访管指令，访管指令是在用户态使用的，所以它不可能是特权指令。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-22T14:19:51.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">进程与线程</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/2/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/2/1/"/>
    <updated>2022-04-14T02:45:22.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
<li><a href="https://www.cnblogs.com/zgq0/p/8780893.html" target="_blank" rel="noopener noreferrer">进程间的五种通信方式介绍 - moon-zhu</a></li>
<li><a href="https://blog.csdn.net/ShenHang_/article/details/106674378" target="_blank" rel="noopener noreferrer">linux 进程间通信-FIFO（有名管道）<em>ShenHang</em></a></li>
<li><a href="https://zhuanlan.zhihu.com/p/268389190" target="_blank" rel="noopener noreferrer">Linux进程间通信——消息队列</a></li>
<li><a href="https://blog.csdn.net/weixin_39138071/article/details/80231760" target="_blank" rel="noopener noreferrer">用户级线程与核心级线程_成天天的博客</a></li>
</ul>
</div>
<h2 id="一、进程的概念和特征"> 一、进程的概念和特征</h2>
<h3 id="_1-1-进程的概念"> 1.1 进程的概念</h3>
<blockquote>
<p>在多道程序环境下，允许多个程序并发执行，此时它们将失去封闭性，并具有间断性及不可再现性的特征。</p>
</blockquote>
<p>为此引入了 <mark>进程(Process)</mark> 的概念，以便更好地描述和控制程序的并发执行，实现操作系统的 <strong>并发性和共享性</strong>。</p>
<p>为了使参与并发执行的每个程序（含数据）都能独立地运行，必须为之配置一个专门的数据结构，称为 <mark>进程控制块(Process Control Block，PCB)</mark> 。</p>
<p>系统利用PCB来描述进程的基本情况和运行状态，进而控制和管理进程。相应地，<strong>由程序段、相关数据段和PCB三部分构成了进程实体（又称进程映像）</strong>。</p>
<blockquote>
<p>所谓创建进程，实质上是创建进程实体中的PCB；而撤销进程，实质上是撤销进程的PCB。值得注意的是，进程映像是静态的，进程则是动态的。注意：PCB是进程存在的唯一标志!从不同的角度，进程可以有不同的定义，比较典型的定义有:</p>
<ol>
<li>进程是程序的一次执行过程。</li>
<li>进程是一个程序及其数据在处理机上顺序执行时所发生的活动。</li>
<li>进程是具有独立功能的程序在一个数据集合上运行的过程，它是系统进行资源分配和调度的一个独立单位。</li>
</ol>
</blockquote>
<div><p>进程</p>
<p>进程是进程实体的运行过程，是系统进行资源分配和调度的一个独立单位。</p>
</div>
<p>系统资源，指处理机、存储器和其他设备服务于某个进程的【时间】，例如把处理机资源理解为处理机的时间片才是准确的。因为进程是这些资源分配和调度的独立单位，即【时间片】分配的独立单位，这就决定了进程一定是一个动态的、过程性的概念。</p>
<h3 id="_1-2-进程的特征"> 1.2 进程的特征</h3>
<p>进程是由多道程序的并发执行而引出的，它和程序是两个截然不同的概念。进程的基本特征是对比单个程序的顺序执行提出的，也是对进程管理提出的基本要求。</p>
<ol>
<li><strong>动态性</strong>。进程是程序的一次执行，它有着创建、活动、暂停、终止等过程，具有一定的生命周期，是动态地产生、变化和消亡的。动态性是进程最基本的特征。</li>
<li><strong>并发性</strong>。指多个进程实体同存于内存中，能在一段时间内同时运行。引入进程的目的就是使进程能和其他进程并发执行。并发性是进程的重要特征，也是操作系统的重要特征。</li>
<li><strong>独立性</strong>。指进程实体是一个能独立运行、独立获得资源和独立接受调度的基本单位。凡未建立PCB的程序，都不能作为一个独立的单位参与运行。</li>
<li><strong>异步性</strong>。由于进程的相互制约，使得进程按各自独立的、不可预知的速度向前推进。异步性会导致执行结果的不可再现性，为此在操作系统中必须配置相应的进程同步机制。</li>
</ol>
<h2 id="二、进程的状态与转换"> 二、进程的状态与转换</h2>
<p>进程在其生命周期内，由于系统中各进程之间的相互制约及系统的运行环境的变化，使得进程的状态也在不断地发生变化。通常进程有以下5种状态，前3种是进程的基本状态。</p>
<ol>
<li><strong>运行态</strong>。进程正在处理机上运行。在单处理机中，每个时刻只有一个进程处于运行态。</li>
<li><strong>就绪态</strong>。进程获得了除处理机外的一切所需资源，一旦得到处理机，便可立即运行。系统中处于就绪状态的进程可能有多个，通常将它们排成一个队列，称为就绪队列。</li>
<li><strong>阻塞态</strong>，又称等待态。进程正在等待某一事件而暂停运行，如等待某资源为可用（不包括处理机）或等待输入/输出完成。即使处理机空闲，该进程也不能运行。系统通常将处于阻塞态的进程也排成一个队列，甚至根据阻塞原因的不同，设置多个阻塞队列。</li>
<li><strong>创建态</strong>。进程正在被创建，尚未转到就绪态。创建进程需要多个步骤：首先申请一个空白PCB，并向PCB中填写用于控制和管理进程的信息；然后为该进程分配运行时所必须的资源；最后把该进程转入就绪态并插入就绪队列。但是，如果进程所需的资源尚不能得到满足，如内存不足，则创建工作尚未完成，进程此时所处的状态称为创建态。</li>
<li><strong>结束态</strong>。进程正从系统中消失，可能是进程正常结束或其他原因退出运行。进程需要结束运行时，系统首先将该进程置为结束态，然后进一步处理资源释放和回收等工作。</li>
</ol>
<div><p>注意区别就绪态和等待态</p>
<p>就绪态是指进程仅缺少处理器，只要获得处理机资源就立即运行；而等待态是指进程需要其他资源（除了处理机）或等待某一事件。 之所以把处理机和其他资源划分开，是因为在分时系统的时间片轮转机制中，每个进程分到的时间片是若干毫秒。也就是说，进程得到处理机的时间很短且非常频繁，进程在运行过程中实际上是频繁地转换到就绪态的；而其他资源（如外设）的使用和分配或某一事件的发生（如I/O操作的完成）对应的时间相对来说很长，进程转换到等待态的次数也相对较少。这样来看，就绪态和等待态是进程生命周期中两个完全不同的状态，显然需要加以区分。</p>
</div>
<p>图2.1说明了5种进程状态的转换，而3种基本状态之间的转换如下：</p>
<ul>
<li>就绪态→运行态：处于就绪态的进程被调度后，<strong>获得处理机资源</strong>（分派处理机时间片），于是进程由就绪态转换为运行态。</li>
<li>运行态→就绪态：<strong>处于运行态的进程在时间片用完后</strong>，不得不让出处理机，从而进程由运行态转换为就绪态。此外，在可剥夺的操作系统中，当有更高优先级的进程就绪时，调度程序将正在执行的进程转换为就绪态，让更高优先级的进程执行。</li>
<li>运行态→阻塞态：进程请求某一资源（如外设）的使用和分配或等待某一事件的发生（如I/O操作的完成）时，它就从运行态转换为阻塞态。<u>进程以系统调用的形式请求操作系统提供服务</u>，这是一种特殊的、由运行用户态程序调用操作系统内核过程的形式。</li>
<li>阻塞态→就绪态：进程等待的事件到来时，如IO操作结束或中断结束时，中断处理程序必须把相应进程的状态由阻塞态转换为就绪态。</li>
</ul>
<p><img src="./README.assets/image-20220330144304759.png" alt="image-20220330144304759" loading="lazy"></p>
<p>需要注意的是，一个进程从运行态变成阻塞态是主动的行为，而从阻塞态变成就绪态是被动的行为，需要其他相关进程的协助。</p>
<div><p>疑问 —— 时间片轮转算法当中，时间片用完的进程在让出处理机的时候，需要让出资源吗？</p>
</div>
<h2 id="三、进程的组织"> 三、进程的组织</h2>
<p>进程是一个独立的运行单位，也是操作系统进行资源分配和调度的基本单位。它由以下三部分组成，其中最核心的是进程控制块(PCB)。</p>
<h3 id="_3-1-进程控制块"> 3.1 进程控制块</h3>
<p>进程创建时，操作系统为它新建一个PCB，该结构之后常驻内存，任意时刻都可以存取，并在进程结束时删除。<mark>PCB是进程实体的一部分， 是进程存在的唯一标志</mark> 。</p>
<blockquote>
<p>进程执行时，系统通过其PCB了解进程的现行状态信息，以便操作系统对其进行控制和管理；进程结束时，系统收回其PCB，该进程随之消亡。</p>
</blockquote>
<div><p>操作</p>
<ul>
<li>当操作系统欲调度某进程运行时，要从该进程的PCB中查出其现行状态及优先级；</li>
<li>在调度到某进程后，要根据其PCB中所保存的处理机状态信息，设置该进程恢复运行的现场，并根据其PCB中的程序和数据的内存始址，找到其程序和数据；</li>
<li>进程在运行过程中，当需要和与之合作的进程实现同步、通信或访问文件时，也需要访问PCB；</li>
<li>当进程由于某种原因而暂停运行时，又需将其断点的处理机环境保存在PCB中。</li>
</ul>
</div>
<p>PCB主要包括进程描述信息、进程控制和管理信息、资源分配清单和处理机相关信息等。各部分的主要说明如下：</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程描述信息</th>
<th style="text-align:center">进程控制和管理信息</th>
<th style="text-align:center">资源分配清单</th>
<th style="text-align:center">处理机相关信息</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">进程标识符 PID</td>
<td style="text-align:center">进程当前状态</td>
<td style="text-align:center">代码段指针</td>
<td style="text-align:center">通用寄存器值</td>
</tr>
<tr>
<td style="text-align:center">用户标识符 UID</td>
<td style="text-align:center">进程优先级</td>
<td style="text-align:center">数据段指针</td>
<td style="text-align:center">地址寄存器值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">代码运行入口地址</td>
<td style="text-align:center">堆栈段指针</td>
<td style="text-align:center">控制寄存器值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">程序的外存地址</td>
<td style="text-align:center">文件描述符</td>
<td style="text-align:center">标志寄存器值</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">进入内存时间</td>
<td style="text-align:center">键盘</td>
<td style="text-align:center">状态字</td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">处理机占用时间</td>
<td style="text-align:center">鼠标</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center"></td>
<td style="text-align:center">信号量使用</td>
<td style="text-align:center"></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p><strong>资源分配清单</strong>，用于说明有关内存地址空间或虚拟地址空间的状况，所打开文件的列表和所使用的输入/输出设备信息。</p>
<p><strong>处理机相关信息</strong>，也称处理机的上下文，主要指处理机中各寄存器的值。当进程处于执行态时，处理机的许多信息都在寄存器中。当进程被切换时，处理机状态信息都必须保存在相应的PCB中，以便在该进程重新执行时，能从断点继续执行。</p>
<div><p>PCB的组织方式</p>
<ul>
<li>链接方式。将同一状态的PCB链接成一个队列，不同状态对应不同的队列，也可把处于阻塞态的进程的PCB，根据其阻塞原因的不同，排成多个阻塞队列。</li>
<li>索引方式。将同一状态的进程组织在一个索引表中，索引表的表项指向相应的PCB，不同状态对应不同的索引表，如就绪索引表和阻塞索引表等。</li>
</ul>
</div>
<h3 id="_3-2-程序段"> 3.2 程序段</h3>
<p>程序段就是能被进程调度程序调度到CPU执行的程序代码段。注意，程序可被多个进程共享，即多个进程可以运行同一个程序。</p>
<h3 id="_3-3-数据段"> 3.3 数据段</h3>
<p>一个进程的数据段，可以是进程对应的程序加工处理的原始数据，也可以是程序执行时产生的中间或最终结果。</p>
<h2 id="四、进程控制"> 四、进程控制</h2>
<p>进程控制的主要功能是对系统中的所有进程实施有效的管理，它具有创建新进程、撤销已有进程、实现进程状态转换等功能。在操作系统中，一般把进程控制用的程序段称为原语， 原语的特点是执行期间不允许中断，它是一个不可分割的基本单位。</p>
<h3 id="_4-1-进程的创建"> 4.1 进程的创建</h3>
<p>允许一个进程创建另一个进程，此时创建者称为父进程，被创建的进程称为子进程。子进程可以继承父进程所拥有的资源。当子进程被撤销时，应将其从父进程那里获得的资源归还给父进程。此外，在撤销父进程时，通常也会同时撤销其所有的子进程。</p>
<p>在操作系统中，终端用户登录系统、作业调度、系统提供服务、用户程序的应用请求等都会引起进程的创建。</p>
<div><p>创建原语</p>
<p>操作系统创建一个新进程的过程如下：</p>
<ol>
<li>为新进程分配一个唯一的进程标识号，并申请一个空白PCB（PCB是有限的）。若PCB申请失败，则创建失败。</li>
<li>为进程分配其运行所需的资源，如内存、文件、I/O 设备和CPU时间等（在PCB中体现）。这些资源或从操作系统获得，或仅从其父进程获得。如果资源不足（如内存），则并不是创建失败，而是处于创建态，等待内存资源。</li>
<li>初始化PCB，主要包括初始化标志信息、初始化处理机状态信息和初始化处理机控制信息，以及设置进程的优先级等。</li>
<li>若进程就绪队列能够接纳新进程，则将新进程插入就绪队列，等待被调度运行。</li>
</ol>
</div>
<h3 id="_4-2-进程的终止"> 4.2 进程的终止</h3>
<p>引起进程终止的事件主要有:</p>
<ol>
<li>正常结束，表示进程的任务已完成并准备退出运行。</li>
<li>异常结束，表示进程在运行时，发生了某种异常事件，使程序无法继续运行，如存储区越界、保护错、非法指令、特权指令错、运行超时、算术运算错、IO故障等。</li>
<li>外界干预，指进程应外界的请求而终止运行，如操作员或操作系统干预、父进程请求和父进程终止。</li>
</ol>
<div><p>终止原语</p>
<p>操作系统终止进程的过程如下：</p>
<ol>
<li>根据被终止进程的标识符，检索出该进程的PCB，从中读出该进程的状态。</li>
<li>若被终止进程处于执行状态，立即终止该进程的执行，将处理机资源分配给其他进程。</li>
<li>若该进程还有子孙进程，则应将其所有子孙进程终止。</li>
<li>将该进程所拥有的全部资源，或归还给其父进程，或归还给操作系统。</li>
<li>将该PCB从所在队列（链表）中删除。</li>
</ol>
</div>
<h3 id="_4-3-进程的阻塞和唤醒"> 4.3 进程的阻塞和唤醒</h3>
<p>正在执行的进程，由于期待的某些事件未发生，如请求系统资源失败、等待某种操作的完成、新数据尚未到达或无新任务可做等，进程便通过调用阻塞原语(Block)，使自己由运行态变为阻塞态。</p>
<p>可见，<strong>阻塞是进程自身的一种主动行为</strong>，也因此只有处于运行态的进程（获得CPU），才可能将其转为阻塞态。</p>
<div><p>阻塞原语</p>
<ol>
<li>找到将要被阻塞进程的标识号对应的PCB.</li>
<li>若该进程为运行态，则保护其现场，将其状态转为阻塞态，停止运行。</li>
<li>把该PCB插入相应事件的等待队列，将处理机资源调度给其他就绪进程。</li>
</ol>
</div>
<p>当被阻塞进程所期待的事件出现时，如它所启动的I/O操作已完成或其所期待的数据已到达，由有关进程（比如，释放该I/O设备的进程，或提供数据的进程）调用唤醒原语(Wakeup), 将等待该事件的进程唤醒。</p>
<div><p>唤醒原语</p>
<ol>
<li>在该事件的等待队列中找到相应进程的PCB。</li>
<li>将其从等待队列中移出，并置其状态为就绪态。</li>
<li>把该PCB插入就绪队列，等待调度程序调度。</li>
</ol>
</div>
<p>应当注意，Block 原语和 Wakeup 原语是一对作用刚好相反的原语，必须成对使用。如果在某进程中调用了Block 原语，则必须在与之合作的或其他相关的进程中安排一条相应的 Wakeup 原语，以便唤醒阻寨进程。否则，阳寒进程将会因不能被唤醒而永久地处千阻塞状态。</p>
<h2 id="五、进程的通信"> 五、进程的通信</h2>
<p>进程通信（IPC，InterProcess Communication）是指进程之间的信息交换。PV操作是低级通信方式，高级通信方式是指以较高的效率传输大量数据的通方式。</p>
<h3 id="_5-1-管道"> 5.1 管道</h3>
<p>管道，通常指无名管道，是 UNIX 系统IPC最古老的形式。</p>
<div><p>特点</p>
<ol>
<li>半双工。数据在某一时刻只能在一个方向上流动。</li>
<li>只能用于具有亲缘关系的进程之间的通信。父子进程或兄弟进程之间。</li>
<li>特殊的文件。可以使用 read、write，但不属于任何文件系统， <mark>只存在于内存</mark></li>
</ol>
</div>
<p>为了协调双方的通信，管道机制必须提供以下三方面的协调能力：互斥、同步和确定对方的存在。</p>
<p><img src="./README.assets/323808-20160311094030069-935122142.png" alt="img" loading="lazy"></p>
<p>若要数据流从父进程流向子进程，则关闭父进程的读端（<code>fd[0]</code>）与子进程的写端（<code>fd[1]</code>）；反之，则可以使数据流从子进程流向父进程。</p>
<h3 id="_5-2-fifo"> 5.2 FIFO</h3>
<p>FIFO，也称为命名管道，它是一种文件类型。</p>
<div><p>特点</p>
<ol>
<li>FIFO可以在无关的进程之间交换数据</li>
<li>FIFO有路径名与之相关联，是一种特殊设备文件形式</li>
</ol>
</div>
<p>FIFO是Linux基础文件类型中的一种。但，FIFO文件在磁盘上没有数据块，仅仅用来标识内核中一条通道。各进程可以打开这个文件进行read/write，实际上是在 <mark>读写内核通道</mark>，这样就实现了进程间通信。</p>
<p>有名管道突破了这种限制，可以实现互不相关的进程实现彼此的通信，管道可以通过路径名指定，在系统是可见的，建立管道之后就可以想普通文件一样进行读写，FIFO严格遵守先进先出的原则，读总是从开始读取数据，写数据写入末尾，不支持lseek()文件定位操作。</p>
<p><img src="./README.assets/fifo.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="_5-3-消息队列"> 5.3 消息队列</h3>
<p>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符（即队列ID）来标识。</p>
<div><p>特点</p>
<ol>
<li>消息队列是面向记录的，其中的消息具有特定的格式以及特定的优先级。</li>
<li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除。</li>
<li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</li>
</ol>
</div>
<p><img src="./README.assets/v2-c2aca533a7dbdee6c69f5116578d2436_720w.jpg" alt="img" loading="lazy"></p>
<h3 id="_5-4-共享内存和信号量"> 5.4 共享内存和信号量</h3>
<p>在通信的进程之间存在一块可直接访问的共享空间，通过对这片共享空间进行写/读操作实现进程之间的信息交换。在对共享空间进行写/读操作时，需要使用同步互斥工具（信号量），对共享空间的写/读进行控制。</p>
<div><p>特点</p>
<ol>
<li><mark>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取</mark>。</li>
<li>因为多个进程可以同时操作，所以需要进行同步。</li>
<li>信号量 + 共享内存通常结合在一起使用，信号量用来同步对共享内存的访问。</li>
</ol>
</div>
<p>操作系统只负责为通信进程提供可共享使用的存储空间和同步互斥工具，而数据交换则由用户自己安排读/写指令完成。注意，进程空间一般都是独立的，进程运行期间一般不能访问其他进程的空间，想让两个进程共享空间， <mark><strong>必须通过特殊的系统调用实现</strong></mark> ，而进程内的线程是自然共享进程空间的。</p>
<p><img src="./README.assets/v2-195b0cf5f101ed8c11910fea9b77559e_r.jpg" alt="preview" loading="lazy"></p>
<h2 id="六、线程"> 六、线程</h2>
<h3 id="_6-1-线程的基本概念"> 6.1 线程的基本概念</h3>
<p>引入进程的目的是更好地使多道程序并发执行，提高资源利用率和系统吞吐量；</p>
<p><strong>而引入线程的目的则是减小程序在并发执行时所付出的时空开销，提高操作系统的并发性能。</strong></p>
<p>线程最直接的理解就是【轻量级进程】，它是一个基本的CPU执行单元，也是程序执行流的最小单元，由线程ID、程序计数器、寄存器集合和堆栈组成。</p>
<blockquote>
<p>线程是进程中的一个实体，是被系统独立调度和分派的基本单位，线程自己不拥有系统资源，只拥有一点儿在运行中必不可少的资源，但它可与同属一个进程的其他线程共享进程所拥有的全部资源。一个线程可以创建和撤销另一个线程， 同一进程中的多个线程之间可以并发执行。由于线程之间的相互制约，致使线程在运行中呈现出间断性。</p>
</blockquote>
<p>线程也有就绪、阻塞和运行三种基本状态。引入线程后，进程的内涵发生了改变，<strong>进程只作为除CPU外的系统资源的分配单元，而线程则作为处理机的分配单元</strong>。由于一个进程内部有多个线程，若线程的切换发生在同一个进程内部，则只需要很少的时空开销。下面从几个方面对线程和进程进行比较。</p>
<h3 id="_6-2-线程与进程的比较"> 6.2 线程与进程的比较</h3>
<ol>
<li><strong>调度</strong>。在传统的操作系统中，拥有资源和独立调度的基本单位都是进程，每次调度都要进行上下文切换，开销较大。在引入线程的操作系统中，线程是独立调度的基本单位，而线程切换的代价远低于进程。在同一进程中，线程的切换不会引起进程切换。但从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li><strong>并发性</strong>。在引入线程的操作系统中，不仅进程之间可以并发执行，而且一个进程中的多个线程之间亦可并发执行，甚至不同进程中的线程也能并发执行，从而使操作系统具有更好的并发性，提高了系统资源的利用率和系统的吞吐量。</li>
<li><strong>拥有资源</strong>。进程是系统中拥有资源的基本单位，而线程不拥有系统资源（仅有一点必不可少、能保证独立运行的资源），但线程可以访问其隶属进程的系统资源，这主要表现在属于同进程的所有线程都具有相同的地址空间。</li>
<li><strong>独立性</strong>。每个进程都拥有独立的地址空间和资源，除了共享全局变量，不允许其他进程访问。某进程中的线程对其他进程不可见。同一进程中 的不同线程是为了提高并发性及进行相互之间的合作而创建的，它们共享进程的地址空间和资源。</li>
<li><strong>系统开销</strong>。在创建或撤销进程时，系统都要为之分配或回收进程控制块PCB及其他资源，如内存空间、I/O 设备等。操作系统为此所付出的开销，明显大于创建或撤销线程时的开销。类似地，在进程切换时涉及进程上下文的切换，而线程切换时只需保存和设置少量寄存器内容，开销很小。此外，由于同一进程内的多个线程共享进程的地址空间，因此这些线程之间的同步与通信非常容易实现，甚至无须操作系统的千预。</li>
<li><strong>支持多处理机系统</strong>。对于传统单线程进程，不管有多少处理机，进程只能运行在一个处理机上。对于多线程进程，可以将进程中的多个线程分配到多个处理机上执行。</li>
</ol>
<h3 id="_6-3-线程的属性"> 6.3 线程的属性</h3>
<p>多线程操作系统中的进程已不再是一个基本的执行实体，但它仍具有与执行相关的状态。所谓进程处于【执行】状态，实际上是指该进程中的某线程正在执行。线程的主要属性如下:</p>
<ol>
<li>线程是一个轻型实体，它不拥有系统资源，但每个线程都应有一个唯一的标识符和一个线程控制块（TCB），线程控制块记录了线程执行的寄存器和栈等现场状态。</li>
<li>不同的线程可以执行相同的程序，即同一个服务程序被不同的用户调用时，操作系统把它们创建成不同的线程。</li>
<li>同一进程中的各个线程共享该进程所拥有的资源。</li>
<li>线程是处理机的独立调度单位，多个线程是可以并发执行的。在单CPU的计算机系统中，各线程可交替地占用CPU；在多CPU的计算机系统中，各线程可同时占用不同的CPU，若各个CPU同时为一个进程内的各线程服务，则可缩短进程的处理时间。</li>
<li>一个线程被创建后，便开始了它的生命周期，直至终止。线程在生命周期内会经历阻塞态、就绪态和运行态等各种状态变化。</li>
</ol>
<p>为什么线程的提出有利于提高系统并发性？可以这样来理解：由于有了线程，线程切换时，有可能会发生进程切换，也有可能不发生进程切换，平均而言每次切换所需的开销就变小了，因此能够让更多的线程参与并发，而不会影响到响应时间等问题。</p>
<h3 id="_6-4-线程的状态与转换"> 6.4 线程的状态与转换</h3>
<p>与进程一样， 各线程之间也存在共享资源和相互合作的制约关系，致使线程在运行时也具有间断性。相应地，线程在运行时也具有下面三种基本状态。</p>
<ul>
<li>执行状态：线程已获得处理机而正在运行。</li>
<li>就绪状态：线程己具备各种执行条件，只需再获得CPU便可立即执行。</li>
<li>阻塞状态：线程在执行中因某事件受阻而处于暂停状态。</li>
</ul>
<p>线程这三种基本状态之间的转换和进程基本状态之间的转换是一样的。</p>
<h3 id="_6-5-线程的组织与控制"> 6.5 线程的组织与控制</h3>
<p><strong>线程控制块，TCB</strong></p>
<p>与进程类似，系统也为每个线程配置一个线程控制块TCB，用于记录控制和管理线程的信息。线程控制块通常包括:</p>
<ol>
<li>线程标识符;</li>
<li>一组寄存器，包括程序计数器、状态寄存器和通用寄存器;</li>
<li>线程运行状态，用于描述线程正处于何种状态;</li>
<li>优先级;</li>
<li>线程专有存储区，线程切换时用于保存现场等;</li>
<li>堆栈指针，用于过程调用时保存局部变量及返回地址等。</li>
</ol>
<p>同一进程中的所有线程都完全共享进程的地址空间和全局变量。各个线程都可以访问进程地址空间的每个单元，所以一个线程可以读、写或甚至清除另一个线程的堆栈。</p>
<hr>
<p><strong>线程的创建</strong></p>
<p>线程也是具有生命期的，它由创建而产生，由调度而执行，由终止而消亡。相应地，在操作系统中就有用于创建线程和终止线程的函数（或系统调用）。</p>
<p>用户程序启动时，通常仅有一个称为【初始化线程】的线程正在执行，其主要功能是用于创建新线程。在创建新线程时，需要利用一个线程创建函数，并提供相应的参数，如指向线程主程序的入口指针、堆栈的大小、线程优先级等。线程创建函数执行完后，将返回一个线程标识符。</p>
<hr>
<p><strong>线程的终止</strong></p>
<p>当一个线程完成自己的任务后，或线程在运行中出现异常而要被强制终止时，由终止线程调用相应的函数执行终止操作。但是有些线程（主要是系统线程）一旦被建立，便一直运行而不会被终止。通常，线程被终止后并不立即释放它所占有的资源，只有当进程中的其他线程执行了分离函数后，被终止线程才与资源分离，此时的资源才能被其他线程利用。被终止但尚未释放资源的线程仍可被其他线程调用，以使被终止线程重新恢复运行。</p>
<h3 id="_6-6-线程的实现方式"> 6.6 线程的实现方式</h3>
<p>线程的实现可以分为两类：<strong>用户级线程</strong>(User-Level Thread, ULT) 和 <strong>内核级线程</strong>(Kemel-LevelThread, KLT)。 内核级线程又称内核支持的线程。</p>
<hr>
<p><strong>用户级线程</strong>(ULT)</p>
<p><strong>在用户级线程中，有关线程管理（创建、撤销和切换等）的所有工作都由应用程序在用户空间中完成，内核意识不到线程的存在。</strong> 应用程序可以通过使用线程库设计成多线程程序。通常，应用程序从单线程开始，在该线程中开始运行，在其运行的任何时刻，可以通过调用线程库中的派生例程创建一个在相同进程中运行的新线程。</p>
<p>图2.5(a)说明了用户级线程的实现方式。对于设置了用户级线程的系统，其调度仍是以进程为单位进行的，各个进程轮流执行一个时间片。假设进程A包含1个用户级线程，进程B包含100个用户级线程，这样，进程A中线程的运行时间将是进程B中各线程运行时间的100倍，因此对线程来说实质上是不公平的。</p>
<p><img src="./README.assets/image-20220403120201066.png" alt="image-20220403120201066" loading="lazy"></p>
<div><p>优缺点</p>
<p>这种实现方式的优点如下:</p>
<ol>
<li>整个用户级线程的切换发生在用户空间，这样的线程切换至少比陷入内核要快一个数量级（不需要陷入内核、不需要上下文切换、不需要对内存高速缓存进行刷新，这就使得线程调度非常快捷）。</li>
<li>调度算法可以是进程专用的，不同的进程可根据自身的需要，对自己的线程选择不同的调度算法。</li>
<li>用户级线程的实现与操作系统平台无关，对线程管理的代码是属于用户程序的一部分。</li>
<li>线程的调度不需要内核直接参与，控制简单。</li>
</ol>
<p>这种实现方式的缺点如下：</p>
<ol>
<li>系统调用的阻塞问题，当线程执行一个系统调用时，不仅该线程被阻塞，而且进程内的所有线程都被阻塞。</li>
<li>不能发挥多处理机的优势，内核每次分配给一个进程的仅有一个CPU，因此进程中仅有一个线程能执行。</li>
</ol>
</div>
<hr>
<p><strong>内核级线程</strong>( KLT)</p>
<p>在操作系统中，无论是系统进程还是用户进程，都是在操作系统内核的支持下运行的，与内核紧密相关。内核级线程同样也是在内核的支持下运行的，线程管理的所有工作也是在内核空间内实现的。<strong>内核空间也为每个内核级线程设置一个线程控制块</strong>，内核根据该控制块感知某线程的存在，并对其加以控制。图2.5(b)说明了内核级线程的实现方式。</p>
<p><img src="./README.assets/image-20220403120139726.png" alt="image-20220403120139726" loading="lazy"></p>
<div><p>优缺点</p>
<p>这种实现方式的优点如下：</p>
<ol>
<li>能发挥多处理机的优势，内核能同时调度同一进程中的多个线程并行执行。</li>
<li>如果进程中的一个线程被阻塞，内核可以调度该进程中的其他线程占用处理机，也可运行其他进程中的线。</li>
<li>内核支持线程具有很小的数据结构和堆栈，线程切换比较快、开销小。</li>
<li>内核本身也可采用多线程技术，可以提高系统的执行速度和效率。</li>
</ol>
<p>这种实现方式的缺点如下：</p>
<ol>
<li>同一进程中的线程切换，需要从用户态转到核心态进行，系统开销较大。这是因为用户进程的线程在用户态运行，而线程调度和管理是在内核实现的。</li>
</ol>
</div>
<hr>
<p><strong>组合方式</strong></p>
<p>有些系统使用组合方式的多线程实现。在组合实现方式中，内核支持多个内核级线程的建立、调度和管理，同时允许用户程序建立、调度和管理用户级线程。</p>
<p>一些内核级线程对应多个用户级线程，这是用户级线程通过 <mark>时分多路复用</mark> 内核级线程实现的。同一进程中的多个线程可以同时在多处理机上并行执行，且在阻塞一个线程时不需要将整个进程阻塞，所以组合方式能结合KLT和ULT的优点，并且克服各自的不足。</p>
<p><img src="./README.assets/image-20220403120307841.png" alt="image-20220403120307841" loading="lazy"></p>
<div><p>线程库是啥</p>
</div>
<h2 id="七、多线程模型"> 七、多线程模型</h2>
<p>有些系统同时支持用户线程和内核线程，由于用户级线程和内核级线程连接方式的不同，从而形成了下面三种不同的多线程模型。</p>
<ol>
<li>多对一模型。将多个用户级线程映射到一个内核级线程，如图2.6(a)所示。 这些用户线程一般属于一个进程，线程的调度和管理在用户空间完成。仅当用户线程需要访问内核时，微才将其映射到一个内核级线程上，但是每次只允许-个线程进行映射。
<ul>
<li>优点：线程管理是在用户空间进行的，因而效率比较高。</li>
<li>缺点：如果一个线程在访问内核时发生阻塞，则整个进程都会被阻塞；在任何时刻，只有一个线程能够访问内核，多个线程不能同时在多个处理机上运行。</li>
</ul>
</li>
<li>一对一模型。 将每个用户级线程映射到一个内核级线程，如图2.6(b)所示。
<ul>
<li>优点：当一个线程被阻塞后，允许调度另一个线程运行，所以并发能力较强。</li>
<li>缺点：每创建一个用户线程， 相应地就需要创建一个内核线程，开销较大。</li>
</ul>
</li>
<li>多对多模型。将n个用户线程映射到m个内核级线程上，要求n≥m，如图2.6(c)所示。
<ul>
<li>特点：既克服了多对一模型并发度不高的缺点，又克服了一对一模型的一个用户进程占用太多内核级线程而开销太大的缺点。此外，还拥有上述两种模型各自的优点。</li>
</ul>
</li>
</ol>
<p><img src="./README.assets/image-20220330144944031.png" alt="image-20220330144944031" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-30T08:27:25.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">处理机调度</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/2/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/2/2/"/>
    <updated>2022-04-14T08:09:13.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
<li><a href="https://blog.csdn.net/qq_19018277/article/details/98491539" target="_blank" rel="noopener noreferrer">操作系统之调度 (十) --- 处理机调度、高级调度、中级调度、低级调度...</a></li>
</ul>
</div>
<h2 id="一、调度的概念"> 一、调度的概念</h2>
<h3 id="_1-1-调度的基本概念"> 1.1 调度的基本概念</h3>
<p>在多道程序系统中，进程的数量往往多于处理机的个数，因此进程争用处理机的情况在所难免。处理机调度是对处理机进行分配，即从就绪队列中按照一定的算法（公平、高效的原则）选择一个进程并将处理机分配给它运行，以实现进程并发地执行。处理机调度是多道程序操作系统的基础，是操作系统设计的核心问题。</p>
<h3 id="_1-2-调度的层次"> 1.2 调度的层次</h3>
<p>一个作业从提交开始直到完成，往往要经历以下三级调度，如图2.7所示。</p>
<p><img src="./README.assets/1-140629144600329.jpg" alt="img" loading="lazy"></p>
<h3 id="_1-3-高级调度-作业调度"> 1.3 高级调度(作业调度)</h3>
<p><mark>作业调度从外存的后备队列中选择一批作业进入内存， 为它们建立进程，这些进程被送入就绪队列。</mark></p>
<p>按照一定的原则从外存上处于后备队列的作业中挑选一个(或多个)，给它(们)分配内存、输入/输出设备等必要的资源，并建立相应的进程，以使它(们)获得竞争处理机的权利。</p>
<p><img src="./README.assets/20190805211416112.png" alt="img" loading="lazy"></p>
<h3 id="_1-4-中级调度-内存调度"> 1.4 中级调度(内存调度)</h3>
<p><mark>中级调度是为了提高内存的利用率，系统将那些暂时不能运行的进程挂起来。</mark></p>
<p>引入中极调度的目的是提高内存利用率和系统吞吐量。为此，将那些暂时不能运行的进程调至外存等待，此时进程的状态称为挂起态。当它们已具备运行条件且内存又稍有空闲时，由中级调度来决定把外存上的那些已具备运行条件的就绪进程再重新调入内存，并修改其状态为就绪态，挂在就绪队列上等待</p>
<p><img src="./README.assets/20190805211913804.png" alt="img" loading="lazy"></p>
<p><img src="./README.assets/process.png" alt="在这里插入图片描述" loading="lazy"></p>
<h3 id="_1-5-低级调度-进程调度"> 1.5 低级调度(进程调度)</h3>
<p><mark>进程调度从就绪队列中选出一个进程，并把其状态改为运行态，把CPU分配给它。</mark></p>
<p>按照某种算法从就绪队列中选取一个进程，将处理机分配给它。进程调度是最基本的一种调度，在各种操作系统中都必须配置这级调度。进程调度的频率很高，一般几十毫秒一次。</p>
<p><img src="./README.assets/20190805212423862.png" alt="在这里插入图片描述" loading="lazy"></p>
<h2 id="二、调度的目标"> 二、调度的目标</h2>
<p>不同的调度算法具有不同的特性，在选择调度算法时，必须考虑算法的特性。为了比较处理机调度算法的性能，人们提出了很多评价标准，下面介绍其中主要的几种:</p>
<ol>
<li>CPU利用率。</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span style="margin-right:0.13889em;">CP</span><span style="margin-right:0.10903em;">U</span><span>的利用率</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.1297em;vertical-align:-0.7693em;"></span><span><span></span><span><span><span><span style="height:1.3603em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.13889em;">CP</span><span style="margin-right:0.10903em;">U</span><span>有效工作时间</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span style="margin-right:0.13889em;">CP</span><span style="margin-right:0.10903em;">U</span><span>空闲等待时间</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span style="margin-right:0.13889em;">CP</span><span style="margin-right:0.10903em;">U</span><span>有效工作时间</span></span></span></span><span>​</span></span><span><span style="height:0.7693em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<ol start="2">
<li>系统吞吐量。表示单位时间内CPU完成作业的数量。</li>
<li>周转时间。指从作业提交到作业完成所经历的时间，是作业等待、在就绪队列中排队、在处理机上运行及输入/输出操作所花费时间的总和。</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span>周转时间</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7667em;vertical-align:-0.0833em;"></span><span>作业完成时间</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6833em;"></span><span>作业提交时间</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span>带权周转时间</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.0463em;vertical-align:-0.686em;"></span><span><span></span><span><span><span><span style="height:1.3603em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span>作业实际运行时间</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>作业周转时间</span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<ol start="4">
<li>等待时间。指进程处于等处理机的时间之和，等待时间越长，用户满意度越低</li>
<li>响应时间。指从用户提交请求到系统首次产生响应所用的时间。</li>
</ol>
<p>要想得到一个满足所有用户和系统要求的算法几乎是不可能的。设计调度程序，一方面要满足特定系统用户的要求（如某些实时和交互进程的快速响应要求），另一方面要考虑系统整体效率（如减少整个系统的进程平均周转时间），同时还要考虑调度算法的开销。</p>
<h2 id="三、调度的实现"> 三、调度的实现</h2>
<h3 id="_3-1-调度程序-调度器"> 3.1 调度程序（调度器）</h3>
<p>在操作系统中，用于调度和分派CPU的组件称为调度程序，它通常由三部分组成，如图2.8所示。</p>
<ol>
<li>排队器。将系统中的所有就绪进程按照一定的策略排成一个或多个队列，以便于调度程序选择。每当有一个进程转变为就绪态时，<strong>排队器便将它插入到相应的就绪队列中</strong>。</li>
</ol>
<p><img src="./README.assets/image-20220330163112335.png" alt="image-20220330163112335" loading="lazy"></p>
<ol start="2">
<li>分派器。依据调度程序所选的进程，<strong>将其从就绪队列中取出</strong>，将CPU分配给新进程。</li>
<li>上下文切换器。在对处理机进行切换时，会发生两对上下文的切换操作：第一对，将当前进程的上下文保存到其PCB中，再装入分派程序的上下文，以便分派程序运行；第二对，移出分派程序的上下文，将新选进程的CPU现场信息装入处理机的各个相应寄存器。在上下文切换时，需要执行大量load和store指令，以保存寄存器的内容，因此会花费较多时间。现在已有硬件实现的方法来减少上下文切换时间。通常采用两组寄存器，其中一组供内核使用，一组供用户使用。这样，上下文切换时，只需改变指针，让其指向当前寄存器组即可。</li>
</ol>
<h3 id="_3-2-调度的时机、切换与过程"> 3.2 调度的时机、切换与过程</h3>
<p>若在以下过程中发生了引起调度的条件，则不能马上进行调度和切换，应置系统的请求调度标志，直到过程结束后才进行相应的调度与切换。</p>
<ol>
<li><strong>在处理中断的过程中</strong>。中断处理过程复杂，在实现上很难做到进程切换，而且中断处理是系统工作的一部分，逻辑上不属于某一进程，不应被剥夺处理机资源。</li>
<li><strong>进程在操作系统内核临界区中</strong>。进入临界区后，需要独占式地访问，理论上必须加锁，以防止其他并行进程进入，在解锁前不应切换到其他进程，以加快临界区的释放。</li>
<li><strong>其他需要完全屏蔽中断的原子操作过程中</strong>。如加锁、解锁、中断现场保护、恢复等原子操作。在原子过程中，连中断都要屏蔽，更不应该进行进程调度与切换。</li>
</ol>
<p>应该进行进程调度与切换的情况如下:</p>
<ol>
<li>发生引起调度条件且当前进程无法继续运行下去时，可以马上进行调度与切换。若操作系统只在这种情况下进行进程调度，则是 <strong>非剥夺调度</strong>。</li>
<li>中断处理结束或自陷处理结束后，返回被中断进程的用户态程序执行现场前，若置上请求调度标志，即可马上进行进程调度与切换。若操作系统支持这种情况下的运行调度程序，则实现了剥夺方式的调度。</li>
</ol>
<p>进程切换往往在调度完成后立刻发生，它要求保存原进程当前断点的现场信息，恢复被调度进程的现场信息。现场切换时，操作系统内核将原进程的现场信息推入当前进程的内核堆栈来保存它们，并更新堆栈指针。内核完成从新进程的内核栈中装入新进程的现场信息、更新当前运行进程空间指针、重设PC寄存器等相关工作之后，开始运行新的进程。</p>
<h3 id="_3-3-进程调度方式"> 3.3 进程调度方式</h3>
<p>所谓进程调度方式，是指当某个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要处理，即有优先权更高的进程进入就绪队列，此时应如何分配处理机。</p>
<p>通常有以下两种进程调度方式</p>
<ol>
<li>
<p>非抢占调度方式，又称非剥夺方式。是指当一个进程正在处理机上执行时，即使有某个更为重要或紧迫的进程进入就绪队列，仍然让正在执行的进程继续执行，直到该进程运行完成或发生某种事件而进入阻塞态时，才把处理机分配给其他进程。</p>
<p><strong>非抢占调度方式的优点是实现简单、系统开销小，适用于大多数的批处理系统，但它不能用于分时系统和大多数的实时系统。</strong></p>
</li>
<li>
<p>抢占调度方式，又称剥夺方式。是指当一个进程正在处理机上执行时，若有某个更为重要或紧迫的进程需要使用处理机，则允许调度程序根据某种原则去暂停正在执行的进程，将处理机分配给这个更为重要或紧迫的进程。</p>
<p><strong>抢占调度方式对提高系统吞吐率和响应效率都有明显的好处</strong>。但“抢占”不是一种任意性行为，必须遵循一定的原则，主要有优先权、短进程优先和时间片原则等。</p>
</li>
</ol>
<h3 id="_3-4-闲逛进程"> 3.4 闲逛进程</h3>
<p>在进程切换时，如果系统中没有就绪进程，就会调度闲逛进程(idle) 运行，如果没有其他进程就绪，<strong>该进程就一直运行， 并在执行过程中测试中断</strong>。闲逛进程的优先级最低，没有就绪进程时才会运行闲逛进程，只要有进程就绪，就会立即让出处理机。</p>
<p>闲逛进程不需要CPU之外的资源，它不会被阻塞。</p>
<h3 id="_3-5-两种线程的调度"> 3.5 两种线程的调度</h3>
<ol>
<li>用户级线程调度。由于内核并不知道线程的存在，所以内核还是和以前一样，选择一个进程，并给予时间控制。由进程中的调度程序决定哪个线程运行。</li>
<li>内核级线程调度。内核选择一个特定线程运行，通常不用考虑该线程属于哪个进程。对被选择的线程赋予一个时间片， 如果超过了时间片，就会强制挂起该线程。用户级线程的线程切换在同一进程中进行，仅需少量的机器指令；内核级线程的线程切换需要完整的上下文切换、修改内存映像、使高速缓存失效，这就导致了若干数量级的延迟。</li>
</ol>
<h2 id="四、典型的调度算法"> 四、典型的调度算法</h2>
<p>操作系统中存在多种调度算法，有的调度算法适用于作业调度，有的调度算法适用于进程调度，有的调度算法两者都适用。下面介绍几种常用的调度算法。</p>
<h3 id="_4-1-先来先服务-fcfs-调度算法"> 4.1 先来先服务(FCFS)调度算法</h3>
<p>FCFS调度算法是一种最简单的调度算法，它既 <mark>可用于作业调度，又可用于进程调度</mark>。</p>
<ul>
<li>在作业调度中，算法每次从后备作业队列中选择最先进入该队列的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</li>
<li>在进程调度中，算法每次从就绪队列中选择最先进入该队列的进程，将处理机分配给它，使之投入运行，直到运行完成或因某种原因而阻塞时才释放处理机。</li>
</ul>
<blockquote>
<p>假设系统中有4个作业，它们的提交时间分别是 <code>8, 8.4, 8.8, 9</code>，运行时间依次是 <code>2, 1, 0.5, 0.2</code> ，系统采用FCFS调度算法，这组作业的平均等待时间、平均周转时间和平均带权周转时间见表2.2。</p>
<p><img src="./README.assets/image-20220330163247148.png" alt="image-20220330163247148" loading="lazy"></p>
</blockquote>
<p>FCFS调度算法属于 <mark>不可剥夺算法</mark>。从表面上看，它对所有作业都是公平的，但若一个长作业先到达系统，就会使后面的许多短作业等待很长时间，因此它不能作为分时系统和实时系统的主要调度策略。</p>
<p><mark>FCFS调度算法的特点是算法简单，但效率低；对长作业比较有利，但对短作业不利(相对SJF和高响应比)；有利于CPU繁忙型作业，而不利于I/O繁忙型作业。</mark></p>
<h3 id="_4-2-短作业优先-sjf-调度算法"> 4.2 短作业优先(SJF)调度算法</h3>
<p>短作业（进程）优先调度算法是指对 <mark>短作业（进程）优先调度</mark> 的算法。</p>
<ul>
<li>短作业优先（SJF）调度算法从后备队列中选择一个或若干估计运行时间最短的作业，将它们调入内存运行；</li>
<li>短进程优先（SPF）调度算法从就绪队列中选择一个估计运行时间最短的进程，将处理机分配给它，使之立即执行，直到完成或发生某事件而阻塞时，才释放处理机。</li>
</ul>
<blockquote>
<p>例如，考虑表2.2中给出的一组作业，若系统采用短作业优先调度算法，其平均等待时间、平均周转时间和平均带权周转时间见表2.3.</p>
<p><img src="./README.assets/image-20220330163308092.png" alt="image-20220330163308092" loading="lazy"></p>
</blockquote>
<p>SJF调度算法也存在不容忽视的缺点：</p>
<ol>
<li>该算法对长作业不利，由表2.2和表2.3可知，SJF<strong>调度算法中长作业的周转时间会增加</strong>。更严重的是，若有一长作业进入系统的后备队列，由于调度程序总是优先调度那些（即使是后进来的）短作业，<strong>将导致长作业长期不被调度</strong>（【饥饿】现象，注意区分【死锁】，后者是系统环形等待，前者是调度策略问题）。</li>
<li><strong>该算法完全未考虑作业的紧迫程度</strong>，因而不能保证紧迫性作业会被及时处理。</li>
<li>由于作业的长短是根据用户所提供的估计执行时间而定的，而用户又可能会有意或无意地缩短其作业的估计运行时间，致使该算法不一定能真正做到短作业优先调度。</li>
</ol>
<p>注意，SJF 调度算法的平均等待时间、平均周转时间最少。</p>
<h3 id="_4-3-优先级调度算法"> 4.3 优先级调度算法</h3>
<p>优先级调度算法既 <mark>可用于作业调度，又可用于进程调度</mark>。该算法中的优先级用于描述作业的紧迫程度。</p>
<ul>
<li>在作业调度中，优先级调度算法每次从后备作业队列中选择优先级最高的一个或几个作业，将它们调入内存，分配必要的资源，创建进程并放入就绪队列。</li>
<li>在进程调度中，优先级调度算法每次从就绪队列中选择优先级最高的进程，将处理机分配给它，使之投入运行。</li>
</ul>
<div><p>是否抢占</p>
<ol>
<li>非抢占式优先级调度算法。当一个进程正在处理机上运行时，即使有某个优先级更高的进程进入就绪队列，仍让正在运行的进程继续运行，直到由于其自身的原因而让出处理机时（任务完成或等待事件），才把处理机分配给就绪队列中优先级最高的进程。</li>
<li>抢占式优先级调度算法。当一个进程正在处理机上运行时，若有某个优先级更高的进程进入就绪队列，则立即暂停正在运行的进程，将处理机分配给优先级更高的进程。</li>
</ol>
</div>
<div><p>静态/动态优先级</p>
<ol>
<li>静态优先级。优先级是在创建进程时确定的，且在进程的整个运行期间保持不变。确定静态优先级的主要依据有进程类型、进程对资源的要求、用户要求。</li>
<li>动态优先级。在进程运行过程中，根据进程情况的变化动态调整优先级。动态调整优先级的主要依据有进程占有CPU时间的长短、就绪进程等待CPU时间的长短。</li>
</ol>
</div>
<p>一般来说，进程优先级的设置可以参照以下原则：</p>
<ol>
<li>系统进程 &gt; 用户进程。系统进程作为系统的管理者，理应拥有更高的优先级。</li>
<li>交互型进程 &gt; 非交互型进程（或前台进程 &gt; 后台进程）。大家平时在使用手机时，在前台运行的正在和你交互的进程应该更快速地响应你，因此自然需要被优先处理。</li>
<li>I/O 型进程 &gt; 计算型进程。所谓I/O型进程，是指那些会频繁使用I/O设备的进程，而计算型进程是那些频繁使用CPU的进程(很少使用I/O设备)。我们知道，I/O 设备(如打印机)的处理速度要比CPU慢得多，因此若将I/O型进程的优先级设置得更高，就更有可能让I/O设备尽早开始工作，进而提升系统的整体效率。</li>
</ol>
<h3 id="_4-4-高响应比优先调度算法"> 4.4 高响应比优先调度算法</h3>
<p>高响应比优先调度算法 <mark>主要用于作业调度</mark>，是对FCFS调度算法和SJF调度算法的一种综合平衡，同时考虑了每个作业的等待时间和估计的运行时间。</p>
<ul>
<li>在每次进行作业调度时，先计算后备作业队列中每个作业的响应比，从中选出响应比最高的作业投入运行。</li>
</ul>
<p>响应比的变化规律可描述为</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span>响应比</span><span>Rp</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.0463em;vertical-align:-0.686em;"></span><span><span></span><span><span><span><span style="height:1.3603em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span>要求服务时间</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>等待时间</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>要求服务时间</span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<p>根据公式可知</p>
<ol>
<li>作业的等待时间相同时，要求服务时间越短，响应比越高，有利于短作业，因而类似于SJF.</li>
<li>要求服务时间相同时，作业的响应比由其等待时间决定，等待时间越长，其响应比越高，因而类似于FCFS。</li>
<li>对于长作业，作业的响应比可以随等待时间的增加而提高，当其等待时间足够长时，也可获得处理机，克服了【饥饿】现象。</li>
</ol>
<h3 id="_4-5-时间片轮转调度算法"> 4.5 时间片轮转调度算法</h3>
<p>时间片轮转调度算法主要适用于分时系统。在这种算法中，系统将所有就绪进程按FCFS策略排成一个就绪队列，调度程序总是选择就绪队列中的第一个进程执行，但仅能运行一个时间片，如50ms。在使用完一个时间片后，即使进程并未运行完成，它也必须释放出（被剥夺）处理机给下一个就绪进程，而被剥夺的进程返回到就绪队列的末尾重新排队，等候再次运行。</p>
<div><p>时间片大小的影响</p>
<ul>
<li>若时间片足够大，以至于所有进程都能在一个时间片内执行完毕，则时间片轮转调度算法就退化为先来先服务调度算法。</li>
<li>若时间片很小，则处理机将在进程间过于频繁地切换，使处理机的开销增大，而真正用于运行用户进程的时间将减少。</li>
</ul>
<p>因此，时间片的大小应选择适当，时间片的长短通常由以下因素确定：系统的响应时间、就绪队列中的进程数目和系统的处理能力。</p>
</div>
<h3 id="_4-6-多级队列调度算法"> 4.6 多级队列调度算法</h3>
<p>前述的各种调度算法，由于系统中仅设置一个进程的就绪队列，即调度算法是固定且单一的，无法满足系统中不同用户对进程调度策略的不同要求。在多处理机系统中，这种单一调度策略实现机制的缺点更为突出，多级队列调度算法能在一定程度上弥补这一缺点。</p>
<p><strong>该算法在系统中设置多个就绪队列，将不同类型或性质的进程固定分配到不同的就绪队列。每个队列可实施不同的调度算法</strong>，因此，系统针对不同用户进程的需求，很容易提供多种调度策略。同一队列中的进程可以设置不同的优先级，不同的队列本身也可以设置不同的优先级。在多处理机系统中，可以很方便为每个处理机设置一个单独的就绪队列，每个处理机可实施各自不同的调度策略，这样就能根据用户需求将多个线程分配到一个或多个处理机上运行。</p>
<h3 id="_4-7-多级反馈队列调度箕法"> 4.7 多级反馈队列调度箕法</h3>
<p>多级反馈队列调度算法是时间片轮转调度算法和优先级调度算法的综合与发展，如图2.9 所示。通过动态调整进程优先级和时间片大小，多级反馈队列调度算法可以兼顾多方面的系统目标。</p>
<blockquote>
<p>例如，为提高系统吞吐量和缩短平均周转时间而照顾短进程：为获得较好的I/O设备利用率和缩短响应时间而照顾I/O型进程；同时，也不必事先估计进程的执行时间。</p>
</blockquote>
<p><img src="./README.assets/image-20220330163414334.png" alt="image-20220330163414334" loading="lazy"></p>
<div><p>实现思想</p>
<ol>
<li>设置多个就绪队列，并为每个队列赋予不同的优先级。第1级队列的优先级最高，第2级队列的优先级次之，其余队列的优先级逐个降低。</li>
<li>赋予各个队列的进程运行时间片的大小各不相同。<strong>在优先级越高的队列中，每个进程的时间片就越小</strong>。例如，第 i + 1 级队列的时间片要比第i级队列的时间片长 1 倍。</li>
<li>每个队列都采用FCFS算法。当新进程进入内存后，首先将它放入第 1 级队列的末尾，按FCFS原则等待调度。当轮到该进程执行时，如它能在该时间片内完成，便可撤离系统。<strong>若它在一个时间片结束时尚未完成，调度程序将其转入第 2 级队列的末尾等待调度</strong>；若它在第 2 级队列中运行一个时间片后仍未完成，再将它放入第 3 级队列....依此类推。当进程最后被降到第 n 级队列后，在第 n 级队列中便采用时间片轮转方式运行。</li>
<li>按队列优先级调度。仅当第 1 级队列为空时，才调度第 2 级队列中的进程运行；仅当第 [1, i - 1] 级队列均为空时，才会调度第i级队列中的进程运行。若处理机正在执行第i级队列中的某进程时，又有新进程进入任一优先级较高的队列，此时须立即把正在运行的进程放回到第i级队列的末尾，而把处理机分配给新到的高优先级进程。</li>
</ol>
</div>
<p>多级反馈队列的优势有以下几点：</p>
<ol>
<li>终端型作业用户：短作业优先。</li>
<li>短批处理作业用户：周转时间较短。</li>
<li>长批处理作业用户：经过前面几个队列得到部分执行，不会长期得不到处理。</li>
</ol>
<p>下表总结了几种常见进程调度算法的特点，读者要在理解的基础上掌握。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">能否是可抢占</th>
<th style="text-align:center">能否是不可抢占</th>
<th style="text-align:center">优点</th>
<th style="text-align:center">缺点</th>
<th style="text-align:center">适用于</th>
<th style="text-align:center">默认决策模式</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">先来先服务</td>
<td style="text-align:center">否</td>
<td style="text-align:center">能</td>
<td style="text-align:center">公平，实现简单</td>
<td style="text-align:center">不利于短作业</td>
<td style="text-align:center">无</td>
<td style="text-align:center">非抢占</td>
</tr>
<tr>
<td style="text-align:center">短作业优先</td>
<td style="text-align:center">能</td>
<td style="text-align:center">能</td>
<td style="text-align:center">平均等待时间最少，效率最高</td>
<td style="text-align:center">长作业会饥饿，估计时间不易确定</td>
<td style="text-align:center">作业调度，批处理系统</td>
<td style="text-align:center">非抢占</td>
</tr>
<tr>
<td style="text-align:center">高响应比优先</td>
<td style="text-align:center">能</td>
<td style="text-align:center">能</td>
<td style="text-align:center">兼顾长短作业</td>
<td style="text-align:center">计算响应比的开销大</td>
<td style="text-align:center">无</td>
<td style="text-align:center">非抢占</td>
</tr>
<tr>
<td style="text-align:center">时间片轮转</td>
<td style="text-align:center">能</td>
<td style="text-align:center">否</td>
<td style="text-align:center">兼顾长短作业</td>
<td style="text-align:center">平均等待时间较长，上下文切换浪费时间</td>
<td style="text-align:center">分时系统</td>
<td style="text-align:center">抢占</td>
</tr>
<tr>
<td style="text-align:center">多级反馈队列</td>
<td style="text-align:center">队列内算法不一定</td>
<td style="text-align:center">队列内算法不一定</td>
<td style="text-align:center">兼顾长短作业，有较好的响应时间，可行性强</td>
<td style="text-align:center">无</td>
<td style="text-align:center">相当通用</td>
<td style="text-align:center">抢占</td>
</tr>
</tbody>
</table>
<h2 id="五、进程切换"> 五、进程切换</h2>
<p>对于通常的进程而言，其创建、撤销及要求由系统设备完成的I/O操作，都是利用系统调用而进入内核，再由内核中的相应处理程序予以完成的。进程切换同样是在内核的支持下实现的，因此可以说，任何进程都是在操作系统内核的支持下运行的，是与内核紧密相关的。</p>
<h3 id="_5-1-上下文切换"> 5.1 上下文切换</h3>
<p>切换CPU到另一个进程需要保存当前进程状态并恢复另一个进程的状态，这个任务称为 <mark>上下文切换</mark> 。上下文是指某一时刻CPU寄存器和程序计数器的内容。进行上下文切换时，内核会将旧进程状态保存在其PCB中，然后加载经调度而要执行的新进程的上下文。</p>
<p>上下文切换实质上是指处理机从一个进程的运行转到另一个进程上运行，在这个过程中，进程的运行环境产生了实质性的变化。上下文切换的流程如下:</p>
<ol>
<li>挂起一个进程，保存CPU上下文，包括程序计数器和其他寄存器。</li>
<li><mark>更新PCB信息</mark>（信息保存在进程控制块）</li>
<li>把进程的PCB移入相应的队列，如就绪、在某事件阻塞等队列。</li>
<li>选择另一个进程执行，并更新其PCB。</li>
<li>跳转到新进程PCB中的程序计数器所指向的位置执行。</li>
<li>恢复处理机上下文。</li>
</ol>
<h3 id="_5-2-上下文切换的消耗"> 5.2 上下文切换的消耗</h3>
<p>上下文切换通常是计算密集型的，即它需要相当可观的CPU时间，在每秒几十上百次的切换中，每次切换都需要纳秒量级的时间，所以上下文切换对系统来说意味着消耗大量的CPU时间。有些处理器提供多个寄存器组，这样，上下文切换就只需要简单改变当前寄存器组的指针。</p>
<h3 id="_5-3-上下文切换与模式切换"> 5.3 上下文切换与模式切换</h3>
<p>模式切换与上下文切换是不同的，模式切换时，CPU逻辑上可能还在执行同一进程。用户进程最开始都运行在用户态，若进程因中断或异常进入核心态运行，执行完后又回到用户态刚被中断的进程运行。用户态和内核态之间的切换称为模式切换，而不是上下文切换，因为没有改变当前的进程。上下文切换只能发生在内核态，它是多任务操作系统中的一个必需的特性。</p>
<p>注意：调度和切换的区别。调度是指决定资源分配给哪个进程的行为，是一种决策行为；切换是指实际分配的行为，是执行行为。一般来说，先有资源的调度，然后才有进程的切换。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-30T13:49:37.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">死锁</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/2/4/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/2/4/"/>
    <updated>2022-04-14T08:09:13.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、死锁的概念"> 一、死锁的概念</h2>
<h3 id="_1-1-死锁的定义"> 1.1 死锁的定义</h3>
<p>在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处理能力。然而，多个进程的并发执行也带来了新的问题——死锁。</p>
<div><p>死锁</p>
<p>是指多个进程因竞争资源而造成的一种僵局（互相等待），若无外力作用，这些进程都将无法向前推进。</p>
</div>
<h3 id="_1-2-死锁产生的原因"> 1.2 死锁产生的原因</h3>
<p><strong>系统资源的竞争</strong></p>
<p>通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产生死锁，对可剥夺资源的竞争是不会引起死锁的。</p>
<hr>
<p><strong>进程推进顺序非法</strong></p>
<p>进程在运行过程中，<strong>请求和释放资源的顺序不当</strong>，也同样会导致死锁。例如，并发进程 P1，P2 分别保持了资源R1，R2，而进程 P1 申请资源 R2、进程 P2 申请资源 R1 时，两者都会因为所需资源被占用而阻塞，于是导致死锁。</p>
<p><strong>信号量使用不当也会造成死锁</strong>。进程间彼此相互等待对方发来的消息，也会使得这些进程间无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。</p>
<hr>
<p><strong>死锁产生的必要条件</strong></p>
<p>产生死锁必须同时满足以下4个条件，只要其中任意一个条件不成立，死锁就不会发生。</p>
<ol>
<li><strong>互斥条件</strong>：进程要求对所分配的资源（如打印机）进行排他性使用，即在一段时间内某资源仅为一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。</li>
<li><strong>不剥夺条件</strong>：进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由获得该资源的进程自己来释放（只能是主动释放）。</li>
<li><strong>请求并保持条件</strong>：进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。</li>
<li><strong>循环等待条件</strong>：存在一种进程资源的循环等待链，链中每个进程已获得的资源同时被链中下一个进程所请求。</li>
</ol>
<h3 id="_1-3-死锁的处理策咯"> 1.3 死锁的处理策咯</h3>
<p>为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当死锁发生时能检测出死锁，并有能力实现恢复。</p>
<ol>
<li><strong>死锁预防</strong>。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。</li>
<li><strong>避免死锁</strong>。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。</li>
<li><strong>死锁的检测及解除</strong>。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。</li>
</ol>
<p>预防死锁和避免死锁都属于 <strong>事先预防策略</strong>，预防死锁的限制条件比较严格，实现起来较为简单，但往往导致系统的效率低，资源利用率低；避免死锁的限制条件相对宽松，资源分配后需要通过算法来判断是否进入不安全状态，实现起来较为复杂。死锁的几种处理策略的比较见表2.4。</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">资源分配策略</th>
<th style="text-align:center">各种可能模式</th>
<th style="text-align:center">主要优点</th>
<th style="text-align:center">主要缺点</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">死锁预防</td>
<td style="text-align:center">保守，宁可资源闲置</td>
<td style="text-align:center">一次请求所有资源，资源剥夺，资源按序分配</td>
<td style="text-align:center">适用于突发式处理的进程，不必进行剥夺</td>
<td style="text-align:center">效率低，进程初始化时间延长；剥夺次数过多；不便灵活申请新资源</td>
</tr>
<tr>
<td style="text-align:center">死锁避免</td>
<td style="text-align:center">是预防和检测的折中</td>
<td style="text-align:center">寻找可能的安全允许顺序</td>
<td style="text-align:center">不必进行剥夺</td>
<td style="text-align:center">必须知道将来的资源需求；进程不能被长时间阻塞</td>
</tr>
<tr>
<td style="text-align:center">死锁检测</td>
<td style="text-align:center">宽松，只要允许就分配资源</td>
<td style="text-align:center">定期检查死锁是否已经发生</td>
<td style="text-align:center">不延长进程初始化时间，允许对死锁进行现场处理</td>
<td style="text-align:center">通过剥夺接触死锁，造成损失</td>
</tr>
</tbody>
</table>
<h2 id="二、死锁预防"> 二、死锁预防</h2>
<p>防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。</p>
<h3 id="_2-1-破坏互斥条件"> 2.1 破坏互斥条件</h3>
<p>若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，如打印机等临界资源只能互斥使用。所以，<strong>破坏互斥条件而预防死锁的方法不太可行</strong>，而且在有的场合应该保护这种互斥性。</p>
<h3 id="_2-2-破坏不剥夺条件"> 2.2 破坏不剥夺条件</h3>
<p>当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或者说是被剥夺，或从而破坏了不剥夺条件。</p>
<p><strong>该策略实现起来比较复杂</strong>，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和释放资源会 <strong>增加系统开销，降低系统吞吐量</strong>。这种方法常用于状态易于保存和恢复的资源，如CPU的寄存器及内存资源，一般不能用于打印机之类的资源。</p>
<h3 id="_2-3-破坏请求并保持条件"> 2.3 破坏请求并保持条件</h3>
<p>采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满足前，不把它投入运行。一旦投入运行， 这些资源就一直归它所有，不再提出其他资源请求，这样就可以保证系统不会发生死锁。</p>
<p><strong>这种方式实现简单</strong>，但缺点也显而易见，<strong>系统资源被严重浪费</strong>，其中有些资源可能仅在运行初期或运行快结束时才使用，甚至根本不使用。而且还会 <strong>导致【饥饿】现象</strong>，由于个别资源长期被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。</p>
<h3 id="_2-4-破坏循环等待条件"> 2.4 破坏循环等待条件</h3>
<p>为了破坏循环等待条件，可采用顺序资源分配法。首先给系统中的资源编号，规定每个进程必须按编号递增的顺序请求资源，同类资源一次申请完。 也就是说，只要进程提出申请分配资源 R，则该进程在以后的资源申请中就只能申请编号大于 R 的资源。</p>
<p>这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加；尽管在为资源编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系统规定顺序不同的情况，<strong>造成资源的浪费</strong>；此外，这种按规定次序申请资源的方法，<strong>也必然会给用户的编程带来麻烦</strong>。</p>
<h2 id="三、死锁避免"> 三、死锁避免</h2>
<p>避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制条件较弱，可以获得较好的系统性能。</p>
<h3 id="_3-1-系统安全状态"> 3.1 系统安全状态</h3>
<p>避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配；否则让进程等待。</p>
<p>所谓安全状态，是指系统能按某种进程推进顺序（P1，P2...,. Pn）为每个进程 Pi 分配其所需的资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称 P1，P2，.，Pn 为安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。</p>
<blockquote>
<p>假设系统中有三个进程 P1，P2 和 P3，共有12台磁带机。进程 P1 共需要10台磁带机，P2 和 P3 分别需要 4 台和 9 台。假设在 T0 时刻，进程 P1，P2 和 P3 已分别获得 5 台、2 台和 2 台，尚有 3 台未分配</p>
<table>
<thead>
<tr>
<th style="text-align:center">进程</th>
<th style="text-align:center">最大需求</th>
<th style="text-align:center">已分配</th>
<th style="text-align:center">可用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">P1</td>
<td style="text-align:center">10</td>
<td style="text-align:center">5</td>
<td style="text-align:center">3</td>
</tr>
<tr>
<td style="text-align:center">P2</td>
<td style="text-align:center">4</td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
</tr>
<tr>
<td style="text-align:center">P3</td>
<td style="text-align:center">9</td>
<td style="text-align:center">2</td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<p>在 T0 时刻是安全的，因为存在一个安全序列 P2，P1，P3，只要系统按此进程序列分配资源，那么每个进程都
能顺利完成。也就是说，当前可用磁带机为3台，先把 3 台磁带机分配给 P2 以满足其最大需求，P2 结束并归还资源后，系统有 5 台磁带机可用；接下来给 P1 分配 5 台磁带机以满足其最大需求，P1 结束并归还资源后，剩余 10 台磁带机可用；最后分配 7 台磁带机给 P3，这样 P3 也能顺利完成。</p>
<p>若在 T0 时刻后，系统分配 1 台磁带机给 P3，系统剩余可用资源数为 2，此时系统进入不安全状态，因为此时已无法再找到一个安全序列。当系统进入不安全状态后，便可能导致死锁。</p>
</blockquote>
<p>并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态；反之，只要系统处于安全状态，系统便可避免进入死锁状态。</p>
<h3 id="_3-2-银行家算法"> 3.2 银行家算法</h3>
<p>银行家算法是最著名的死锁避免算法，其思想是：把操作系统视为银行家，操作系统管理的资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系统按照银行家制定的规则为进程分配资源。进程运行之前先声明对各种资源的最大需求量，当进程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。</p>
<p><strong>数据结构描述</strong></p>
<ol>
<li>
<p>可利用资源向量 Available：含有 m 个元素的数组，其中每个元素代表一类可用的资源数目。<code>Available[i] = K</code> 表示系统中现有 Ri 类资源 K 个。</p>
</li>
<li>
<p>最大需求矩阵 <code>Max: n * m</code> 矩阵，定义系统中 n 个进程中的每个进程对 m 类资源的最大需求。</p>
<p>简单来说，一行代表一个进程，一列代表一类资源。<code>Max[i, j] = K</code> 表示进程 i 需要 Rj 类资源的最大数目为K。</p>
</li>
<li>
<p>分配矩阵 <code>Allocation: n * m</code> 矩阵，定义系统中每类资源当前已分配给每个进程的资源数。<code>Allocation[i, j] = K</code> 表示进程 i 当前已分得 Rj 类资源的数目为 K。</p>
</li>
<li>
<p>需求矩阵 <code>Need: n * m</code> 矩阵，表示每个进程接下来最多还需要多少资源。<code>Need[i, j] = K</code> 表示进程 i 还需要 Rj 类资源的数目为 K。</p>
</li>
</ol>
<p>上述三个矩阵间存在下述关系：</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span>d</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7667em;vertical-align:-0.0833em;"></span><span style="margin-right:0.10903em;">M</span><span>a</span><span>x</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.6944em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span>n</span></span></span></span></span></p>
<p>一般情况下， 在银行家算法的题目中，Max 矩阵和 Allocation 矩阵是已知条件，而求出 Need 矩阵是解题的第一步。</p>
<hr>
<p><strong>银行家算法描述</strong></p>
<p>设 Request<sub>i</sub> 是进程 Pi 的请求向量，<code>Request_i[j] = K</code> 表示进程 Pi 需要j类资源 K 个。当 Pi 发出资源请求后，系统按下述步骤进行检查：</p>
<ol>
<li>若 <code>Request_i[j] &lt;= Need[i, j]</code>，则转向步骤2；否则认为出错，因为它所需要的资源数已超过它所宣布的最大值。</li>
<li>若 <code>Request_i[j] &lt;= Available[j]</code>，则转向步骤3；否则，表示尚无足够资源，Pi 须等待。</li>
<li>系统试探着把资源分配给进程 Pi，并修改下面数据结构中的数值:</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span>t</span><span>;</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span>n</span><span>[</span><span>i</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>c</span><span>a</span><span>t</span><span>i</span><span>o</span><span>n</span><span>[</span><span>i</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span><span>;</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span>d</span><span>[</span><span>i</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span>d</span><span>[</span><span>i</span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.05724em;">j</span><span>]</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>[</span><span style="margin-right:0.05724em;">j</span><span>]</span><span>;</span></span></span></span></span></p>
<ol start="4">
<li>系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全，才正式将资源分配给进程 Pi，以完成本次分配；否则，将本次的试探分配作废，恢复原来的资源分配状态，让进程 Pi 等待。</li>
</ol>
<hr>
<p><strong>安全性算法</strong></p>
<p>设置工作向量Work，有 m 个元素，表示系统中的剩余可用资源数目。在执行安全性算法开始时，<code>Work = Available</code></p>
<ol>
<li>初始时安全序列为空</li>
<li>从 Need 矩阵中找出符合下面条件的行：该行对应的进程不在安全序列中，而且该行小于等于 Work 向量，找到后，把对应的进程加入安全序列；若找不到，则执行步骤 4</li>
<li>进程 Pi 进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源，因此应执行 <code>Work = Work + Allocation[i]</code>，其中 Allocation[i] 表示进程 Pi 代表的在 Allocation 矩阵中对应的行，返回步骤2。</li>
<li>若此时安全序列中已有所有进程，则系统处于安全状态，否则系统处于不安全状态。</li>
</ol>
<h3 id="_3-3-安全性算法举例"> 3.3 安全性算法举例</h3>
<p>假定系统中有 5 个进程 <code>{P0, P1, P2, P3, P4}</code> 和三类资源 <code>{A, B, C}</code>，各种资源的数量分别为 10，5，7，在 T0 时刻的资源分配情况见表2.6。</p>
<p>T0 时刻的安全性。利用安全性算法对 T0 时刻的资源分配进行分析。</p>
<p><img src="./README.assets/image-20220401194651548.png" alt="image-20220401194651548" loading="lazy"></p>
<ol>
<li>从题目中我们可以提取 Max 矩阵和 Allocation 矩阵，这两个矩阵相减可得到 Need 矩阵：</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:6.0001em;vertical-align:-2.75em;"></span><span style="margin-right:0.10903em;">M</span><span>a</span><span>x</span><span style="margin-right:0.1667em;"></span><span><span><span><span><span><span style="height:3.25em;"><span style="top:-2.311em;"><span style="height:4.416em;"></span><span><span>⎣</span></span></span><span style="top:-3.458em;"><span style="height:4.416em;"></span><span style="height:2.416em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='2.416em' style='width:0.6667em' viewBox='0 0 666.67 2416' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V2416 H319z M319 0 H403 V2416 H319z'/></svg></span></span><span style="top:-6.5111em;"><span style="height:4.416em;"></span><span><span>⎡</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span><span><span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>7</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>3</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>9</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-4.05em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.85em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-0.45em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>5</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>3</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-4.05em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.85em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-0.45em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>3</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>3</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span></span><span><span><span><span><span style="height:3.25em;"><span style="top:-2.311em;"><span style="height:4.416em;"></span><span><span>⎦</span></span></span><span style="top:-3.458em;"><span style="height:4.416em;"></span><span style="height:2.416em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='2.416em' style='width:0.6667em' viewBox='0 0 666.67 2416' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V2416 H263z M263 0 H347 V2416 H263z'/></svg></span></span><span style="top:-6.5111em;"><span style="height:4.416em;"></span><span><span>⎤</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:6.0001em;vertical-align:-2.75em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span>in</span><span style="margin-right:0.1667em;"></span><span><span><span><span><span><span style="height:3.25em;"><span style="top:-2.311em;"><span style="height:4.416em;"></span><span><span>⎣</span></span></span><span style="top:-3.458em;"><span style="height:4.416em;"></span><span style="height:2.416em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='2.416em' style='width:0.6667em' viewBox='0 0 666.67 2416' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V2416 H319z M319 0 H403 V2416 H319z'/></svg></span></span><span style="top:-6.5111em;"><span style="height:4.416em;"></span><span><span>⎡</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span><span><span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>3</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-4.05em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.85em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-0.45em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-4.05em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.85em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-0.45em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span></span><span><span><span><span><span style="height:3.25em;"><span style="top:-2.311em;"><span style="height:4.416em;"></span><span><span>⎦</span></span></span><span style="top:-3.458em;"><span style="height:4.416em;"></span><span style="height:2.416em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='2.416em' style='width:0.6667em' viewBox='0 0 666.67 2416' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V2416 H263z M263 0 H347 V2416 H263z'/></svg></span></span><span style="top:-6.5111em;"><span style="height:4.416em;"></span><span><span>⎤</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:6.0001em;vertical-align:-2.75em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span>d</span><span style="margin-right:0.1667em;"></span><span><span><span><span><span><span style="height:3.25em;"><span style="top:-2.311em;"><span style="height:4.416em;"></span><span><span>⎣</span></span></span><span style="top:-3.458em;"><span style="height:4.416em;"></span><span style="height:2.416em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='2.416em' style='width:0.6667em' viewBox='0 0 666.67 2416' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V2416 H319z M319 0 H403 V2416 H319z'/></svg></span></span><span style="top:-6.5111em;"><span style="height:4.416em;"></span><span><span>⎡</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span><span><span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>7</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>6</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-4.05em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.85em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-0.45em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>4</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>3</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-4.05em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.85em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-0.45em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:3.25em;"><span style="top:-5.41em;"><span style="height:3em;"></span><span><span>3</span></span></span><span style="top:-4.21em;"><span style="height:3em;"></span><span><span>2</span></span></span><span style="top:-3.01em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-1.81em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-0.61em;"><span style="height:3em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span></span><span><span><span><span><span style="height:3.25em;"><span style="top:-2.311em;"><span style="height:4.416em;"></span><span><span>⎦</span></span></span><span style="top:-3.458em;"><span style="height:4.416em;"></span><span style="height:2.416em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='2.416em' style='width:0.6667em' viewBox='0 0 666.67 2416' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V2416 H263z M263 0 H347 V2416 H263z'/></svg></span></span><span style="top:-6.5111em;"><span style="height:4.416em;"></span><span><span>⎤</span></span></span></span><span>​</span></span><span><span style="height:2.75em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<ol start="2">
<li>然后，将 Work 向量与 Need 矩阵的各行进行比较，找出比 Work 矩阵小的行。例如，在初始时,</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span><span style="margin-right:0.2778em;"></span><span>&gt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span></span><span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span><span style="margin-right:0.2778em;"></span><span>&gt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>1</span><span>)</span></span></span></span></span></p>
<p>​	对应的两个进程分别为 P1 和 P3，这里我们选择 P1（也可以选择P3）暂时加入安全序列。</p>
<ol start="3">
<li>释放 P1 所占的资源，即把 P1 进程对应的 Allocation 矩阵中的一行与 Work 向量相加：</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>332</span><span>)</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>200</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>532</span><span>)</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6944em;"></span><span style="margin-right:0.13889em;">W</span><span style="margin-right:0.02778em;">or</span><span style="margin-right:0.03148em;">k</span></span></span></span></span></p>
<p>​	此时需求矩阵更新为（去掉了 P1 对应的一行）：</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:4.8001em;vertical-align:-2.15em;"></span><span><span><span><span><span><span style="height:2.65em;"><span style="top:-1.711em;"><span style="height:3.216em;"></span><span><span>⎣</span></span></span><span style="top:-2.858em;"><span style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M319 0 H403 V1216 H319z M319 0 H403 V1216 H319z'/></svg></span></span><span style="top:-4.7111em;"><span style="height:3.216em;"></span><span><span>⎡</span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span></span><span><span><span><span><span><span style="height:2.65em;"><span style="top:-4.81em;"><span style="height:3em;"></span><span><span style="margin-right:0.13889em;">P</span><span>0</span></span></span><span style="top:-3.61em;"><span style="height:3em;"></span><span><span style="margin-right:0.13889em;">P</span><span>2</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span style="margin-right:0.13889em;">P</span><span>3</span></span></span><span style="top:-1.21em;"><span style="height:3em;"></span><span><span style="margin-right:0.13889em;">P</span><span>4</span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:2.65em;"><span style="top:-4.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-3.45em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.05em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:2.65em;"><span style="top:-4.81em;"><span style="height:3em;"></span><span><span>7</span></span></span><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>6</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-1.21em;"><span style="height:3em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:2.65em;"><span style="top:-4.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-3.45em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.05em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:2.65em;"><span style="top:-4.81em;"><span style="height:3em;"></span><span><span>4</span></span></span><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-1.21em;"><span style="height:3em;"></span><span><span>3</span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:2.65em;"><span style="top:-4.65em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-3.45em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-2.25em;"><span style="height:2.84em;"></span><span></span></span><span style="top:-1.05em;"><span style="height:2.84em;"></span><span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span><span style="width:0.5em;"></span><span style="width:0.5em;"></span><span><span><span><span style="height:2.65em;"><span style="top:-4.81em;"><span style="height:3em;"></span><span><span>3</span></span></span><span style="top:-3.61em;"><span style="height:3em;"></span><span><span>0</span></span></span><span style="top:-2.41em;"><span style="height:3em;"></span><span><span>1</span></span></span><span style="top:-1.21em;"><span style="height:3em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span></span></span><span><span><span><span><span style="height:2.65em;"><span style="top:-1.711em;"><span style="height:3.216em;"></span><span><span>⎦</span></span></span><span style="top:-2.858em;"><span style="height:3.216em;"></span><span style="height:1.216em;width:0.6667em;"><svg xmlns="http://www.w3.org/2000/svg" width='0.6667em' height='1.216em' style='width:0.6667em' viewBox='0 0 666.67 1216' preserveAspectRatio='xMinYMin'><path d='M263 0 H347 V1216 H263z M263 0 H347 V1216 H263z'/></svg></span></span><span style="top:-4.7111em;"><span style="height:3.216em;"></span><span><span>⎤</span></span></span></span><span>​</span></span><span><span style="height:2.15em;"><span></span></span></span></span></span></span></span></span></span></span></span></p>
<p>​	再用更新的 Work 向量和 Need 矩阵重复步骤2。利用安全性算法分析 T0 时刻的资源分配情况如表2.7所示，最后得到一个安全序列 <code>{P1, P3, P4, P2, P0}</code>.</p>
<p><img src="./README.assets/image-20220401194800797.png" alt="image-20220401194800797" loading="lazy"></p>
<h3 id="_3-4-银行家算法举例"> 3.4 银行家算法举例</h3>
<p>安全性算法是银行家算法的核心，在银行家算法的题目中，一般会有某个进程的一个资源请求向量，读者只要执行上面所介绍的银行家算法的前三步，马上就会得到更新的 Allocation 矩阵和 Need 矩阵，再按照上例的安全性算法判断，就能知道系统能否满足进程提出的资源请求。</p>
<p>假设当前系统中资源的分配和剩余情况如表2.6所示。</p>
<ol>
<li>P1 请求资源：P1 发出请求向量 Request(1, 0, 2)， 系统按银行家算法进行检查：</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span><span>e</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span></span></span></span></span></p>
<p>​	系统先假定可为P分配资源，并修改</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span><span>n</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span><span>n</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>)</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>1</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span></span></p>
<p>由此形成的资源变化情况如表2.6中的圆括号所示。
​	令 <code>Work = Available = (2, 3, 0)</code>，再利用安全性算法检查此时系统是否安全，如表2.8所示。</p>
<p><img src="./README.assets/v2-3dba3dc26ae03df3ddf638067f5779ab_r.jpg" alt="preview" loading="lazy"></p>
<p>​	由所进行的安全性检查得知，可找到一一个安全序列{P1, P3, P4, P2, P0}。因此，系统是安全的，可以立即将 P1 所申请的资源分配给它。分配后系统中的资源情况如表2.9所示。</p>
<p><img src="./README.assets/image-20220401194845324.png" alt="image-20220401194845324" loading="lazy"></p>
<ol start="2">
<li>P4 请求资源：P4 发出请求向量 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span>，系统按银行家算法进行检查：</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>4</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>1</span><span>)</span><span>;</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>4</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span><span style="margin-right:0.2778em;"></span><span>&gt;</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>(</span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span></span></p>
<p>​	让P4 等待。</p>
<ol start="3">
<li>P0请求资源：P0 发出请求向量 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>s</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span>，系统按银行家算法进行检查：</li>
</ol>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>7</span><span>,</span><span style="margin-right:0.1667em;"></span><span>4</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>)</span><span>;</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1em;vertical-align:-0.25em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>(</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span><span style="margin-right:0.2778em;"></span><span>≤</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>(</span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span></span></p>
<p>​	系统暂时先假定可为 P0 分配资源，并修改有关数据：</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.7778em;vertical-align:-0.0833em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>1</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span><span>n</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span><span>n</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>,</span><span style="margin-right:0.1667em;"></span><span>0</span><span>)</span></span></span></span></span></p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.8444em;vertical-align:-0.15em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.8778em;vertical-align:-0.1944em;"></span><span style="margin-right:0.00773em;">R</span><span>e</span><span style="margin-right:0.03588em;">q</span><span>u</span><span>es</span><span><span>t</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>(</span><span>7</span><span>,</span><span style="margin-right:0.1667em;"></span><span>2</span><span>,</span><span style="margin-right:0.1667em;"></span><span>3</span><span>)</span></span></span></span></span></p>
<p>​	结果如表2.10所示。</p>
<p><img src="./README.assets/image-20220401194917962.png" alt="image-20220401194917962" loading="lazy"></p>
<p>进行安全性检查：可用资源 Available(2, 1, 0) 已不能满足任何进程的需要，因此系统进入不安全状态，因此拒绝 P0 的请求，让 P0 等待，并将 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span>A</span><span style="margin-right:0.03588em;">v</span><span>ai</span><span style="margin-right:0.01968em;">l</span><span>ab</span><span style="margin-right:0.01968em;">l</span><span>e</span><span>,</span><span style="margin-right:0.1667em;"></span><span>A</span><span style="margin-right:0.01968em;">ll</span><span>oc</span><span>a</span><span>t</span><span>i</span><span>o</span><span><span>n</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>,</span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.10903em;">N</span><span>ee</span><span><span>d</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>0</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span> 恢复为之前的值。</p>
<h2 id="四、死锁检测和解除"> 四、死锁检测和解除</h2>
<p>前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。</p>
<h3 id="_4-1-资源分配图"> 4.1 资源分配图</h3>
<p>系统死锁可利用资源分配图来描述。如图2.15 所示，用圆圈代表一个进程，用框代表一类资源。由于一种类型的资源可能有多个，因此用框中的一个圆代表一类资源中的一个资源。从进程到资源的有向边称为请求边，表示该进程申请一个单位的该类资源；从资源到进程的边称为分配边，表示该类资源已有一个资源分配给了该进程。</p>
<p>在图2.15所示的资源分配图中，进程 P1 已经分得了两个 R1 资源，并又请求一个 R2 资源；进程 P2 分得了一个R1 资源和一个 R2 资源，并又请求-一个R1 资源。</p>
<p><img src="./README.assets/image-20220401194958504.png" alt="image-20220401194958504" loading="lazy"></p>
<h3 id="_4-2-死锁定理"> 4.2 死锁定理</h3>
<p>简化资源分配图可检测系统状态 S 是否为死锁状态。简化方法如下：</p>
<ol>
<li>
<p>在资源分配图中， 找出既不阻塞又不孤点的进程 Pi（即找出一条有向边与它相连，且该有向边对应资源的申请数量小于等于系统中已有的空闲资源数量，如在图2.15中，R1 没有空闲资源，R2 有一个空闲资源。若所有连接该进程的边均满足上述条件，则这个进程能继续运行直至完成，然后释放它所占有的所有资源）。消去它所有的请求边和分配边，使之成为孤立的结点。在图2.16(a)中，P1 是满足这一条件的进程结点，将 P1 的所有边消去，便得到图2.16(b)所示的情况。</p>
<p>这里要注意一个问题，判断某种资源是否有空闲，应该用它的资源数量减去它在资源分配图中的出度，例如在图2.15中，R1 的资源数为 3，而出度也为 3，所以 R1 没有空闲资源，R2 的资源数为 2，出度为 1，所以 R2 有一个空闲资源。</p>
</li>
<li>
<p>进程 Pi 所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可能变为非阻塞进程。在图2.15中，进程 P2 就满足这样的条件。根据 1 中的方法进行一系列简化后，若能消去图中所有的边，则称该图是可完全简化的，如图2.16(c)所示。</p>
</li>
</ol>
<p><img src="./README.assets/image-20220401195040638.png" alt="image-20220401195040638" loading="lazy"></p>
<p>S 为死锁的条件是当且仅当 S 状态的资源分配图是不可完全简化的，该条件为死锁定理。</p>
<h3 id="_4-3-死锁解除"> 4.3 死锁解除</h3>
<p>一旦检测出死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有：</p>
<ol>
<li><strong>资源剥夺法</strong>。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。</li>
<li><strong>撤销进程法</strong>。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以按进程优先级和撤销进程代价的高低进行。</li>
<li><strong>进程回退法</strong>。让一（或多）个进程回退到足以回避死锁的地步，进程回退时自愿释放资源而非被剥夺。要求系统保持进程的历史信息，设置还原点。</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-01T11:51:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">内存管理概念</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/3/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/3/1/"/>
    <updated>2022-04-20T15:31:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
<li><a href="https://blog.csdn.net/weixin_44225940/article/details/105266677" target="_blank" rel="noopener noreferrer">【内存管理】页式&amp;段式&amp;段页式&amp;优缺点</a></li>
</ul>
</div>
<h2 id="一、内存管理的基本原理和要求"> 一、内存管理的基本原理和要求</h2>
<p><strong>操作系统对内存的划分和动态分配，就是内存管理的概念。</strong></p>
<div><p>内存管理的主要功能</p>
<ul>
<li><strong>内存空间的分配与回收</strong>。由操作系统完成主存储器空间的分配和管理，使程序员摆脱存储分配的麻烦，提高编程效率。</li>
<li><strong>地址转换</strong>。在多道程序环境下，程序中的逻辑地址与内存中的物理地址不可能一致，因此存储管理必须提供地址变换功能，把逻辑地址转换成相应的物理地址。</li>
<li><strong>内存空间的扩充</strong>。利用虚拟存储技术或自动覆盖技术，从逻辑上扩充内存。</li>
<li><strong>内存共享</strong>。指允许多个进程访问内存的同一部分。例如，多个合作进程可能需要访问同一块数据，因此必须支持对内存共享区域进行受控访问。</li>
<li><strong>存储保护</strong>。保证各道作业在各自的存储空间内运行，互不干扰。</li>
</ul>
</div>
<div><p>虚拟存储技术 & 自动覆盖技术 ？</p>
</div>
<h3 id="_1-1-程序的链接与装入"> 1.1 程序的链接与装入</h3>
<p>创建进程首先要将程序和数据装入内存。将用户源程序变为可在内存中执行的程序，通常需要以下几个步骤：</p>
<ul>
<li>编译。由编译程序将用户源代码编译成若干目标模块。</li>
<li>链接。由链接程序将编译后形成的一组目标模块及它们所需的库函数链接在一起，形成一个完整的装入模块。</li>
<li>装入。由装入程序将装入模块装入内存运行。</li>
</ul>
<p><img src="./README.assets/image-20220405134129215.png" alt="image-20220405134129215" loading="lazy"></p>
<div><p>这几个链接是啥啊，没看懂</p>
</div>
<div><p>程序的链接有三种方式。</p>
<p><strong>静态链接</strong></p>
<p>在程序运行之前，先将各目标模块及它们所需的库函数链接成一个完整的装配模块，以后不再拆开。将几个目标模块装配成一个装入模块时，需要解决两个问题：</p>
<ol>
<li>修改相对地址，编译后的所有目标模块都是从0开始的相对地址，当链接成一个装入模块时要修改相对地址。</li>
<li>变换外部调用符号，将每个模块中所用的外部调用符号也都变换为相对地址。</li>
</ol>
<hr>
<p><strong>装入时动态链接</strong></p>
<p>将用户源程序编译后所得到的一组目标模块，在装入内存时，采用边装入边链接的方式。其优点是便于修改和更新，便于实现对目标模块的共享。</p>
<hr>
<p><strong>运行时动态链接</strong></p>
<p>对某些目标模块的链接，是在程序执行中需要该目标模块时才进行的。凡在执行过程中未被用到的目标模块，都不会被调入内存和被链接到装入模块上。其优点是能加快程序的装入过程，还可节省大量的内存空间。</p>
</div>
<div><p>装入内存有三种方式</p>
<p><strong>绝对装入</strong></p>
<p>绝对装入方式 <mark>只适用于单道程序环境</mark>。在编译时，若知道程序将驻留在内存的某个位置，则编译程序将产生绝对地址的目标代码。绝对装入程序按照装入模块中的地址，将程序和数据装入内存。由于程序中的逻辑地址与实际内存地址完全相同，因此不需对程序和数据的地址进行修改。</p>
<p>另外，程序中所用的绝对地址，可在编译或汇编时给出，也可由程序员直接赋予。而通常情况下在程序中采用的是符号地址，编译或汇编时再转换为绝对地址。</p>
<hr>
<p><strong>可重定位装入</strong></p>
<p>在多道程序环境下，多个目标模块的起始地址通常都从 0 开始，程序中的其他地址都是相对于起始地址的，此时应采用可重定位装入方式。根据内存的当前情况，将装入模块装入内存的适当位置。在装入时对目标程序中指令和数据地址的修改过程称为重定位，又因为地址变换通常是在进程装入时一次完成的，故称为 <mark>静态重定位</mark>，如图3.2(a)所示。</p>
<p>当一个作业装入内存时，必须给它分配要求的全部内存空间，若没有足够的内存，则无法装入。此外，作业一日进入内存，整个运行期间就不能在内存中移动，也不能再申请内存空间。</p>
<hr>
<p><strong>动态运行时装入</strong></p>
<p>也称 <mark>动态重定位</mark>。程序在内存中若发生移动，则需要采用动态的装入方式。装入程序把装入模块装入内存后，并不立即把装入模块中的相对地址转换为绝对地址，而是把这种地址转换推迟到程序真正要执行时才进行。因此，装入内存后的所有地址均为相对地址。这种方式需要一个重定位寄存器的支持，如图3.2(b)所示。</p>
<p>动态重定位的优点：可以将程序分配到不连续的存储区；在程序运行之前可以只装入部分代码即可投入运行，然后在程序运行期间，根据需要动态申请分配内存；便于程序段的共享。</p>
<p><img src="./README.assets/image-20220402090018476.png" alt="image-20220402090018476" loading="lazy"></p>
</div>
<h3 id="_1-2-逻辑地址与物理地址"> 1.2 逻辑地址与物理地址</h3>
<p>编译后，每个目标模块都从 0 号单元开始编址，这称为该目标模块的 <strong>相对地址（或逻辑地址）</strong>。当链接程序将各个模块链接成一个完整的叮执行目标程序时，链接程序顺序依次按各个模块的相对地址构成统一的从 0 号单元开始编址的 <strong>逻辑地址空间（或虚拟地址空间）</strong>，对于32位系统，逻辑地址空间的范围为 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span>[</span><span>0</span><span>,</span><span style="margin-right:0.1667em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>32</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>]</span></span></span></span>。进程在运行时，看到和使用的地址都是逻辑地址。用户程序和程序员只需知道逻辑地址，而内存管理的具体机制则是完全透明的。不同进程可以有相同的逻辑地址，因为这些相同的逻辑地址可以映射到主存的不同位置。</p>
<p>物理地址空间是指内存中物理单元的集合，它是地址转换的最终地址，进程在运行时执行指令和访问数据，最后都要通过物理地址从主存中存取。当装入程序将可执行代码装入内存时，必须通过地址转换将逻辑地址转换成物理地址，这个过程称为 <mark>地址重定位</mark></p>
<p><mark>操作系统通过【内存管理部件(MMU)】将进程使用的逻辑地址转换为物理地址。</mark> 进程使用虚拟内存空间中的地址，操作系统在相关硬件的协助下，将它“转换”成真正的物理地址。逻辑地址通过页表映射到物理内存，页表由操作系统维护并被处理器引用。</p>
<h3 id="_1-3-进程的内存映像"> 1.3 进程的内存映像</h3>
<p>不同于存放在硬盘上的可执行程序文件，当一个程序调入内存运行时，就构成了进程的内存映像。一个进程的内存映像一般有几个要素：</p>
<ul>
<li>代码段：即程序的二进制代码，代码段是只读的，可以被多个进程共享。</li>
<li>数据段：即程序运行时加工处理的对象，包括全局变量和静态变量。</li>
<li>进程控制块(PCB)：存放在系统区。操作系统通过PCB来控制和管理进程。</li>
<li>堆：用来存放动态分配的变量。通过调用 malloc 函数动态地向高地址分配空间。</li>
<li>栈：用来实现函数调用。从用户空间的最大地址往低地址方向增长。</li>
</ul>
<p>代码段和数据段在程序调入内存时就指定了大小，而堆和栈不一样。当调用像 malloc 和 free 这样的 C 标准库函数时，堆可以在运行时动态地扩展和收缩。用户栈在程序运行期间也可以动态地扩展和收缩，每次调用一个函数， 栈就会增长；从一个函数返回时，栈就会收缩。</p>
<blockquote>
<p>图3.3是一个进程在内存中的映像。其中，共享库用来存放进程用到的共享函数库代码，如 printf() 函数等。在只读代码段中，.init 是程序初始化时调用的 _init 函数；.text 是用户程序的机器代码；.rodata 是只读数据。在读/写数据段中，.data 是已初始化的全局变量和静态变量；.bss 是未初始化及所有初始化为0的全局变量和静态变量。</p>
</blockquote>
<p><img src="./README.assets/image-20220402090111621.png" alt="image-20220402090111621" loading="lazy"></p>
<h3 id="_1-4-内存保护"> 1.4 内存保护</h3>
<p>确保每个进程都有一个单独的内存空间。内存分配前，<strong>需要保护操作系统不受用户进程的影响</strong>，同时保护用户进程不受其他用户进程的影响。内存保护可采取两种方法：</p>
<ol>
<li>在 CPU 中设置一对 <mark>上、下限寄存器</mark> ，存放用户作业在主存中的下限和上限地址，每当CPU要访问一个地址时， 分别和两个寄存器的值相比，判断有无越界。</li>
<li>采用 <mark>重定位寄存器（又称基地址寄存器）</mark> 和 <mark>界地址寄存器（又称限长寄存器）</mark> 来实现这种保护。重定位寄存器含最小的物理地址值，界地址寄存器含逻辑地址的最大值。内存管理机构动态地将逻辑地址与界地址寄存器进行比较，若未发生地址越界，则加上重定位寄存器的值后映射成物理地址，再送交内存单元，如图3.4所示。</li>
</ol>
<p><img src="./README.assets/image-20220405133020133.png" alt="image-20220405133020133" loading="lazy"></p>
<p>实现内存保护需要重定位寄存器和界地址寄存器，因此要注意两者的区别。</p>
<ul>
<li>重定位寄存器是用来【加】的，逻辑地址加上重定位寄存器中的值就能得到物理地址；</li>
<li>界地址寄存器是用来【比】的，通过比较界地址寄存器中的值与逻辑地址的值来判断是否越界。</li>
</ul>
<p>加载重定位寄存器和界地址寄存器时必须使用特权指令，只有操作系统内核才可以加载这两个存储器。这种方案允许操作系统内核修改这两个寄存器的值，而不允许用户程序修改。</p>
<h3 id="_1-5-内存共享"> 1.5 内存共享</h3>
<p>并不是所有的进程内存空间都适合共享，<strong>只有那些只读的区域才可以共享</strong>。可重入代码又称纯代码，是一种允许多个进程同时访问但不允许被任何进程修改的代码。但在实际执行时，也可以为每个进程配以局部数据区，把在执行中可能改变的部分复制到该数据区，这样，程序在执行时只需对该私有数据区中的内存进行修改，并不去改变共享的代码。</p>
<h3 id="_1-6-内存分配与回收"> 1.6 内存分配与回收</h3>
<p>存储管理方式随着操作系统的发展而发展。在操作系统由单道向多道发展时，存储管理方式便由单一连续分配发展为固定分区分配。为了能更好地适应不同大小的程序要求，又从固定分区分配发展到动态分区分配。为了更好地提高内存的利用率，进而从连续分配方式发展到离散分配方式 —— 页式存储管理。 引入分段存储管理的目的，主要是为了满足用户在编程和使用方面的要求，其中某些要求是其他几种存储管理方式难以满足的。</p>
<h2 id="二、覆盖与交换"> 二、覆盖与交换</h2>
<p>覆盖与交换技术是在多道程序环境下用来扩充内存的两种方法。</p>
<h3 id="_2-1-覆盖"> 2.1 覆盖</h3>
<p>早期的计算机系统中，主存容量很小，虽然主存中仅存放一道用户程序，但存储空间放不下用户进程的现象也经常发生，这一矛盾可以用覆盖技术来解决。</p>
<p>覆盖的基本思想如下：由于程序运行时并非任何时候都要访问程序及数据的各个部分（尤其是大程序），因此可把用户空间分成一个固定区和若干覆盖区。将经常活跃的部分放在固定区，其余部分按调用关系分段。首先将那些即将要访问的段放入覆盖区，其他段放在外存中，在需要调用前，系统再将其调入覆盖区，替换覆盖区中原有的段。</p>
<p>覆盖技术的特点是，打破了必须将一个进程的全部信息装入主存后才能运行的限制，但当同时运行程序的代码量大于主存时仍不能运行，此外，内存中能够更新的地方只有覆盖区的段，不在覆盖区中的段会常驻内存。覆盖技术对用户和程序员不透明。</p>
<h3 id="_2-2-交换"> 2.2 交换</h3>
<p>交换（对换）的基本思想是，把处于等待状态（或在 CPU 调度原则下被剥夺运行权利）的程序从内存移到辅存，把内存空间腾出来，这一过程又称换出；把准备好竞争 CPU 运行的程序从辅存移到内存，这过程又称换入。 第2章介绍的中级调度采用的就是交换技术。</p>
<blockquote>
<p>例如，有一个 CPU 采用时间片轮转调度算法的多道程序环境。时间片到，内存管理器将刚刚执行过的进程换出，将另一进程换入刚刚释放的内存空间。同时，CPU 调度器可以将时间片分配给其他已在内存中的进程。每个进程用完时间片都与另一进程交换。在理想情况下，内存管理器的交换过程速度足够快，总有进程在内存中可以执行。</p>
</blockquote>
<p>有关交换，需要注意以下几个问题：</p>
<ul>
<li>交换需要备份存储，通常是磁盘。它必须足够大，并提供对这些内存映像的直接访问。</li>
<li>为了有效使用 CPU，需要使每个进程的执行时间比交换时间长。</li>
<li>若换出进程，则必须确保该进程完全处于空闲状态。</li>
<li>交换空间通常作为磁盘的一整块，且独立于文件系统，因此使用起来可能很快。</li>
<li>交换通常在有许多进程运行且内存空间吃紧时开始启动，而在系统负荷降低时就暂停。</li>
<li>普通的交换使用不多，但交换策略的某些变体在许多系统(如UNIX)中仍发挥作用。</li>
</ul>
<p><mark>交换技术主要在不同进程(或作业)之间进行，而覆盖则用于同一个程序或进程中</mark>。对于主存无法存放用户程序的矛盾，现代操作系统是通过虚拟内存技术来解决的，覆盖技术则已成为历史；而交换技术在现代操作系统中仍具有较强的生命力。</p>
<h2 id="三、连续分配管理方式"> 三、连续分配管理方式</h2>
<p>连续分配方式是指为一个用户程序分配一个连续的内存空间，譬如某用户需要 100MB 的内存空间，连续分配方式就在内存空间中为用户分配一块连续的 100MB 空间。连续分配方式主要包括单一连续分配、 固定分区分配和动态分区分配。</p>
<h3 id="_3-1-单一连续分配"> 3.1 单一连续分配</h3>
<p>内存在此方式下分为系统区和用户区，系统区仅供操作系统使用，通常在低地址部分；在用户区内存中，<strong>仅有一道用户程序</strong>，即整个内存的用户空间由该程序独占。</p>
<p>这种方式的优点是简单、无外部碎片，无须进行内存保护，因为内存中永远只有一道程序。</p>
<p>缺点是只能用于单用户、单任务的操作系统中，有内部碎片，存储器的利用率极低。</p>
<h3 id="_3-2-固定分区分配"> 3.2 固定分区分配</h3>
<p><strong>固定分区分配是最简单的一种多道程序存储管理方式</strong>，它将用户内存空间划分为若千固定大小的区域，每个分区只装入一道作业。当有空闲分区时，便可再从外存的后备作业队列中选择适当大小的作业装入该分区，如此循环。在划分分区时有两种不同的方法。</p>
<ul>
<li>分区大小相等。程序太小会造成浪费，程序太大又无法装入，缺乏灵活性。</li>
<li>分区大小不等。划分为多个较小的分区、适量的中等分区和少量大分区。</li>
</ul>
<p>为便于内存分配，通常将分区按大小排队，并为之建立一张分区 说明表，其中各表项包括每个分区的始址、大小及状态，如图3.5所示。当有用户程序要装入时，便检索该表，以找到合适的分区给予分配并将其状态置【已分配】；未找到合适分区时，则拒绝为该程序分配内存。</p>
<p><img src="./README.assets/image-20220405134326239.png" alt="image-20220405134326239" loading="lazy"></p>
<p>这种方式存在两个问题：</p>
<ul>
<li>一是程序可能太大而放不进任何一个分区， 这时就需要采用覆盖技术来使用内存空间；</li>
<li>二是当程序小于固定分区大小时，也要占用一个完整的内存分区，这样分区内部就存在空间浪费，这种现象称为 <mark>内部碎片</mark> 。</li>
</ul>
<p>固定分区是可用于多道程序设计的最简单的存储分配，无外部碎片，但不能实现多进程共享一个主存区，所以存储空间利用率低。</p>
<p>在固定分区分配中，为了便于分配，建立一张分区使用表，通常按分区大小排队，各表项包括每个分区的起始地址、大小及状态（是否已分配）。分配内存时，检索分区使用表，找到一个能满足要求且尚未分配的分区分配给装入程序，并将对应表项的状态置为【已分配】；若找不到这样的分区，则拒绝分配。回收内存时，只需将对应表项的状态置为【未分配】即可。</p>
<h3 id="_3-3-动态分区分配"> 3.3 动态分区分配</h3>
<p>又称可变分区分配，它是在进程装入内存时，根据进程的实际需要，动态地为之分配内存，并使分区的大小正好适合进程的需要。因此，系统中分区的大小和数目是可变的。</p>
<blockquote>
<p>如图3.6所示，系统有 64MB 内存空间，其中低 8MB 固定分配给操作系统，其余为用户可用内存。开始时装入前三个进程，它们分别分配到所需的空间后，内存仅剩 4MB，进程 4 无法装入。在某个时刻，内存中没有一个就绪进程，CPU 出现空闲，操作系统就换出进程 2，换入进程 4。由于进程 4 比进程 2 小，这样在主存中就产生了一个 6MB 的内存块。之后 CPU 又出现空闲，需要换入进程 2，而主存无法容纳进程 2，操作系统就换出进程 1，换入进程 2。</p>
<p><img src="./README.assets/image-20220402090359669.png" alt="image-20220402090359669" loading="lazy"></p>
</blockquote>
<p>动态分区在开始时是很好的，但随着时间的推移，内存中会产生越来越多小的内存块，内存的利用率也随之下降。这些小的内存块称为 <mark>外部碎片</mark> ，它存在于所有分区的外部，这与固定分区中的内部碎片正好相对。克服外部碎片可以通过紧凑技术来解决，即操作系统不时地对进程进行移动和整理。但这需要动态重定位寄存器的支持，且相对费时。紧凑的过程实际上类似于 Windows 系统中的磁盘碎片整理程序，只不过后者是对外存空间的紧凑。</p>
<p>在进程装入或换入主存时， 若内存中有多个足够大的空闲块，则操作系统必须确定分配哪个内存块给进程使用，这就是动态分区的分配策略。考虑以下几种算法：</p>
<ol>
<li>首次适应（First Fit）算法。空闲分区以地址递增的次序链接。分配内存时，从链首开始，顺序查找， 找到大小能满足要求的第一个空闲分区分配给作业。</li>
<li>邻近适应（Next Fit）算法。又称循环首次适应算法，由首次适应算法演变而成。不同之处是，分配内存时从上次查找结束的位置开始继续查找。</li>
<li>最佳适应（Best Fit） 算法。空闲分区按容量递增的次序形成空闲分区链，找到第一个能满足要求且最小的空闲分区分配给作业，避免“大材小用”。</li>
<li>最坏适应（Worst Fit）算法。空闲分区以容量递减的次序链接，找到第一个能满足要求的，即最大的分区，从中分割一部分存储空间给作业。</li>
</ol>
<div><p>各算法对比</p>
<p>首次适应算法最简单，通常也是最好和最快的。不过，首次适应算法会使得内存的低地址部分出现很多小的空闲分区，而每次分配查找时都要经过这些分区，因此增加了开销。</p>
<p>邻近适应算法试图解决这个问题。但它常常导致在内存空间的尾部（因为在一遍扫描中， 内存前面部分使用后再释放时，不会参与分配）分裂成小碎片。通常比首次适应算法要差。</p>
<p>最佳适应算法虽然称为“最佳”，但是性能通常很差，因为每次最佳的分配会留下很小的难以利用的内存块，会产生最多的外部碎片。</p>
<p>最坏适应算法与最佳适应算法相反，它选择最大的可用块，这看起来最不容易产生碎片，但是却把最大的连续内存划分开，会很快导致没有可用的大内存块，因此性能也非常差。</p>
</div>
<p>在动态分区分配中，与固定分区分配类似，设置一张空闲分区链（表），并按始址排序。分配内存时，检索空闲分区链，找到所需的分区，若其大小大于请求大小，便从该分区中按请求大小分割一块空间分配给装入进程 （若剩余部分小到不足以划分，则无须分割），余下部分仍留在空闲分区链中。回收内存时，系统根据回收分区的始址，从空闲分区链中找到相应的插入点，此时可能出现四种情况：</p>
<ol>
<li>回收区与插入点的前一空闲分区相邻，将这两个分区合并，并修改前一分区表项的大小为两者之和</li>
<li>回收区与插入点的后一空闲分区相邻，将这两个分区合并，并修改后一分区表项的始址和大小</li>
<li>回收区同时与插入点的前、后两个分区相邻，此时将这三个分区合并，修改前一分区 表项的大小为三者之和，取消后一分区表项</li>
<li>回收区没有相邻的空闲分区，此时应为回收区新建一个表项，填写始址和大小，并插入空闲分区链。</li>
</ol>
<p>以上三种内存分区管理方法有一个共同特点，即用户程序在主存中都是连续存放的。</p>
<p>在连续分配方式中，我们发现，即使内存有超过 1GB 的空闲空间，但若没有连续的 1GB 空间，则需要 1GB 空间的作业仍然是无法运行的；但若采用非连续分配方式，则作业所要求的 1GB 内存空间可以分散地分配在内存的各个区域，当然，这也需要额外的空间去存储它们（分散区域）的索引，使得非连续分配方式的存储密度低于连续分配方式。非连续分配方式根据分区的大小是否固定，分为分页存储管理和分段存储管理。在分页存储管理中，又根据运行作业时是否要把作业的所有页面都装入内存才能运行，分为基本分页存储管理和请求分页存储管理。</p>
<h2 id="四、基本分页存储管理"> 四、基本分页存储管理</h2>
<p>固定分区会产生内部碎片，动态分区会产生外部碎片，这两种技术对内存的利用率都比较低。我们希望内存的使用能尽量避免碎片的产生，这就引入了分页的思想：</p>
<div><p>分页</p>
<p>把主存空间划分为大小相等且固定的块，块相对较小，作为主存的基本单位。每个进程也以块为单位进行划分，进程在执行时，以块为单位逐个申请主存中的块空间。</p>
</div>
<p>分页的方法从形式上看，像分区相等的固定分区技术，分页管理不会产生外部碎片。但它又有本质的不同点：块的大小相对分区要小很多，而且进程也按照块进行划分，进程运行时按块申请主存可用空间并执行。这样，进程只会在为最后一个不完整的块申请一个主存块空间时，才产生主存碎片，所以尽管会产生内部碎片，但这种碎片相对于进程来说也是很小的，每个进程平均只产生半个块大小的内部碎片（也称页内碎片）。</p>
<h3 id="_4-1-分页存储的几个基本概念"> 4.1 分页存储的几个基本概念</h3>
<p><strong>页面和页面大小</strong></p>
<p>进程中的块称为 <mark>页或页面</mark>（Page），内存中的块称为 <mark>页框或页帧</mark>（Page Frame）。 外存也以同样的单位进行划分，直接称为 <mark>块或盘块</mark>（Block）。 进程在执行时需要申请主存空间，即要为每个页面分配主存中的可用页框，这就产生了页和页框的一一对应。</p>
<p>为方便地址转换，页面大小应是 2 的整数幂。同时页面大小应该适中，页面太小会使进程的页面数过多，这样页表就会过长，占用大量内存，而且也会增加硬件地址转换的开销，降低页面换入/换出的效率；页面过大又会使页内碎片增多，降低内存的利用率。</p>
<hr>
<p><strong>地址结构：</strong> <mark>页号 + 页内偏移量</mark></p>
<p><img src="./README.assets/image-20220402090454813.png" alt="image-20220402090454813" loading="lazy"></p>
<p>地址结构包含两部分：前一部分为页号P，后一部分为页内偏移量 W 地址长度为 32 位，其中 0 ~ 11 位为页内地址，即每页大小为 4KB；12 ~ 31 位为页号，即最多允许 20 页。</p>
<p>注意，地址结构决定了虚拟内存的寻址空间有多大。</p>
<hr>
<p><strong>页表项：</strong> <mark>页号 + 块号</mark></p>
<p>为了便于在内存中找到进程的每个页面所对应的物理块，系统为每个进程建立一张页表， 它记录页面在内存中对应的物理块号，页表一般存放在内存中。</p>
<p>在配置页表后，进程执行时，通过查找该表，即可找到每页在内存中的物理块号。可见，页表的作，用是实现从页号到物理块号的地址映射，如图3.8所示。</p>
<p><img src="./README.assets/image-20220402090525649.png" alt="image-20220402090525649" loading="lazy"></p>
<p>页表是由页表项组成的，初学者容易混淆页表项与地址结构，页表项与地址都由两部分构成，而且第一部分都是页号， 但页表项的第二部分是物理内存中的块号，而地址的第二部分是页内偏移；页表项的第二部分与地址的第二部分共同组成物理地址（块号 + 偏移量）。</p>
<h3 id="_4-2-基本地址变换机构"> 4.2 基本地址变换机构</h3>
<p><mark>地址变换机构的任务是将逻辑地址转换为内存中的物理地址。</mark></p>
<p>地址变换是借助于页表实现的。图3.9给出了分页存储管理系统中的地址变换机构。</p>
<p><img src="./README.assets/image-20220402090549884.png" alt="image-20220402090549884" loading="lazy"></p>
<p>在系统中通常设置一个 <mark>页表寄存器（PTR）</mark> ，存放页表在内存的起始地址 F 和页表长度 M 。平时，进程未执行时，页表的始址和页表长度存放在本进程的 PCB 中，当进程被调度执行时，才将页表始址和页表长度装入页表寄存器中。设页面大小为 L，逻辑地址 A 到物理地址 E 的变换过程如下（假设逻辑地址、页号、每页的长度都是十进制数）：</p>
<ol>
<li>计算页号P（<code>P = A / L</code>）和页内偏移量W（<code>w = A % L</code>）。</li>
<li>比较页号 P 和页表长度 M ，若P ≥ M，则产生越界中断，否则继续执行。</li>
<li>页表中页号P对应的 <code>页表项地址 = 页表始址F + 页号P * 页表项长度</code>，取出该页表项内容 b，即为物理块号。注意区分页表长度和页表项长度。页表长度是指一共有多少页，页表项长度是指页地址占多大的存储空间。</li>
<li>计算<code>E = b * L + w</code>，用得到的物理地址E去访问内存。</li>
</ol>
<p>以上整个地址变换过程均是由硬件自动完成的。例如，若页面大小 L 为 1KB，页号 2 对应的物理块为 b = 8，计算逻辑地址 A = 2500 的物理地址E的过程如下：<code>P= 2500 / 1K = 2, W = 250 % 1K = 452</code>，查找得到页号 2 对应的物理块的块号为 8，<code>E = 8 * 1024 + 452 = 8644</code>。</p>
<p>计算条件用十进制数和用二进制数给出，过程会稍有不同。页式管理只需给出一个整数就能确定对应的物理地址，因为页面大小L是固定的。因此，页式管理中地址空间是一维的。</p>
<blockquote>
<p>页表项的大小不是随意规定的，而是有所约束的。如何确定页表项的大小？页表项的作用是找到该页在内存中的位置。以 32 位逻辑地址空间、字节编址单位、一页 4KB 为例，地址空间内一共有 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:1.0641em;vertical-align:-0.25em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>32</span></span></span></span></span></span></span></span></span><span style="margin-right:0.05017em;">B</span><span>/4</span><span style="margin-right:0.07153em;">K</span><span style="margin-right:0.05017em;">B</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6833em;"></span><span>1</span><span style="margin-right:0.10903em;">M</span><span>页</span></span></span></span>，因此需要 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8889em;vertical-align:-0.1944em;"></span><span style="margin-right:0.01968em;">l</span><span>o</span><span><span style="margin-right:0.03588em;">g</span><span><span><span><span style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0359em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>2</span></span></span></span><span>​</span></span><span><span style="height:0.15em;"><span></span></span></span></span></span></span><span>1</span><span style="margin-right:0.10903em;">M</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>20</span></span></span></span> 位才能保证表示范围能容纳所有页面，又因为以字节作为编址单位，即页表项的大小 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.7719em;vertical-align:-0.136em;"></span><span>≥</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>⌈</span><span>20/81</span><span>⌉</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6833em;"></span><span>3</span><span style="margin-right:0.05017em;">B</span></span></span></span>。所以在这个条件下，为了保证页表项能够指向所有页面，页表项的大小应该大于等于 3B，当然，也可选择更大的页表项让一个页面能够正好容下整数个页表项，进而方便存储（如取成 4B，这样一页正好可以装下 1K 个页表项），或增加一些其他信息。</p>
</blockquote>
<p>下面讨论分页管理方式存在的两个主要问题：</p>
<ol>
<li>每次访存操作都需要进行逻辑地址到物理地址的转换，地址转换过程必须足够快，否则访存速度会降低</li>
<li>每个进程引入页表，用于存储映射机制，页表不能太大，否则内存利用率会降低</li>
</ol>
<h3 id="_4-3-具有快表的地址变换机构"> 4.3 具有快表的地址变换机构</h3>
<p>由上面介绍的地址变换过程可知，若页表全部放在内存中，则存取一个数据或一条指令至少要访问两次内存：第一次是访问页表，确定所存取的数据或指令的物理地址；第二次是根据该地址存取数据或指令。显然，这种方法比通常执行指令的速度慢了一半。</p>
<p>为此，在地址变换机构中增设一个具有并行查找能力的 <mark>高速缓冲存储器快表</mark>，又称相联存储器（TLB），用来存放当前访问的若干页表项，以加速地址变换的过程。与此对应，主存中的页表常称为慢表。具有快表的地址变换机构如图3.10所示。</p>
<p><img src="./README.assets/image-20220402090636828.png" alt="image-20220402090636828" loading="lazy"></p>
<p>在具有快表的分页机制中，地址的变换过程如下：</p>
<ol>
<li>CPU 给出逻辑地址后，由硬件进行地址转换，将页号送入高速缓存寄存器，并将此页号与快表中的所有页号进行比较。</li>
<li>若找到匹配的页号，说明所要访问的页表项在快表中，则直接从中取出该页对应的页框号，与页内偏移量拼接形成物理地址。这样，存取数据仅一次访存便可实现。</li>
<li>若未找到匹配的页号，则需要访问主存中的页表，读出页表项后,应同时将其存入快表，以便后面可能的再次访问。若快表已满，则须按特定的算法淘汰一个旧页表项。</li>
</ol>
<p>注意：有些处理机设计为快表和慢表同时查找，若在快表中查找成功则终止慢表的查找。一般快表的命中率可达 90% 以上，这样分页带来的速度损失就可降低至 10% 以下。快表的有效性基于著名的局部性原理，后面讲解虚拟内存时将会具体讨论它。</p>
<h3 id="_4-4-两级页表"> 4.4 两级页表</h3>
<div><p>一级页表的问题</p>
<ul>
<li>页表内内存配分必须连续，否则无法查表。</li>
<li>当进程需要的空间越大，一级页表也将越大</li>
</ul>
</div>
<p>二级页表则是将所有的页表项，拆开分成若干部分，每个【第二级页表】只需要存放其中部分页表项，而【第一级页表】则只需要存放一共有多少个【第二级页表】；从总空间上看，二级页表需要的空间更大，但是要求的连续空间更小。</p>
<p><img src="./README.assets/image-20220405145409026.png" alt="image-20220405145409026" loading="lazy"></p>
<p>建立多级页表的目的在于建立索引，以便不用浪费主存空间去存储无用的页表项，也不用盲目地顺序式查找页表项。</p>
<p><strong>二级页表项：</strong> <mark>一级页号 + 二级页号 + 页内偏移量</mark></p>
<p><img src="./README.assets/image-20220402090724860.png" alt="image-20220402090724860" loading="lazy"></p>
<h2 id="五、基本分段存储管理"> 五、基本分段存储管理</h2>
<p>分页管理方式是从计算机的角度考虑设计的，目的是提高内存的利用率，提升计算机的性能。分页通过硬件机制实现，对用户完全透明。</p>
<p><mark>分段管理方式的提出则考虑了用户和程序员，以满足方便编程、信息保护和共享、动态增长及动态链接等多方面的需要。</mark></p>
<h3 id="_5-1-分段"> 5.1 分段</h3>
<p>段式管理方式按照用户进程中的自然段划分逻辑空间。例如，用户进程由主程序段、两个子程序段、栈段和数据段组成，于是可以把这个用户进程划分为 5 段，每段从 0 开始编址，并分配一段连续的地址空间（段内要求连续，段间不要求连续，因此整个作业的地址空间是二维的），其逻辑地址由段号 S 与段内偏移量 W 两部分组成。</p>
<p>在图3.13中，段号为 16 位，段内偏移量为 16 位，因此-一个作业最多有 <span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.8141em;"></span><span><span>2</span><span><span><span><span style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span>16</span></span></span></span></span></span></span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:0.6444em;"></span><span>65536</span></span></span></span> 段，最大段长为 64KB。</p>
<p><strong>地址结构：</strong> <mark>段号 + 段内偏移量</mark></p>
<p><img src="./README.assets/image-20220402090820108.png" alt="image-20220402090820108" loading="lazy"></p>
<p>在页式系统中，逻辑地址的页号和页内偏移量对用户是透明的，但在段式系统中，段号和段内偏移量必须由用户显式提供，在高级程序设计语言中，这个工作由编译程序完成。</p>
<h3 id="_5-2-段表"> 5.2 段表</h3>
<p>每个进程都有张逻辑空间与内存空间映射的段表，其中每个段表项对应进程的一段，段表项记录该段在内存中的始址和长度。段表的内容如图3.14所示。</p>
<p><strong>段表项：</strong> <mark>段号 + 段长 + 主存始址</mark></p>
<p><img src="./README.assets/image-20220402090842959.png" alt="image-20220402090842959" loading="lazy"></p>
<p>配置段表后，执行中的进程可通过查找段表，找到每段所对应的内存区。可见，段表用于实现从逻辑段到物理内存区的映射，如图3.15所示。</p>
<p><img src="./README.assets/image-20220405151131345.png" alt="image-20220405151131345" loading="lazy"></p>
<h3 id="_5-3-地址变换机构"> 5.3 地址变换机构</h3>
<p>分段系统的地址变换过程如图3.16所示。为了实现进程从逻辑地址到物理地址的变换功能，在系统中设置了段表寄存器，用于存放段表始址 F 和段表长度 M。从逻辑地址A到物理地址 E 之间的地址变换过程如下:</p>
<p><img src="./README.assets/image-20220402090926345.png" alt="image-20220402090926345" loading="lazy"></p>
<ol>
<li>从逻辑地址 A 中取出前几位为段号S，后几位为段内偏移量 W。</li>
<li>比较段号 S 和段表长度 M，若S ≥ M，则产生越界中断，否则继续执行。</li>
<li>段表中段号 S 对应的 <code>段表项地址 = 段表始址F + 段号S * 段表项长度</code>，取出该段表项的前几位得到段长 C。若段内偏移量 ≥ C，则产生越界中断，否则继续执行。从这句话我们可以看出，段表项实际上只有两部分，前几位是段长，后几位是始址。</li>
<li>取出段表项中该段的始址 b，计算 E = b + W，用得到的物理地址 E 去访问内存。</li>
</ol>
<h3 id="_5-4-段的共享与保护"> 5.4 段的共享与保护</h3>
<p>在分段系统中，段的共享是通过两个作业的段表中相应表项指向被共享的段的同一个物理副本来实现的。当一个作业正从共享段中读取数据时，必须防止另一个作业修改此共享段中的数据。不能修改的代码称为纯代码或可重入代码（它不属于临界资源），这样的代码和不能修改的数据可以共享，而可修改的代码和数据不能共享。</p>
<p>与分页管理类似，分段管理的保护方法主要有两种：一种是存取控制保护，另一种是地址越界保护。地址越界保护将段表寄存器中的段表长度与逻辑地址中的段号比较，若段号大于段表长度，则产生越界中断；再将段表项中的段长和逻辑地址中的段内偏移进行比较，若段内偏移大于段长，也会产生越界中断。分页管理只需要判断页号是否越界，页内偏移是不可能越界的。</p>
<div><p>越界判断</p>
<p>分页存储中有一次越界判断：</p>
<ol>
<li>计算得到的页号是否 &gt;= 页表长度</li>
</ol>
<p>分段存储中有两次越界判断：</p>
<ol>
<li>计算得到的段号是否 &gt;= 段表长度</li>
<li>段内偏移量是否 &gt;= 段表项长度</li>
</ol>
<p>因为分页存储中每个页面的大小都是固定的，<code>页内偏移量 = 逻辑地址 % 页面大小</code>，因此不可能超过页面大小，从而比分段存储少一次越界判断。</p>
</div>
<p>与页式管理不同，段式管理不能通过给出一个整数便确定对应的物理地址，因为每段的长度是不固定的，无法通过整数除法得出段号，无法通过求余得出段内偏移，所以段号和段内偏移一定要显式给出（段号，段内偏移），因此分段管理的地址空间是二维的。</p>
<h2 id="六、段页式管理"> 六、段页式管理</h2>
<p>分页存储管理能有效地提高内存利用率，而分段存储管理能反映程序的逻辑结构并有利于段的共享和保护。将这两种存储管理方法结合起来，便形成了段页式存储管理方式。</p>
<p>在段页式系统中，作业的地址空间首先被分成若干逻辑段，每段都有自己的段号，然后将每段分成若千大小固定的页。对内存空间的管理仍然和分页存储管理一样， 將其分成若干和页面大小相同的存储块，对内存的分配以存储块为单位，如图3.17所示。</p>
<p><strong>地址结构：</strong> <mark>段号 + 页号 + 页内偏移量</mark></p>
<p><img src="./README.assets/image-20220402091009301.png" alt="image-20220402091009301" loading="lazy"></p>
<p>为了实现地址变换，系统为每个进程建立一张段表， 每个分段有一张页表。 段表表项中至少包括段号、页表长度和页表始址，页表表项中至少包括页号和块号。此外，系统中还应有一个段表寄存器，指出作业的段表始址和段表长度（段表寄存器和页表寄存器的作用都有两个，一是在段表或页表中寻址，二是判断是否越界）。</p>
<p>注意：在一个进程中，段表只有一个，而页表可能有多个。</p>
<p>在进行地址变换时，首先通过段表查到页表始址，然后通过页表找到页帧号，最后形成物理地址。进行一次访问实际需要三次访问主存，这里同样可以使用快表来加快查找速度，其关键字由段号、页号组成，值是对应的页帧号和保护码。</p>
<p><img src="./README.assets/image-20220405152323764.png" alt="image-20220405152323764" loading="lazy"></p>
<p>结合上面对段式和页式管理地址空间的分析，得出结论：段页式管理的地址空间是二维的。</p>
<div><p>对比</p>
<p><strong>页式管理</strong></p>
<p>优点：没有外碎片，每个内碎片不超过页的大小</p>
<p>缺点：程序全部装入内存，要求有相应的硬件支持</p>
<hr>
<p><strong>段式管理</strong></p>
<p>优点：可以分别编写和编译，可以针对不同类型的段采取不同的保护，可以按段为单位进行共享，</p>
<p>缺点：会产生碎片</p>
<hr>
<p><strong>段页式管理</strong></p>
<p>优点：结合上面两者的优点</p>
<p>缺点：复杂性和开销增加，需要的硬件以及占用的内存有所增加，执行速度下降</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T01:11:19.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">同步与互斥</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/2/3/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/2/3/"/>
    <updated>2022-04-03T08:48:48.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
<li><a href="https://blog.csdn.net/weixin_34097242/article/details/86458859" target="_blank" rel="noopener noreferrer">开中断和关中断</a></li>
</ul>
</div>
<h2 id="一、同步与互斥的基本概念"> 一、同步与互斥的基本概念</h2>
<p>在多道程序环境下，进程是并发执行的，不同进程之间存在着不同的相互制约关系。为了协调进程之间的相互制约关系，引入了进程同步的概念。</p>
<blockquote>
<p>例如，让系统计算 <code>1 + 2 x 3</code>，假设系统产生两个进程：一个是加法进程，一个是乘法进程。要让计算结果是正确的，一定要让加法进程发生在乘法进程之后，但实际，上操作系统具有异步性，若不加以制约，加法进程发生在乘法进程之前是绝对有可能的，因此要制定一定的机制去约束加法进程，让它在乘法进程完成之后才发生，而这种机制就是本节要讨论的内容。</p>
</blockquote>
<h3 id="_1-1-临界资源"> 1.1 临界资源</h3>
<div><p>临界资源</p>
<p>一次仅允许一个进程使用的资源称为临界资源</p>
</div>
<p>虽然多个进程可以共享系统中的各种资源，但其中许多资源一次只能为一个进程所用。许多物理设备都属于临界资源，如打印机等。此外，还有许多变量、数据等都可以被若干进程共享，也属于临界资源。</p>
<p>对临界资源的访问，必须互斥地进行，在每个进程中，访问临界资源的那段代码称为临界区。为了保证临界资源的正确使用，可把临界资源的访问过程分成4个部分:</p>
<ol>
<li><strong>进入区</strong>。为了进入临界区使用临界资源，在进入区要检查可否进入临界区，若能进入临界区，则应设置正在访问临界区的标志，以阻止其他进程同时进入临界区。</li>
<li><strong>临界区</strong>。进程中访问临界资源的那段代码，又称临界段。</li>
<li><strong>退出区</strong>。将正在访问临界区的标志清除。</li>
<li><strong>剩余区</strong>。代码中的其余部分。</li>
</ol>
<div><pre><code><span>do</span> <span>{</span>
    entry section<span>;</span>  	<span>//进入区</span>
    critical section<span>;</span>	<span>//临界区</span>
    exit section<span>;</span> 		<span>//退出区</span>
    remainder section<span>;</span>	<span>//剩余区</span>
<span>}</span> <span>while</span> <span>(</span><span>true</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_1-2-同步"> 1.2 同步</h3>
<div><p>同步</p>
<p>同步亦称直接制约关系，是指为完成某种任务而建立的两个或多个进程，这些进程因为需要在某些位置上协调它们的工作次序而等待、传递信息所产生的制约关系。</p>
</div>
<blockquote>
<p>进程间的直接制约关系源于它们之间的相互合作。例如，输入进程 A 通过单缓冲向进程 B 提供数据。当该缓冲区空时，进程 B 不能获得所需数据而阻塞，一旦进程 A 将数据送入缓冲区，进程 B 就被唤醒。反之，当缓冲区满时，进程 A 被阻塞，仅当进程 B 取走缓冲数据时，才唤醒进程 A。</p>
</blockquote>
<h3 id="_1-3-互斥"> 1.3 互斥</h3>
<div><p>互斥</p>
<p>互斥也称间接制约关系。当一个进程进入临界区使用临界资源时，另一个进程必须等待，当占用临界资源的进程退出临界区后，另一进程才允许去访问此临界资源。</p>
</div>
<blockquote>
<p>例如，在仅有一台打印机的系统中，有两个进程A和进程B，若进程A需要打印时，系统已将打印机分配给进程B,则进程A必须阻塞。一旦进程 B将打印机释放，系统便将进程A唤醒，并将其由阻塞态变为就绪态。</p>
</blockquote>
<p>为禁止两个进程同时进入临界区，同步机制应遵循以下准则:</p>
<ol>
<li><strong>空闲让进</strong>。临界区空闲时，可以允许一个请求进入临界区的进程立即进入临界区。</li>
<li><strong>忙则等待</strong>。当已有进程进入临界区时，其他试图进入临界区的进程必须等待。</li>
<li><strong>有限等待</strong>。对请求访问的进程，应保证能在有限时间内进入临界区。</li>
<li><strong>让权等待</strong>。当进程不能进入临界区时，应立即释放处理器，防止进程忙等待。</li>
</ol>
<h2 id="二、实现临界区互斥的基本方法"> 二、实现临界区互斥的基本方法</h2>
<h3 id="_2-1-软件实现方法"> 2.1 软件实现方法</h3>
<p>在进入区设置并检查一些标志 来标明是否有进程在临界区中，若已有进程在临界区，则在进入区通过循环检查进行等待，进程离开临界区后则在退出区修改标志。</p>
<hr>
<p>算法一：<strong>单标志法</strong>。</p>
<p>该算法设置一个公用整型变量 <code>turn</code>，用于指示被允许进入临界区的进程编号，即若 <code>turn = 0</code> ，则允许 P0 进程进入临界区。该算法可确保每次只允许一个进程进入临界区。</p>
<CodeGroup>
<CodeGroupItem title="P0">
<div><pre><code>P0 进程<span>:</span>
<span>while</span> <span>(</span>turn <span>!=</span> <span>0</span><span>)</span><span>;</span>	<span>//进入区</span>
critical section<span>;</span>	<span>//临界区</span>
turn <span>=</span> <span>1</span><span>;</span>			<span>//退出区</span>
remainder section<span>;</span>	<span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="P1">
<div><pre><code>P1 进程<span>:</span>
<span>while</span> <span>(</span>turn <span>!=</span> <span>1</span><span>)</span><span>;</span>  <span>//进入区</span>
critical section<span>;</span> 	<span>//临界区</span>
turn <span>=</span> <span>0</span><span>;</span> 			<span>//退出区</span>
remainder section<span>;</span>	<span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p>但两个进程必须交替进入临界区，若某个进程不再进入临界区，则另一个进程也将无法进入临界区（ <mark>违背【空闲让进】</mark> ）。这样很容易造成资源利用不充分。若 P0 顺利进入临界区并从临界区离开，则此时临界区是空闲的，但 P1 并没有进入临界区的打算，<code>turn = 1</code> 一直成立，P0 就无法再次进入临界区（一直被while死循环困住）。</p>
<hr>
<p>算法二：<strong>双标志法先检查</strong>。</p>
<p>该算法的基本思想是在每个进程访问临界区资源之前，先查看临界资源是否正被访问，若正被访问，该进程需等待；否则，进程才进入自己的临界区。为此，设置一个数据 <code>flag[i]</code>，如第i 个元素值为 FALSE，表示 Pi 进程未进入临界区，值为TRUE，表示 Pi 进程进入临界区。</p>
<CodeGroup>
<CodeGroupItem title="Pi">
<div><pre><code>Pi 进程<span>:</span>
<span>while</span><span>(</span>flag<span>[</span>j<span>]</span><span>)</span><span>;</span> 	<span>//1. 进入区</span>
flag<span>[</span>i<span>]</span> <span>=</span> TRUE<span>;</span>  	<span>//3. 进入区</span>
critical section<span>;</span>	<span>//临界区</span>
flag<span>[</span>i<span>]</span> <span>=</span> FALSE<span>;</span>    <span>//退出区</span>
remainder section<span>;</span>  <span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Pj">
<div><pre><code>Pj 进程<span>:</span>
<span>while</span><span>(</span>flag<span>[</span>i<span>]</span><span>)</span><span>;</span> 	<span>//2. 进入区</span>
flag<span>[</span>j<span>]</span> <span>=</span> TRUE<span>;</span>  	<span>//4. 进入区</span>
critical section<span>;</span>	<span>//临界区</span>
flag<span>[</span>j<span>]</span> <span>=</span> FALSE<span>;</span>    <span>//退出区</span>
remainder section<span>;</span>  <span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></CodeGroupItem>
</CodeGroup>
<ul>
<li>优点：不用交替进入，可连续使用；</li>
<li>缺点：Pi 和 Pj 可能同时进入临界区。按序列①②③④执行时，会同时进入临界区（ <mark>违背【忙则等待】</mark> ）。即在检查对方的 flag 后和切换自己的 flag 前有一段时间，结果都检查通过。这里的问题出在检查和修改操作不能一次进行。</li>
</ul>
<hr>
<p>算法三：<strong>双标志法后检查</strong>。</p>
<p>算法二先检测对方的进程状态标志，再置自己的标志，由于在检测和放置中可插入另一个进程到达时的检测操作，会造成两个进程在分别检测后同时进入临界区。为此，算法三先将自己的标志设置为TRUE，再检测对方的状态标志，若对方标志为 TRUE，则进程等待；否则进入临界区。</p>
<CodeGroup>
<CodeGroupItem title="Pi">
<div><pre><code>Pi 进程：
flag<span>[</span>i<span>]</span> <span>=</span> TRUE<span>;</span> 	<span>//进入区</span>
<span>while</span><span>(</span>flag<span>[</span>j<span>]</span><span>)</span><span>;</span> 	<span>//进入区</span>
critical section<span>;</span>	<span>//临界区</span>
flag<span>[</span>i<span>]</span> <span>=</span> FALSE<span>;</span>	<span>//退出区</span>
remainder section<span>;</span>	<span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Pj">
<div><pre><code>Pj 进程<span>:</span>
flag<span>[</span>j<span>]</span> <span>=</span> TRUE<span>;</span> 	<span>//进入区</span>
<span>while</span><span>(</span>flag<span>[</span>i<span>]</span><span>)</span><span>;</span> 	<span>//进入区</span>
critical section<span>;</span>	<span>//临界区</span>
flag<span>[</span>i<span>]</span> <span>=</span> FALSE<span>;</span>	<span>//退出区</span>
remainder section<span>;</span>	<span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p>两个进程几乎 同时都想进入临界区时，它们分别将自己的标志值 flag 设置为TRUE，并且同时检测对方的状态（执行while语句），发现对方也要进入临界区时，双方互相谦让，结果谁也进不了临界区，从而 <mark>导致【饥饿】现象</mark></p>
<hr>
<p>算法四：<strong>Peterson's Algorithm</strong>。</p>
<p>为了防止两个进程为进入临界区而无限期等待，又设置了变量 turn，每个进程在先设置自己的标志后再设置 turn 标志。这时，再同时检测另一个进程状态标志和允许进入标志，以便保证两个进程同时要求进入临界区时，只允许一个进程进入临界区。</p>
<CodeGroup>
<CodeGroupItem title="Pi">
<div><pre><code>Pi进程：
flag<span>[</span>i<span>]</span> <span>=</span> TRUE<span>;</span> turn <span>=</span> j<span>;</span>		<span>//进入区</span>
<span>while</span><span>(</span>flag<span>[</span>j<span>]</span> <span>&amp;&amp;</span> turn <span>=</span> j<span>)</span><span>;</span>		<span>//进入区</span>
critical section<span>;</span>				<span>//临界区</span>
flag<span>[</span>i<span>]</span> <span>=</span> FALSE<span>;</span>				<span>//退出区</span>
remainder section<span>;</span>				<span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="Pj">
<div><pre><code>Pj进程<span>:</span>
flag<span>[</span>j<span>]</span> <span>=</span> TRUE<span>;</span> turn <span>=</span> i<span>;</span>		<span>//进入区</span>
<span>while</span><span>(</span>flag<span>[</span>i<span>]</span> <span>&amp;&amp;</span> turn <span>==</span> i<span>)</span><span>;</span>	<span>//进入区</span>
critical section<span>;</span>				<span>//临界区</span>
flag<span>[</span>i<span>]</span> <span>=</span> FALSE<span>;</span> 				<span>//退出区</span>
remainder section<span>;</span> 				<span>//剩余区</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p>具体如下：考虑进程 Pi，一旦设置 <code>flag[i] = true</code>，就表示它想要进入临界区，同时 <code>turn = j</code>，此时若进程 Pj 已在临界区中，符合进程 Pi 中的 while 循环条件，则 Pi 不能进入临界区。若 Pj 不想要进入临界区，即 <code>flag[j] = false</code>， 循环条件不符合，则 Pi 可以顺利进入，反之亦然。本算法的基本思想是算法一和算法三的结合。利用 flag 解决临界资源的互斥访问，而利用 turn 解决【饥饿】现象。理解Peterson's Algorithm的最好方法就是手动模拟。</p>
<h3 id="_2-2-硬件实现方法"> 2.2 硬件实现方法</h3>
<p>计算机提供了特殊的硬件指令，允许对一个字中的内容进行检测和修正，或对两个字的内容进行交换等。通过硬件支持实现临界段问题的方法称为低级方法，或称 <mark>元方法</mark></p>
<h4 id="_1-中断屏蔽方法"> <strong>1. 中断屏蔽方法</strong></h4>
<p>当一个进程正在执行它的临界区代码时，防止其他进程进入其临界区的最简方法是关中断。因为CPU只在发生中断时引起进程切换，因此屏蔽中断能够保证当前运行的进程让临界区代码顺利地执行完，进而保证互斥的正确实现，然后执行开中断。其典型模式为</p>
<div><pre><code>关中断<span>;</span>
临界区<span>;</span>
开中断<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>这种方法限制了处理机交替执行程序的能力，因此执行的效率会明显降低</strong>。对内核来说，在它执行更新变量或列表的几条指令期间，关中断是很方便的，但将关中断的权力交给用户则很不明智，若一个进程关中断后不再开中断，则系统可能会因此终止。</p>
<div><p>关中断</p>
<p>关中断和开中断其实就是像我们生活中的开关一样。 关中断是为了保护一些不能中途停止执行的程序而设计的，计算机的CPU进行的是时分复用，即每个时钟周期内，CPU只能执行一条指令。在多道程序设计的环境下（就是我们通常所说的多个程序同时运行时），CPU是不断地交替地将这些程序的指令一条一条的分别执行，这样从宏观上看我们就感觉多个程序是在同时执行，但从微观上看则是CPU在不同的时间段（极短）内执行着不同程序的单条指令。而CPU在这些指令之间的切换就是通过中断来实现的。关中断就是为了让CPU在一段时间内执行同一程序的多条指令而设计的，比如在出现了非常事件后又恢复正常时，CPU就会忙于恢复非常事件出现之前计算机的工作环境（通常叫做恢复现场），在恢复现场的时候，CPU是不允许被其他的程序打扰的，此时就要启动关中断，不再相应其他的请求。当现场恢复完毕后，CPU就启动开中断，其他等待着的程序的指令就开始被CPU执行，计算机恢复正常。</p>
<div><p>多核下的关中断又是怎么样的呢？</p>
</div>
</div>
<hr>
<h4 id="_2-硬件指令方法"> <strong>2. 硬件指令方法</strong></h4>
<div><p>TestAndSet 指令</p>
<p>这条指令是原子操作，即执行该代码时不允许被中断。其功能是读出指定标志后把该标志设置为真。指令的功能描述如下:</p>
<div><pre><code>boolean <span>TestAndSet</span> <span>(</span>boolean <span>*</span>lock<span>)</span> <span>{</span>
    boolean old<span>;</span>
    old <span>=</span> <span>*</span>lock<span>;</span>
    <span>*</span>lock <span>=</span> <span>true</span><span>;</span>
    <span>return</span> old<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>可以为每个临界资源设置一个共享布尔变量 lock，表示资源的两种状态：true表示正被占用，初值为 false。 进程在进入临界区之前，利用 TestAndSet 检查标志 lock，若无进程在临界区，则其值为 false，可以进入，关闭临界资源，把 lock 置为 true，使任何进程都不能进入临界区；若有进程在临界区，则循环检查，直到进程退出。利用该指令实现互斥的过程描述如下:</p>
<div><div><div>&nbsp;</div><br><br><br><br></div><pre><code><span>while</span> <span>TestAndSet</span> <span>(</span><span>&amp;</span>lock<span>)</span><span>;</span>
进程的临界区代码段<span>;</span>
lock <span>=</span> <span>false</span><span>;</span>
进程的其他代码<span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></div>
<div><p>Swap指令</p>
<p>该指令的功能是交换两个字(字节)的内容。其功能描述如下:</p>
<div><pre><code><span>Swap</span><span>(</span>boolean <span>*</span>a<span>,</span> boolean <span>*</span>b<span>)</span> <span>{</span>
    boolean temp<span>;</span>
    Temp <span>=</span> <span>*</span>a<span>;</span> 
    <span>*</span>a <span>=</span> tb<span>;</span>
    <span>*</span>b <span>=</span> temp<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><blockquote>
<p>注意：以上对 TestAndSet 和 Swap 指令的描述仅是功能实现，而并非软件实现的定义。事实上，它们是由硬件逻辑直接实现的，不会被中断。</p>
</blockquote>
<p>用 Swap 指令可以简单有效地实现互斥，为每个临界资源设置一个共享布尔变量 lock，初值为 false；在每个进程中再设置一个局部布尔变量 key，用于与 lock 交换信息。在进入临界区前，先利用 Swap 指令交换 lock 与 key 的内容，然后检查 key 的状态；有进程在临界区时，重复交换和检查过程，直到进程退出。其处理过程描述如下:</p>
<div><div><br><div>&nbsp;</div><br><br><br><br></div><pre><code>key <span>=</span> <span>true</span><span>;</span>
<span>while</span> <span>(</span>key<span>)</span> <span>Swap</span><span>(</span><span>&amp;</span>lock<span>,</span> <span>&amp;</span>key<span>)</span><span>;</span>
进程的临界区代码段<span>;</span>
lock <span>=</span> <span>false</span><span>;</span>
进程的其他代码<span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div></div>
<div><p>硬件方法的优缺点</p>
<p>硬件方法的优点：适用于任意数目的进程，而不管是单处理机还是多处理机；简单、容易验证其正确性。可以支持进程内有多个临界区，只需为每个临界区设立一个布尔变量。</p>
<p>硬件方法的缺点：进程等待进入临界区时要耗费处理机时间，不能实现让权等待。从等待进程中随机选择-一个进入临界区，有的进程可能一直选不上， 从而导致【饥饿】现象。</p>
</div>
<h2 id="三、互斥锁"> 三、互斥锁</h2>
<p>解决临界区最简单的工具就是 <strong>互斥锁(mutex lock)</strong>。一个进程在进入临界区时应获得锁；在退出临界区时释放锁。函数 acquire() 获得锁，而函数 release() 释放锁。每个互斥锁有一个布尔变量 available，表示锁是否可用。如果锁是可用的，调用 acqiure() 会成功，且锁不再可用。当一个进程试图获取不可用的锁时，会被阻塞，直到锁被释放。</p>
<div><pre><code><span>acquire</span><span>(</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span><span>!</span>available<span>)</span><span>;</span>	<span>//忙等待</span>
    available <span>=</span> <span>false</span><span>;</span>	<span>//获得锁</span>
<span>}</span>

<span>release</span><span>(</span><span>)</span> <span>{</span>
    available <span>=</span> <span>true</span><span>;</span> 	<span>//释放锁</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>acquire() 或 release() 的执行必须是原子操作，因此互斥锁通常采用硬件机制来实现。</p>
<p><strong>互斥锁的主要缺点是忙等待</strong>，当有一个进程在临界区中，任何其他进程在进入临界区时必须连续循环调用acquire()。当多个进程共享同一CPU时，就浪费了CPU周期。因此，互斥锁通常用于多处理器系统，一个线程可以在一个处理器上等待，不影响其他线程的执行。</p>
<h2 id="四、信号量"> 四、信号量</h2>
<p>信号量机制是一种功能较强的机制，可用来解决互斥与同步问题，它只能被两个标准的原语 wait(S) 和 signal(S) 访问，也可记为【P操作，申请资源】和【V操作，释放资源】。</p>
<div><p>原语</p>
<p>原语是指完成某种功能且不被分割、不被中断执行的操作序列，通常可由硬件来实现。</p>
</div>
<blockquote>
<p>例如，前述的 Test-and-Set 和 Swap 指令就是由硬件实现的原子操作。原语功能的不被中断执行特性在单处理机上可由软件通过屏蔽中断方法实现。原语之所以不能被中断执行，是因为原语对变量的操作过程若被打断，可能会去运行另一个对同一-变量的操作过程，从而出现临界段问题。</p>
</blockquote>
<h3 id="_4-1-整型信号量"> 4.1 整型信号量</h3>
<p>整型信号量被定义为一个用于表示资源数目的整型量 s，wait 和 signal 操作可描述为</p>
<div><pre><code><span>wait</span><span>(</span>S<span>)</span> <span>{</span>
    <span>while</span><span>(</span>S <span>&lt;=</span> <span>0</span><span>)</span><span>;</span>
    S <span>=</span> S <span>-</span> <span>1</span><span>;</span>
<span>}</span>

<span>signal</span><span>(</span>S<span>)</span> <span>{</span>
    S <span>=</span> S <span>+</span> <span>1</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在整型信号量机制中的 wait 操作，只要信号量 S ≤ 0，就会不断地测试。</p>
<p>因此，<mark>该机制并未遵循【让权等待】的准则，而是使进程处于【忙等】的状态</mark></p>
<h3 id="_4-2-记录型信号量"> 4.2 记录型信号量</h3>
<p>记录型信号量机制是一种不存在【忙等】现象的进程同步机制。除了需要一个用于代表资源数目的整型变量 value外，再增加一个进程链表L，用于链接所有等待该资源的进程。记录型信号量得名于采用了记录型的数据结构。记录型信号量可描述为</p>
<div><pre><code><span>typedef</span> <span>struct</span> <span>{</span>
    <span>int</span> value<span>;</span>
    <span>struct</span> <span>process</span> <span>*</span>L<span>;</span>
<span>}</span> semaphore<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>相应的 wait(S) 和 signal(S) 的操作如下:</p>
<div><pre><code><span>void</span> <span>wait</span><span>(</span>semaphore S<span>)</span> <span>{</span> <span>//相当于申请资源</span>
    s<span>.</span>value<span>--</span><span>;</span>
    <span>if</span> <span>(</span>S<span>.</span>value <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        add <span>this</span> process to S<span>.</span>L<span>;</span>
        <span>block</span><span>(</span>S<span>.</span>L<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>wait 操作，<code>S.value--</code> 表示进程请求一个该类资源，当 <code>S.value &lt; 0</code> 时，表示该类资源已分配完毕，因此进程应调用 block 原语，进行自我阻塞，放弃处理机，并插入该类资源的等待队列 S.L，可见该机制遵循了【让权等待】的准则。</p>
<div><pre><code><span>void</span> <span>signal</span><span>(</span>semaphore S<span>)</span><span>{</span> <span>//相当于释放资源</span>
    s<span>.</span>value<span>++</span><span>;</span>
    <span>if</span><span>(</span>S<span>.</span>value <span>&lt;=</span> <span>0</span><span>)</span> <span>{</span>
        remove a process P from S<span>.</span>L<span>;</span>
        <span>wakeup</span><span>(</span>P<span>)</span> <span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>signal 操作，表示进程释放一个资源，使系统中可供分配的该类资源数增1，因此有 <code>S.value++</code>。若加1后仍是 <code>S.value &lt;= 0</code> ，则表示在 S.L 中仍有等待该资源的进程被阻塞，因此还应调用 wakeup 原语，将 S.L 中的第一个等待进程唤醒。</p>
<h3 id="_4-3-利用信号量实现同步"> 4.3 利用信号量实现同步</h3>
<p>信号量机制能用于解决进程间的各种同步问题。设 S 为实现进程 P1，P2 同步的公共信号量，初值为 0。进程 P2 中的语句 y 要使用进程 P1 中语句 x 的运行结果，所以只有当语句 x 执行完成之后语句 y 才可以执行。其实现进程同步的算法如下：</p>
<div><pre><code>semaphore S <span>=</span> <span>0</span><span>;</span>	<span>//初始化信号量</span>

<span>P1</span><span>(</span><span>)</span> <span>{</span>
    x<span>;</span> 				<span>//语句x</span>
    <span>V</span><span>(</span>S<span>)</span><span>;</span>			<span>//告诉进程P2，语句x已经完成</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>

<span>P2</span><span>(</span><span>)</span> <span>{</span>
    <span>P</span><span>(</span>S<span>)</span><span>;</span> 			<span>//检查语句x是否运行完成</span>
    y<span>;</span> 				<span>//检查无误，运行y语句</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>若 P2 先执行到 P(S) 时，S 为 0，执行 P 操作会把进程 P2 阻塞，并放入阻塞队列；当进程 P1 中的 x 执行完后，执行 V 操作，把 P2 从阻塞队列中放回就绪队列，当 P2 得到处理机时，就得以继续执行。</p>
<h3 id="_4-4-利用信号量实现进程互斥"> 4.4 利用信号量实现进程互斥</h3>
<p>信号量机制也能很方便地解决进程互斥问题。设 S 为实现进程 P1，P2 互斥的信号量，由于每次只允许一个进程进入临界区，所以 S 的初值应为 1 (即可用资源数为1)。只需把临界区置于 P(S) 和 V(S) 之间，即可实现两个进程对临界资源的互斥访问。其算法如下:</p>
<div><pre><code>semaphore S <span>=</span> <span>1</span><span>;</span>	<span>//初始化信号量</span>

<span>P1</span><span>(</span><span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>P</span><span>(</span>S<span>)</span><span>;</span> 			<span>//准备开始访问临界资源，加锁</span>
    进程P1的临界区<span>;</span>
    <span>V</span><span>(</span>S<span>)</span><span>;</span> 			<span>//访问结束，解锁</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>

<span>P2</span><span>(</span><span>)</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span>
    <span>P</span><span>(</span>S<span>)</span><span>;</span> 			<span>//准备开始访问临界资源，加锁</span>
    进程P2的临界区<span>;</span>
    <span>V</span><span>(</span>S<span>)</span><span>;</span> 			<span>//访问结束，解锁</span>
    <span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>当没有进程在临界区时，任意一个进程要进入临界区，就要执行 P 操作，把 S 的值减为 0，然后进入临界区；当有进程存在于临界区时，S 的值为 0，再有进程要进入临界区，执行 P 操作时将会被阻塞，直至在临界区中的进程退出，这样便实现了临界区的互斥。</p>
<p>互斥是不同进程对同一信号量进行 P，V 操作实现的，一个进程成功对信号量执行了 P 操作后进入临界区，并在退出临界区后，由该进程本身对该信号量执行 V 操作，表示当前没有进程进入临界区，可以让其他进程进入。</p>
<h2 id="五、管程"> 五、管程</h2>
<p>在信号量机制中，每个要访问临界资源的进程都必须自备同步的 PV 操作，大量分散的同步操作给系统管理带来了麻烦，且容易因同步操作不当而导致系统死锁。于是，便产生了一种新的进程同步工具——管程。 管程的特性保证了进程互斥，无须程序员自己实现互斥，从而降低了死锁发生的可能性。同时管程提供了条件变量，可以让程序员灵活地实现进程同步。</p>
<h3 id="_5-1-管程的定义"> 5.1 管程的定义</h3>
<p>系统中的各种硬件资源和软件资源，均可用数据结构抽象地描述其资源特性，即用少量信息和对资源所执行的操作来表征该资源，而忽略它们的内部结构和实现细节。</p>
<p>利用共享数据结构抽象地表示系统中的共享资源，而把对该数据结构实施的操作定义为一组过程。进程对共享资源的申请、释放等操作，都通过这组过程来实现，这组过程还可以根据资源情况，或接受或阻塞进程的访问，确保每次仅有一个进程使用共享资源，这样就可以统一管理对共享资源的所有访问，实现进程互斥。这个代表共享资源的数据结构，以及由对该共享数据结构实施操作的一组过程所组成的资源管理程序，称为管程( monitor)。管程定义了一个数据结构和能为并发进程所执行(在该数据结构上)的一组操作，这组操作能同步进程和改变管程中的数据。</p>
<p>由上述定义可知，管程由4部分组成：</p>
<ol>
<li>管程的名称</li>
<li>局部于管程内部的共享数据结构说明</li>
<li>对该数据结构进行操作的一组过程(或函数)</li>
<li>对局部于管程内部的共享数据设置初始值的语句。</li>
</ol>
<p>管程的定义描述举例如下:</p>
<div><pre><code>monitor Demo <span>{</span> <span>// 1.定义一个名称为“Demo"的管程</span>
    <span>// 2. 定义共享数据结构，对应系统中的某种共享资源</span>
    共享数据结构S<span>;</span>
    
    <span>// 4. 对共享数据结构初始化的语句</span>
    <span>init_code</span><span>(</span><span>)</span><span>{</span>
        S <span>=</span> <span>5</span><span>;</span> <span>// 初始资源数等于5</span>
    <span>}</span>

    <span>// 3. 过程1：申请一个资源</span>
    <span>take_away</span><span>(</span><span>)</span><span>{</span>
        对共享 数据结构x的一系列处理<span>;</span>
        S<span>--</span><span>;</span> <span>//可用资源数-1</span>
        <span>.</span><span>.</span><span>.</span>
    <span>}</span>

    <span>// 3. 过程2：归还一个资源</span>
    <span>give_back</span><span>(</span><span>)</span> <span>{</span>
        对共享数据结构x的一系列处理<span>;</span>
        S<span>++</span><span>;</span> <span>//可用资源数+1</span>
        <span>.</span><span>.</span><span>.</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>熟悉面向对象程序设计的读者看到管程的组成后，会立即联想到管程很像一个类 (class)。</p>
<ol>
<li>管程把对共享资源的操作封装起来，管程内的共享数据结构只能被管程内的过程所访问。一个进程只有通过调用管程内的过程才能进入管程访问共享资源。对于上例，外部进程只能通过调用 <code>take_away()</code> 过程来申请一个资源；归还资源也一样。</li>
<li>每次仅允许一个进程进入管程，从而实现进程互斥。若多个进程同时调用 <code>take_away()</code>，<code>give back()</code>，则只有某个进程运行完它调用的过程后，下个进程才能开始运行它调用的过程。也就是说，各个进程只能串行执行管程内的过程，这一特性保证了进程【互斥】访问共享数据结构 S。</li>
</ol>
<h3 id="_5-2-条件变量"> 5.2 条件变量</h3>
<p>当一个进程进入管程后被阻塞，直到阻塞的原因解除时，在此期间，如果该进程不释放管程，那么其他进程无法进入管程。为此，将阻塞原因定义为条件变量 condition。 通常，一个进程被阻塞的原因可以有多个，因此在管程中设置了多个条件变量。每个条件变量保存了一个等待队列，用于记录因该条件变量而阻塞的所有进程，对条件变量只能进行两种操作，即 wait 和 signal。</p>
<ul>
<li>x.wait：当x对应的条件不满足时，正在调用管程的进程调用 x.wait 将自己插入 x 条件的等待队列，并释放管程。此时其他进程可以使用该管程。</li>
<li>x.signal：x对应的条件发生了变化，则调用 x.signal，唤醒一个因 x 条件而阻塞的进程。</li>
</ul>
<p>下面给出条件变量的定义和使用:</p>
<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br></div><pre><code>monitor Demo <span>{</span>
    共享数据结构S<span>;</span>
    condition x<span>;</span> <span>// 定义一个条件变量x</span>

    <span>init_code</span><span>(</span><span>)</span> <span>{</span> <span>.</span><span>.</span><span>.</span> <span>}</span>

    <span>take_away</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span><span>(</span>S <span>&lt;=</span> <span>0</span><span>)</span> x<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span> <span>// 资源不够， 在条件变量x上阻塞等待</span>
        资源足够，分配资源，做一系列相应处理<span>;</span>
    <span>}</span>

    <span>give_back</span><span>(</span><span>)</span> <span>{</span>
        归还资源，做一系列相应处理<span>;</span>
        <span>if</span><span>(</span>有进程在等待<span>)</span> x<span>.</span>signal<span>;</span> <span>// 唤醒一个阻塞进程</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>条件变量和信号量的比较：</p>
<p>相似点：条件变量的 wait/signal 操作类似于信号量的 P/V 操作，可以实现进程的阻塞/唤醒。</p>
<p>不同点：条件变量是【没有值】的，仅实现了【排队等待】功能；而信号量是【有值】的，信号量的值反映了剩余资源数，而在管程中，剩余资源数用共享数据结构记录。</p>
<h2 id="六、经典同步问题"> 六、经典同步问题</h2>
<h3 id="_6-1-生产者-消费者问题"> 6.1 生产者-消费者问题</h3>
<p>问题描述：一组生产者进程和一组消费者进程共享一个初始为空、大小为 n 的缓冲区，只有缓冲区没满时，生产者才能把消息放入缓冲区，否则必须等待；只有缓冲区不空时，消费者才能从中取出消息，否则必须等待。由于缓冲区是临界资源，它只允许一个生产者放入消息，或一个消费者从中取出消息。</p>
<p>问题分析：</p>
<ol>
<li>关系分析。<strong>生产者和消费者对缓冲区互斥访问是互斥关系</strong>，同时生产者和消费者又是一个相互协作的关系，只有生产者生产之后，消费者才能消费，<strong>它们也是同步关系</strong>。</li>
<li>整理思路。这里比较简单，只有生产者和消费者两个进程，正好是这两个进程存在着互斥关系和同步关系。那么需要解决的是互斥和同步 PV 操作的位置。</li>
<li>信号量设置。信号量 mutex 作为互斥信号量，用于控制互斥访问缓冲池，互斥信号量初值为1；信号量 full 用于记录当前缓冲池中的【满】缓冲区数，初值为 0。信号量 empty 用于记录当前缓冲池中的【空】缓冲区数，初值为 n。</li>
</ol>
<div><pre><code>semaphore mutex <span>=</span> <span>1</span><span>;</span> 				<span>// 临界区互斥信号量</span>
semaphore empty <span>=</span> n<span>;</span> 				<span>// 空闲缓冲区</span>
semaphore full <span>=</span> <span>0</span><span>;</span> 				<span>// 缓冲区初始化为空</span>
<span>producer</span><span>(</span><span>)</span> <span>{</span> 						<span>// 生产者进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        produce an item in nextp<span>;</span> 	<span>// 生产数据</span>
        <span>P</span><span>(</span>empty<span>)</span><span>;</span> 					<span>// 获取空缓冲区单元</span>
        <span>P</span><span>(</span>mutex<span>)</span><span>;</span> 					<span>// 进入临界区</span>
        add nextp to buffer<span>;</span> 		<span>// 将数据放入缓冲区</span>
        <span>V</span><span>(</span>mutex<span>)</span><span>;</span>  					<span>// 离开临界区，释放互斥信号量</span>
        <span>V</span><span>(</span>full<span>)</span><span>;</span>  					<span>// 满缓冲区数加1</span>
    <span>}</span> 
<span>}</span>

<span>consumer</span><span>(</span><span>)</span> <span>{</span> 						<span>// 消费者进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span><span>(</span>fu1l<span>)</span><span>;</span> 					<span>// 获取满缓冲区单元</span>
        <span>P</span><span>(</span>mutex<span>)</span><span>;</span> 					<span>// 进入临界区</span>
        remove an item from buffer<span>;</span> <span>// 从缓冲区中取出数据</span>
        <span>V</span><span>(</span>mutex<span>)</span><span>;</span> 					<span>// 离开临界区，释放互斥信号量</span>
        <span>V</span><span>(</span>empty<span>)</span><span>;</span> 					<span>// 空缓冲区数加1</span>
        consume the item<span>;</span> 			<span>// 消费数据</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p>该类问题要注意对缓冲区大小为 n 的处理，当缓冲区中有空时，便可对 empty 变量执行 P 操作，一旦取走一个产品便要执行V操作以释放空闲区。对 empty 和 full 变量的 P 操作必须放在对 mutex 的 P 操作之前。</p>
<p>若生产者进程先执行 P(mutex)，然后执行 P(empty)，消费者执行 P(mutex)，然后执行 P(full)，这样可不可以？答案是否定的。设想生产者进程已将缓冲区放满，消费者进程并没有取产品，即 <code>empty= 0</code>，当下次仍然是生产者进程运行时，它先执行 P(mutex) 封锁信号量，再执行 P(empty) 时将被阻塞，希望消费者取出产品后将其唤醒。轮到消费者进程运行时，它先执行 P(mutex)，然而由于生产者进程已经封锁 mutex 信号量，消费者进程也会被阻塞，这样一来生产者、消费者进程都将阻塞，都指望对方唤醒自己，因此陷入了无休止的等待。</p>
<p>同理，若消费者进程已将缓冲区取空，即 full= 0，下次若还是消费者先运行，也会出现类似的死锁。不过生产者释放信号量时，mutex，full 先释放哪一个 无所谓，消费者先释放 mutex 或 empty 都可以。</p>
<p>根据对同步互斥问题的简单总结，我们发现，其实生产者消费者问题只是一个同步互斥问题的综合而已。</p>
<hr>
<p>下面再看一个较为复杂的生产者-消费者问题。</p>
<p>问题描述：桌子上有一个盘子，每次只能向其中放入一个水果。爸爸专向盘子中放苹果，妈妈专向盘子中放橘子，儿子专等吃盘子中的橘子，女儿专等吃盘子中的苹果。只有盘子为空时，爸爸或妈妈才可向盘子中放一个水果；仅当盘子中有自己需要的水果时，儿子或女儿可以从盘子中取出</p>
<p><img src="./README.assets/image-20220331091841339.png" alt="image-20220331091841339" loading="lazy"></p>
<p>问题分析：</p>
<ol>
<li>关系分析。这里的关系要稍复杂一些。由每次只能向其中放入一个水果可知，爸爸和妈妈是互斥关系。
爸爸和女儿、妈妈和儿子是同步关系，而且这两对进程必须连起来，儿子和女儿之间没有互斥和同步
关系，因为他们是选择条件执行，不可能并发，如图2.11所示。</li>
<li>整理思路。这里有4个进程，实际上可抽象为两个生产者和两个消费者被连接到大小为 1 的缓冲区上。</li>
<li>信号量设置。首先将信号量 plate 设置互斥信号量，表示是否允许向盘子放入水果，初值为 1 表示允许放入，且只允许放入一个。信号量 apple 表示盘子中是否有苹果，初值为 0 表示盘子为空，不许取，apple = 1表示可以取。信号量 orange 表示盘子中是否有橘子，初值为 0 表示盘子为空，不许取，orange = 1表示可以取。</li>
</ol>
<p>解决该问题的代码如下:</p>
<div><pre><code>semaphore plate <span>=</span> <span>1</span><span>,</span> apple <span>=</span> <span>0</span><span>,</span> orange <span>=</span> <span>0</span><span>;</span>
<span>dad</span><span>(</span><span>)</span> <span>{</span> 								<span>// 父亲进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        prepare an apple<span>;</span>
        <span>P</span><span>(</span>plate<span>)</span><span>;</span> 						<span>// 互斥向盘中取、放水果</span>
        put the apple on the plate<span>;</span>		<span>// 向盘中放苹果</span>
        <span>V</span><span>(</span>apple<span>)</span><span>;</span> 						<span>// 允许取苹果</span>
    <span>}</span>
<span>}</span>

<span>mom</span><span>(</span><span>)</span> <span>{</span> 								<span>// 母亲进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        prepare an orange<span>;</span>
        <span>P</span><span>(</span>plate<span>)</span><span>;</span> 						<span>// 互斥向盘中取、放水果</span>
        put the orange on the plate<span>;</span>	<span>// 向盘中放橘子</span>
        <span>V</span><span>(</span>orange<span>)</span><span>;</span> 						<span>// 允许取橘子</span>
    <span>}</span>
<span>}</span>

<span>son</span><span>(</span><span>)</span> <span>{</span> 								<span>// 儿子进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span><span>{</span>
        <span>P</span><span>(</span>orange<span>)</span><span>;</span> 						<span>// 互斥向盘中取橘子</span>
        take an orange from the plate<span>;</span>
        <span>V</span><span>(</span>plate<span>)</span><span>;</span> 						<span>// 允许向盘中取、放水果</span>
        eat the orange<span>;</span>
    <span>}</span>
<span>}</span>

<span>daughter</span><span>(</span><span>)</span> <span>{</span> 							<span>// 女儿进程</span>
    <span>while</span><span>(</span>l<span>)</span> <span>{</span>
        <span>P</span><span>(</span>apple<span>)</span><span>;</span> 						<span>// 互斥向盘中取苹果</span>
        take an apple from the plate<span>;</span>
        <span>V</span><span>(</span>plate<span>)</span><span>;</span> 						<span>// 允许向盘中取、放水果</span>
        eat the apple<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>进程间的关系如图2.11所示。dad() 和 daughter()、mom() 和 son() 必须连续执行，正因为如此，也只能在女儿拿走苹果后或儿子拿走橘子后才能释放盘子，即 V(plate) 操作。</p>
<h3 id="_6-2-读者-写者问题"> 6.2 读者-写者问题</h3>
<p>问题描述：有读者和写者两组并发进程，共享一个文件，当两个或以上的读进程同时访问共享数据时不会产生副作用，但若某个写进程和其他进程（读进程或写进程）同时访问共享数据时则可能导致数据不一致的错误。因此要求：</p>
<ol>
<li>允许多个读者可以同时对文件执行读操作</li>
<li>只允许一个写者往文件中写信息</li>
<li>任一写者在完成写操作之前不允许其他读者或写者工作</li>
<li>写者执行写操作前，应让已有的读者和写者全部退出。</li>
</ol>
<p>问题分析：</p>
<ol>
<li>关系分析。由题目分析读者和写者是互斥的，写者和写者也是互斥的，而读者和读者不存在互斥问题。</li>
<li>整理思路。两个进程，即读者和写者。写者是比较简单的，它和任何进程互斥，用互斥信号量的P操作、V操作即可解决。读者的问题比较复杂，它必须在实现与写者互斥的同时，实现与其他读者的同步，因此简单的一-对P操作、V操作是无法解决问题的。这里用到了一个计数器，用它来判断当前是否有读者读文件。当有读者时，写者是无法写文件的，此时读者会一直占用文件，当没有读者时，写者才可以写文件。同时，这里不
同读者对计数器的访问也应该是互斥的。</li>
<li>信号量设置。首先设置信号量 count 为计数器，用于记录当前读者的数量，初值为 0；设置 mutex 为互斥信号量，用于保护更新 count 变量时的互斥；设置互斥信号量 rw，用于保证读者和写者的互斥访问。</li>
</ol>
<p>代码如下:</p>
<div><pre><code><span>int</span> count <span>=</span> <span>0</span><span>;</span> 				<span>// 用于记录当前的读者数量</span>
semaphore mutex <span>=</span> <span>1</span><span>;</span>		<span>// 用于保护更新count变量时的互斥</span>
semaphore rw <span>=</span> <span>1</span><span>;</span> 			<span>// 用于保证读者和写者互斥地访问文件</span>
<span>writer</span><span>(</span><span>)</span> <span>{</span> 					<span>// 写者进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span><span>(</span>rw<span>)</span><span>;</span> 				<span>// 互斥访问共享文件</span>
        writing<span>;</span> 			<span>// 写入</span>
        <span>V</span><span>(</span>rw<span>)</span><span>;</span>				<span>// 释放共享文件</span>
    <span>}</span>
<span>}</span>

<span>reader</span><span>(</span><span>)</span> <span>{</span> 					<span>// 读者进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span><span>(</span>mutex<span>)</span><span>;</span> 			<span>// 互斥访问count变量</span>
        <span>if</span><span>(</span>count <span>==</span> <span>0</span><span>)</span> 		<span>// 当第一个读进程读共享文件时</span>
            <span>P</span><span>(</span>rw<span>)</span><span>;</span> 			<span>// 阻止写进程写</span>
        count<span>++</span><span>;</span> 			<span>// 读者计数器加1</span>
        <span>V</span><span>(</span>mutex<span>)</span><span>;</span>	 		<span>// 释放互斥变量count</span>
        
        reading<span>;</span>  			<span>// 读取</span>
        
        <span>P</span><span>(</span>mutex<span>)</span><span>;</span> 			<span>// 互斥访问count变量</span>
        count<span>--</span><span>;</span> 			<span>// 读者计数器减1</span>
        <span>if</span><span>(</span>count <span>==</span> <span>0</span><span>)</span> 		<span>// 当最后一个读进程读完共享文件</span>
            <span>V</span><span>(</span>rw<span>)</span><span>;</span> 			<span>// 允许写进程写</span>
        <span>V</span><span>(</span>mutex<span>)</span><span>;</span> 			<span>// 释放互斥变量count</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>在上面的算法中，读进程是优先的，即当存在读进程时，写操作将被延迟，且只要有一个读进程活跃，随后而来的读进程都将被允许访问文件。这样的方式会导致写进程可能长时间等待，且存在 <mark>写进程【饿死】的情况</mark></p>
<p>若希望写进程优先，即当有读进程正在读共享文件时，有写进程请求访问，这时应禁止后续读进程的请求，等到已在共享文件的读进程执行完毕，立即让写进程执行，只有在无写进程执行的情况下才允许读进程再次运行。为此，增加一个信号量并在上面程序的 writer() 和 reader() 函数中各增加一对 PV 操作，就可以得到写进程优先的解决程序。</p>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>int</span> count <span>=</span> <span>0</span><span>;</span> 				<span>// 用于记录当前的读者数量</span>
semaphore mutex <span>=</span> <span>1</span><span>;</span>		<span>// 用于保护更新count变量时的互斥</span>
semaphore rw <span>=</span> <span>1</span><span>;</span> 			<span>// 用于保证读者和写者互斥地访问文件</span>
semaphore w <span>=</span> <span>1</span><span>;</span>			<span>// 用于实现写优先</span>
<span>writer</span><span>(</span><span>)</span> <span>{</span> 					<span>// 写者进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span> <span>(</span>w<span>)</span><span>;</span>				<span>// 在无写进程时请求进入</span>
        <span>P</span> <span>(</span>rw<span>)</span><span>;</span> 			<span>// 互斥访问共享文件</span>
        writing<span>;</span> 			<span>// 写入</span>
        <span>V</span> <span>(</span>rw<span>)</span><span>;</span>				<span>// 释放共享文件</span>
        <span>V</span> <span>(</span>w<span>)</span><span>;</span>				<span>// 恢复对共享文件的访问</span>
    <span>}</span>
<span>}</span>

<span>reader</span><span>(</span><span>)</span> <span>{</span> 					<span>// 读者进程</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span> <span>(</span>w<span>)</span><span>;</span>				<span>// 在无写进程时请求进入</span>
        <span>P</span> <span>(</span>mutex<span>)</span><span>;</span> 			<span>// 互斥访问count变量</span>
        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span> 	<span>// 当第一个读进程读共享文件时</span>
            <span>P</span> <span>(</span>rw<span>)</span><span>;</span> 		<span>// 阻止写进程写</span>
        count<span>++</span><span>;</span> 			<span>// 读者计数器加1</span>
        <span>V</span> <span>(</span>mutex<span>)</span><span>;</span>	 		<span>// 释放互斥变量count</span>
        <span>V</span> <span>(</span>w<span>)</span><span>;</span>				<span>// 恢复对共享文件的访问</span>
        
        reading<span>;</span>  			<span>// 读取</span>
        
        <span>P</span> <span>(</span>mutex<span>)</span><span>;</span> 			<span>// 互斥访问count变量</span>
        count<span>--</span><span>;</span> 			<span>// 读者计数器减1</span>
        <span>if</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span> 	<span>// 当最后一个读进程读完共享文件</span>
            <span>V</span><span>(</span>rw<span>)</span><span>;</span> 			<span>// 允许写进程写</span>
        <span>V</span> <span>(</span>mutex<span>)</span><span>;</span> 			<span>// 释放互斥变量count</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>这里的写进程优先是相对而言的，有些书上把这个算法称为读写公平法，即读写进程具有一样的优先级。当一个写进程访问文件时，若先有一些读进程要求访问文件，后有另一个写进程要求访问文件，则当前访问文件的进程结束对文件的写操作时，会是一个读进程而不是一个写进程占用文件（在信号量w的阻塞队列上，因为读进程先来，因此排在阻塞队列队首，而V操作唤醒进程时唤醒的是队首进程），所以说这里的写优先是相对的，想要了解如何做到真正写者优先，</p>
<p>可参考其他相关资料。读者-写者问题有一个关键的特征，即有一个互斥访问的计数器 count，因此遇到一个不太好解决的同步互斥问题时，要想一想用互斥访问的计数器 count 能否解决问题。</p>
<h3 id="_6-3-哲学家进餐问题"> 6.3 哲学家进餐问题</h3>
<p><img src="./README.assets/image-20220331092329801.png" alt="image-20220331092329801" loading="lazy"></p>
<p>问题描述：一张圆桌边上坐着5名哲学家，每两名哲学家之间的桌上摆一根筷子，两根筷子中间是一碗米饭，如图2.12所示。哲学家们倾注毕生精力用于思考和进餐，哲学家在思考时，并不影响他人。只有当哲学家饥饿时，才试图拿起左、右两根筷子（一根一根地拿起）。若筷子已在他人手上，则需要等待。饥饿的哲学家只有同时拿到了两根筷子才可以开始进餐，进餐完毕后，放下筷子继续思考。</p>
<p>问题分析：</p>
<ol>
<li>关系分析。5名哲学家与左右邻居对其中间筷子的访问是互斥关系。</li>
<li>整理思路。显然，这里有5个进程。本题的关键是如何让一名哲学家拿到左右两根筷子而不造成死锁或饥饿现象。解决方法有两个：一是让他们同时拿两根筷子：二是对每名哲学家的动作制定规则，避免饥饿或死锁现象的发生。</li>
<li>信号量设置。定义互斥信号量数组 <code>chopstick[5]={l, 1,1,1,1}</code> ，用于对5个筷子的互斥访问。哲学家按顺序编号为0~4，哲学家i左边筷子的编号为i,哲学家右边筷子的编号为 <code>(i + 1) % 5</code>。</li>
</ol>
<div><pre><code>semaphore chopstick<span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>}</span><span>;</span> 	<span>// 定义信号量数组chopstick[5],并初始化</span>
<span>Pi</span><span>(</span><span>)</span><span>{</span> 										<span>// i号哲学家的进程</span>
    <span>do</span><span>{</span>
        <span>P</span> <span>(</span>chopstick<span>[</span>i<span>]</span><span>)</span><span>;</span> 					<span>// 取左边筷子</span>
        <span>P</span> <span>(</span>chopstick<span>[</span><span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>5</span><span>]</span><span>)</span><span>;</span> 		<span>// 取右边筷子</span>
        eat<span>;</span> 								<span>// 进餐</span>
        <span>V</span> <span>(</span>chopstick<span>[</span>i<span>]</span><span>)</span><span>;</span> 					<span>// 放回左边筷子</span>
        <span>V</span> <span>(</span>chopstick<span>[</span><span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>5</span><span>]</span><span>)</span><span>;</span> 		<span>// 放回右边筷子</span>
        think<span>;</span> 								<span>// 思考</span>
    <span>}</span> <span>while</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>该算法存在以下问题：当5名哲学家都想要进餐并分别拿起左边的筷子时（都恰好执行完
<code>wait(chopstick[i);</code>）筷子已被拿光，等到他们再想拿右边的筷子时（执行 <code>wait(chopstick[(i + 1)%5]);</code>）就全被阻塞，因此出现了死锁。</p>
<p>为防止死锁发生，可对哲学家进程施加一些限制条件，比如至多允许 4 名哲学家同时进餐；仅当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子：对哲学家顺序编号，要求奇数号哲学家先拿左边的筷子，然后拿右边的筷子，而偶数号哲学家刚好相反。</p>
<p>制定的正确规则如下：假设采用第二种方法，当一名哲学家左右两边的筷子都可用时，才允许他抓起筷子。</p>
<div><pre><code>semaphore chopstick<span>[</span><span>5</span><span>]</span> <span>=</span> <span>{</span><span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>}</span><span>;</span> 	<span>// 初始化信号量</span>
semaphore mutex <span>=</span> <span>1</span><span>;</span> 						<span>// 设置取筷子的信号量</span>
<span>Pi</span><span>(</span><span>)</span> <span>{</span>	 									<span>// i号哲学家的进程</span>
    <span>do</span><span>{</span>
        <span>P</span> <span>(</span>mutex<span>)</span><span>;</span> 							<span>// 在取筷子前获得互斥量</span>
        <span>P</span> <span>(</span>chopstick<span>[</span>i<span>]</span><span>)</span><span>;</span> 					<span>// 取左边筷子</span>
        <span>P</span> <span>(</span>chopstick<span>[</span><span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>5</span><span>]</span><span>)</span><span>;</span> 		<span>// 取右边筷子</span>
        <span>V</span> <span>(</span>mutex<span>)</span><span>;</span> 							<span>// 释放取筷子的信号量</span>
        eat<span>;</span> 								<span>// 进餐</span>
        <span>V</span> <span>(</span>chopstick<span>[</span>i<span>]</span><span>)</span><span>;</span> 					<span>// 放回左边筷子</span>
        <span>V</span> <span>(</span>chopstick<span>[</span><span>(</span>i <span>+</span> <span>1</span><span>)</span> <span>%</span> <span>5</span><span>]</span><span>)</span><span>;</span> 		<span>// 放回右边筷子</span>
        think<span>;</span> 								<span>// 思考</span>
    <span>}</span> <span>while</span><span>(</span><span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>此外，还可采用AND型信号量机制来解决哲学家进餐问题，有兴趣的读者可以查阅相关资料，自行思考。熟悉ACM或有过相关训练的读者都应知道贪心算法，哲学家进餐问题的思想其实与贪心算法的思想截然相反，贪心算法强调争取眼前认为最好的，而不考虑后续会有什么后果。若哲学家进餐问题用贪心算法来解决，即只要眼前有筷子能拿起就拿起的话，就会出现死锁。然而，若不仅考虑眼前的一步，而且考虑下一步，即不因为有筷子能拿起就拿起，而考虑能不能一次拿起两根筷子才做决定的话，就会避免死锁问题，这就是哲学家进餐问题的思维精髓。</p>
<h3 id="_6-4-吸烟者问题"> 6.4 吸烟者问题</h3>
<p>问题描述：假设一个系统有三个抽烟者进程和一个供应者进程。每个抽烟者不停地卷烟并抽掉它，但要卷起并抽掉一支烟， 抽烟者需要有三种材料：烟草、纸和胶水。三个抽烟者中，第一个拥有烟草，第二个拥有纸，第三个拥有胶水。供应者进程无限地提供三种材料，供应者每次将两种材料放到桌子上，拥有剩下那种材料的抽烟者卷一根烟并抽掉它，并给供应者一个信号告诉已完成，此时供应者就会将另外两种材料放到桌上，如此重复（让三个抽烟者轮流地抽烟）。</p>
<p>问题分析：</p>
<ol>
<li>关系分析。供应者与三个抽烟者分别是同步关系。由于供应者无法同时满足两个或以上的抽烟者，三个抽烟者对抽烟这个动作互斥（或由三个抽烟者轮流抽烟得知）。</li>
<li>整理思路。显然这里有4个进程。供应者作为生产者向三个抽烟者提供材料。</li>
<li>信号量设置。信号量 offerl，offer2，offer3 分别表示烟草和纸组合的资源、烟草和胶水组合的资源、纸和胶水组合的资源。信号量 finish 用于互斥进行抽烟动作。</li>
</ol>
<p>代码如下:</p>
<div><pre><code><span>int</span> num <span>=</span> <span>0</span><span>;</span> 			<span>// 存储随机数</span>
semaphore offer1 <span>=</span> <span>0</span><span>;</span> 	<span>// 定义信号量对应烟草和纸组合的资源</span>
semaphore offer2 <span>=</span> <span>0</span><span>;</span> 	<span>// 定义信号量对应烟草和胶水组合的资源</span>
semaphore offer3 <span>=</span> <span>0</span><span>;</span> 	<span>// 定义信号量对应纸和胶水组合的资源</span>
semaphore finish <span>=</span> <span>0</span><span>;</span> 	<span>// 定义信号量表示抽烟是否完成</span>

process <span>P1</span><span>(</span><span>)</span> <span>{</span>			<span>// 供应者</span>
    <span>while</span><span>(</span><span>1</span><span>)</span><span>{</span>
        num<span>++</span><span>;</span>
        num <span>=</span> num <span>%</span> <span>3</span><span>;</span>
        <span>if</span><span>(</span>num <span>==</span> <span>0</span><span>)</span>
            <span>V</span><span>(</span>offerl<span>)</span><span>;</span> 	<span>// 提供烟草和纸</span>
        <span>else</span> <span>if</span> <span>(</span>num <span>==</span> <span>1</span><span>)</span>
            <span>V</span><span>(</span>offer2<span>)</span><span>;</span> 	<span>// 提供烟草和胶水</span>
        <span>else</span>
            <span>V</span><span>(</span>offer3<span>)</span><span>;</span> 	<span>// 提供纸和胶水</span>
        任意两种材料放在桌子上<span>;</span>
        <span>P</span><span>(</span>finish<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

process <span>P2</span><span>(</span><span>)</span> <span>{</span> 			<span>// 拥有烟草者</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span><span>(</span>offer3<span>)</span><span>;</span>
        拿纸和胶水，卷成烟，抽掉<span>;</span> 
        <span>V</span><span>(</span>finish<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
    
process <span>P3</span><span>(</span><span>)</span> <span>{</span> 			<span>// 拥有纸者</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span><span>(</span>offer2<span>)</span><span>;</span>
        拿烟草和胶水，卷成烟，抽掉<span>;</span>
        <span>V</span><span>(</span>finish<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

process <span>P4</span><span>(</span><span>)</span> <span>{</span> 			<span>// 拥有胶水者</span>
    <span>while</span><span>(</span><span>1</span><span>)</span> <span>{</span>
        <span>P</span><span>(</span>offerl<span>)</span><span>;</span>
        拿烟草和纸，卷成烟，抽掉<span>;</span> 
        <span>V</span><span>(</span>finish<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T05:13:59.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">虚拟内存管理</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/3/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/3/2/"/>
    <updated>2022-04-20T15:46:54.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、虚拟内存的基本概念"> 一、虚拟内存的基本概念</h2>
<h3 id="_1-1-传统存储管理方式的特征"> 1.1 传统存储管理方式的特征</h3>
<p>各种内存管理策略都是为了同时将多个进程保存在内存中，以便允许进行多道程序设计。它们都具有以下两个共同的特征：</p>
<ol>
<li>
<p>一次性。作业必须一次性全部装入内存后，才能开始运行。这会导致两种情况：</p>
<ol>
<li>当作业很大而不能全部被装入内存时，将使该作业无法运行</li>
<li>当大量作业要求运行时，由于内存不足以容纳所有作业，只能使少数作业先运行，导致多道程序度的下降。</li>
</ol>
</li>
<li>
<p>驻留性。作业被装入内存后，就一直驻留在内存中，其任何部分都不会被换出，直至作业运行结束。运行中的进程会因等待 I/O 而被阻塞，可能处于长期等待状态。</p>
</li>
</ol>
<p>由以上分析可知，许多在程序运行中不用或暂时不用的程序（数据）占据了大量的内存空间，而一些需要运行的作业又无法装入运行，显然浪费了宝贵的内存资源。</p>
<h3 id="_1-2-局部性原理"> 1.2 局部性原理</h3>
<p>要真正理解虚拟内存技术的思想，首先须了解著名的局部性原理。</p>
<ol>
<li><strong>时间局部性</strong>。程序中的某条指令一旦执行，不久后该指令可能再次执行；某数据被访问过，不久后该数据可能再次被访问。产生的原因是程序中存在着大量的循环操作。</li>
<li><strong>空间局部性</strong>。一旦程序访问了某个存储单元，在不久后，其附近的存储单元也将被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围之内，因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的。</li>
</ol>
<p>时间局部性通过将近来使用的指令和数据保存到高速缓存中，并使用高速缓存的层次结构实现。空间局部性通常使用较大的高速缓存，并将预取机制集成到高速缓存控制逻辑中实现。虚拟内存技术实际上建立了【内存外存】的两级存储器结构，利用局部性原理实现高速缓存。</p>
<h3 id="_1-3-虚拟存储器的定义和特征"> 1.3 虚拟存储器的定义和特征</h3>
<p>基于局部性原理，在程序装入时，仅须将程序当前要运行的少数页面或段先装入内存，而将其余部分暂留在外存，便可启动程序执行。在程序执行过程中，当所访问的信息不在内存时，由操作系统将所需要的部分调入内存，然后继续执行程序。另一方面，操作系统将内存中暂时不使用的内容换出到外存上，从而腾出空间存放将要调入内存的信息。这样，系统好像为用户提供了一个比实际内存容量大得多的存储器，称为 <mark>虚拟存储器</mark></p>
<p>之所以将其称为虚拟存储器，是因为这种存储器实际上并不存在，只是由于系统提供了部分装入、请求调入和置换功能后（对用户透明），给用户的感觉是好像存在一个比实际物理内存大得多的存储器。但容量大只是一种错觉，是虚的。虚拟存储器有以下三个主要特征：</p>
<ol>
<li>多次性。是指无须在作业运行时一次性地全部装入内存，而允许被分成多次调入内存运行，即只需将当前要运行的那部分程序和数据装入内存即可开始运行。以后每当要运行到尚未调入的那部分程序时，再将它调入。多次性是虚拟存储器最重要的特征。</li>
<li>对换性。是指无须在作业运行时一直常驻内存，在进程运行期间，允许将那些暂不使用的程序和数据从内存调至外存的对换区（换出），待以后需要时再将它们从外存调至内存（换进）。正是由于对换性，才使得虚拟存储器得以正常运行。</li>
<li>虚拟性。是指从逻辑上扩充内存的容量，使用户所看到的内存容量远大于实际的内存容量。这是虚拟存储器所表现出的最重要特征，也是实现虚拟存储器的最重要目标。</li>
</ol>
<h3 id="_1-4-虚叔内存技术的实现"> 1.4 虚叔内存技术的实现</h3>
<p>虚拟内存技术允许将一个作业分多次调入内存。采用连续分配方式时，会使相当一部分内存空间都处于暂时或【永久】的空闲状态，造成内存资源的严重浪费，而且也无法从逻辑上扩大内存容最。因此，虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。</p>
<p>虚拟内存的实现有以下三种方式：</p>
<ul>
<li>请求分页存储管理。</li>
<li>请求分段存储管理。</li>
<li>请求段页式存储管理。</li>
</ul>
<p>不管哪种方式，都需要有一定的硬件支持。一般需要的支持有以下几个方面：</p>
<ul>
<li>一定容量的内存和外存。</li>
<li>页表机制（或段表机制），作为主要的数据结构。</li>
<li>中断机构，当用户程序要访问的部分尚未调入内存时，则产生中断。</li>
<li>地址变换机构，逻辑地址到物理地址的变换。</li>
</ul>
<h2 id="二、请求分页管理方式"> 二、请求分页管理方式</h2>
<p>请求分页系统建立在基本分页系统基础之上，为了支持虚拟存储器功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虛拟存储器的方法。</p>
<p>在请求分页系统中，只要求将当前需要的一部分页面装入内存，便可以启动作业运行。在作业执行过程中，当所要访问的页面不在内存中时，再通过调页功能将其调入，同时还可通过置换功能将暂时不用的页面换出到外存上，以便腾出内存空间。</p>
<h3 id="_2-1-页表机制"> 2.1 页表机制</h3>
<p>请求分页系统的页表机制不同于基本分页系统，请求分页系统在一个作业运行之前不要求全部一次性调入内存，因此在作业的运行过程中，必然会出现要访问的页面不在内存中的情况，如何发现和处理这种情况是请求分页系统必须解决的两个基本问题。为此，在请求页表项中增加了4个字段，如图3.20所示。</p>
<p><strong>页表项：</strong> <mark>页号 + 物理块号 + 状态位 + 访问字段 + 修改位 + 外存地址</mark></p>
<p><img src="./README.assets/image-20220402133753810.png" alt="image-20220402133753810" loading="lazy"></p>
<p>增加的4个字段说明如下：</p>
<ul>
<li>状态位P。用于指示该项是否已调入内存，供程序访问时参考。</li>
<li>访问字段A。用于记录本页在一段时间内被访问的次数，或记录本页最近已有多长时间未被访问，供置换算法换出页面时参考。</li>
<li>修改位M。标识该页在调入内存后是否被修改过，以确定页面置换时是否写回外存。</li>
<li>外存地址。用于指出该页在外存上的地址，通常是物理块号，供调入该页时参考。</li>
</ul>
<h3 id="_2-2-缺页中断机构"> 2.2 缺页中断机构</h3>
<p>在请求分页系统中，每当所要访问的页面不在内存中时，便产生一个缺页中断，请求操作系统将所缺的页调入内存。此时应将缺页的进程阻塞（调页完成唤醒），若内存中有空闲块，则分配一个块，将要调入的页装入该块，并修改页表中的相应页表项，若此时内存中没有空闲块，则要淘汰某页（若被淘汰页在内存期间被修改过，则要将其写回外存）。</p>
<p>缺页中断作为中断，同样要经历诸如 <mark>保护 CPU 环境、分析中断原因、转入缺页中断处理程序、恢复CPU环境</mark> 等几个步骤。但与一般的中断相比，它有以下两个明显的区别：</p>
<ul>
<li>在指令执行期间而非一条指令执行完后产生和处理中断信号，属于 <mark>内部异常</mark></li>
<li>一条指令在执行期间，可能产生多次缺页中断。</li>
</ul>
<h3 id="_2-3-地址变换机构"> 2.3 地址变换机构</h3>
<p>请求分页系统中的地址变换机构，是在分页系统地址变换机构的基础上，为实现虚拟内存，又增加了某些功能而形成的，如产生和处理缺页中断，及从内存中换出一页 的功能等等。在进行地址变换时，先检索快表：</p>
<p><img src="./README.assets/20160730160944404.png" alt="img" loading="lazy"></p>
<ul>
<li>若找到要访问的页，则修改页表项中的访问位（写指令还需要重置修改位），然后利用页表项中给出的物理块号和页内地址形成物理地址。</li>
<li>若未找到该页的页表项，则应到内存中去查找页表，再对比页表项中的状态位P，看该页是否已调入内存，若页面已调入，则将该页的页表写入快表，若快表已满，则需采用某种算法替换。若页面未调入，则产生缺页中断，请求从外存把该页调入内存。</li>
</ul>
<h2 id="三、页框分配"> 三、页框分配</h2>
<h3 id="_3-1-驻留集大小"> 3.1 驻留集大小</h3>
<p>对于分页式的虚拟内存，在进程准备执行时，不需要也不可能把一个进程的所有页都读入主存。因此，操作系统必须决定读取多少页，即决定给特定的进程分配几个页框。给一个进程分配的物理页框的集合就是这个进程的驻留集。需要考虑以下几点：</p>
<ol>
<li>分配给一个进程的页框越少，驻留在主存中的进程就越多，从而可提高 CPU 的利用率。</li>
<li>若一个进程在主存中的页面过少，则尽管有局部性原理，缺页率仍相对较高。</li>
<li>若分配的页框过多，则由于局部性原理，对该进程的缺页率没有太明显的影响。</li>
</ol>
<h3 id="_3-2-内存分配策略"> 3.2 内存分配策略</h3>
<p>在请求分页系统中，可采取两种内存分配策略，即固定和可变分配策略。在进行置换时，也可采取两种策略，即全局置换和局部置换。于是可组合出下面三种适用的策略。</p>
<p><strong>固定分配局部置换</strong></p>
<p>为每个进程分配一定数目的物理块，在进程运行期间都不改变。所谓局部置换，是指如果进程在运行中发生缺页，则只能从分配给该进程在内存的页面中选出一页换出，然后再调入一页，以保证分配给该进程的内存空间不变。实现这种策略时，难以确定应为每个进程分配的物理块数目：太少会频繁出现缺页中断，太多又会降低 CPU 和其他资源的利用率。</p>
<hr>
<p><strong>可变分配全局置换</strong></p>
<p>先为每个进程分配一定数目的物理块，在进程运行期间可根据情况适当地增加或减少。所谓全局置换，是指如果进程在运行中发生缺页，系统从空闲物理块队列中取出一块分配给该进程，并将所缺页调入。这种方法比固定分配局部置换更加灵活，可以动态增加进程的物理块，但也存在弊端，如它会自目地给进程增加物理块，从而导致系统多道程序的并发能力下降。</p>
<hr>
<p><strong>可变分配局部置换</strong></p>
<p>为每个进程分配一定数目的物理块，当某进程发生缺页时，只允许从该进程在内存的页面中选出一页换出，因此不会影响其他进程的运行。若进程在运行中频繁地发生缺页中断，则系统再为该进程分配若干物理块，直至该进程的缺页率趋于适当程度；反之，若进程在运行中的缺页率特别低，则可适当减少分配给该进程的物理块，但不能引起其缺页率的明显增加。这种方法在保证进程不会过多地调页的同时，也保持了系统的多道程序并发能力。当然它需要更复杂的实现，也衢要更大的开销，但对比频繁地换入换出所浪费的计算机资源，这种牺牲是值得的。</p>
<h3 id="_3-3-物理块调入算法"> 3.3 物理块调入算法</h3>
<p>采用固定分配策略时，将系统中的空闲物理块分配给各个进程，可采用下述几种算法。</p>
<ol>
<li>平均分配算法，将系统中所有可供分配的物理块平均分配给各个进程。</li>
<li>按比例分配算法，根据进程的大小按比例分配物理块。</li>
<li>优先权分配算法，为重要和紧迫的进程分配较多的物理块。通常采取的方法是把所有可分配的物理块分成两部分：一部分按比例分配给各个进程，一部分则根据优先权分配。</li>
</ol>
<h3 id="_3-4-调入页面的时机"> 3.4 调入页面的时机</h3>
<p>为确定系统将进程运行时所缺的页面调入内存的时机，可采取以下两种调页策略：</p>
<ol>
<li>预调页策略。根据局部性原理，一次调入若干相邻的页会比一次调入一页更高效。但若调入的一批页面中的大多数都未被访问，则又是低效的。因此，需要采用以预测为基础的预调页策略，将那些预计在不久之后便会被访问的页面预先调入内存。但目前预调页的成功率仅约50%。因此这种策略主要用于进程的首次调入，由程序员指出应先调入哪些页。</li>
<li>请求调页策略。进程在运行中需要访问的页面不在内存，便提出请求，由系统将其所需页面调入内存。由这种策略调入的页一定会被访问，且这种策略比较易于实现，因此目前的虚拟存储器大多采用此策略。其缺点是每次仅调入一页， 增加了磁盘I/O开销。预调入实际上就是运行前的调入，请求调页实际上就是运行期间调入。</li>
</ol>
<h3 id="_3-5-从何处调入页面"> 3.5 从何处调入页面</h3>
<p>请求分页系统中的外存分为两部分：用于存放文件的文件区和用于存放对换页面的对换区。对换区采用连续分配方式，而文件区采用离散分配方式，因此对换区的磁盘I/O速度比文件区的更快。这样，当发生缺页请求时，系统从何处将缺页调入内存就分为三种情况：</p>
<ol>
<li>系统拥有足够的对换区空间。可以全部从对换区调入所需页面，以提高调页速度。为此，在进程运行前，需将与该进程有关的文件从文件区复制到对换区。</li>
<li>系统缺少足够的对换区空间。凡是不会被修改的文件都直接从文件区调入；而当换出这些页面时，由于它们未被修改而不必再将它们换出。但对于那些可能被修改的部分，在将它们換出时须调到对换区，以后需要时再从对换区调入（因为读比写的速度快）。</li>
</ol>
<ol start="3">
<li>UNIX 方式。与进程有关的文件都放在文件区，因此未运行过的页面都应从文件区调入。曾经运行过但又被换出的页面，由于是放在对换区，因此在下次调入时应从对换区调入。进程请求的共享页面若被其他进程调入内存，则无须再从对换区调入。</li>
</ol>
<h3 id="_3-6-如何调入页面"> 3.6 如何调入页面</h3>
<p>当进程所访问的页面不在内存中时（存在位为0），便向CPU发出缺页中断，中断响应后便转入缺页中断处理程序。该程序通过查找页表得到该页的物理块，此时如果内存未满， 则启动磁盘I/O，将所缺页谓入内存，并修改页表。如果内存已满，则先按某种置换算法从内存中选出一页准备换出；如果该页未被修改过（修改位为0），则无须将该页写回磁盘；但是，如果该页已被修改（修改位为1），则必须将该页写回磁盘，然后将所缺页调入内存，并修改页表中的相应表项，置其存在位为1。调入完成后，进程就可利用修改后的页表形成所要访间数据的内存地址。</p>
<h2 id="四、页面置换算法"> 四、页面置换算法</h2>
<p>进程运行时，若其访问的页面不在内存中而需将其调入，但内存已无空闲空间时，就需要从内存中调出一页程序或数据，送入磁盘的对换区。</p>
<p>选择调出页面的算法就称为页面置换算法。好的页面置换算法应有较低的页面更换频率，也就是说，应将以后不会再访问或以后较长时间内不会再访问的页面先调出。</p>
<p>常见的置换算法有以下4种。</p>
<h3 id="_4-1-最佳-opt-置换算法"> 4.1 最佳(OPT) 置换算法</h3>
<p>最佳置换算法选择的被淘汰页面是以后永不使用的页面，或是在最长时间内不再被访问的页面，以便保证获得最低的缺页率。然而，由于人们目前无法预知进程在内存下的若干页面中哪个是未来最长时间内不再被访问的，因而该算法无法实现。但可利用该算法去评价其他算法。</p>
<p>假定系统为某进程分配了三个物理块，并考虑有页面号引用串：</p>
<p><code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 2, 0, 1, 7, 0, 1</code></p>
<p>进程运行时，先将 <code>7, 0, 1</code> 三个页面依次装入内存。当进程要访问页面 2 时，产生缺页中断，根据最佳置换算法，选择将第 18 次访问才需调入的页面 7 淘汰。然后，访问页面 0 时，因为它已在内存中，所以不必产生缺页中断。访问页面 3 时，又会根据最佳置换算法将页面 1 淘汰......以此类推，从图中可以看出采用最佳置换算法时的情况。</p>
<p><img src="./README.assets/image-20220406224938736.png" alt="image-20220406224938736" loading="lazy"></p>
<p>可以看到，发生缺页中断的次数为9，页面置换的次数为6。</p>
<h3 id="_4-2-先进先出-fifo-页面置换算法"> 4.2 先进先出(FIFO)页面置换算法</h3>
<p>优先淘汰最早进入内存的页面，即淘汰在内存中驻留时间最久的页面。该算法实现简单，只需把已调入内存的页面根据先后次序链接成队列，设置一个指针总是指向最老的页面。但该算法与进程实际运行时的规律不适应，因为在进程中，有的页面经常被访问。</p>
<p>这里仍用上面的例子采用FIFO算法进行页面置换。当进程访问页面2时，把最早进入内存的页面 7 换出。然后访问页面 3 时，把 <code>2, 0, 1</code> 中最先进入内存的页面 0 换出。由图3.23可以看出，利用FIFO算法时进行了 12 次页面置换，比最佳置换算法正好多一倍。</p>
<div><p>Belady 异常</p>
<p>FIFO 算法还会产生所分配的物理块数增大而页故障数不减反增的异常现象，称为Belady异常。只有FIFO算法可能出现Belady异常，LRU 和OPT算法永远不会出现Belady异常。</p>
</div>
<p><img src="./README.assets/image-20220406225221630.png" alt="image-20220406225221630" loading="lazy"></p>
<p>页面访问顺序为 <code>3, 2, 1, 0, 3, 2, 4, 3, 2, 1, 0, 4</code>。若采用FIFO置换算法，当分配的物理块为3个时，缺页次数为9次；当分配的物理块为4个时，缺页次数为10 次。分配给进程的物理块增多，但缺页次数不减反增。</p>
<p><img src="./README.assets/image-20220402134604783.png" alt="image-20220402134604783" loading="lazy"></p>
<h3 id="_4-3-最近最久未使用-lru-置换算法"> 4.3 最近最久未使用(LRU)置换算法</h3>
<p>选择最近最长时间未访问过的页面予以淘汰，它认为过去一段时间内未访问过的页面，在最近的将来可能也不会被访问。该算法为每个页面设置一个访问字段，用来记录页面自上次被访问以来所经历的时间，淘汰页面时选择现有页面中值最大的予以淘汰。</p>
<p>再对上面的例子采用LRU算法进行页面置换。进程第一次对页面 2 访问时，将最近最久未被访问的页面 7 置换出去。然后在访问页面 3 时，将最近最久未使用的页面 1 换出。</p>
<p><img src="./README.assets/image-20220406225320628.png" alt="image-20220406225320628" loading="lazy"></p>
<p>前 5 次置换的情况与最佳置换算法相同，但两种算法并无必然联系。实际上，LRU 算法根据各页以前的使用情况来判断，是“向前看”的，而最佳置换算法则根据各页以后的使用情况来判断，是“向后看”的。而页面过去和未来的走向之间并无必然联系。</p>
<p>LRU算法的性能较好，但需要寄存器和栈的硬件支持。LRU是堆栈类的算法。理论上可以证明，堆栈类算法不可能出现 Belady 异常。FIFO 算法基于队列实现，不是堆栈类算法。</p>
<h3 id="_4-4-时钟-clock-置换算法"> 4.4 时钟(CLOCK)置换算法.</h3>
<p>LRU 算法的性能接近 OPT 算法，但实现起来的开销大。因此，操作系统的设计者尝试了很多算法，试图用比较小的开销接近 LRU 算法的性能，这类算法都是CLOCK算法的变体。</p>
<p><strong>简单的CLOCK置换算法</strong></p>
<p>为每帧设置一位访问位，当某页首次被装入或被访问时，其访问位被置为1。对于替换算法，将内存中的所有页面视为一个循环队列，并有一个替换指针与之相关联，当某一页被替换时， 该指针被设置指向被替换页面的下一页。在选择一页淘汰时， 只需检查页的访问位：</p>
<ul>
<li>若为0，就选择该页换出；</li>
<li>若为1，则将它置为0，暂不换出，给予该页第二次驻留内存的机会，再依次顺序检查下一个页面。</li>
</ul>
<p>当检查到队列中的最后一个页面时，若其访问位仍为 1，则返回到队首去循环检查。由于该算法是循环地检查各个页面的使用情况，故称CLOCK算法。但是，因为该算法只有一位访问位，而置换时将未使用过的页面换出，故又称最近未用(NRU)算法。</p>
<p>假设页面访问顺序为 <code>7, 0, 1, 2, 0, 3, 0, 4, 2, 3, 0, 3, 2, 1, 3, 2</code>，采用简单CLOCK置换算法，分配 4 个页帧，每个页对应的结构为（页面号，访问位）。</p>
<p><img src="./README.assets/image-20220402134738427.png" alt="image-20220402134738427" loading="lazy"></p>
<p>首次访问 7, 0, 1, 2 时，产生缺页中断，依次调入主存，访问位都置为 1。访问 0 时，已存在，访问位置为 1。访问 3 时，产生第 5 次缺页中断，替换指针初始指向帧 1，此时所有帧的访问位均为 1，则替换指针完整地扫描一周， 把所有帧的访问位都置为 0，然后回到最初的位置（帧1），替换帧1中的页（包括置换页面和置访问位为1）。访问 0 时，已存在，访问位置为 1。访问 4 时，产生第 6 次缺页中断，替换指针指向帧 2（上次替换位置的下一帧），帧 2 的访问位为 1，将其修改为 0，继续扫描，帧 3 的访问位为0，替换帧 3 中的页。然后依次访问 2, 3, 0, 3, 2 均已存在，每次访问都将其访问位置为 1。访问 1 时，产生缺页中断，替换指针指向帧 4，此时所有帧的访问位均为 1，又完整扫描一周并置访问位为 0，回到帧 4，替换之。访问 3 时，已存在，访问位置为 1。访问 2 时，产生缺页中断，替换指针指向帧 1，帧 1 的访问位为 1，将其修改为 0，继续扫描，帧 2 的访问位为 0，替换帧 2 中的页。</p>
<p><img src="./README.assets/image-20220402134812424.png" alt="image-20220402134812424" loading="lazy"></p>
<hr>
<p><strong>改进型CLOCK置换算法</strong></p>
<p>将一个页面换出时，若该页已被修改过，则要将该页写回磁盘，若该页未被修改过，则不必将它写回磁盘。可见，对于修改过的页面，替换代价更大。在改进型CLOCK算法中，除考虑页面使用情况外，还增加了置换代价一修改位。 在选择页面换出时，优先考虑既未使用过又未修改过的页面。由访问位A和修改位M可以组合成下面四种类型的页面：</p>
<ul>
<li>1类A = 0，M = 0：最近未被访问且未被修改，是最佳淘汰页。</li>
<li>2类A = 0，M = 1：最近未被访问，但已被修改，不是很好的淘汰页。</li>
<li>3类A = 1，M = 0：最近已被访问，但未被修改，可能再被访问。</li>
<li>4类A = 1，M = 1：最近已被访问且已被修改，可能再被访问。</li>
</ul>
<p>内存中的每页必定都是这四类页面之一。在进行页面置换时，可采用与简单CLOCK算法类似的算法，差别在于该算法要同时检查访问位和修改位。算法执行过程如下：</p>
<ol>
<li>
<p>从指针的当前位置开始，扫描循环队列，寻找A = 0且M = 0的 1 类页面，将遇到的第一个 1 类页面作为选中的淘汰页。在第一次扫描期间不改变访问位A。</p>
</li>
<li>
<p>若第 1 步失败，则进行第二轮扫描，寻找A = 0且M = 1的 2 类页面。将遇到的第一个 2 类页面作为淘汰页。在第二轮扫描期间，将所有扫描过的页面的访问位都置为 0。</p>
</li>
<li>
<p>若第 2 步也失败，则将指针返回到开始的位置，并将所有帧的访问位置为 0。重复第 1 步，并且若有必要，重复第 2 步，此时一定能找到被淘汰的页。</p>
</li>
</ol>
<p>改进型CLOCK算法优于简单CLOCK算法的地方在于，可减少磁盘的 I/O 操作次数。但为了找到一个可置换的页，可能要经过几轮扫描，即实现算法本身的开销将有所增加。</p>
<p>操作系统中的页面置换算法都有一个原则，即尽可能保留访问过的页面，而淘汰未访问的页面。简单的CLOCK算法只考虑页面是否被访问过；改进型CLOCK算法对这两类页面做了细分，分为修改过的页面和未修改的页面。因此，若有未使用过的页面，则当然优先将其中未修改过的页面换出。若全部页面都用过，还是优先将其中未修改过的页面换出。</p>
<h2 id="五、抖动和工作集"> 五、抖动和工作集</h2>
<h3 id="_5-1-抖动"> 5.1 抖动</h3>
<p>在页面置换过程中，一种最糟糕的情形是，刚刚换出的页面马上又要换入主存，刚刚换入的页面马上又要换出主存，这种频繁的页面调度行为称为 <mark>抖动或颠簸</mark></p>
<p>系统发生抖动的根本原因是，系统中同时运行的进程太多，由此分配给每个进程的物理块太少，不能满足进程正常运行的基本要求，致使每个进程在运行时频繁地出现缺页，必须请求系统将所缺页面调入内存。这会使得在系统中排队等待页面调入/调出的进程数目增加。显然，对磁盘的有效访问时间也随之急剧增加，造成每个进程的大部分时间都用于页面的换入/换出，而几乎不能再去做任何有效的工作，进而导致发生处理机的利用率急剧下降并趋于零的情况。抖动是进程运行时出现的严重问题，必须采取相应的措施解决它。由于抖动的发生与系统为进程分配物理块的多少有关，于是又提出了关于进程工作集的概念。</p>
<h3 id="_5-2-工作集"> 5.2 工作集</h3>
<p>工作集是指在某段时间间隔内，进程要访问的页面集合。基于局部性原理，可以用最近访问过的页面来确定工作集。一般来说，工作集 W 可由时间 t 和工作集窗口大小  ⊿ 来确定。例如，某进程对页面的访问次序如下：</p>
<p><img src="./README.assets/image-20220402135036575.png" alt="image-20220402135036575" loading="lazy"></p>
<p>假设系统为该进程设定的工作集窗口大小 ⊿ 为 5，则在 t1 时刻，进程的工作集为 {2, 3, 5}，在 t2 时刻，进程的工作集为 {1, 2, 3, 4}。</p>
<p>实际应用中，工作集窗口会设置得很大，即对于局部性好的程序，工作集大小一般会比工作集窗口 ⊿ 小很多。工作集反映了进程在接下来的一段时间内很有可能会频繁访问的页面集合，因此，若分配给进程的物理块小于工作集大小，则该进程就很有可能频繁缺页，所以为了防止这种抖动现象，一般来说分配给进程的物理块数（即驻留集大小）要大于工作集大小。</p>
<p>工作集模型的原理是，让操作系统跟踪每个进程的工作集，并为进程分配大于其工作集的物理块。落在工作集内的页面需要调入驻留集中，而落在工作集外的页面可从驻留集中换出。若还有空闲物理块，则可再调一个进程到内存。若所有进程的工作集之和超过了可用物理块总数，则操作系统会暂停-一个进程，将其页面调出并将物理块分配给其他进程，防止出现抖动现象。</p>
<h2 id="六、内存映射文件"> 六、内存映射文件</h2>
<p>内存映射文件(Memory-MappedFiles)与虚拟内存有些相似，将磁盘文件的全部或部分内容与进程虚拟地址空间的某个区域建立映射关系，便可以直接访问被映射的文件，而不必执行文件I/O操作，也无须对文件内容进行缓存处理。这种特性非常适合用来管理大尺寸文件。</p>
<p>使用内存映射文件所进行的任何实际交互都是在内存中进行的，并且是以标准的内存地址形式来访问的。磁盘的周期性分页是由操作系统在后台隐蔽实现的，对应用程序而言是完全透明的。系统内存中的所有页面都由虚拟存储器负责管理，虚拟存储器以统一的方式处理所有磁盘I/O。当进程退出或显式地解除文件映射时，所有被改动的页面会被写回磁盘文件。</p>
<p>多个进程允许并发地内存映射同一文件，以便允许数据共享。实际上，很多时候，共享内存是通过内存映射来实现的。进程可以通过共享内存来通信，而共享内存是通过映射相同文件到通信进程的虚拟地址空间实现的。内存映射文件充当通信进程之间的共享内存区域。一个进程在共享内存上完成了写操作，此刻当另一个进程在映射到这个文件的虚拟地址空间上执行读操作时，就能立刻看到上一个进程写操作的结果。</p>
<p><img src="./README.assets/attachments-2020-07-B00e2eHO5f0724211b691.gif" alt="img" loading="lazy"></p>
<h2 id="七、虚拟存储器性能影响因素"> 七、虚拟存储器性能影响因素</h2>
<p>根据局部性原理，页面较大则缺页率较低，页面较小则缺页率较高。页面较小时，一方面减少了内存碎片，有利于提高内存利用率；另一方面，也会使每个进程要求较多的页面，导致页表过长，占用大量内存。页面较大时，虽然可以减少页表长度，但会使页内碎片增大。</p>
<p>分配给进程的物理块数越多，缺页率就越低，但是当物理块超过某个数目时，再为进程增加一个物理块对缺页率的改善是不明显的。可见，此时已没有必要再为它分配更多的物理块，否则也只能是浪费内存空间。只要保证活跃页面在内存中，保持缺页率在一个很低的范围即可。</p>
<p>好的页面置换算法可使进程在运行过程中具有较低的缺页率。选择LRU、CLOCK等置换算法，将未来有可能访问的页面尽量保留在内存中，从而提高页面的访问速度。</p>
<p>写回磁盘(见《计算机组成原理考研复习指导》)的频率。换出已修改过的页面时，应当写回磁盘，如果每当一个页面被换出时就将它写回磁盘，那么每换出一个页面就需要启动一次磁盘，效率极低。为此在系统中建立一个已修改换出页面的链表，对每个要被换出的页面（已修改），可以暂不将它们写回磁盘，而将它们挂在该链表上，仅当被换出页面数达到给定值时，才将它们一起写回磁盘，这样就可显著减少磁盘I/O的次数，即减少已修改页面换出的开销。此外，如果有进程在这批数据还未写回磁盘时需要再次访问这些页面，就不需从外存调入，而直接从已修改换出页面链表上获取，这样也可以减少页面从磁盘读入内存的频率，减少页面换进
的开销。</p>
<p>编写程序的局部化程度越高，执行时的缺页率就越低。如果存储采用的是按行存储，访问时就要尽量采用相同的访问方式，避免按列访问造成缺页率过高的现象。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T05:55:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">文件管理</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/4/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/4/1/"/>
    <updated>2022-04-07T01:20:43.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、文件的基本概念"> 一、文件的基本概念</h2>
<p>文件（File）是以硬盘为载体的存储在计算机上的信息集合，文件可以是文本文档、图片、程序等。</p>
<p>在系统运行时，计算机以进程为基本单位进行资源的调度和分配；而在用户进行的输入、输出中，则以文件为基本单位。大多数应用程序的输入都是通过文件来实现的，其输出也都保存在文件中，以便信息的长期存储及将来的访问。</p>
<p>从用户的角度看，文件系统是操作系统的重要部分之一。用户关心的是如何命名、分类和查找文件，如何保证文件数据的安全性及对文件可以进行哪些操作等。而对于其中的细节，如文件如何存储在辅存上、如何管理文件辅存区域等方面关心甚少。</p>
<p>文件系统提供了与二级存储相关的资源的抽象，让用户能在不了解文件的各种属性、文件存储介质的特征及文件在存储介质上的具体位置等情况下，方便快捷地使用文件。用户通过文件系统建立文件，提供应用程序的输入、输出，对资源进行管理。</p>
<p>首先了解文件的结构，我们通过自底向上的方式来定义。</p>
<div><p>Note</p>
<ol>
<li>数据项。是文件系统中最低级的数据组织形式，可分为以下两种类型：
<ul>
<li>基本数据项。用于描述一个对象的某种属性的一个值，是数据中的最小逻辑单位。</li>
<li>组合数据项。由多个基本数据项组成。</li>
</ul>
</li>
<li>记录。是一组相关的数据项的集合，用于描述一个对象在某方面的属性。</li>
<li>文件。是指由创建者所定义的、具有文件名的一组相关元素的集合，可分为有结构文件和无结构文件两种。在有结构的文件中，文件由若干个相似的记录组成，如一个班的学生记录；而无结构文件则被视为一个字符流，比如一个二进制文件或字符文件。</li>
</ol>
</div>
<p>虽然上面给出了结构化的表述，但实际上关于文件并无严格的定义。在操作系统中，通常将程序和数据组织成文件。文件可以是数字、字符或二进制代码，基本访问单元可以是字节或记录。文件可以长期存储在硬盘中，允许可控制的进程间共享访问，能够被组织成复杂的结构。</p>
<h2 id="二、文件控制块和索引结点"> 二、文件控制块和索引结点</h2>
<p>与进程管理一样，为便于文件管理，在操作系统中引入了文件控制块的数据结构。</p>
<h3 id="_2-1-文件的属性"> 2.1 文件的属性</h3>
<p>除了文件数据，操作系统还会保存与文件相关的信息，如所有者、创建时间等，这些附加信息称为文件属性或文件元数据。文件属性在不同系统中差别很大，但通常都包括如下属性。</p>
<ol>
<li>名称。文件名称唯一，以容易读取的形式保存。</li>
<li>类型。被支持不同类型的文件系统所使用。</li>
<li>创建者。文件创建者的ID。</li>
<li>所有者。文件当前所有者的ID.</li>
<li>位置。指向设备和设备.上文件的指针。</li>
<li>大小。文件当前大小(用字节、字或块表示)，也可包含文件允许的最大值。</li>
<li>保护。对文件进行保护的访问控制信息。</li>
<li>创建时间、最后一次修改时间和最后一次存取时间。文件创建、上次修改和上次访问的相关信息，用于保护和跟踪文件的使用。</li>
</ol>
<p>操作系统通过文件控制块(FCB)来维护文件元数据。</p>
<h3 id="_2-2-文件控制块"> 2.2 文件控制块</h3>
<p>文件控制块(FCB)是用来存放控制文件需要的各种信息的数据结构，以实现【按名存取】。FCB的有序集合称为文件目录，一个FCB就是一个文件目录项。为了创建一个新文件，系统将分配一个FCB并存放在文件目录中，称为目录项。</p>
<p>FCB主要包含以下信息：</p>
<ul>
<li>基本信息，如文件名、文件的物理位置、文件的逻辑结构、文件的物理结构等。</li>
<li>存取控制信息，包括文件主的存取权限、核准用户的存取权限以及一般用户的存取权限。</li>
<li>使用信息，如文件建立时间、上次修改时间等。</li>
</ul>
<p>一个文件目录也被视为一个文件，称为目录文件。</p>
<h3 id="_2-3-索引结点"> 2.3 索引结点</h3>
<p>文件目录通常存放在磁盘上，当文件很多时，文件目录会占用大量的盘块。在查找目录的过程中，要先将存放目录文件的第一个盘块中的目录调入内存，然后用给定的文件名逐一比较，若未找到指定文件，就还需要不断地将下一盘块中的目录项调入内存，逐一比较。</p>
<p>我们发现，在检索目录的过程中，只用到了文件名，仅当找到一个目录项（其中的文件名与要查找的文件名匹配）时，才需从该目录项中读出该文件的物理地址。也就是说，在检索目录时，文件的其他描述信息不会用到，也不需要调入内存。</p>
<p>因此，有的系统便采用了文件名和文件描述信息分开的方法，使文件描述信息单独形成一个称为索引结点的数据结构，简称 i 结点（inode）。</p>
<p><mark>在文件目录中的每个目录项仅由文件名和指向该文件所对应的 i 结点的指针构成</mark></p>
<hr>
<p><strong>磁盘索引结点</strong></p>
<p>它是指存放在磁盘上的索引结点。每个文件有一个唯一的磁盘索引结点，主要包括以下内容：</p>
<ul>
<li>文件主标识符，拥有该文件的个人或小组的标识符。</li>
<li>文件类型，包括普通文件、目录文件或特别文件。</li>
<li>文件存取权限，各类用户对该文件的存取权限。</li>
<li>文件物理地址，每个索引结点中含有13个地址项，即iaddr(0)~iaddr(12)，它们以直接或间接方式给出数据文件所在盘块的编号。</li>
<li>文件长度，指以字节为单位的文件长度。</li>
<li>文件链接计数，在本文件系统中所有指向该文件的文件名的指针计数。</li>
<li>文件存取时间，本文件最近被进程存取的时间、最近被修改的时间及索引结点最近被修改的时间。</li>
</ul>
<hr>
<p><strong>内存索引结点</strong></p>
<p>它是指存放在内存中的索引结点。当文件被打开时，要将磁盘索引结点复制到内存的索引结点中，便于以后使用。在内存索引结点中增加了以下内容：</p>
<ul>
<li>索引结点编号，用于标识内存索引结点。</li>
<li>状态，指示i结点是否上锁或被修改。访问计数，每当有一-进程要访问此i结点时，计数加1;访问结束减1。</li>
<li>逻辑设备号，文件所属文件系统的逻辑设备号。</li>
<li>链接指针，设置分别指向空闲链表和散列队列的指针。</li>
</ul>
<p>FCB或索引结点相当于图书馆中图书的索书号，我们可以在图书馆网站上找到图书的索书号，然后根据索书号找到想要的书本。</p>
<h2 id="三、文件的操作"> 三、文件的操作</h2>
<h3 id="_3-1-文件的基本操作"> 3.1 文件的基本操作</h3>
<p>文件属于抽象数据类型。为了正确地定义文件，需要考虑可以对文件执行的操作。操作系统提供系统调用，它对文件进行创建、写、读、重定位、删除和截断等操作。</p>
<ol>
<li>创建文件。创建文件有两个必要步骤：一是为新文件分配必要的外存空间；二是在目录中为之创建一个目录项，目录项记录了新文件名、在外存中的地址及其他可能的信息。</li>
<li>写文件。为了写文件，执行一个系统调用。对于给定文件名，搜索目录以查找文件位置。系统必须为该文件维护一个写位置的指针。每当发生写操作时，便更新写指针。</li>
<li>读文件。为了读文件，执行一个系统调用。同样需要搜索目录以找到相关目录项，系统维护一个读位置的指针。每当发生读操作时，更新读指针。一个进程通常只对一个文件读或写，因此当前操作位置可作为每个进程当前文件位置的指针。由于读和写操作都使用同一指针，因此节省了空间，也降低了系统复杂度。</li>
<li>重新定位文件，也称文件定位。搜索目录以找到适当的条目，并将当前文件位置指针重新定位到给定值。重新定位文件不涉及读、写文件。</li>
<li>删除文件。为了删除文件，先从目录中检索指定文件名的目录项，然后释放该文件所占的存储空间，以便可被其他文件重复使用，并删除目录条目。</li>
<li>截断文件。允许文件所有属性不变，并删除文件内容，将其长度置为0并释放其空间。</li>
</ol>
<h3 id="_3-2-文件的打开与关闭"> 3.2 文件的打开与关闭</h3>
<p>当用户对一个文件实施操作时，每次都要从检索目录开始。为了避免多次重复地检索目录，大多数操作系统要求，在文件使用之前通过系统调用 open 被显式地打开。操作系统维护一个包含所有打开文件信息的表（打开文件表）。所谓【打开】，是指调用open根据文件名搜索目录，将指明文件的属性（包括该文件在外存上的物理位置），从外存复制到内存打开文件表的一个表目中，并将该表目的编号（也称索引）返回给用户。当用户再次向系统发出文件操作请求时，可通过索引在打开文件表中查到文件信息，从而节省再次搜索目录的开销。当文件不再使用时，可利用系统调用 close 关闭它，操作系统将会从打开文件表中删除这一条目。</p>
<p>在多个不同进程可以同时打开文件的操作系统中，通常采用两级表：每个进程表和整个系统表。每个进程表根据它打开的所有文件，表中存储的是进程对文件的使用信息。系统打开文件表包含文件相关信息，如文件在磁盘的位置、访问日期和大小。一旦有进程打开了一个文件，系统表就包含该文件的条目。当另一个进程执行调用open时，只不过是在其进程打开表中增加一个条目，并指向系统表的相应条目。通常，系统打开文件表为每个文件关联一个打开计数器（OpenCount），以记录多少进程打开了该文件。每个关闭操作 close 使 count 递减，当打开计数器为 0 时，表示该文件不再被使用，并且可从系统打开文件表中删除相应条目。</p>
<p>文件名不必是打开文件表的一部分，因为一旦完成对FCB在磁盘上的定位，系统就不再使用文件名。对于访问打开文件表的索引，UNIX称之为文件描述符，而Windows称之为文件句柄。因此，只要文件未被关闭，所有文件操作就通过打开文件表来进行。</p>
<p>每个打开文件都具有如下关联信息：</p>
<ul>
<li>文件指针。系统跟踪上次的读写位置作为当前文件位置的指针，这种指针对打开文件的某个进程来说是唯一的， 因此必须与磁盘文件属性分开保存。</li>
<li>文件打开计数。计数器跟踪当前文件打开和关闭的数量。因为多个进程可能打开同一个文件，所以系统在删除打开文件条目之前，必须等待最后一个进程关闭文件。</li>
<li>文件磁盘位置。大多数文件操作要求系统修改文件数据。查找磁盘上的文件所需的信息保存在内存中，以便系统不必为每个操作都从磁盘上读取该信息。</li>
<li>访问权限。每个进程打开文件都需要有一个访问模式(创建、只读、读写、添加等)。该信息保存在进程的打开文件表中，以便操作系统能够允许或拒绝后续的I/O请求。</li>
</ul>
<h2 id="四、文件保护"> 四、文件保护</h2>
<p>为了防止文件共享可能会导致文件被破坏或未经核准的用户修改文件，文件系统必须控制用户对文件的存取，即解决对文件的读、写、执行的许可问题。为此，必须在文件系统中建立相应的文件保护机制。文件保护通过口令保护、加密保护和访问控制等方式实现。其中，口令和加密是为了防止用户文件被他人存取或窃取，而访问控制则用于控制用户对文件的访问方式。</p>
<h3 id="_4-1-访问类型"> 4.1 访问类型</h3>
<p>对文件的保护可从限制对文件的访问类型中出发。可加以控制的访问类型主要有以下几种。</p>
<ul>
<li>读。从文件中读。</li>
<li>写。向文件中写。</li>
<li>执行。将文件装入内存并执行。</li>
<li>添加。将新信息添加到文件结尾部分。</li>
<li>删除。删除文件，释放空间。</li>
<li>列表清单。列出文件名和文件属性。</li>
</ul>
<p>此外还可以对文件的重命名、复制、编辑等加以控制。这些高层的功能可以通过系统程序调用低层系统调用来实现。保护可以只在低层提供。例如，复制文件可利用一系列的读请求来完成，这样，具有读访问权限的用户同时也就具有了复制和打印权限。</p>
<h3 id="_4-2-访问控制"> 4.2 访问控制</h3>
<p>解决访问控制最常用的方法是根据用户身份进行控制。而实现基于身份访问的最为普通的方法是，为每个文件和目录增加一个访问控制列表( Acess-Control List, ACL)， 以规定每个用户名及其所允许的访问类型。这种方法的优点是可以使用复杂的访问方法，缺点是长度无法预计并且可能导致复杂的空间管理，使用精简的访问列表可以解决这个问题。</p>
<p>精简的访问列表采用拥有者、组和其他三种用户类型。</p>
<ol>
<li>拥有者。创建文件的用户。</li>
<li>组。一组需要共享文件且具有类似访问的用户。</li>
<li>其他。系统内的所有其他用户。</li>
</ol>
<p>这样，只需用三个域即可列出访问表中这三类用户的访问权限。文件拥有者在创建文件时，说明创建者用户名及所在的组名，系统在创建文件时也将文件主的名字、所属组名列在该文件的FCB中。用户访问该文件时，按照拥有者所拥有的权限访问文件，若用户和拥有者在同一个用户组，则按照同组权限访问，否则只能按其他用户权限访问。UNIX操作系统即采用此种方法。</p>
<p>口令和密码是另外两种访问控制方法。</p>
<p>口令指用户在建立一个文件时提供一个口令，系统为其建立FCB时附上相应口令，同时告诉允许共享该文件的其他用户。用户请求访问时必须提供相应的口令。这种方法时间和空间的开销不多，缺点是口令直接存在系统内部，不够安全。</p>
<p>密码指用户对文件进行加密，文件被访问时需要使用密钥。这种方法保密性强，节省了存储空间，不过编码和译码要花费一定的时间。</p>
<p>口令和密码都是防止用户文件被他人存取或窃取，并没有控制用户对文件的访问类型。</p>
<p>注意两个问题：</p>
<ol>
<li>现代操作系统常用的文件保护方法是，将访问控制列表与用户、组和其他成员访问控制方案一起组合使用。</li>
<li>对于多级目录结构而言，不仅需要保护单个文件，而且需要保护子目录内的文件，即需要提供目录保护机制。目录操作与文件操作并不相同，因此需要不同的保护机制。</li>
</ol>
<h2 id="五、文件的逻辑结构"> 五、文件的逻辑结构</h2>
<p>文件的逻辑结构是从用户观点出发看到的文件的组织形式。文件的物理结构是从实现观点出发看到的文件在外存上的存储组织形式。文件的逻辑结构与存储介质特性无关，它实际上是指在文件的内部，数据逻辑上是如何组织起来的。</p>
<p>按逻辑结构，文件可划分为无结构文件和有结构文件两大类。</p>
<h3 id="_5-1-无结构文件-流式文件"> 5.1 无结构文件(流式文件)</h3>
<p>无结构文件是最简单的文件组织形式。无结构文件将数据按顺序组织成记录并积累、保存，它是有序相关信息项的集合，以字节(Byte)为单位。由于无结构文件没有结构，因而对记录的访问只能通过穷举搜索的方式，因此这种文件形式对大多数应用不适用。但字符流的无结构文件管理简单，用户可以方便地对其进行操作。所以，那些对基本信息单位操作不多的文件较适于采用字符流的无结构方式，如源程序文件、目标代码文件等。</p>
<h3 id="_5-2-有结构文件-记录式文件"> 5.2 有结构文件(记录式文件)</h3>
<p>有结构文件按记录的组织形式可以分为如下几种：</p>
<p><strong>顺序文件</strong></p>
<p>文件中的记录一个接一个地顺序排列，记录通常是定长的，可以顺序存储或以链表形式存储。顺序文件有以下两种结构：</p>
<ul>
<li>第一种是串结构，记录之间的顺序与关键字无关，通常是按存入时间的先后进行排列，对串结构文件进行检索必须从头开始顺序依次查找，比较费时。</li>
<li>第二种是顺序结构，指文件中的所有记录按关键字顺序排列，可采用折半查找法，提高了检索效率。</li>
</ul>
<p>在对记录进行批量操作，即每次要读或写一大批记录时，顺序文件的效率是所有逻辑文件中最高的。此外，对于顺序存储设备(如磁带)，也只有顺序文件才能被存储并能有效地工作。在经常需要查找、修改、增加或删除单个记录的场合，顺序文件的性能也比较差。</p>
<hr>
<p><strong>索引文件</strong></p>
<p>对于定长记录文件，要查找第i条记录，可直接根据下式计算得到第i条记录相对于第1条记录的地址：A = i * L。然而，对于可变长记录的文件，要查找第 i 条记录，必须顺序地查找前 i - 1 条记录，从而获得相应记录的长度 L，进而按下式计算出第 i 条记录的首址：</p>
<p><img src="./README.assets/image-20220402141146026.png" alt="image-20220402141146026" loading="lazy"></p>
<p>注意：假定每条记录前用一个字节指明该记录的长度。</p>
<p>变长记录文件只能顺序查找，效率较低。为此，可以建立一张索引表，为主文件的每个记录在索引表中分别设置一个表项，包含指向变长记录的指针（即逻辑起始地址）和记录长度，索引表按关键字排序，因此其本身也是一个定长记录的顺序文件。这样就把对变长记录顺序文件的检索转变为对定长记录索引文件的随机检索，从而加快了记录的检索速度。图4.4所示为索引文件示意图。</p>
<p><img src="./README.assets/image-20220402141206952.png" alt="image-20220402141206952" loading="lazy"></p>
<hr>
<p><strong>索引顺序文件</strong></p>
<p>索引顺序文件是顺序文件和索引文件的结合。最简单的索引顺序文件只使用了一级索引。索引顺序文件将顺序文件中的所有记录分为若干组，为顺序文件建立一张索引表，在索引表中为每组中的第一条记录建立一个索引项，其中含有该记录的关键字值和指向该记录的指针。</p>
<p>主文件名包含姓名和其他数据项。姓名为关键字，索引表中为每组的第一条记录（不是每条记录）的关键字值，用指针指向主文件中该记录的起始位置。索引表只包含关键字和指针两个数据项，所有姓名关键字递增排列。主文件中记录分组排列，同一个组中的关键字可以无序，但组与组之间的关键字必须有序。查找一条记录时，首先通过索引表找到其所在的组，然后在该组中使用顺序查找，就能很快地找到记录。</p>
<p><img src="./README.assets/image-20220406235216573.png" alt="image-20220406235216573" loading="lazy"></p>
<p>对于含有N条记录的顺序文件，查找某关键字的记录时，平均需要查找N/2次。在索引顺序文件中，假设N条记录分为√N组，索引表中有√N个表项，每组有VN条记录，在查找某关键字的记录时，先顺序查找索引表，需要查找N12次，然后在主文件中对应的组中顺序查找，也需要查找√N12次，因此共需查找√N12+√N12=JN次。显然,索引顺序文件提高了查找效率，若记录数很多，则可采用两级或多级索引。这种方式就是数据结构中的分块查找。</p>
<p>索引文件和索引顺序文件都提高了存取的速度，但因为配置索引表而增加了存储空间。</p>
<hr>
<p><strong>直接文件或散列文件(Hash File)</strong></p>
<p>给定记录的键值或通过散列函数转换的键值直接决定记录的物理地址。这种映射结构不同于顺序文件或索引文件，没有顺序的特性。</p>
<p>散列文件有很高的存取速度，但是会引起冲突，即不同关键字的散列函数值相同。</p>
<p>复习了数据结构的读者读到这里时，会有这样的感觉:有结构文件逻辑上的组织，是为在文件中查找数据服务的(顺序查找、索引查找、索引顺序查找、哈希查找)。</p>
<h2 id="六、文件的物理结构"> 六、文件的物理结构</h2>
<p>前面说过，文件实际上是一种抽象数据类型，我们要研究它的逻辑结构、物理结构，以及关于它的一系列操作。文件的物理结构就是研究文件的实现，即文件数据在物理存储设备上是如何分布和组织的。同一个问题有两个方面的回答：一是文件的分配方式，讲的是对磁盘非空闲块的管理；二是文件存储空间管理，讲的是对磁盘空闲块的管理(详见4.3节)。</p>
<p>文件分配对应于文件的物理结构，是指如何为文件分配磁盘块。常用的磁盘空间分配方法有三种：连续分配、链接分配和索引分配。有的系统(如RDOS操作系统)对三种方法都支持，但更普遍的是一个系统只支持一种方法。对于本节的内容，读者要注意与文件的逻辑结构区分，从历年的经验来看，这是很多读者容易搞混的地方</p>
<h3 id="_6-1-连续分配"> 6.1 连续分配</h3>
<p>连续分配方法要求每个文件在磁盘上占有一组连续的块。磁盘地址定义了磁盘上的一个线性排序，这种排序使作业访问磁盘时需要的寻道数和寻道时间最小。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70.png" alt="img" loading="lazy"></p>
<p>采用连续分配时，逻辑文件中的记录顺序也存储在相邻接的块中。一个文件的目录项中“文件物理地址”字段应包括第一块的地址和该文件所分配区域的长度，若文件长n块并从位置b开始，则该文件将占有块b,b+ 1,b+2,, b+n-1。</p>
<p>连续分配支持顺序访问和直接访问。</p>
<p>优点是实现简单、存取速度快。</p>
<p>缺点是：</p>
<ol>
<li>文件长度不宜动态增加，因为一个文件末尾后的盘块可能已分配给其他文件，一旦需要增加，就需要大量移动盘块。</li>
<li>为保持文件的有序性，删除和插入记录时，需要对相邻的记录做物理上的移动，还会动态改变文件的长度。</li>
<li>反复增删文件后会产生外部碎片(与内存管理分配方式中的碎片相似)。</li>
<li>很难确定一个文件需要的空间大小，因而只适用于长度固定的文件。</li>
</ol>
<h3 id="_6-2-链接分配"> 6.2 链接分配</h3>
<p>链接分配是一种采用离散分配的方式。它消除了磁盘的外部碎片，提高了磁盘的利用率。可以动态地为文件分配盘块，因此无须事先知道文件的大小。此外，对文件的插入、删除和修改也非常方便。链接分配又可分为隐式链接和显式链接两种形式。</p>
<p><strong>隐式链接</strong></p>
<p>目录项中含有文件第一块的指针和最后一块的指针。每个文件对应一个磁盘块的链表；磁盘块分布在磁盘的任何地方，除最后一个盘块外，每个盘块都含有指向文件下一个盘块的指针，这些指针对用户是透明的。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16492605132955.png" alt="img" loading="lazy"></p>
<p>隐式链接的缺点是只适合顺序访问，若要访问文件的第i个盘块，则只能从第1个盘块开始通过盘块指针顺序查找到第i块，随机访问效率很低。隐式链接的稳定性也是一个问题，系统在运行过程中由于软件或硬件错误导致链表中的指针丢失或损坏，会导致文件数据的丢失。</p>
<p>通常的解决方案是，将几个盘块组成簇(cluster)，按簇而不按块来分配，可以成倍地减少查找时间。比如一簇为4块，这样，指针所占的磁盘空间比例也要小得多。这种方法的代价是增加了内部碎片。簇可以改善许多算法的磁盘访问时间，因此应用于大多数操作系统。</p>
<hr>
<p><strong>显式链接</strong></p>
<p>显式链接是指把用于链接文件各物理块的指针，从每个物理块的末尾中提取出来，显式地存放在内存的一张链接表中。该表在整个磁盘中仅设置一张，称为 <mark>文件分配表( File Allocation Table, FAT)</mark> 。每个表项中存放链接指针，即下一个盘块号。文件的第一个盘块号记录在目录项“物理地址”字段中，后续的盘块可通过查FAT找到。例如，某磁盘共有100个磁盘块，存放了两个文件：</p>
<p>FAT表在系统启动时就会被读入内存，因此查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且明显减少了访问磁盘的次数。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16492605860217.png" alt="img" loading="lazy"></p>
<p>FAT表在系统启动时就会被读入内存，因此查找记录的过程是在内存中进行的，因而不仅显著地提高了检索速度，而且明显减少了访问磁盘的次数。</p>
<h3 id="_6-3-索引分配"> 6.3 索引分配</h3>
<p>链接分配解决了连续分配的外部碎片和文件大小管理的问题。但依然存在问题：</p>
<ol>
<li>链接分配不能有效支持直接访问(FAT除外)</li>
<li>FAT需要占用较大的内存空间。</li>
</ol>
<p>事实上，在打开某个文件时，只需将该文件对应盘块的编号调入内存即可，完全没有必要将整个FAT调入内存。为此，索引分配将每个文件所有的盘块号都集中放在一起构成索引块(表)，如图4.9所示。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70.png" alt="img" loading="lazy"></p>
<p>每个文件都有其索引块，这是一个磁盘块地址的数组。索引块的第 i 个条目指向文件的第 i 个块。要读第 i 块，通过索引块的第 i 个条目的指针来查找和读入所需的块。</p>
<p>索引分配的优点是支持直接访问，且没有外部碎片问题。缺点是由于索引块的分配，增加了系统存储空间的开销。索引块的大小是一个重要的问题，每个文件必须有一个索引块，因此索引块应尽可能小，但索引块太小就无法支持大文件。可以采用以下机制来处理这个问题。</p>
<ul>
<li>链接方案。一个索引块通常为一个磁盘块，因此它本身能直接读写。为了支持大文件，可以将多个索引块链接起来。</li>
<li>多层索引。通过第一级索引块指向一组第二级的索引块，第二级索引块再指向文件块。查找时，通过第一级索引查找第二级索引，再采用这个第二级索引查找所需数据块。这种方法根据最大文件大小，可以继续到第三级或第四级。例如，4096B 的块，能在索引块中存入1024个4B的指针。两级索引支持1048576个数据块，即支持最大文件为4GB。</li>
<li>混合索引。将多种索引分配方式相结合的分配方式。例如，系统既采用直接地址，又采用单级索引分配方式或两级索引分配方式。</li>
</ul>
<p>此外，访问文件需两次访问外存，先读取索引块的内容，然后访问具体的磁盘块，因而降低了文件的存取速度。为了解决这一问题，通常将文件的索引块读入内存，以提高访问速度。</p>
<h3 id="_6-4-混合索引分配"> 6.4 混合索引分配</h3>
<p>为了能够较全面地照顾到小型、中型、大型和特大型文件，可采用混合索引分配方式。对于小文件，为了提高对众多小文件的访问速度，最好能将它们的每个盘块地址直接放入FCB，这样就可以直接从FCB中获得该文件的盘块地址，即为直接寻址。对于中型文件，可以采用单级索引方式，需要先从FCB中找到该文件的索引表，从中获得该文件的盘块地址，即为一次间址。对于大型或特大型文件，可以采用两级和三级索引分配方式。UNIX系统采用的就是这种分配方式，在其索引结点中，共设有13个地址项，即i.addr(0)~i.addr(12)，如图4.10所示。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16492943845442.png" alt="img" loading="lazy"></p>
<ol>
<li>直接地址。为了提高对文件的检索速度，在索引结点中可设置10个直接地址项，即用i.addr(0)~iaddr(9)来存放直接地址，即文件数据盘块的盘块号。假如每个盘块的大小为4KB，当文件不大于40KB时，便可直接从索引结点中读出该文件的全部盘块号。</li>
<li>一次间接地址。对于中、大型文件，只采用直接地址并不现实的。为此，可再利用索引结点中的地址项i.addr( 10)来提供-次间接地址。这种方式的实质就是一-级索引分配方式。图中的一次间址块也就是索引块，系统将分配给文件的多个盘块号记入其中。在-次间址块中可存放1024个盘块号，因而允许文件长达4MB.</li>
<li>多次间接地址。当文件长度大于4MB + 40KB (一次间接地址与10个直接地址项)时，系统还需采用二次间接地址分配方式。这时，用地址项i.addr(1 1)提供二次间接地址。该方式的实质是两级索引分配方式。系统此时在二次间址块中记入所有一次间址块的盘号。地址项i.addr(11)作为二次间址块，允许文件最大长度可达4GB。同理，地址项iaddr(12)作为三次间址块，其允许的文件最大长度可达4TB.</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T06:30:02.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">目录</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/4/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/4/2/"/>
    <updated>2022-04-07T01:31:27.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、目录的基本概念"> 一、目录的基本概念</h2>
<p>上节说过，FCB 的有序集合称为文件目录，一个FCB就是一个文件目录项。与文件管理系统和文件集合相关联的是文件目录，它包含有关文件的属性、位置和所有权等。</p>
<p>首先来看目录管理的基本要求：从用户的角度看，目录在用户（应用程序）所需要的文件名和文件之间提供一种映射，所以目录管理要实现【按名存取】：目录存取的效率直接影响到系统的性能，所以要提高对目录的检索速度；在多用户系统中，应允许多个用户共享一个文件，因此目录还需要提供用于控制访问文件的信息。此外，应允许不同用户对不同文件采用相同的名字，以便于用户按自己的习惯给文件命名，目录管理通过树形结构来解决和实现。</p>
<h2 id="二、目录结构"> 二、目录结构</h2>
<h3 id="_2-1-单级目录结构"> 2.1 单级目录结构</h3>
<p>在整个文件系统中只建立一张目录表，每个文件占一个目录项</p>
<p><img src="./README.assets/image-20220402142245144.png" alt="image-20220402142245144" loading="lazy"></p>
<p>当访问一个文件时，先按文件名在该目录中查找到相应的FCB，经合法性检查后执行相应的操作。当建立一个新文件时，必须先检索所有目录项，以确保没有【重名】的情况，然后在该目录中增设一项，把新文件的属性信息填入到该项中。当删除一个文件时，先从该目录中找到该文件的目录项，回收该文件所占用的存储空间，然后清除该目录项。</p>
<p>单级目录结构实现了【按名存取】，但是存在查找速度慢、文件不允许重名、不便于文件共享等缺点，而且对于多用户的操作系统显然是不适用的。</p>
<h3 id="_2-2-两级目录结构"> 2.2 两级目录结构</h3>
<p>为了克服单级目录所存在的缺点，可以采用两级方案，将文件目录分成主文件目录(MasterFile Directory, MFD)和用户文件目录(User File Directory, UFD)两级，如图4.12所示。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70.png" alt="img" loading="lazy"></p>
<p>主文件目录项记录用户名及相应用户文件目录所在的存储位置。用户文件目录项记录该用户文件的FCB信息。当某用户欲对其文件进行访问时，只需搜索该用户对应的UFD，这既解决了不同用户文件的【重名】问题，又在一定程度上保证了文件的安全。</p>
<p>两级目录结构提高了检索的速度，解决了多用户之间的文件重名问题，文件系统可以在目录上实现访问限制。但是两级目录结构缺乏灵活性，不能对文件分类。</p>
<h3 id="_2-3-树形目录结构"> 2.3 树形目录结构</h3>
<p>将两级日录结构加以推广，就形成了树形目录结构。它可以明显地提高对目录的检索速度和文件系统的性能。当用户要访问某个文件时，用文件的路径名标识文件，文件路径名是个字符串，由从根目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成。从根目录出发的路径称为绝对路径。当层次较多时，每次从根目录查询会浪费时间，于是加入了当前目录(又称工作目录)，进程对各文件的访问都是相对于当前目录进行的。当用户要访问某个文件时，使用相对路径标识文件，相对路径由从当前目录出发到所找文件通路上所有目录名与数据文件名用分隔符“/”链接而成。</p>
<p>图4.13是Linux操作系统的目录结构，“/dev/hda”就是一个绝对路径。若当前目录为“/bin&quot;，则“/s”就是一个相对路径，其中符号“.” 表示当前工作目录。</p>
<p>通常，每个用户都有各自的“当前目录”，登录后自动进入该用户的“当前目录”。操作系统提供一-条专门的系统调用，供用户随时改变“当前目录”。例如，在UNIX系统中，“/etc/passwd&quot; 文件就包含有用户登录时默认的“当前目录”，可用cd命令改变“当前目录</p>
<p>树形目录结构可以很方便地对文件进行分类，层次结构清晰，也能够更有效地进行文件的管理和保护。在树形目录中，不同性质、不同用户的文件，可以分.别呈现在系统目录树的不同层次或不同子树中，很容易地赋予不同的存取权限。但是，在树形目录中查找- -个文件，需要按路径名逐级访问中间结点，增加了磁盘访问次数，这无疑会影响查询速度。目前，大多数操作系统如UNIX.Linux和Windows系统都采用了树形文件目录。</p>
<p><img src="./README.assets/image-20220402142458761.png" alt="image-20220402142458761" loading="lazy"></p>
<h3 id="_2-4-无环图目录结构"> 2.4 无环图目录结构</h3>
<p>树形目录结构能便于实现文件分类，但不便于实现文件共享，为此在树形目录结构的基础上增加了一些指向同一结点的有向边，使整个目录成为一个有向无环图，如图4.14所示。</p>
<p>当某用户要求删除一个共享结点时，若系统只是简单地将它删除，则当另一共享用户需要访问时，会因无法找到这个文件而发生错误。为此，可为每个共享结点设置一个共享计数器，每当图中增加对该结点的共享链时，计数器加1；每当某用户提出删除该结点时，计数器减1。仅当共享计数器为0时，才真正删除该结点，否则仅删除请求用户的共享链。</p>
<p>共享文件（或目录）不同于文件拷贝（副本）。若有两个文件拷贝，则每个程序员看到的是拷贝而不是原件；然而，若一个文件被修改，则另一个程序员的拷贝不会改变。对于共享文件，只存在一个真正的文件，任何改变都会为其他用户所见。</p>
<p>无环图目录结构方便地实现了文件的共享，但使得系统的管理变得更加复杂。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16492947519115.png" alt="img" loading="lazy"></p>
<h2 id="三、目录的操作"> 三、目录的操作</h2>
<p>在理解一个文件系统的需求前，我们首先考虑在目录这个层次上所需要执行的操作，这有助于后面文件系统的整体理解。</p>
<ul>
<li>
<p>搜索。当用户使用一个文件时，需要搜索目录，以找到该文件的对应目录项。</p>
</li>
<li>
<p>创建文件。当创建一个新文件时， 需要在目录中增加一个目录项。</p>
</li>
<li>
<p>删除文件。当删除一个文件时，需要在目录中删除相应的目录项。</p>
</li>
<li>
<p>创建目录。在树形目录结构中，用户可创建自己的用户文件目录，并可再创建子目录。</p>
</li>
<li>
<p>删除目录。有两种方式：</p>
<ol>
<li>不删除非空目录，删除时要先删除目录中的所有文件，并递归地删除子目录。</li>
<li>可删除非空目录，目录中的文件和子目录同时被删除。</li>
</ol>
</li>
<li>
<p>移动目录。将文件或子目录在不同的父目录之间移动，文件的路径名也会随之改变。</p>
</li>
<li>
<p>显示目录。用户可以请求显示目录的内容，如显示该用户目录中的所有文件及属性。</p>
</li>
<li>
<p>修改目录。某些文件属性保存在目录中，因而这些属性的变化需要改变相应的目录项。</p>
</li>
</ul>
<h2 id="四、目录实现"> 四、目录实现</h2>
<p>在访问一个文件时，操作系统利用路径名找到相应目录项，目录项中提供了查找文件磁盘块所需要的信息。目录实现的基本方法有线性列表和哈希表两种,要注意目录的实现就是为了查找，因此线性列表实现对应线性查找，哈希表的实现对应散列查找。</p>
<h3 id="_4-1-线性列表"> 4.1 线性列表</h3>
<p>最简单的目录实现方法是，采用文件名和数据块指针的线性列表。当创建新文件时，必须首先搜索目录以确定没有同名的文件存在，然后在目录中增加一个新的目录项。当删除文件时，则根据给定的文件名搜索目录，然后释放分配给它的空间。当要重用目录项时有许多种方法：可以将目录项标记为不再使用，或将它加到空闲目录项的列表上，还可以将目录的最后一个目录项复制到空闲位置，并减少目录的长度。采用链表结构可以减少删除文件的时间。</p>
<p>线性列表的优点在于实现简单，不过由于线性表的特殊性，查找比较费时。</p>
<h3 id="_4-2-哈希表"> 4.2 哈希表</h3>
<p>除了采用线性列表存储文件目录项，还可以采用哈希数据结构。哈希表根据文件名得到一个值，并返回一个指向线性列表中元素的指针。这种方法的优点是查找非常迅速，插入和刪除也较简单，不过需要一些措施来避免冲突(两个文件名称哈希到同一位置)。</p>
<p>目录查询是通过在磁盘上反复搜索完成的，需要不断地进行I/O操作，开销较大。所以如前所述，为了减少I/O操作，把当前使用的文件目录复制到内存，以后要使用该文件时只需在内存中操作，因此降低了磁盘操作次数，提高了系统速度。</p>
<h2 id="五、文件共享"> 五、文件共享</h2>
<p>文件共享使多个用户共享同一个文件，系统中只需保留该文件的一个副本。若系统不能提供共享功能，则每个需要该文件的用户都要有各自的副本，会造成对存储空间的极大浪费。</p>
<p>现代常用的两种文件共享方法如下。</p>
<h3 id="_5-1-基于索引结点的共享方式-硬链接"> 5.1 基于索引结点的共享方式(硬链接)</h3>
<p>在树形结构的目录中，当有两个或多个用户要共享一个子目录或文件时，必须将共享文件或子目录链接到两个或多个用户的目录中，才能方便地找到该文件，如图4.15所示。</p>
<p><img src="./README.assets/image-20220402142802961.png" alt="image-20220402142802961" loading="lazy"></p>
<p>在这种共享方式中，诸如文件的物理地址及其他的文件属性等信息，不再放在目录项中，而放在索引结点中。在文件目录中只设置文件名及指向相应索引结点的指针。在索引结点中还应有一个链接计数count，用于表示链接到本索引结点(即文件)上的用户目录项的数目。当count = 2时，表示有两个用户目录项链接到本文件上，或者说有两个用户共享此文件。</p>
<p>用户A创建一个新文件时，他便是该文件的所有者，此时将count置为1。用户B要共享此文件时，在B的目录中增加一个目录项，并设置一个指针指向该文件的索引结点。此时，文件主仍然是用户A，count = 2。 如果用户A不再需要此文件，能否直接将其删除呢？答案是否定的。因为若删除了该文件，也必然删除了该文件的索引结点，这样便会使用户B的指针悬空，而B可能正在此文件上执行写操作，此时将因此半途而废。因此用户A不能删除此文件,只是将该文件的count减1，然后删除自己目录中的相应目录项。用户B仍可以使用该文件。当count = 0时，表示没有用户使用该文件，才会删除该文件。如图4.16给出了用户B链接到文件上的前、后情况。</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MzkxNDYwNA==,size_16,color_FFFFFF,t_70-16492949851077.png" alt="img" loading="lazy"></p>
<h3 id="_5-2-利用符号链实现文件共享-软链接"> 5.2 利用符号链实现文件共享(软链接)</h3>
<p>为使用户B能共享用户A的一个文件F，可以由系统创建一个LINK类型的新文件，也取名为F，并将该文件写入用户B的目录中，以实现用户B的目录与文件F的链接。在新文件中只包含被链接文件F的路径名。当用户B要访问被链接的文件F且正要读LINK类新文件时，操作系统查看到要读的文件是LINK类型，则根据该文件中的路径名去找到文件F，然后对它进行读，从而实现用户B对文件F的共享。这样的链接方法被称为符号链接。</p>
<p>在利用符号链方式实现文件共享时，只有文件主才拥有指向其索引结点的指针。而共享该文件的其他用户只有该文件的路径名，并不拥有指向其索引结点的指针。这样，也就不会发生在文件主删除共享文件后留下悬空指针的情况。当文件主把一个共享文件删除后，若其他用户又试图通过符号链去访问它时，则会访问失败，于是将符号链删除，此时不会产生任何影响。</p>
<p>在符号链的共享方式中，当其他用户读共享文件时，系统根据文件路径名逐个查找目录，直至找到该文件的索引结点。因此，每次访问共享文件时，都可能要多次地读盘。使得访问文件的开销甚大，且增加了启动磁盘的频率。此外，符号链的索引结点也要耗费一定的磁盘空间。</p>
<p>利用符号链实现网络文件共享时，只需提供该文件所在机器的网络地址及文件路径名。</p>
<p>硬链接和软链接都是文件系统中的静态共享方法，在文件系统中还存在着另外的共享需求，即两个进程同时对同一个文件进行操作，这样的共享称为动态共享。</p>
<p>可以这样说：文件共享，“软”“硬”兼施。硬链接就是多个指针指向一个索引结点，保证只要还有一个指针指向索引结点，索引结点就不能删除；软链接就是把到达共享文件的路径记录下来，当要访问文件时，根据路径寻找文件。可见，硬链接的查找速度要比软链接的快。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T06:30:02.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">文件系统</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/4/3/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/4/3/"/>
    <updated>2022-04-07T01:46:36.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、文件系统结构"> 一、文件系统结构</h2>
<p>文件系统(File system)提供高效和便捷的磁盘访问，以便允许存储、定位、提取数据。文件系统有两个不同的设计问题：</p>
<ul>
<li>第一个问题是，定义文件系统的用户接口，它涉及定义文件及其属性、所允许的文件操作、如何组织文件的目录结构。</li>
<li>第二个问题是，创建算法和数据结构，以便映射逻辑文件系统到物理外存设备。</li>
</ul>
<p>现代操作系统有多种文件系统类型，因此文件系统的层次结构也不尽相同。</p>
<p><img src="./README.assets/image-20220402143336402.png" alt="image-20220402143336402" loading="lazy"></p>
<h3 id="_1-1-i-o控制"> 1.1 I/O控制</h3>
<p>包括设备驱动程序和中断处理程序，在内存和磁盘系统之间传输信息。设备驱动程序将输入的命令翻译成底层硬件的特定指令，硬件控制器利用这些指令使I/O设备与系统交互。设备驱动程序告诉I/O控制器对设备的什么位置采取什么动作。</p>
<h3 id="_1-2-基本文件系统"> 1.2 基本文件系统</h3>
<p>向对应的设备驱动程序发送通用命令，以读取和写入磁盘的物理块。每个物理块由磁盘地址标识。该层也管理内存缓冲区,并保存各种文件系统、目录和数据块的缓存。在进行磁盘块传输前，分配合适的缓冲区，并对缓冲区进行管理。管理它们对于系统性能的优化至关重要。</p>
<h3 id="_1-3-文件组织模块"> 1.3 文件组织模块</h3>
<p>组织文件及其逻辑块和物理块。文件组织模块可以将逻辑块地址转换成物理块地址，每个文件的逻辑块从0到N编号，它与数据的物理块不匹配，因此需要道过转换来定位。文件组织模块还包括空闲空间管理器，以跟踪未分配的块，根据需求提供给文件组织模块。</p>
<h3 id="_1-4-逻辑文件系统"> 1.4 逻辑文件系统</h3>
<p>用于管理元数据信息。元数据包括文件系统的所有结构，而不包括实际数据(或文件内容)。逻辑文件系统管理目录结构，以便根据给定文件名称为文件组织模块提供所需要的信息。它通过文件控制块来维护文件结构。逻辑文件系统还负贵文件保护。</p>
<h2 id="二、文件系统布局"> 二、文件系统布局</h2>
<h3 id="_2-1-文件系统在磁盘中的结构"> 2.1 文件系统在磁盘中的结构</h3>
<p>文件系统存放在磁盘上，多数磁盘划分为一个或多个分区，每个分区中有一个独立的文件系统。文件系统可能包括如下信息：启动存储在那里的操作系统的方式、总的块数、空闲块的数量和位置、目录结构以及各个具体文件等。图4.18所示为一个可能的文件系统布局。</p>
<p><img src="https://img-blog.csdn.net/20170519143414939" alt="img" loading="lazy"></p>
<p>简单描述如下：</p>
<ol>
<li>主引导记录(Master Boot Record, MBR)，位于磁盘的0号扇区，用来引导计算机，MBR后面是分区表，该表给出每个分区的起始和结束地址。表中的一个分区被标记为活动分区，当计算机启动时，BIOS读入并执行MBR。MBR做的第一件事是确定活动分区，读入它的第一块，即引导块。</li>
<li>引导块(boot block)，MBR执行引导块中的程序后，该程序负责启动该分区中的操作系统。为统一起见，每个分区都从一个引导块开始，即使它不含有一个可启动的操作系统,也不排除以后会在该分区安装一个操作系统。Windows 系统称之为分区引导扇区。除了从引导块开始，磁盘分区的布局是随着文件系统的不同而变化的。</li>
<li>超级块(super block)，包含文件系统的所有关键信息，在计算机启动时，或者在该文件系统首次使用时，超级块会被载入内存。超级块中的典型信息包括分区的块的数量、块的大小、空闲块的数量和指针、空闲的FCB数量和FCB指针等。</li>
<li>文件系统中空闲块的信息，可以使用位示图或指针链接的形式给出。后面也许跟的是一组i结点，每个文件对应一个结点，i结点说明了文件的方方面面。接着可能是根目录，它存放文件系统目录树的根部。最后，磁盘的其他部分存放了其他所有的目录和文件.</li>
</ol>
<h3 id="_2-2-文件系统在内存中的结构"> 2.2 文件系统在内存中的结构</h3>
<p>内存中的信息用于管理文件系统并通过缓存来提高性能。这些数据在安装文件系统时被加载，在文件系统操作期间被更新，在卸载时被丢弃。这些结构的类型可能包括：</p>
<ol>
<li>内存中的安装表(mounttable)，包含每个已安装文件系统分区的有关信息。</li>
<li>内存中的目录结构的缓存包含最近访问目录的信息。对安装分区的目录，它可以包括一个指向分区表的指针。</li>
<li>整个系统的打开文件表，包含每个打开文件的FCB副本及其他信息。</li>
<li>每个进程的打开文件表，包含一个指向整个系统的打开文件表中的适当条目的指针，以及其他信息。</li>
</ol>
<p>为了创建新的文件，应用程序调用逻辑文件系统。逻辑文件系统知道目录结构的格式，它将为文件分配一个新的FCB。然后，系统将相应的目录读入内存，使用新的文件名和FCB进行更新，并将它写回磁盘。</p>
<p>一旦文件被创建， 它就能用于IO。不过，首先要打开文件。系统调用open()将文件名传递给逻辑文件系统。调用open()首先搜索整个系统的打开文件表，以确定这个文件是否已被其他进程使用。如果已被使用，则在单个进程的打开文件表中创建一个条目， 让其指向现有整个系统的打开文件表的相应条目。该算法在文件已打开时，能节省大量开销。如果这个文件尚未打开，则根据给定文件名来搜索目录结构。部分目录结构通常缓存在内存中，以加快目录操作。找到文件后，它的FCB会复制到整个系统的打开文件表中。该表不但存储FCB，而且跟踪打开该文件的进程的数量。然后，在单个进程的打开文件表中创建一个条目，并且通过指针将整个系统打开文件表的条目与其他域(如文件当前位置的指针和文件访问模式等)相连。调用open()返回的是--个指向单个进程的打开文件表中的适当条目的指针。以后，所有文件操作都通过该指针执行。一旦文件被打开，内核就不再使用文件名来访问文件，而使用文件描述符( Windows称之为文件句柄)。</p>
<p>当进程关闭一个文件时，就会删除单个进程打开文件表中的相应条目，整个系统的打开文件表的文件打开数量也会递减。当所有打开某个文件的用户都关闭该文件后，任何更新的元数据将复制到磁盘的目录结构中，并且整个系统的打开文件表的对应条目也会被删除。</p>
<h2 id="三、外存空闲空间管理"> 三、外存空闲空间管理</h2>
<p>一个存储 设备可以按整体用于文件系统，也可以细分。例如，一个磁盘可以划分为4个分区，每个分区都可以有单独的文件系统。包含文件系统的分区通常称为卷(volume)。卷可以是磁盘的一部分，也可以是整个磁盘，还可以是多个磁盘组成RAID集，如图4.19所示。</p>
<p><img src="./README.assets/image-20220402143919864.png" alt="image-20220402143919864" loading="lazy"></p>
<p>在一个卷中，存放文件数据的空间(文件区)和FCB的空间(目录区)是分离的。由于存在很多种类的文件表示和存放格式，所以现代操作系统中一般都有很多不同的文件管理模块，通过它们可以访问不同格式的卷中的文件。卷在提供文件服务前，必须由对应的文件程序进行初始化，划分好目录区和文件区，建立空闲空间管理表格及存放卷信息的超级块。</p>
<p>文件存储设备分成许多大小相同的物理块，并以块为单位交换信息，因此，文件存储设备的管理实质上是对空闲块的组织和管理，它包括空闲块的组织、分配与回收等问题。</p>
<h3 id="_3-1-空闲表法"> 3.1 空闲表法</h3>
<p>空闲表法属于连续分配方式，它与内存的动态分配方式类似，为每个文件分配一块连续的存储空间。系统为外存上的所有空闲区建立一张空闲盘块表，每个空闲区对应于一个空闲表项，其中包括表项序号、该空闲区的第一个盘块号、该区的空闲盘块数等信息。再将所有空闲区按其起始盘块号递增的次序排列，如表4.1所示。</p>
<p>空闲盘区的分配与内存的动态分配类似，同样采用首次适应算法和最佳适应算法等。例如，在系统为某新创建的文件分配空闲盘块时，先顺序地检索空闲盘块表的各表项，直至找到第一个其大小能满足要求的空闲区，再将该盘区分配给用户，同时修改空闲盘块表。</p>
<p>系统在对用户所释放的存储空间进行回收时，也采取类似于内存回收的方法，即要考虑回收区是否与空闲盘块表中插入点的前区和后区相邻接，对相邻接者应予以合并。</p>
<p><img src="./README.assets/image-20220402144040903.png" alt="image-20220402144040903" loading="lazy"></p>
<h3 id="_3-2-空闹链表法"> 3.2 空闹链表法</h3>
<p>将所有空闲盘区拉成一条空闲链。根据构成链所用基本元素的不同，分为两种形式：</p>
<ol>
<li>空闲盘块链。将磁盘上的所有空闲空间以盘块为单位拉成一条链。当用户因创建文件而请求分配存储空间时，系统从链首开始，依次摘下适当数目的空闲盘块分配给用户。当用户因删除文件而释放存储空间时，系统将回收的盘块依次插入空闲盘块链的末尾。这种方法的优点是分配和回收一个盘块的过程非常简单，但在为一个文件分配盘块时可能要重复操作多次，效率较低。又因它是以盘块为单位的，空闲盘块链会很长。</li>
<li>空闲盘区链。将磁盘上的所有空闲盘区(每个盘区可包含若干个盘块)拉成一条链。每个盘区除含有用于指示下一个空闲盘区的指针外，还应有能指明本盘区大小(盘块数)的信息。分配盘区的方法与内存的动态分区分配类似，通常采用首次适应算法。在回收盘区时，同样也要将回收区与相邻接的空闲盘区合并。这种方法的优缺点刚好与第一种方法的相反，即分配与回收的过程比较复杂，但效率通常较高，且空闲盘区链较短。</li>
</ol>
<h3 id="_3-3-位示图法"> 3.3 位示图法</h3>
<p>位示图是利用二进制的一位来表示磁盘中一个盘块的使用情况，磁盘上所有的盘块都有一个二进制位与之对应。当其值为“0”时，表示对应的盘块空闲：为“1”时，表示已分配。这样，-一个mxn位组成的位示图就可用来表示mxn个盘块的使用情况，如图4.20所示。</p>
<p><img src="./README.assets/image-20220402144137463.png" alt="image-20220402144137463" loading="lazy"></p>
<p>盘块的分配：</p>
<ol>
<li>顺序扫描位示图， 从中找出一个或一组其值为 “0”的二进制位。</li>
<li>将找到的一个或一组二进制位，转换成与之对应的盘块号。若找到的其值为“0” 的二进制位位于位示图的第i行、第j列，则其相应的盘块号应按下式计算(n 为每行位数)：<span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6944em;"></span><span>b</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>n</span><span>(</span><span>i</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:1em;vertical-align:-0.25em;"></span><span>1</span><span>)</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span></span><span><span style="height:0.854em;vertical-align:-0.1944em;"></span><span style="margin-right:0.05724em;">j</span></span></span></span></li>
<li>修改位示图，令map[i,j]= 1。</li>
</ol>
<p>盘块的回收:：</p>
<ol>
<li>将回收盘块的盘块号转换成位示图中的行号和列号。转换公式为:
i=(b- 1) DIV n+ 1
j=(b- 1) MOD n+ 1</li>
<li>修改位示图，令map[i,j]= 0。</li>
</ol>
<p>空闲表法和空闲链表法都不适用于大型文件系统，因为这会使空闲表或空闲链表太大。</p>
<h3 id="_3-4-成组链接法"> 3.4 成组链接法</h3>
<p>在UNIX系统中采用的是成组链接法，这种方法结合了空闲表和空闲链表两种方法，它具有上述两种方法的优点，克服了两种方法均有的表太长的缺点。</p>
<p>用来存放一组空闲盘块号(空闲盘块的块号)的盘块称为成组链块。成组链接法的大致思想是：把顺序的n个空闲盘块号保存在第一个成组链块中，其最后一个空闲盘块(作为成组链块)则用于保存另一组空闲盘块号，如此继续，直至所有空闲盘块均予以链接。系统只需保存指向第一个成组链块的指针。假设磁盘最初全为空闲盘块，</p>
<p><img src="./README.assets/image-20220407093900721.png" alt="image-20220407093900721" loading="lazy"></p>
<p>盘块的分配：</p>
<p>根据第一个成组链块的指针，将其对应的盘块分配给用户，然后将指针下移一格。若该指针指向的是最后一个盘块(即成组链块)，由于该盘块记录的是下一组空闲盘块号，因此要将该盘块读入内存，并将指针指向新的成组链块的第一条记录， 然后执行上述分配操作。</p>
<p>盘块的回收：</p>
<p>成组链块的指针上移一格， 再记入回收盘块号。当成组链块的链接数达到n时，表示已满，便将现有已记录n个空闲盘块号的成组链块号记入新回收的盘块(作为新的成组链块)。</p>
<p>表示空闲空间的位向量表或第一个成组链块，以及卷中的目录区、文件区划分信息都要存放在磁盘中，一般放在卷头位置，在UNIX系统中称为超级块。在对卷中的文件进行操作前，超级块需要预先读入系统空闲的主存，并且经常保持主存超级块与磁盘卷中超级块的一致性。</p>
<h2 id="四、虚拟文件系统"> 四、虚拟文件系统.</h2>
<p>虚拟文件系统(VFS) 为用户程序提供了文件系统操作的统一接口，屏蔽了不同文件系统的差异和操作细节，如图4.1所示。用户程序可以通过VFS提供的统一调用函数 (如open()等)来操作不同文件系统(如ext3等)的文件，而无须考虑具体的文件系统和实际的存储介质。</p>
<p><img src="./README.assets/image-20220402145018811.png" alt="image-20220402145018811" loading="lazy"></p>
<p>虚拟文件系统采用了面向对象的思想，它抽象出一个通用的文件系统模型，定义了通用文件系统都支持的接口。新的文件系统只要支持并实现这些接口，即可安装和使用。以Linux中调用write()操作为例，它在VFS中通过sys_ write()函 数处理，sys_ write()找到具体文件系统，将控制权交给该文件系统，最后由具体文件系统与物理介质交互并读出数据，如图4.23所示。</p>
<p><img src="./README.assets/image-20220407094404999.png" alt="image-20220407094404999" loading="lazy"></p>
<p>为了实现VFS，Linux主要抽象了四种对象类型。每个VFS对象都存放在一个适当的数据结构中，其中包括对象的属性和指向对象方法(函数)表的指针。</p>
<ul>
<li>超级块对象：表示一个已安装(或称挂载)的特定文件系统。</li>
<li>索引结点对象：表示一个特定的文件。</li>
<li>目录项对象：表示一个特定的目录项。</li>
<li>文件对象：表示一个与进程相关的已打开文件。</li>
</ul>
<p>Linux将目录当作文件对象来处理，文件操作能同时应用于文件或目录。文件系统是由层次.目录组成的，一个目录项可能包含文件名和其他目录名。目录项作为单独抽象的对象，是因为目录可以层层嵌套，以便于形成文件路径，而路径中的每-部分其实就是目录项。</p>
<ol>
<li>超级块对象。超级块对象对应于磁盘上特定扇区的文件系统超级块，用于存储已安装文件系统的元信息，元信息中包含文件系统的基本属性信息，如文件系统类型、文件系统基本块的大小、文件系统所挂载的设备、操作方法(函数)指针等。其中操作方法(函数)指针指向该超级块的操作方法表，包含一系列可在超级块对象上调用的操作函数，主要有分配inode、销毁inode、读inode、写inode、文件同步等。</li>
<li>索引结点对象。文件系统处理文件所需要的所有信息，都放在一个称为索引结点的数据结构中，索引结点对文件是唯一的。 只有当文件被访问时，才在内存中创建索引结点对象，每个索引结点对象都会复制磁盘索引结点包含的一些数据。该对象中有一个状态字段表示是否被修改，其值为“脏”时，说明对应的磁盘索引结点必须被更新。索引结点对象还提供许多操作接口，如创建新索引结点、创建硬链接、创建新目录等。</li>
<li>目录项对象。由于VFS经常执行切换到某个目录这种操作，为了提高效率，便引入了目录项的概念。目录项对象是一个路径的组成部分，它要么是目录名，要么是文件名。例如，在查找路径名/test时，内核为根目录“/”创建一个目录项对象，为根目录下的test创建一个第二级目录项对象。目录项对象包含指向关联索引结点的指针，还包含指向父目录和指向子目录的指针。不同于前面两个对象，目录项对象在磁盘上没有对应的数据结构，而是VFS在遍历路径的过程中，将它们逐个解析成目录项对象的。</li>
<li>文件对象。文件对象代表进程打开的一个文件。可以通过open()调用打开一个文件，通过close()调用关闭一个文件。文件对象和物理文件的关系类似于进程和程序的关系。由于多个进程可以打开和操作同一文件，所以同一文件在内存中可能存在多个对应的文件对象，但对应的索引结点和目录项是唯一的。文件对象仅在进程观点上代表已经打开的文件，它反过来指向其索引结点。文件对象包含与该文件相关联的目录项对象，包含该文件的文件系统、文件指针等，还包含在该文件对象上调用的一系列操作函数。</li>
</ol>
<p>图4.24所示是一个进程与文件进行交互的简单实例。三个不同的进程已打开了同一个文件，其中两个进程使用同一个硬链接。在这种情况下，每个进程都使用自己的文件对象，但只需要两个目录项对象，每个硬链接对应一个目录项对象。这两个目录项对象指向同一个索引结点对象，这个索引结点对象标识的是超级块对象及随后的普通磁盘文件。</p>
<p><img src="./README.assets/image-20220402145209473.png" alt="image-20220402145209473" loading="lazy"></p>
<p>VFS还有另一个重要作用，即提高系统性能。最近最常使用的目录项对象被放在目录项高速缓存的磁盘缓存中，以加速从文件路径名到最后一个路径分量的索引结点的转换过程。</p>
<p>对用户来说，不需要关心不同文件系统的具体实现细节，只需要对一个虚拟的文件操作界面进行操作。VFS对每个文件系统的所有细节进行抽象，使得不同的文件系统在系统中运行的其他进程看来都是相同的。严格来说，VFS并不是一种实际的文件系统，它只存在于内存中，不存在于任何外存空间中。VFS 在系统启动时建立，在系统关闭时消亡。</p>
<h2 id="五、分区和安装"> 五、分区和安装</h2>
<p>一个磁盘可以划分为多个分区，每个分区都可以用于创建单独的文件系统，每个分区还可以包含不同的操作系统。分区可以是原始的，没有文件系统，当没有合适的文件系统时，可以使用原始磁盘。例如，UNIX 交换空间可以使用原始磁盘格式，而不使用文件系统。</p>
<p>第1章中介绍过操作系统的引导。Linux启动后，首先载入MBR,随后MBR识别活动分区，并且加载活动分区中的引导程序。图4.25中显示了一个典型的Linux分区。</p>
<p><img src="./README.assets/image-20220402145248632.png" alt="image-20220402145248632" loading="lazy"></p>
<p>分区的第一部分是引导块，里面存储着引导信息，它有自身的格式，因为在引导时系统并未加载文件系统代码，因此不能解释文件系统的格式。引导信息是一系列可 以加载到内存中的连续块，加载到内存后从其第-条代码开始执行，引导程序便启动一个具体的操作系统。引导块之后是超级块，它存储文件系统的有关信息，包括文件系统的类型、i结点的数目、数据块的数目。随后是多个索引结点，它们是实现文件存储的关键，每个文件对应-一个索引结点， 索引结点中包含多个指针，指向属于该文件的各个数据块。最后是文件数据块。</p>
<p>如文件在使用前必须打开一样，文件系统在进程使用前必须先安装，也称挂载。</p>
<p>Windows系统维护一个扩展的两级目录结构，用驱动器字母表示设备和卷。卷具有常规树结构的目录，与驱动器号相关联，还含有指向已安装文件系统的指针。特定文件的路径形式为driver-lttre:pathtofile，操作系统找到相应文件系统的指针，并且遍历该设备的目录结构，以查找指定的文件。新版本的Windows允许文件系统安装在目录树下的任意位置，就像UNIX-样。 在启动时，Windows 操作系统自动发现所有设备，并且安装所有找到的文件系统。</p>
<p>UNIX使用系统的根文件系统，由内核在引导阶段直接安装，其他文件系统要么由初始化脚本安装，要么由用户安装在已安装文件系统的目录下。作为一个目录树，每个文件系统都拥有自己的根目录。安装文件系统的这个目录称为安装点，安装就是将磁盘分区挂载到该安装点下，进入该目录就可以读取该分区的数据。已安装文件系统属于安装点目录的一个子文件系统。安装的实现是在目录inode 的内存副本上加上一个标志，表示该目录是安装点。还有一个域指向安装表的条目，表示哪个设备安装在哪里，这个条目还包括该设备的文件系统超级块的一个指针。</p>
<p>假定将存放在/dev/fd0软盘上的ext2 文件系统通过mount命令安装到/fhp:mount -t ext2 /dev/fd0 /flp</p>
<p>如需卸载该文件系统，可以使用umount命令。</p>
<p>我们可以这么理解：UNIX本身是一个固定的目录树，只要安装就有，但是如果不给它分配存储空间，就不能对它进行操作，所以首先要给根目录分配空间，这样才能操作这个目录树。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T06:54:00.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">设备独立性软件</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/5/2/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/5/2/"/>
    <updated>2022-04-09T02:37:28.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、与设备无关的软件"> 一、与设备无关的软件</h2>
<p>与设备无关的软件是I/O系统的最高层软件，它的下层是设备驱动程序，其间的界限因操作系统和设备的不同而有所差异。比如，一些本应 由设备独立性软件实现的功能，也可能放在设备驱动程序中实现。这样的差异主要是出于对操作系统、设备独立性软件和设备驱动程序运行效率等多方面因素的权衡。总体而言，设备独立性软件包括执行所有设备公有操作的软件。</p>
<h2 id="二、高速缓存与缓冲区"> 二、高速缓存与缓冲区</h2>
<h3 id="_2-1-磁盘高速缓存-disk-cache"> 2.1 磁盘高速缓存(Disk Cache)</h3>
<p>操作系统中使用磁盘高速缓存技术来提高磁盘的I/O速度，对访问高速缓存要比访问原始磁盘数据更为高效。</p>
<p>例如，正在运行进程的数据既存储在磁盘上，又存储在物理内存上，也被复制到CPU的二级和一级高速缓存中。不过，磁盘高速缓存技术不同于通常意义下的介于CPU与内存之间的小容量高速存储器，而是指利用内存中的存储空间来暂存从磁盘中读出的一系列盘块中的信息。因此，磁盘高速缓存逻辑上属于磁盘，物理上则是驻留在内存中的盘块。</p>
<p>高速缓存在内存中分为两种形式：一种是在内存中开辟一个单独的空间作为磁盘高速缓存，大小固定；另一种是把未利用的内存空间作为一个缓冲池，供请求分页系统和磁盘IO时共享。</p>
<h3 id="_2-2-缓冲区-buffer"> 2.2 缓冲区(Buffer)</h3>
<p>在设备管理子系统中，引入缓冲区的目的主要如下:</p>
<ol>
<li>缓和CPU与I/O设备间速度不匹配的矛盾。</li>
<li>减少对CPU的中断频率，放宽对CPU中断响应时间的限制。</li>
<li>解决基本数据单元大小(即数据粒度)不匹配的问题。</li>
<li>提高CPU和I/O设备之间的并行性。</li>
</ol>
<p>其实现方法如下:</p>
<ol>
<li>采用硬件缓冲器，但由于成本太高，除一些关键部位外，一般不采用硬件缓冲器。</li>
<li>采用缓冲区(位于内存区域)。</li>
</ol>
<p>根据系统设置缓冲器的个数，缓冲技术可以分为如下几种:</p>
<p><strong>单缓冲</strong></p>
<p>在主存中设置一个缓冲区。当设备和处理机交换数据时，先将数据写入缓冲区，然后需要数据的设备或处理机从缓冲区取走数据，在缓冲区写入或取出的过程中，另一方需等待。</p>
<p>如图5.6 所示，在块设备输入时，假定从磁盘把一块数据输入到缓冲区的时间为T，操作系统将该缓冲区中的数据传送到用户区的时间为M，而CPU对这一块数据处理的时间为C。</p>
<p><img src="./README.assets/image-20220409091131511.png" alt="image-20220409091131511" loading="lazy"></p>
<hr>
<p><strong>双缓冲</strong></p>
<p>根据单缓冲的特点，CPU在传送时间M内处于空闲状态，由此引入双缓冲。I/O设备输入数据时先装填到缓冲区 1，在缓冲区 1 填满后才开始装填缓冲区 2，与此同时处理机可以从缓冲区1中取出数据送入用户进程，当缓冲区 1 中的数据处理完后，若缓冲区 2 已填满，则处理机又从缓冲区 2 中取出数据送入用户进程，而I/O设备又可以装填缓冲区 1。注意，<strong>必须等缓冲区 2 充满才能让处理机从缓冲区 2 取出数据</strong>。双缓冲机制提高了处理机和输入设备的并行程度。</p>
<p><img src="./README.assets/image-20220402152139806.png" alt="image-20220402152139806" loading="lazy"></p>
<p>若两台机器之间通信仅配置了单缓冲，如图5.8(a)所示， 则它们在任意时刻都只能实现单方向的数据传输。例如，只允许把数据从A机传送到B机，或从B机传送到A机，而绝不允许双方同时向对方发送数据。为了实现双向数据传输，必须在两台机器中都设置两个缓冲区，一个用作发送缓冲区，另一个用作接收缓冲区，如图5.8(b)所示。</p>
<p><img src="./README.assets/image-20220402152221627.png" alt="image-20220402152221627" loading="lazy"></p>
<hr>
<p><strong>循环缓冲</strong></p>
<p>包含多个大小相等的缓冲区，每个缓冲区中有一个链接指针指向下一个缓冲区，最后一个缓冲区指针指向第一个缓冲区，多个缓冲区构成一个环形 。</p>
<p>循环缓冲用于输入/输出时，还需要有两个指针in和out。对输入而言，首先要从设备接收数据到缓冲区中，in 指针指向可以输入数据的第一个空缓冲区；当运行进程需要数据时，从循环缓冲区中取一个装满数据的缓冲区，并从此缓冲区中提取数据，out 指针指向可以提取数据的第一个满缓冲区。输出则正好相反。</p>
<hr>
<p><strong>缓冲池</strong></p>
<p>由多个系统公用的缓冲区组成，缓冲区按其使用状况可以形成三个队列：空缓冲队列、装满输入数据的缓冲队列(输入队列)和装满输出数据的缓冲队列(输出队列)。还应具有4种缓冲区：用于收容输入数据的工作缓冲区、用于提取输入数据的工作缓冲区、用于收容输出数据的工作缓冲区及用于提取输出数据的工作缓冲区，如图5.9 所示。</p>
<p><img src="./README.assets/image-20220402152312652.png" alt="image-20220402152312652" loading="lazy"></p>
<p>当输入进程需要输入数据时，便从空缓冲队列的队首摘下一个空缓冲区，把它作为收容输入工作缓冲区，然后把输入数据输入其中，装满后再将它挂到输入队列队尾。当计算进程需要输入数据时，便从输入队列取得一个缓冲区作为提取输入工作缓冲区，计算进程从中提取数据，数据用完后再将它挂到空缓冲队列尾。当计算进程需要输出数据时，便从空缓冲队列的队首取得一个空缓冲区，作为收容输出工作缓冲区，当其中装满输出数据后，再将它挂到输出队列队尾。当要输出时，由输出进程从输出队列中取得-一个装满输出数据的缓冲区，作为提取输出工作缓冲区，当数据提取完后，再将它挂到空缓冲队列的队尾。</p>
<p>对于循环缓冲和缓冲池，我们只是定性地介绍它们的机理，而不去定量研究它们平均处理一块数据所需要的时间。而对于单缓冲和双缓冲，我们只要按照上面的模板分析，就可以解决任何计算单缓冲和双缓冲情况下数据块处理时间的问题，以不变应万变。</p>
<h3 id="_2-3-高速缓存与缓冲区的对比"> 2.3 高速缓存与缓冲区的对比</h3>
<p>高速缓存是可以保存数据拷贝的高速存储器,访问高速缓存比访问原始数据更高效，速度更快。高速缓存和缓冲区的对比见表5.1.</p>
<p><img src="./README.assets/image-20220402152347796.png" alt="image-20220402152347796" loading="lazy"></p>
<h2 id="三、设备分配与回收"> 三、设备分配与回收</h2>
<h3 id="_3-1-设备分配概述"> 3.1 设备分配概述</h3>
<p>设备分配是指根据用户的I/0请求分配所需的设备。分配的总原则是充分发挥设备的使用效率，尽可能地让设备忙碌，又要避免由于不合理的分配方法造成进程死锁。从设备的特性来看，采用下述三种使用方式的设备分别称为独占设备、共享设备和虚拟设备。</p>
<ol>
<li>独占式使用设备。进程分配到独占设备后，便由其独占，直至该进程释放该设备。</li>
<li>分时式共享使用设备。对于共享设备，可同时分配给多个进程，通过分时共享使用。</li>
<li>以SPOOLing方式使用外部设备。SPOOLing技术实现了虚拟设备功能，可以将设备同时分配给多个进程。这种技术实质上就是实现了对设备的I/O操作的批处理。</li>
</ol>
<h3 id="_3-2-设备分配的数据结构"> 3.2 设备分配的数据结构</h3>
<p>设备分配依据的主要数据结构有设备控制表(DCT)、 控制器控制表(COCT)、 通道控制表(CHCT)和系统设备表(SDT),各数据结构功能如下。</p>
<p>设备控制表(DCT): - -个设备控制表就表征-一个设备， 而这个控制表中的表项就是设备的各个属性，如图5.10所示。凡因请求本设备而未得到满足的进程，应将其PCB按某种策略排成-一个设备请求队列，设备队列的队首指针指向该请求队列队首PCB.</p>
<p><img src="./README.assets/image-20220402152449947.png" alt="image-20220402152449947" loading="lazy"></p>
<p>设备控制器控制设备与内存交换数据，而设备控制器又需要请求通道为它服务，因此每个COCT [图5.11(a)]有一一个表项存放指向相应通道控制表(CHCT) [图5.11(b)]的指针，而一个通道可为多个设备控制器服务，因此CHCT中必定有一个指针，指向一个表，这个表上的信息表达的是CHCT提供服务的那几个设备控制器。CHCT与COCT的关系是一对多的关系。</p>
<p>系统设备表(SDT): 整个系统只有一-张 SDT,如图5.11(C)所示。它记录己连接到系统中的所有物理设备的情况，每个物理设备占-一个表目。</p>
<p><img src="./README.assets/image-20220402152513907.png" alt="image-20220402152513907" loading="lazy"></p>
<p>在多道程序系统中，进程数多于资源数,因此要有一套合理的分配原则，主要考虑的因素有：I/O设备的固有属性、I/O设备的分配算法、I/O设备分配的安全性以及I/O设备的独立性。</p>
<h3 id="_3-3-设备分配的策咯"> 3.3 设备分配的策咯.</h3>
<ol>
<li>设备分配原则。设备分配应根据设备特性、用户要求和系统配置情况。既要充分发挥设备的使用效率，又要避免造成进程死锁，还要将用户程序和具体设备隔离开。</li>
<li>设备分配方式。设备分配方式有静态分配和动态分配两种：
<ol>
<li>静态分配主要用于对独占设备的分配，它在用户作业开始执行前，由系统- -次性分配该作业所要求的全部设备、控制器。一旦分配， 这些设备、 控制器就-直为该作业所占用，直到该作业被撤销。静态分配方式不会出现死锁，但设备的使用效率低</li>
<li>动态分配在进程执行过程中根据执行需要进行。当进程需要设备时，通过系统调用命令向系统提出设备请求，由系统按某种策略给进程分配所需要的设备、控制器，一 旦用完，便立即释放。这种方式有利于提高设备利用率，但若分配算法使用不当，则有可能造成进程死锁。</li>
</ol>
</li>
<li>设备分配算法。常用的动态设备分配算法有先请求先分配、优先级高者优先等。</li>
</ol>
<p>对于独占设备，既可以采用动态分配方式，又可以采用静态分配方式，但往往采用静态分配方式。共享设备可被多个进程所共享，- 般采用动态分配方式，但在每个I/O传输的单位时间内只被一一个进程所占有，通常采用先请求先分配和优先级高者优先的分配算法。</p>
<h3 id="_3-4-设备分配的安全性"> 3.4 设备分配的安全性</h3>
<p>设备分配的安全性是指设备分配中应防止发生进程死锁。</p>
<ol>
<li>安全分配方式。每当进程发出I/O请求后便进入阻塞态，直到其I/O操作完成时才被唤醒。这样，一旦进程已经获得某种设备后便阻塞，不能再请求任何资源，而在它阻塞时也不保持任何资源。其优点是设备分配安全，缺点是CPU和IO设备是串行工作的。</li>
<li>不安全分配方式。进程在发出I/0请求后仍继续运行，需要时又发出第二个、第三个IO请求等。仅当进程所请求的设备已被另一进程占用时，才进入阻塞态。优点是一一个进程可同时操作多个设备，使进程推进迅速;缺点是有可能造成死锁。</li>
</ol>
<h3 id="_3-5-逻辑设备名到物理设备名的映射"> 3.5 逻辑设备名到物理设备名的映射</h3>
<p>为了提高设备分配的灵活性和设备的利用率，方便实现I/O重定向，引入了设备独立性。设备独立性是指应用程序独立于具体使用的物理设备。</p>
<p>为了实现设备独立性，在应用程序中使用逻辑设备名来请求使用某类设备，在系统中设置一张逻辑设备表(Logical Unit Table, LUT),用于将逻辑设备名映射为物理设备名。LUT表项包括逻辑设备名、物理设备名和设备驱动程序入口地址;当进程用逻辑设备名来请求分配设备时，系统为它分配一台相应的物理设备，并在LUT中建立-一个表目,当以后进程再利用该逻辑设备名请求I/O操作时，系统通过查找LUt来寻找对应的物理设备和驱动程序。</p>
<p>在系统中可采取两种方式设置逻辑设备表:</p>
<ol>
<li>在整个系统中只设置- -张LUT.这样,所有进程的设备分配情况都记录在同一张LUT中，因此不允许LUT中具有相同的逻辑设备名，主要适用于单用户系统。.</li>
<li>为每个用户设置- -张LUT.每当用户登录时，系统便为该用户建立-一个进程，同时也为之建立一-张LUT,并将该表放入进程的PCB中。</li>
</ol>
<h2 id="四、spooling-技术-假脱机技术"> 四、SPOOLing 技术(假脱机技术)</h2>
<p>为了缓和CPU的高速性与I/O设备低速性之间的矛盾，引入了脱机输入/输出技术，它是操作系统中采用的一-项将独占设备改造成共享设备的技术。该技术利用专门的外围控制机，将低速I/O设备上的数据传送到高速磁盘上，或者相反。SPOOLing 系统的组成如图5.12所示。</p>
<p><img src="./README.assets/image-20220402152753404.png" alt="image-20220402152753404" loading="lazy"></p>
<h3 id="_4-1-输入井和输出井"> 4.1 输入井和输出井</h3>
<p>在磁盘上开辟出的两个存储区域。输入井模拟脱机输入时的磁盘，用于收容I/O设备输入的数据。输出井模拟脱机输出时的磁盘，用于收容用户程序的输出数据。-一个进程的输入(或输出)数据保存为一个文件，所有进程的数据输入(或输出)文件链接成一个输入(或输出)队列。</p>
<h3 id="_4-2-输入缓冲区和输出缓冲区"> 4.2 输入缓冲区和输出缓冲区</h3>
<p>在内存中开辟的两个缓冲区。输入缓冲区用于暂存由输入设备送来的数据，以后再传送到输入井。输出缓冲区用于暂存从输出井送来的数据，以后再传送到输出设备。</p>
<h3 id="_4-3-输入进程和输出进程"> 4.3 输入进程和输出进程</h3>
<p>输入/输出进程用于模拟脱机输入/输出时的外围控制机。用户要求的数据从输入设备经过输入缓冲区送到输入井，当CPU需要输入数据时，直接从输入井读入内存。用户要求输出的数据先从内存送到输出井，待输出设备空闲时，再将输出井中的数据经过输出缓冲区送到输出设备。</p>
<p>共享打印机是使用SPOOLing技术的实例。当用户进程请求打印输出时，SPOOLing 系统同意打印，但是并不真正立即把打印机分配给该进程，而由假脱机管理进程完成两项任务:</p>
<ol>
<li>在磁盘缓冲区中为之申请一个空闲盘块，并将要打印的数据送入其中暂存。</li>
<li>为用户进程申请一-张空白的用户请求打印表，并将用户的打印要求填入其中，再将该表挂到假脱机文件队列上。</li>
</ol>
<p>这两项工作完成后，虽然还没有任何实际的打印输出，但是对于用户进程而言，其打印任务已完成。对用户而言，系统并非立即执行真实的打印操作，而只是立即将数据输出到缓冲区,真正的打印操作是在打印机空闲且该打印任务已排在等待队列队首时进行的。</p>
<p>SPOOLing系统的特点如下：</p>
<ol>
<li>提高了I/O的速度,将对低速IO设备执行的IO操作演变为对磁盘缓冲区中数据的存取，如同脱机输入/输出一样， 缓和了CPU和低速I/O设备之间的速度不匹配的矛盾</li>
<li>将独占设备改造为共享设备，在假脱机打印机系统中，实际上并没有为任何进程分配设备</li>
<li>实现了虚拟设备功能，对每个进程而言，它们都认为自己独占了一个设备。</li>
</ol>
<p>前面我们提到过SPOOLing技术是-一种以空间换时间的技术,我们很容易理解它牺牲了空间，因为它开辟了磁盘上的空间作为输入井和输出井，但它又如何节省时间呢？</p>
<p>从前述内容我们了解到，磁盘是一-种高速设备， 在与内存交换数据的速度上优于打印机、键盘、鼠标等中低速设备。试想一下， 若没有SPOOLing技术，CPU要向打印机输出要打印的数据，打印机的打印速度比较慢，CPU 就必须迁就打印机，在打印机把数据打印完后才能继续做其他的工作，浪费了CPU的不少时间。在SPOOLing技术下，CPU 要打印机打印的数据可以先输出到磁盘的输出井中(这个过程由假脱机进程控制)，然后做其他的事情。若打印机此时被占用，则SPOOLing系统就会把这个打印请求挂到等待队列上，待打印机有空时再把数据打印出来。向磁盘输出数据的速度比向打印机输出数据的速度快，因此就节省了时间。</p>
<h2 id="五、设备驱动程序接口"> 五、设备驱动程序接口</h2>
<p>如果每个设备驱动程序与操作系统的接口都不同，那么每次出现一个新设备时，都必须为此修改操作系统。因此，要求每个设备驱动程序与操作系统之间都有着相同或相近的接口。这样会使得添加一一个新设备驱动程序变得很容易，同时也便于开发人员编制设备驱动程序。</p>
<p>对于每种设备类型，例如磁盘，操作系统都要定义一组驱动程序必须支持的函数。对磁盘而言，这些函数自然包含读、写、格式化等。驱动程序中通常包含一张表格，这张表格具有针对这些函数指向驱动程序自身的指针。装载驱动程序时，操作系统记录这个函数指针表的地址，所以当操作系统需要调用一一个函数时，它可以通过这张表格发出间接调用。这个函数指针表定义了驱动程序与操作系统其余部分之间的接口。给定类型的所有设备都必须服从这一要求。</p>
<p>与设备无关的软件还要负责将符号化的设备名映射到适当的驱动程序上。例如，在UNIX中，设备名/dev/disk0唯- -确定了一个特殊文件的i结点，这个i结点包含了主设备号(用于定位相应的驱动程序)和次设备号(用来确定要读写的具体设备)。</p>
<p>在UNIX和Windows中，设备是作为命名对象出现在文件系统中的，因此针对文件的常规保护规则也适用于I/O设备。系统管理员可以为每个设备设置适当的访问权限。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T07:33:21.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">I/O管理概述</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/5/1/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/5/1/"/>
    <updated>2022-04-07T02:02:41.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、i-o-设备"> 一、I/O 设备</h2>
<p>I/O设备管理是操作系统设计中最凌乱也最具挑战性的部分。由于它包含了很多领域的不同设备及与设备相关的应用程序，因此很难有一个通用且一致的设计方案。</p>
<h3 id="_1-1-设备的分类"> 1.1 设备的分类</h3>
<p>按信息交换的单位分类，I/O 设备可分为：</p>
<ol>
<li>块设备。信息交换以数据块为单位。它属于有结构设备，如磁盘等。磁盘设备的基本特征是传输速率较高、可寻址，即对它可随机地读/写任一块。</li>
<li>字符设备。信息交换以字符为单位。它属于无结构类型，如交互式终端机、打印机等。它们的基本特征是传输速率低、不可寻址，并且时常采用中断I/O方式。</li>
</ol>
<p>按传输速率分类，I/O 设备可分为：</p>
<ol>
<li>低速设备。传输速率仅为每秒几字节到数百字节的一类设备，如键盘、鼠标等.</li>
<li>中速设备。传输速率为每秒数千字节至数万字节的一类设备，如激光打印机等。</li>
<li>高速设备。传输速率在数百千字节至千兆字节的一类设备,如磁盘机、光盘机等。</li>
</ol>
<h3 id="_1-2-i-o接口"> 1.2 I/O接口</h3>
<p>I/O接口(设备控制器)位于CPU与设备之间，它既要与CPU通信，又要与设备通信，还要具有按CPU发来的命令去控制设备工作的功能，主要由三部分组成，如图5.1所示。</p>
<p><img src="./README.assets/image-20220407094839882.png" alt="image-20220407094839882" loading="lazy"></p>
<ol>
<li>设备控制器与CPU的接口。该接口有三类信号线：数据线、地址线和控制线。数据线通常与两类寄存器相连；数据寄存器(存放从设备送来的输入数据或从CPU送米的输出数据)和控制/状态寄存器(存放从CPU送来的控制信息或设备的状态信息)。</li>
<li>设备控制器与设备的接口。一个设备控制器可以连接一个或多个设备，因此控制器中有一个或多个设备接口。每个接口中都存在数据、控制和状态三种类型的信号。</li>
<li>I/O逻辑。用于实现对设备的控制。它通过一组控制线与CPU交互，对从CPU收到的I/O命令进行译码。CPU启动设备时，将启动命令发送给控制器，同时通过地址线把地址发送给控制器，由控制器的I/O逻辑对地址进行译码，并相应地对所选设备进行控制。</li>
</ol>
<p>设备控制器的主要功能有：</p>
<ol>
<li>接收和识别CPU发来的命令，如磁盘控制器能接收读、写、查找等命令</li>
<li>数据交换，包括设备和控制器之间的数据传输，以及控制器和主存之间的数据传输</li>
<li>标识和报告设备的状态，以供CPU处理</li>
<li>地址识别</li>
<li>数据缓冲</li>
<li>差错控制。</li>
</ol>
<h3 id="_1-3-i-o-端口"> 1.3 I/O 端口</h3>
<p>I/O端口是指设备控制器中可被CPU直接访问的寄存器，主要有以下三类寄存器。</p>
<ul>
<li>数据寄存器:实现CPU和外设之间的数据缓冲。</li>
<li>状态寄存器:获取执行结果和设备的状态信息，以让CPU知道是否准备好。</li>
<li>控制寄存器:由CPU写入，以便启动命令或更改设备模式。</li>
</ul>
<p>为了实现CPU与I/O端口进行通信，有两种方法，如图5.2所示。</p>
<ol>
<li>独立编址。为每个端口分配一个I/O端口号，所有I/O端口形成I/0端口空间，普通用户程序不能对其进行访问，只有操作系统使用特殊的I/O指令才能访问端口。</li>
<li>统一编址。 又称内存映射I/O，每个端口被分配唯一的内存地址，且不会有内存被分配这一地址， 通常分配给端口的地址靠近地址空间的顶端。</li>
</ol>
<p><img src="./README.assets/image-20220402150852660.png" alt="image-20220402150852660" loading="lazy"></p>
<h2 id="二、i-o控制方式"> 二、I/O控制方式</h2>
<p>设备管理的主要任务之一是控制设备和内存或CPU之间的数据传送。外围设备和内存之间的输入/输出控制方式有4种，下面分别加以介绍。</p>
<h3 id="_2-1-程序直接控制方式"> 2.1 程序直接控制方式</h3>
<p>计算机从外部设备读取的每个字，CPU需要对外设状态进行循环检查，直到确定该字已经在I/O控制器的数据寄存器中。在程序直接控制方式中，由于CPU的高速性和I/O设备的低速性，致使CPU的绝大部分时间都处于等待I/O设备完成数据I/O的循环测试中，造成了CPU资源的极大浪费。在该方式中，CPU之所以要不断地测试I/O设备的状态，就是因为在CPU中未采用中断机构，使I/O设备无法向CPU报告它已完成了一个字符的输入操作。</p>
<p><img src="./README.assets/image-20220407095101202.png" alt="image-20220407095101202" loading="lazy"></p>
<p>程序直接控制方式虽然简单且易于实现，但其缺点也显而易见，由于CPU和I/O设备只能串行工作，导致CPU的利用率相当低。</p>
<h3 id="_2-2-中断驱动方式"> 2.2 中断驱动方式</h3>
<p>中断驱动方式的思想是，允许I/O设备主动打断CPU的运行并请求服务，从而“解放&quot;CPU，使得其向I/O控制器发送读命令后可以继续做其他有用的工作。如图5.3(b)所示，我们从I/O控制器和CPU两个角度分别来看中断驱动方式的工作过程。</p>
<p>从I/O控制器的角度来看，I/O 控制器从CPU接收一个读命令，然后从外部设备读数据。一旦数据读入I/O控制器的数据寄存器，便通过控制线给CPU发出中断信号，表示数据已准备好，然后等待CPU请求该数据。I/O控制器收到CPU发出的取数据请求后，将数据放到数据总线上，传到CPU的寄存器中。至此，本次I/O操作完成，I/O 控制器又可开始下一次I/O操作。</p>
<p>从CPU的角度来看，CPU发出读命令，然后保存当前运行程序的上下文(现场，包括程序计数器及处理机寄存器)，转去执行其他程序。在每个指令周期的末尾，CPU检查中断。当有来自I/O控制器的中断时，CPU保存当前正在运行程序的上下文，转去执行中断处理程序以处理该中断。这时，CPU从I/O控制器读一个字的数据传送到寄存器，并存入主存。接着，CPU恢复发出IO命令的程序(或其他程序)的上下文，然后继续运行。</p>
<p>中断驱动方式比程序直接控制方式有效，但由于数据中的每个字在存储器与I/O控制器之间的传输都必须经过CPU,这就导致了中断驱动方式仍然会消耗较多的CPU时间。</p>
<p><img src="./README.assets/image-20220407095119633.png" alt="image-20220407095119633" loading="lazy"></p>
<h3 id="_2-3-dma方式"> 2.3 DMA方式</h3>
<p><img src="./README.assets/image-20220407095142627.png" alt="image-20220407095142627" loading="lazy"></p>
<p>在中断驱动方式中，I/O设备与内存之间的数据交换必须要经过CPU中的寄存器，所以速度还是受限，而DMA (直接存储器存取)方式的基本思想是在I/O设备和内存之间开辟直接的数据交换通路，彻底“解放”CPU。DMA方式的特点如下:</p>
<ol>
<li>基本单位是数据块。</li>
<li>所传送的数据，是从设备直接送入内存的，或者相反。</li>
<li>仅在传送一一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在DMA控制器的控制下完成的。</li>
</ol>
<p>图5.4列出了DMA控制器的组成。</p>
<p><img src="./README.assets/image-20220402151042132.png" alt="image-20220402151042132" loading="lazy"></p>
<p>要在主机与控制器之间实现成块数据的直接交换,须在DMA控制器中设置如下4类寄存器：</p>
<ol>
<li>命令/状态寄存器(CR)。 接收从CPU发来的I/O命令、有关控制信息，或设备的状态。</li>
<li>内存地址寄存器(MAR)。 在输入时，它存放把数据从设备传送到内存的起始目标地址在输出时，它存放由内存到设备的内存源地址。</li>
<li>数据寄存器(DR)。暂存从设备到内存或从内存到设备的数据。</li>
<li>数据计数器(DC)。存放本次要传送的字(节)数。</li>
</ol>
<p>如图5.3(c)所示，DMA方式的工作过程是：CPU接收到I/O设备的DMA请求时，它给DMA控制器发出一条命令， 同时设置MAR和DC初值，启动DMA控制器，然后继续其他工作。之后CPU就把控制操作委托给DMA控制器，由该控制器负贵处理。DMA控制器直接与存储器交互，传送整个数据块，每次传送一个字， 这个过程不需要CPU参与。传送完成后，DMA控制器发送一个中断信号给处理器。因此只有在传送开始和结束时才需要CPU的参与。</p>
<p>DMA方式与中断方式的主要区别是，中断方式在每个数据需要传输时中断CPU，而DMA方式则是在所要求传送的一批数据全部传送结束时才中断CPU；此外，中断方式的数据传送是在中断处理时由CPU控制完成的，而DMA方式则是在DMA控制器的控制下完成的。</p>
<h3 id="_2-4-通道控制方式"> 2.4 通道控制方式</h3>
<p>I/O通道是指专门负责输入/输出的处理机。I/O通道方式是DMA方式的发展，它可以进一步减少CPU的干预，即把对一个数据块的读(或写)为单位的干预，减少为对一组数据块的读(或写)及有关控制和管理为单位的干预。同时，又可以实现CPU、通道和I/O设备三者的并行操作，从而更有效地提高整个系统的资源利用率。</p>
<p>例如，当CPU要完成一组相关的读(或写)操作及有关控制时，只需向I/O通道发送一条I/O指令,以给出其所要执行的通道程序的首地址和要访问的I/O设备，通道接到该指令后，执行通道程序便可完成CPU指定的I/O任务，数据传送结束时向CPU发中断请求。</p>
<p>I/O通道与一般处理机的区别是：通道指令的类型单一，没有自己的内存，通道所执行的通道程序是放在主机的内存中的，也就是说通道与CPU共享内存。</p>
<p>I/O通道与DMA方式的区别是：DMA方式需要CPU来控制传输的数据块大小、传输的内存位置，而通道方式中这些信息是由通道控制的。另外，每个DMA控制器对应一台设备与内存传递数据，而一个通道可以控制多台设备与内存的数据交换。</p>
<div><p>Note</p>
<p>下面用一个例子来总结这4种I/O方式。想象一位客户要去裁缝店做一批衣服的情形。</p>
<p>采用程序控制方式时，裁缝没有客户的联系方式，客户必须每隔一段时间去裁缝店看看裁缝把衣服做好了没有，这就浪费了客户不少的时间。采用中断方式时，裁缝有客户的联系方式，每当他完成一件衣服后，给客户打一个电话，让客户去拿，与程序直接控制能省去客户不少麻烦，但每完成一件衣服就让客户去拿一次，仍然比较浪费客户的时间。采用DMA方式时，客户花钱雇一位单线秘书，并向秘书交代好把衣服放在哪里(存放仓库)，裁缝要联系就直接联系秘书，秘书负贵把衣服取回来并放在合适的位置，每处理完100件衣服，秘书就要给客户报告一次(大大节省了客户的时间)。采用通道方式时，秘书拥有更高的自主权，与DMA方式相比，他可以决定把衣服存放在哪里，而不需要客户操心。而且，何时向客户报告，是处理完100件衣服就报告,还是处理完10000件衣服才报告，秘书是可以决定的。客户有可能在多个裁缝那里订了货，一位DMA类的秘书只能负贵与一位裁缝沟通，但通道类秘书却可以与多名裁缝进行沟通。</p>
</div>
<h2 id="三、i-o-软件层次结构"> 三、I/O 软件层次结构</h2>
<p>I/O软件涉及的面很宽，往下与硬件有着密切关系，往上又与虚拟存储器系统、文件系统和用户直接交互，它们都需要I/O软件来实现I/O操作。</p>
<p>为使复杂的1/O软件能具有清晰的结构、良好的可移植性和易适应性，目前已普遍采用层次式结构的I/O软件。将系统中的设备管理模块分为若干个层次，每层都是利用其下层提供的服务，完成输入/输出功能中的某些子功能，并屏蔽这些功能实现的细节，向高层提供服务。在层次式结构的I/O软件中，只要层次间的接口不变，对某一层次中的软件的修改都不会引起其下层或高层代码的变更，仅最低层才涉及硬件的具体特性。</p>
<p>一个比较合理的层次划分如图5.5所示。整个I/O软件可以视为具有4个层次的系统结构，各层次及其功能如下:</p>
<p><img src="./README.assets/image-20220402151335667.png" alt="image-20220402151335667" loading="lazy"></p>
<h3 id="_3-1-用户层i-o软件"> 3.1 用户层I/O软件</h3>
<p>实现与用户交互的接口，用户可直接调用在用户层提供的、与I/0操作有关的库函数，对设备进行操作。一般而言，大部分的IO软件都在操作系统内部，但仍有一小部分在用户层，包括与用户程序链接在一起的库函数。用户层软件必须通过一组系统调用来获取操作系统服务。</p>
<h3 id="_3-2-设备独立性软件"> 3.2 设备独立性软件</h3>
<p>用于实现用户程序与设备驱动器的统一接口、设备命令、设备的保护及设备的分配与释放等，同时为设备管理和数据传送提供必要的存储空间。</p>
<p>设备独立性也称设备无关性，使得应用程序独立于具体使用的物理设备。为实现设备独立性而引入了逻辑设备和物理设备这两个概念。在应用程序中，使用逻辑设备名来请求使用某类设备；而在系统实际执行时，必须将逻辑设备名映射成物理设备名使用。</p>
<p>使用逻辑设备名的好处是：</p>
<ol>
<li>增加设备分配的灵活性</li>
<li>易于实现I/0重定向，所谓IO重定向，是指用于I/O操作的设备可以更换(即重定向)，而不必改变应用程序。</li>
</ol>
<p>为了实现设备独立性，必须再在驱动程序之上设置一层设备独立性软件。总体而言，设备独立性软件的主要功能可分为以下两个方面：</p>
<ol>
<li>执行所有设备的公有操作，包括：对设备的分配与回收；将逻辑设备名映射为物理设备名;对设备进行保护，禁止用户直接访问设备；缓冲管理；差错控制;提供独立于设备的大小统一的逻辑块，屏蔽设备之间信息交换单位大小和传输速率的差异。</li>
<li>向用户层(或文件层)提供统接口。无论何种设备，它们向用户所提供的接口应是相同的。例如，对各种设备的读/写操作，在应用程序中都统一使用read/write命令等。</li>
</ol>
<h3 id="_3-3-设备驱动程序"> 3.3 设备驱动程序</h3>
<p>与硬件直接相关，负责具体实现系统对设备发出的操作指令，驱动I/O设备工作的驱动程序。通常，每类设备配置一个设备驱动程序，它是I/O进程与设备控制器之间的通信程序，常以进程形式存在。设备驱动程序向上层用户程序提供一组标准接口，设备具体的差别被设备驱动程序所封装，用于接收上层软件发来的抽象I/O要求，如read和write命令，转换为具体要求后，发送给设备控制器，控制I/O设备工作；它也将由设备控制器发来的信号传送给上层软件，从而为I/O内核子系统隐藏设备控制器之间的差异。</p>
<h3 id="_3-4-中断处理程序"> 3.4 中断处理程序</h3>
<p>用于保存被中断进程的CPU环境，转入相应的中断处理程序进行处理，处理完毕再恢复被中断进程的现场后，返回到被中断进程。</p>
<p>中断处理层的主要任务有：进行进程上下文的切换，对处理中断信号源进行测试，读取设备状态和修改进程状态等。由于中断处理与硬件紧密相关，对用户而言，应尽量加以屏蔽，因此应放在操作系统的底层，系统的其余部分尽可能少地与之发生联系。</p>
<p>类似于文件系统的层次结构，I/O子系统的层次结构也是我们需要记忆的内容，但记忆不是死记硬背，我们以用户对设备的一次命令来总结各层次的功能，帮助各位读者记忆。例如：</p>
<ol>
<li>当用户要读取某设备的内容时，通过操作系统提供的read命令接口，这就经过了用户层</li>
<li>操作系统提供给用户使用的接口，一般是统一的通用接口，也就是几乎每个设备都可以响应的统一命令， 如read命令，用户发出的read命令，首先经过设备独立层进行解析，然后交往下层。</li>
<li>接下来，不同类型的设备对read命令的行为会有所不同，如磁盘接收read命令后的行为与打印机接收read命令后的行为是不同的。因此，需要针对不同的设备，把read命令解析成不同的指令，这就经过了设备驱动层。</li>
<li>命令解析完毕后，需要中断正在运行的进程，转而执行read命令，这就需要中断处理程序</li>
<li>最后，命令真正抵达硬件设备，硬件设备的控制器按照上层传达的命令操控硬件设备，完成相应的功能。</li>
</ol>
<h2 id="五、应用程序i-o接口"> 五、应用程序I/O接口</h2>
<p>在I/O系统与高层之间的接口中，根据设备类型的不同，又进一步分为若干接口。</p>
<h3 id="_5-1-字符设备接口"> 5.1 字符设备接口</h3>
<p>字符设备是指数据的存取和传输是以字符为单位的设备，如键盘、打印机等。基本特征是传输速率较低、不可寻址，并且在输入/输出时通常采用中断驱动方式。</p>
<p>get和put操作。由于字符设备不可寻址，只能采取顺序存取方式，通常为字符设备建立一个字符缓冲区，用户程序通过get操作从缓冲区获取字符，通过put操作将字符输出到缓冲区。</p>
<p>in-control指令。字符设备类型繁多，差异甚大，因此在接口中提供-种通用的in-control 指令来处理它们(包含了许多参数，每个参数表示-一个与具体设备相关的特定功能)。</p>
<p>字符设备都属于独占设备，为此接口中还需要提供打开和关闭操作，以实现互斥共享。</p>
<h3 id="_5-2-块设备接口"> 5.2 块设备接口</h3>
<p>块设备是指数据的存取和传输是以数据块为单位的设备，典型的块设备是磁盘。基本特征是传输速率较高、可寻址。磁盘设备的I/0常采用DMA方式。</p>
<p>隐藏了磁盘的二维结构。在二维结构中，每个扇区的地址需要用磁道号和扇区号来表示。块设备接口将磁盘的所有扇区从0到n-1依次编号，这样，就将二维结构变为一种线性序列。</p>
<p>将抽象命令映射为低层操作。块设备接口支持上层发来的对文件或设备的打开、读、写和关闭等抽象命令，该接口将上述命令映射为设备能识别的较低层的具体操作。</p>
<p>内存映射接口通过内存的字节数组来访问磁盘，而不提供读/写磁盘操作。映射文件到内存的系统调用返回包含文件副本的一个虚拟内存地址。只在需要访问内存映像时，才由虚拟存储器实际调页。内存映射文件的访问如同内存读写一样简单，极大地方便了程序员。</p>
<h3 id="_5-3-网络设备接口"> 5.3 网络设备接口</h3>
<p>现代操作系统都提供面向网络的功能，因此还需要提供相应的网络软件和网络通信接口，使计算机能够通过网络与网络上的其他计算机进行通信或上网浏览。</p>
<p>许多操作系统提供的网络I/O接口为网络套接字接口，套接字接口的系统调用使应用程序创建的本地套接字连接到远程应用程序创建的套接字，通过此连接发送和接收数据。</p>
<h3 id="_5-4-阻塞-非阻塞i-o"> 5.4 阻塞/非阻塞I/O</h3>
<p>操作系统的I/O接口还涉及两种模式:阻塞和非阻塞。</p>
<p>阻塞I/O是指当用户进程调用I/O操作时，进程就被阻塞，需要等待I/O 操作完成，进程才被唤醒继续执行。非阻塞I/O是指用户进程调用I/O操作时，不阻塞该进程，该I/O调用返回一个错误返回值，通常，进程需要通过轮询的方式来查询I/O操作是否完成。</p>
<p>大多数操作系统提供的I/O接口都是采用阻塞I/O。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T07:18:22.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">数据结构和算法</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/"/>
    <updated>2022-03-19T03:07:34.000Z</updated>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T03:07:34.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">磁盘和固态硬盘</title>
    <id>https://notes.lllllan.cn/cs-basic/os/wangdao/5/3/</id>
    <link href="https://notes.lllllan.cn/cs-basic/os/wangdao/5/3/"/>
    <updated>2022-04-02T08:00:10.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《王道考研-操作系统》</li>
</ul>
</div>
<h2 id="一、磁盘"> 一、磁盘</h2>
<p>磁盘(Disk) 是由表面涂有磁性物质的物理盘片，通过- - 个称为磁头的导体线圈从磁盘存取数据。在读/写操作期间，磁头固定，磁盘在下面高速旋转。如图5.13所示，磁盘盘面上的数据存储在一组同心圆中， 称为磁道。每个磁道与磁头-样宽，- 一个盘面有上千个磁道。磁道又划分为几百个扇区，每个扇区固定存储大小，-一个扇区称为一个盘块。相邻磁道及相邻扇区间通过一定的间隙分隔开，以避免精度错误。注意，由于扇区按固定圆心角度划分，所以密度从最外道向里道增加，磁盘的存储能力受限于最内道的最大记录密度。</p>
<p>磁盘安装在一个磁盘驱动器中,它由磁头臂、用于旋转磁盘的主轴和用于数据输入/输出的电子设备组成。如图5.14所示，多个盘片垂直堆叠，组成磁盘组，每个盘面对应-一个磁头，所有磁头固定在一起， 与磁盘中心的距离相同且-起移动。所有盘片，上相对位置相同的磁道组成柱面。扇区是磁盘可寻址的最小单位，磁盘上能存储的物理块数目由扇区数、磁道数及磁盘面数决定,磁盘地址用“柱面号●盘面号●扇区号”表示。</p>
<p><img src="./README.assets/image-20220402155020497.png" alt="image-20220402155020497" loading="lazy"></p>
<p>磁盘按不同的方式可分为若干类型:磁头相对于盘片的径向方向固定的，称为固定头磁盘,每个磁道一个磁头;磁头可移动的，称为活动头磁盘，磁头臂可来回伸缩定位磁道;磁盘永久固定在磁盘驱动器内的，称为固定盘磁盘;可移动和替换的，称为可换盘磁盘。</p>
<p>操作系统中几乎每介绍一类资源及其管理时，都要涉及一类调度算法。用户访问文件,需要操作系统的服务，文件实际上存储在磁盘中，操作系统接收用户的命令后，经过一系列的检验访问权限和寻址过程后，最终都会到达磁盘，控制磁盘把相应的数据信息读出或修改。当有多个请求同时到达时，操作系统就要决定先为哪个请求服务，这就是磁盘调度算法要解决的问题。</p>
<h2 id="二、磁盘的管理"> 二、磁盘的管理</h2>
<h3 id="_2-1-磁盘初始化"> 2.1 磁盘初始化</h3>
<p>一个新的磁盘只是一个磁性记录材料的空白盘。在磁盘可以存储数据之前，必须将它分成扇区，以便磁盘控制器能够进行读写操作，这个过程称为低级格式化( 或称物理格式化)。低级格式化为每个扇区使用特殊的数据结构,填充磁盘。每个扇区的数据结构通常由头部、数据区域(通常为512B大小)和尾部组成。头部和尾部包含了- -些磁盘控制器的使用信息。</p>
<p>大多数磁盘在工厂时作为制造过程的-部分就已低级格式化,这种格式化能够让制造商测试磁盘,并且初始化逻辑块号到无损磁盘扇区的映射。对于许多磁盘,当磁盘控制器低级格式化时,还能指定在头部和尾部之间留下多长的数据区，通常选择256或512字节等。</p>
<h3 id="_2-2-分区"> 2.2 分区</h3>
<p>在可以使用磁盘存储文件之前，操作系统还要将自己的数据结构记录到磁盘上，分为两步:第- -步是，将磁盘分为由一个或多个柱面组成的分区( 即我们熟悉的C盘、D盘等形式的分区),每个分区的起始扇区和大小都记录在磁盘主引导记录的分区表中;第二步是，对物理分区进行逻辑格式化(创建文件系统)，操作系统将初始的文件系统数据结构存储到磁盘上，这些数据结构包括空闲空间和已分配的空间以及-个初始为空的目录。</p>
<p>因扇区的单位太小，为了提高效率，操作系统将多个相邻的扇区组合在一起，形成-簇(在Linux中称为块)。为了更高效地管理磁盘，-簇只能存放-一个文件的内容，文件所占用的空间只能是簇的整数倍;如果文件大小小于- -簇(甚至是0字节)，也要占用- -簇的空间。</p>
<h3 id="_2-3-引导块"> 2.3 引导块</h3>
<p>计算机启动时需要运行-一个初始化程序( 自举程序),它初始化CPU、寄存器、设备控制器和内存等，接着启动操作系统。为此，自举程序找到磁盘上的操作系统内核，将它加载到内存,并转到起始地址，从而开始操作系统的运行。</p>
<p>自举程序通常存放在ROM中，为了避免改变自举代码而需要改变ROM硬件的问题，通常只在ROM中保留很小的自举装入程序，而将完整功能的引导程序保存在磁盘的启动块上，启动块位于磁盘的固定位置。具有启动分区的磁盘称为启动磁盘或系统磁盘。</p>
<p>引导ROM中的代码指示磁盘控制器将引导块读入内存，然后开始执行，它可以从非固定的磁盘位置加载整个操作系统，并且开始运行操作系统。下 面以Windows为例来分析引导过程。Windows允许将磁盘分为多个分区，有一个分区为引导分区， 它包含操作系统和设备驱动程序。Windows系统将引导代码存储在磁盘的第0号扇区，它称为主引导记录(MBR)。引导首先运行ROM中的代码，这个代码指示系统从MBR中读取引导代码。除了包含引导代码，MBR还包含:一个磁盘分区表和一个标志(以指示从哪个分区引导系统)，如图5.15所示。当系统找到引导分区时，读取分区的第-一个扇区，称为引导扇区，并继续余下的引导过程，包括加载各种系统服务。</p>
<p><img src="./README.assets/image-20220402155219006.png" alt="image-20220402155219006" loading="lazy"></p>
<h3 id="_2-4坏块"> 2.4坏块</h3>
<p>由于磁盘有移动部件且容错能力弱，因此容易导致一个或多个扇区损坏。部分磁盘甚至在出厂时就有坏块。根据所用的磁盘和控制器，对这些块有多种处理方式。</p>
<p>对于简单磁盘，如采用IDE控制器的磁盘，坏块可手动处理，如MS-DOS的Format命令执行逻辑格式化时会扫描磁盘以检查坏块。坏块在FAT表上会标明，因此程序不会使用它们。</p>
<p>对于复杂的磁盘,控制器维护磁盘内的坏块列表。这个列表在出厂低级格式化时就已初始化,并在磁盘的使用过程中不断更新。低级格式化将一些块保留 作为备用，操作系统看不到这些块。控制器可以采用备用块来逻辑地替代坏块，这种方案称为扇区备用。.</p>
<p>对坏块的处理实质上就是用某种机制使系统不去使用坏块。</p>
<h2 id="三、磁盘调度算法"> 三、磁盘调度算法</h2>
<p>一次磁 盘读写操作的时间由寻找(寻道)时间、旋转延迟时间和传输时间决定。</p>
<ol>
<li>寻找时间Tg。活动头磁盘在读写信息前，将磁头移动到指定磁道所需要的时间。这个时间除跨越n条磁道的时间外，还包括启动磁臂的时间s，即 T= mxn+s 式中，m是与磁盘驱动器速度有关的常数，约为0.2ms,磁臂的启动时间约为2ms。</li>
<li>旋转延迟时间Tp。磁头定位到某- - 磁道的扇区所需要的时间，设磁盘的旋转速度为r,则 T=:1/2r 对于硬盘，典型的旋转速度为5400转/分，相当于- -周11.1ms，则T为5.55ms; 对于软盘，其旋转速度为300<sub>600转/分，则T,为50</sub> l00ms.</li>
<li>传输时间T。从磁盘读出或向磁盘写入数据所经历的时间，这个时间取决于每次所读/写的字节数b和磁盘的旋转速度: T = b /rN 式中，r为磁盘每秒的转数，N为--个磁道上的字节数。</li>
</ol>
<p>在磁盘存取时间的计算中，寻道时间与磁盘调度算法相关;而延迟时间和传输时间都与磁盘旋转速度相关，且为线性相关，所以在硬件上，转速是磁盘性能的- -个非常重要的参数。</p>
<p>总平均存取时间T可以表示为 T=T + 1/2r + b/rN</p>
<p>虽然这里给出了总平均存取时间的公式，但是这个平均值是没有太大实际意义的，因为在实际的磁盘I/O操作中，存取时间与磁盘调度算法密切相关。</p>
<p>目前常用的磁盘调度算法有以下几种。</p>
<h3 id="_3-1-先来先服务-first-come-first-served-fcfs-算法"> 3.1 先来先服务( First Come First Served, FCFS)算法</h3>
<p>FCFS算法根据进程请求访问磁盘的先后顺序进行调度，这是一种最简单的调度算法，如图5.16所示。该算法的优点是具有公平性。若只有少量进程需要访问，且大部分请求都是访问簇聚的文件扇区，则有望达到较好的性能;若有大量进程竞争使用磁盘，则这种算法在性能上往往接近于随机调度。所以，实际磁盘调度中会考虑-些更为复杂的调度算法。</p>
<p><img src="./README.assets/image-20220402155439694.png" alt="image-20220402155439694" loading="lazy"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55, 58, 39, 18, 90, 160, 150, 38, 184，磁头的初始位置是磁道100,采用FCFS算法时磁头的运动过程如图5.16所示。磁头共移动了(45+3+ 19+21 +72 + 70+ 10+ 112+ 146) =498个磁道，平均寻找长度= 498/9 = 55.3。</p>
<h3 id="_3-2-最短寻找时间优先-shortest-seek-time-first-sstf-算法"> 3.2 最短寻找时间优先( Shortest Seek Time First, SSTF)算法</h3>
<p>SSTF算法选择调度处理的磁道是与当前磁头所在磁道距离最近的磁道，以便使每次的寻找时间最短。当然，总是选择最小寻找时间并不能保证平均寻找时间最小，但能提供比FCFS算法更好的性能。这种算法会产生“饥饿”现象。如图5.17所示，若某时刻磁头正在18 号磁道，而在18号磁道附近频繁地增加新的请求，则SSTF算法使得磁头长时间在18号磁道附近工作，将使184号磁道的访问被无限期地延迟，即被“饿死”。.</p>
<p><img src="./README.assets/image-20220402155507898.png" alt="image-20220402155507898" loading="lazy"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55, 58, 39, 18, 90, 160, 150, 38, 184，磁头初始位置是磁道100,采用SSTF算法时磁头的运动过程如图5.17所示。磁头共移动了10+32+3+16+1 +20+ 132+ 10+ 24= 248个磁道，平均寻找长度= 248/9= 27.5.</p>
<h3 id="_3-3-扫描-scan-算法-又称电梯调度算法"> 3.3 扫描(SCAN)算法(又称电梯调度算法)</h3>
<p>SCAN算法在磁头当前移动方向上选择与当前磁头所在磁道距离最近的请求作为下一次服务的对象，实际上就是在最短寻找时间优先算法的基础上规定了磁头运动的方向，如图5.18所示。由于磁头移动规律与电梯运行相似，因此又称电梯调度算法。SCAN算法对最近扫描过的区域不公平，因此它在访问局部性方面不如FCFS算法和SSTF算法好。</p>
<p><img src="./README.assets/image-20220402155547077.png" alt="image-20220402155547077" loading="lazy"></p>
<p>例如，磁盘请求队列中的请求顺序分别为55, 58, 39, 18, 90, 160, 150, 38, 184,磁头初始位置是磁道100。采用SCAN算法时，不但要知道磁头的当前位置，而且要知道磁头的移动方向，假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图5.18所示。移动磁道的顺序为100, 150,160, 184, 200, 90, 58, 55, 39, 38, 18。磁头共移动了(50+ 10+ 24+ 16+ 110+32+3+ 16+ 1 + 20)=282个磁道，平均寻道长度= 282/9=31.33.</p>
<h3 id="_3-4-循环扫描-circular-scan-c-scan-箅法"> 3.4 循环扫描( Circular SCAN, C-SCAN)箅法</h3>
<p>在扫描算法的基础上规定磁头单向移动来提供服务，回返时直接快速移动至起始端而不服务任何请求。由于SCAN算法偏向于处理那些接近最里或最外的磁道的访问请求，所以使用改进型的C-SCAN算法来避免这个问题，如图5.19所示。.</p>
<p><img src="./README.assets/image-20220402155623632.png" alt="image-20220402155623632" loading="lazy"></p>
<p>采用SCAN算法和C-SCAN算法时，磁头总是严格地遵循从盘面的一端到另一端，显然，在实际使用时还可以改进,即磁头移动只需要到达最远端的一个请求即可返回,不需要到达磁盘端点。这种形式的SCAN算法和C-SCAN算法称为LOOK调度( 见图5.20)和C-LOOK (见图5.21)调度，因为它们在朝-一个给定方向移动前会查看是否有请求。</p>
<p><img src="./README.assets/image-20220402155642271.png" alt="image-20220402155642271" loading="lazy"></p>
<p>注意,若无特别说明,也可以默认SCAN算法和C-SCAN算法为LOOK和C-LOOK调度(请读者认真领悟，并通过结合后面的习题进- 步加深对以.上相关算法的理解)。</p>
<p><img src="./README.assets/image-20220402155700295.png" alt="image-20220402155700295" loading="lazy"></p>
<p>例如，磁盘请求队列中的请求顺序为55, 58, 39, 18, 90, 160, 150, 38, 184,磁头初始位置是磁道100.采用C-SCAN算法时,假设磁头沿磁道号增大的顺序移动，则磁头的运动过程如图5.19所示。移动磁道的顺序为100, 150, 160, 184, 200, 0, 18, 38, 39, 55, 58, 90。磁头共移动50+ 10+ 24+ 16+200+ 18+20+1 +16+3+ 32= 390个磁道，平均寻道长度= 390/9 = 43.33.</p>
<p>不太熟悉操作系统整体框架的读者经常混淆磁盘调度算法中的循环扫描算法和页面调度算法中的CLOCK算法，请读者注意区分。</p>
<p>对比以上几种磁盘调度算法，FCFS 算法太过简单，性能较差，仅在请求队列长度接近于1时才较为理想; SSTF算法较为通用和自然; SCAN算法和C-SCAN算法在磁盘负载较大时比较占优势。它们之间的比较见表5.2。</p>
<p><img src="./README.assets/image-20220402155729182.png" alt="image-20220402155729182" loading="lazy"></p>
<p>除减少寻找时间外，减少延迟时间也是提高磁盘传输效率的重要因素。可以对盘面扇区进行交替编号,对磁盘片组中的不同盘面错位命名。假设每个盘面有8个扇区，磁盘片组共8个盘面,则可以采用如图5.22所示的编号。</p>
<p><img src="./README.assets/image-20220402155746785.png" alt="image-20220402155746785" loading="lazy"></p>
<p>磁盘是连续自转设备，磁头读/写一个物理块后，需要经过短暫的处理时间才能开始读/写下一块。假设逻辑记录数据连续存放在磁盘空间中，若在盘面上按扇区交替编号连续存放，则连续读/写多条记录时能减少磁头的延迟时间;同柱面不同盘面的扇区若能错位编号，连续读/写相邻两个盘面的逻辑记录时也能减少磁头延迟时间。</p>
<p>以图5.22为例，在随机扇区访问情况下，定位磁道中的一个扇区平均需要转过4个扇区，这时，延迟时间是传输时间的4倍，这是一种非常低效的方式。理想的情况是不需要定位而直接连续读取扇区，没有延迟时间，这样磁盘数据存取效率可以成倍提高。但由于读取扇区的顺序是不可预测的，所以延迟时间不可避免。图5.22中的编号方式是读取连续编号扇区时的一种方法。</p>
<p>磁盘寻块时间分为三个部分，即寻道时间、延迟时间和传输时间，寻道时间和延迟时间属于“找”的时间，凡是“找”的时间都可以通过一-定的方法削减，但传输时间是磁盘本身性质所决定的，不能通过一定的措施减少。</p>
<h2 id="四、固态硬盘"> 四、固态硬盘</h2>
<h3 id="_4-1-固态硬盘的特性"> 4.1 固态硬盘的特性</h3>
<p>固态硬盘(SSD) 是- -种基于闪存技术的存储器。它与U盘并无本质差别，只是容量更大,存取性能更好。-一个SSD由一个或多个闪存芯片和闪存翻译层组成，如图5.23所示。闪存芯片替代传统旋转磁盘中的机械驱动器，而闪存翻译层将来自CPU的逻辑块读写请求翻译成对底层物理设备的读写控制信号，因此闪存翻译层相当于扮演了磁盘控制器的角色。</p>
<p><img src="./README.assets/image-20220402155850442.png" alt="image-20220402155850442" loading="lazy"></p>
<p>在图5.23中，一个闪存由B块组成，每块由P页组成。通常，页的大小是512B<sub>4KB，每块由32</sub>128页组成，块的大小为16KB~512KB。 数据是以页为单位读写的。只有在-页所属的块整个被擦除后，才能写这一页。不过，-旦擦除-块，块中的每页就都可以直接再写-一次。某块进行若千次重复写后，就会磨损坏，不能再使用。</p>
<p>随机写很慢，有两个原因。首先，擦除块比较慢，通常比访问页高一个数量级。其次，如果写操作试图修改包含已有数据的页P，那么这个块中所有含有用数据的页都必须被复制到--个新(擦除过的)块中，然后才能进行对页P; 的写操作。</p>
<p>比起传统磁盘，SSD有很多优点，它由半导体存储器构成，没有移动的部件，因而随机访问时间比机械磁盘要快很多，也没有任何机械噪声和震动，能耗更低、抗震性好、安全性高等。</p>
<p>随着技术的不断发展，价格也不断下降，SSD会有望逐步取代传统机械硬盘。</p>
<h3 id="_4-2-磨损均衡-wear-leveling"> 4.2 磨损均衡(Wear Leveling)</h3>
<p>固态硬盘也有缺点，闪存的擦写寿命是有限的，一般是几百次到几千次。如果直接用普通闪存组装SSD,那么实际的寿命表现可能非常令人失望一一读写 数据时会集中在SSD的一部分闪存，这部分闪存的寿命会损耗得特别快。一旦这部分闪存损坏，整块SSD也就损坏了。这种磨损不均衡的情况，可能会导致一块256GB的SSD，只因数兆空间的闪存损坏而整块损坏。</p>
<p>为了弥补SSD的寿命缺陷，引入了磨损均衡。SSD磨损均衡技术大致分为两种:</p>
<ol>
<li>动态磨损均衡。写入数据时，自动选择较新的闪存块。老的闪存块先歇- - 歇。</li>
<li>静态磨损均衡。这种技术更为先进，就算没有数据写入，SSD也会监测并自动进行数据分配，让老的闪存块承担无须写数据的存储任务，同时让较新的闪存块腾出空间，平常的读写操作在较新的闪存块中进行。如此一来，各闪存块的寿命损耗就都差不多。</li>
</ol>
<p>有了这种算法加持，SSD 的寿命就比较可观了。例如，对于一个256GB的SSD,如果闪存的擦写寿命是500次，那么就需要写入125TB数据，才寿终正寝。就算每天写入10GB数据，也要三十多年才能将闪存磨损坏，更何况很少有人每天往SSD中写入10GB数据。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-02T08:00:10.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">算法</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/algorithms/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/algorithms/"/>
    <updated>2022-03-19T03:07:34.000Z</updated>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T03:07:34.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">排序算法</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/algorithms/sort/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/algorithms/sort/"/>
    <updated>2022-03-19T03:07:34.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/weixin_44531966/article/details/116464294" target="_blank" rel="noopener noreferrer">java实现10种排序算法</a></p>
</li>
<li>
<p><a href="https://blog.csdn.net/alzzw/article/details/98100378" target="_blank" rel="noopener noreferrer">十大经典排序算法的复杂度分析</a></p>
</li>
<li>
<p><a href="https://www.jianshu.com/p/d730ae586cf3" target="_blank" rel="noopener noreferrer">排序：希尔排序</a></p>
</li>
<li>
<p><a href="https://www.cnblogs.com/aishangJava/p/10092341.html" target="_blank" rel="noopener noreferrer">10大经典排序算法动图演示，看这篇就够了！</a></p>
</li>
<li></li>
</ul>
</div>
<h2 id="一、冒泡排序"> 一、冒泡排序</h2>
<p>时间复杂度：O(n<sup>2</sup>)</p>
<p>空间复杂度：O(1)</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> arr<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> len <span>-</span> <span>1</span><span>;</span> j <span>></span> i<span>;</span> <span>--</span>j<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>)</span> <span>{</span>
                    <span>int</span> tmp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                    arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j <span>-</span> <span>1</span><span>]</span><span>;</span>
                    arr<span>[</span>j <span>-</span> <span>1</span><span>]</span> <span>=</span> tmp<span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="二、选择排序"> 二、选择排序</h2>
<p>时间复杂度：O(n<sup>2</sup>)</p>
<p>空间复杂度：O(1)</p>
<p><img src="./README.assets/20210506221249385.gif" alt="在这里插入图片描述" loading="lazy"></p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> arr<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>int</span> idx <span>=</span> i<span>;</span>
            <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>+</span> <span>1</span><span>;</span> j <span>&lt;</span> len<span>;</span> <span>++</span>j<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>&lt;</span> arr<span>[</span>idx<span>]</span><span>)</span> idx <span>=</span> j<span>;</span>
            <span>}</span>
            <span>int</span> tmp <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
            arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>idx<span>]</span><span>;</span>
            arr<span>[</span>idx<span>]</span> <span>=</span> tmp<span>;</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="三、插入排序"> 三、插入排序</h2>
<p>时间复杂度：O(n<sup>2</sup>)</p>
<p>空间复杂度：O(1)</p>
<p><img src="./README.assets/2021050622130485.gif" alt="在这里插入图片描述" loading="lazy"></p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> arr<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>int</span> val <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
            <span>int</span> idx <span>=</span> i <span>-</span> <span>1</span><span>;</span>

            <span>while</span> <span>(</span>idx <span>>=</span> <span>0</span> <span>&amp;&amp;</span> arr<span>[</span>idx<span>]</span> <span>></span> val<span>)</span> <span>{</span>
                arr<span>[</span>idx <span>+</span> <span>1</span><span>]</span> <span>=</span> arr<span>[</span>idx<span>]</span><span>;</span>
                idx<span>--</span><span>;</span>
            <span>}</span>
            arr<span>[</span>idx <span>+</span> <span>1</span><span>]</span> <span>=</span> val<span>;</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="四、希尔排序"> 四、希尔排序</h2>
<p>时间复杂度：O(nlog<sub>2</sub>n)</p>
<p>空间复杂度：O(1)</p>
<p>希尔排序是将待排序的数组元素 按下标的一定增量分组 ，分成多个子序列，然后对各个子序列进行直接插入排序算法排序；然后依次缩减增量再进行排序，直到增量为1时，进行最后一次直接插入排序，排序结束。</p>
<p><img src="./README.assets/640.gif" alt="img" loading="lazy"></p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>int</span> len <span>=</span> arr<span>.</span>length<span>;</span>
        <span>for</span> <span>(</span><span>int</span> step <span>=</span> len <span>/</span> <span>2</span><span>;</span> step <span>></span> <span>0</span><span>;</span> step <span>/=</span> <span>2</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> step<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> j <span>=</span> i <span>-</span> step<span>;</span> j <span>>=</span> <span>0</span><span>;</span> j <span>-=</span> step<span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>arr<span>[</span>j<span>]</span> <span>></span> arr<span>[</span>j <span>+</span> step<span>]</span><span>)</span> <span>{</span>
                        <span>int</span> tmp <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                        arr<span>[</span>j<span>]</span> <span>=</span> arr<span>[</span>j <span>+</span> step<span>]</span><span>;</span>
                        arr<span>[</span>j <span>+</span> step<span>]</span> <span>=</span> tmp<span>;</span>
                    <span>}</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><h2 id="五、快速排序"> 五、快速排序</h2>
<p>时间复杂度：O(nlog<sub>2</sub>n)</p>
<p>空间复杂度：O(logn)</p>
<p>排序算法的思想非常简单，在待排序的数列中，我们首先要找一个数字作为基准数（这只是个专用名词）。为了方便，我们一般选择第 1 个数字作为基准数（其实选择第几个并没有关系）。接下来我们需要把这个待排序的数列中小于基准数的元素移动到待排序的数列的左边，把大于基准数的元素移动到待排序的数列的右边。这时，左右两个分区的元素就相对有序了；接着把两个分区的元素分别按照上面两种方法继续对每个分区找出基准数，然后移动，直到各个分区只有一个数时为止。</p>
<p><img src="./README.assets/bee5aef6950ac9dd5619b15a4f6daff9.gif" alt="bee5aef6950ac9dd5619b15a4f6daff9.gif" loading="lazy"></p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> l<span>,</span> <span>int</span> r<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l <span>></span> r<span>)</span> <span>return</span><span>;</span>

        <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> r<span>;</span>
        <span>int</span> tmp <span>=</span> arr<span>[</span>l<span>]</span><span>;</span>
        <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
            <span>while</span> <span>(</span>tmp <span>&lt;=</span> arr<span>[</span>j<span>]</span> <span>&amp;&amp;</span> i <span>&lt;</span> j<span>)</span> <span>--</span>j<span>;</span>
            <span>while</span> <span>(</span>tmp <span>>=</span> arr<span>[</span>i<span>]</span> <span>&amp;&amp;</span> i <span>&lt;</span> j<span>)</span> <span>++</span>i<span>;</span>
            <span>if</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
                <span>int</span> tem <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
                arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                arr<span>[</span>j<span>]</span> <span>=</span> tem<span>;</span>
            <span>}</span>
        <span>}</span>
        arr<span>[</span>l<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        arr<span>[</span>i<span>]</span> <span>=</span> tmp<span>;</span>

        <span>sort</span><span>(</span>arr<span>,</span> l<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>sort</span><span>(</span>arr<span>,</span> j <span>+</span> <span>1</span><span>,</span> r<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>sort</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> arr<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id="六、归并排序"> 六、归并排序</h2>
<p>时间复杂度：O(nlog<sub>2</sub>n)</p>
<p>空间复杂度：O(n)</p>
<p><img src="./README.assets/v2-2958d4f3d9dd9156f1b5dca6788fe8a7_720w.jpg" alt="img" loading="lazy"></p>
<p><img src="./README.assets/202105062211506.gif" alt="在这里插入图片描述" loading="lazy"></p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>merge</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> l1<span>,</span> <span>int</span> r1<span>,</span> <span>int</span> l2<span>,</span> <span>int</span> r2<span>)</span> <span>{</span>
        <span>int</span> <span>L</span> <span>=</span> l1<span>,</span> <span>R</span> <span>=</span> r2<span>;</span>
        <span>int</span><span>[</span><span>]</span> tar <span>=</span> <span>new</span> <span>int</span><span>[</span>arr<span>.</span>length<span>]</span><span>;</span>

        <span>int</span> idx <span>=</span> l1<span>;</span>
        <span>while</span> <span>(</span>l1 <span>&lt;=</span> r1 <span>&amp;&amp;</span> l2 <span>&lt;=</span> r2<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>arr<span>[</span>l1<span>]</span> <span>&lt;</span> arr<span>[</span>l2<span>]</span><span>)</span> <span>{</span>
                tar<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>l1<span>++</span><span>]</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                tar<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>l2<span>++</span><span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>while</span> <span>(</span>l1 <span>&lt;=</span> r1<span>)</span> <span>{</span>
            tar<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>l1<span>++</span><span>]</span><span>;</span>
        <span>}</span>
        <span>while</span> <span>(</span>l2 <span>&lt;=</span> r2<span>)</span> <span>{</span>
            tar<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>l2<span>++</span><span>]</span><span>;</span>
        <span>}</span>

        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>tar<span>,</span> <span>L</span><span>,</span> arr<span>,</span> <span>L</span><span>,</span> <span>R</span> <span>-</span> <span>L</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> l<span>,</span> <span>int</span> r<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l <span>&lt;</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>sort</span><span>(</span>arr<span>,</span> l<span>,</span> mid<span>)</span><span>;</span>
            <span>sort</span><span>(</span>arr<span>,</span> mid <span>+</span> <span>1</span><span>,</span> r<span>)</span><span>;</span>
            <span>merge</span><span>(</span>arr<span>,</span> l<span>,</span> mid<span>,</span> mid <span>+</span> <span>1</span><span>,</span> r<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>sort</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> arr<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据结构和算法"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T03:07:34.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">平衡搜索树</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/data-structures/avl/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/data-structures/avl/"/>
    <updated>2022-03-28T13:14:01.000Z</updated>
    <content type="html"><![CDATA[<p>ads</p>
<p>看懂思路之后自己手敲的，还没有拿数据严格校验过。</p>
<p>大体操作和 <a href="./../bst/">二叉搜索树相同</a>，下面只给出不同的地方的代码</p>
<h2 id="插入节点"> 插入节点</h2>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>public</span> <span>boolean</span> <span>insert</span><span>(</span><span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> pre<span>,</span> <span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
    <span>boolean</span> res<span>;</span>

    <span>int</span> cmp <span>=</span> value<span>.</span><span>compareTo</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span> <span>{</span>
        res <span>=</span> <span>false</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
            node<span>.</span>left <span>=</span> <span>new</span> <span>AVLNode</span><span>(</span>value<span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
            res <span>=</span> <span>true</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            res <span>=</span> <span>insert</span><span>(</span>node<span>,</span> node<span>.</span>left<span>,</span> value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            node<span>.</span>right <span>=</span> <span>new</span> <span>AVLNode</span><span>(</span>value<span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
            res <span>=</span> <span>true</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            res <span>=</span> <span>insert</span><span>(</span>node<span>,</span> node<span>.</span>right<span>,</span> value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>rebalance</span><span>(</span>pre<span>,</span> node<span>)</span><span>;</span>

    <span>return</span> res<span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="删除节点"> 删除节点</h2>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>public</span> <span>boolean</span> <span>delete</span><span>(</span><span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> pre<span>,</span> <span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>boolean</span> res<span>;</span>

    <span>int</span> cmp <span>=</span> value<span>.</span><span>compareTo</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>delete</span><span>(</span>pre<span>,</span> node<span>)</span><span>;</span>
        res <span>=</span> <span>true</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        res <span>=</span> <span>delete</span><span>(</span>node<span>,</span> node<span>.</span>left<span>,</span> value<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        res <span>=</span> <span>delete</span><span>(</span>node<span>,</span> node<span>.</span>right<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>

    <span>if</span> <span>(</span>pre <span>==</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>pre<span>.</span>left <span>==</span> node<span>)</span> <span>{</span>
        pre<span>.</span>left <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        pre<span>.</span>right <span>=</span> node<span>;</span>
    <span>}</span>

    <span>rebalance</span><span>(</span>pre<span>,</span> node<span>)</span><span>;</span>

    <span>return</span> res<span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code><span>public</span> <span>void</span> <span>delete</span><span>(</span><span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> pre<span>,</span> <span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>AVLNode</span> ori <span>=</span> node<span>;</span>
    <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 右子树为空，直接接上左子树</span>
        node <span>=</span> node<span>.</span>left<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 左子树为空，直接接上右子树</span>
        node <span>=</span> node<span>.</span>right<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// 都不为空</span>
        <span>// 找到左子树中，最大的节点，并替换到删除节点位置处</span>
        <span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> parent <span>=</span> node<span>;</span>
        <span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> leftMaxValueNode <span>=</span> node<span>.</span>left<span>;</span>
        <span>while</span> <span>(</span>leftMaxValueNode<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            parent <span>=</span> leftMaxValueNode<span>;</span>
            leftMaxValueNode <span>=</span> leftMaxValueNode<span>.</span>right<span>;</span>
        <span>}</span>

        node<span>.</span>value <span>=</span> leftMaxValueNode<span>.</span>value<span>;</span>
        <span>if</span> <span>(</span>parent <span>==</span> node<span>)</span> <span>{</span>
            <span>// 如果替换节点，就是删除节点的左节点。将替换节点的左子树，替换删除节点的左子树</span>
            parent<span>.</span>left <span>=</span> leftMaxValueNode<span>.</span>left<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 否则，将替换节点的左子树，连接到其父亲节点的右子树上</span>
            parent<span>.</span>right <span>=</span> leftMaxValueNode<span>.</span>left<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>if</span> <span>(</span>pre <span>==</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>ori <span>==</span> pre<span>.</span>left<span>)</span> <span>{</span>
        pre<span>.</span>left <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        pre<span>.</span>right <span>=</span> node<span>;</span>
    <span>}</span>

    <span>// 平衡左右子树，再平衡自己</span>
    <span>rebalance</span><span>(</span>node<span>,</span> node<span>.</span>left<span>)</span><span>;</span>
    <span>rebalance</span><span>(</span>node<span>,</span> node<span>.</span>right<span>)</span><span>;</span>
    <span>rebalance</span><span>(</span>pre<span>,</span> node<span>)</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="保持平衡"> 保持平衡</h2>
<div><pre><code><span>public</span> <span>void</span> <span>rebalance</span><span>(</span><span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> pre<span>,</span> <span>AVLNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span><span>;</span>

    node<span>.</span><span>updateHeight</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> balance <span>=</span> node<span>.</span><span>balanceFactor</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>balance <span>>=</span> <span>-</span><span>1</span> <span>&amp;&amp;</span> balance <span>&lt;=</span> <span>1</span><span>)</span> <span>return</span><span>;</span>

    <span>AVLNode</span> link<span>;</span>
    <span>if</span> <span>(</span>balance <span>==</span> <span>-</span><span>2</span><span>)</span> <span>{</span>
        <span>AVLNode</span> right <span>=</span> node<span>.</span>right<span>;</span>
        node<span>.</span>right <span>=</span> right<span>.</span>left<span>;</span>
        right<span>.</span>left <span>=</span> node<span>;</span>
        link <span>=</span> right<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>AVLNode</span> left <span>=</span> node<span>.</span>left<span>;</span>
        node<span>.</span>left <span>=</span> left<span>.</span>right<span>;</span>
        left<span>.</span>right <span>=</span> node<span>;</span>
        link <span>=</span> left<span>;</span>
    <span>}</span>

    node<span>.</span><span>updateHeight</span><span>(</span><span>)</span><span>;</span>
    link<span>.</span><span>updateHeight</span><span>(</span><span>)</span><span>;</span>

    <span>if</span> <span>(</span>pre <span>==</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> link<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>pre<span>.</span>left <span>==</span> node<span>)</span> <span>{</span>
        pre<span>.</span>left <span>=</span> link<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        pre<span>.</span>right <span>=</span> link<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-28T13:14:01.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">数据结构</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/data-structures/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/data-structures/"/>
    <updated>2022-03-19T03:07:34.000Z</updated>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T03:07:34.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">框架技术概览</title>
    <id>https://notes.lllllan.cn/framework/</id>
    <link href="https://notes.lllllan.cn/framework/"/>
    <updated>2022-04-17T06:53:24.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.jianshu.com/p/f1770b9dce27" target="_blank" rel="noopener noreferrer">AOP 面向切面编程 - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/q982151756/article/details/80513340" target="_blank" rel="noopener noreferrer">细说Spring——AOP详解（AOP概览）_Jivan2233的博客-CSDN博客_aop</a></li>
<li><a href="https://www.jianshu.com/p/994027425b44" target="_blank" rel="noopener noreferrer">Spring(4)——面向切面编程（AOP模块） - 简书 (jianshu.com)</a></li>
</ul>
</div>
<h2 id="aop"> AOP</h2>
<p><a href="https://blog.csdn.net/q982151756/article/details/80513340" target="_blank" rel="noopener noreferrer">细说Spring——AOP详解（AOP概览）_Jivan2233的博客-CSDN博客_aop</a></p>
<p>AOP全称 <code>Aspect Oriented Programming</code> 意为面向切面编程，也叫做面向方法编程， <mark>是通过预编译方式和运行期动态代理的方式实现不修改源代码的情况下给程序动态统一添加功能的技术</mark> 。</p>
<p>AOP技术利用一种称为【横切】的技术，剖解开封装对象的内部，将影响多个类的公共行为封装到一个可重用的模块中，并将其命名为 <code>Aspect</code> 切面。 <mark>利用AOP可以对业务逻辑各个部分进行隔离，从而使业务逻辑各部分之间的耦合度降低，提高程序的可重用性，同时提高开发效率。</mark></p>
<ul>
<li>连接点，join point。连接点是程序过程中 <strong>能够</strong> 插入切面的点。</li>
<li>切入点，point cut。真正插入切面连接点。</li>
<li>通知，advice。在切入点中具体要做的事情。</li>
<li>切面，aspect。切入点 + 通知，在什么时候、什么地方做什么事情。</li>
<li>织入，weaving。把切面切入到对象，并创建出代理对象的过程。</li>
</ul>
<blockquote>
<p>好奇怪的描述，不是特别明确。</p>
</blockquote>
<p><img src="./README.assets/image-20220417145300699.png" alt="image-20220417145300699" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T03:07:34.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">不稳定的快速排序</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/algorithms/sort/unstable-quick-sort/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/algorithms/sort/unstable-quick-sort/"/>
    <updated>2022-04-03T12:58:26.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://blog.csdn.net/qianqin_2014/article/details/51207165" target="_blank" rel="noopener noreferrer">经典排序算法----快速排序算法（不稳定）</a></li>
</ul>
</div>
<p>首先，这里的【不稳定】不是指快速排序排序速度的不稳定。不同的算法应对不同的情况都可能出现最坏的时间复杂度。</p>
<p>排序算法的稳定性，通俗地讲就是能保证排序前2个相等的数其在序列的前后位置顺序和排序后它们两个的前后位置顺序相同。在简单形式化一下，如果Ai = Aj，Ai原来在位置前，排序后Ai还是要在Aj位置前。</p>
<p>快速排序有两个方向，左边的 i 下标一直往右走，当 <code>a[i] &lt;= a[center_index]</code>，其中 center_index 是中枢元素的数组下标，一般取为数组第 0 个元素。而右边的 j 下标一直往左走，当 <code>a[j] &gt; a[center_index]</code>。如果i和j都走不动了，<code>i &lt;= j</code>，交换 a[i] 和 a[j] ，重复上面的过程，直到 i &gt; j。 交换 a[j] 和 a[center_index]，完成一趟快速排序。在中枢元素和 a[j] 交换的时候，很有可能把前面的元素的稳定性打乱，比如序列为 <code>5 3 3 4 3 8 9 10 11</code>，现在中枢元素 5 和 3（第5个元素，下标从1开始计）交换就会把元素3的稳定性打乱，所以快速排序是一个不稳定的排序算法，不稳定发生在中枢元素和a[j] 交换的时刻。</p>
<h2 id="一般写法"> 一般写法</h2>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> l<span>,</span> <span>int</span> r<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l <span>>=</span> r<span>)</span> <span>return</span><span>;</span>

        <span>int</span> i <span>=</span> l<span>,</span> j <span>=</span> r<span>;</span>
        <span>int</span> tmp <span>=</span> arr<span>[</span>l<span>]</span><span>;</span>
        <span>while</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
            <span>while</span> <span>(</span>tmp <span>&lt;=</span> arr<span>[</span>j<span>]</span> <span>&amp;&amp;</span> i <span>&lt;</span> j<span>)</span> <span>--</span>j<span>;</span>
            <span>while</span> <span>(</span>tmp <span>>=</span> arr<span>[</span>i<span>]</span> <span>&amp;&amp;</span> i <span>&lt;</span> j<span>)</span> <span>++</span>i<span>;</span>
            <span>if</span> <span>(</span>i <span>&lt;</span> j<span>)</span> <span>{</span>
                <span>int</span> tem <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
                arr<span>[</span>i<span>]</span> <span>=</span> arr<span>[</span>j<span>]</span><span>;</span>
                arr<span>[</span>j<span>]</span> <span>=</span> tem<span>;</span>
            <span>}</span>
        <span>}</span>
        arr<span>[</span>l<span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        arr<span>[</span>i<span>]</span> <span>=</span> tmp<span>;</span>

        <span>sort</span><span>(</span>arr<span>,</span> l<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>sort</span><span>(</span>arr<span>,</span> j <span>+</span> <span>1</span><span>,</span> r<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>

        <span>sort</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> arr<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><h2 id="解决不稳定性"> 解决不稳定性</h2>
<p><img src="./README.assets/image-20220403205257815.png" alt="image-20220403205257815" loading="lazy"></p>
<p>为了维持原来的相对顺序，需要借助一个辅助数来来存放，并且还牺牲了很大的时间复杂度。</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Arrays</span></span><span>;</span>

<span>public</span> <span>class</span> <span>Solution</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> tmp<span>;</span>

    <span>public</span> <span>static</span> <span>void</span> <span>sort</span><span>(</span><span>int</span><span>[</span><span>]</span> arr<span>,</span> <span>int</span> l<span>,</span> <span>int</span> r<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>l <span>>=</span> r<span>)</span> <span>return</span><span>;</span>

        <span>int</span> idx <span>=</span> l<span>,</span> i <span>=</span> l<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>;</span> i <span>&lt;=</span> r<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>&lt;</span> arr<span>[</span>l<span>]</span><span>)</span> tmp<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>;</span> i <span>&lt;=</span> r<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>==</span> arr<span>[</span>l<span>]</span><span>)</span> tmp<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>;</span> i <span>&lt;=</span> r<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>arr<span>[</span>i<span>]</span> <span>></span> arr<span>[</span>l<span>]</span><span>)</span> tmp<span>[</span>idx<span>++</span><span>]</span> <span>=</span> arr<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>;</span> i <span>&lt;=</span> r<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            arr<span>[</span>i<span>]</span> <span>=</span> tmp<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>

        <span>sort</span><span>(</span>arr<span>,</span> l<span>,</span> j <span>-</span> <span>1</span><span>)</span><span>;</span>
        <span>sort</span><span>(</span>arr<span>,</span> j <span>+</span> <span>1</span><span>,</span> r<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span><span>3</span><span>,</span> <span>44</span><span>,</span> <span>38</span><span>,</span> <span>5</span><span>,</span> <span>47</span><span>,</span> <span>15</span><span>,</span> <span>36</span><span>,</span> <span>26</span><span>,</span> <span>27</span><span>,</span> <span>2</span><span>,</span> <span>46</span><span>,</span> <span>4</span><span>,</span> <span>19</span><span>,</span> <span>50</span><span>,</span> <span>48</span><span>}</span><span>;</span>
        tmp <span>=</span> <span>new</span> <span>int</span><span>[</span>arr<span>.</span>length<span>]</span><span>;</span>

        <span>sort</span><span>(</span>arr<span>,</span> <span>0</span><span>,</span> arr<span>.</span>length <span>-</span> <span>1</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>Arrays</span><span>.</span><span>toString</span><span>(</span>arr<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据结构和算法"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-03T12:58:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">二叉搜索树 代码实现</title>
    <id>https://notes.lllllan.cn/ds-and-algorithms/data-structures/bst/</id>
    <link href="https://notes.lllllan.cn/ds-and-algorithms/data-structures/bst/"/>
    <updated>2022-03-28T08:24:22.000Z</updated>
    <content type="html"><![CDATA[<p>偷懒就不写思路了，贴个代码和一些简单注释</p>
<h2 id="创建类"> 创建类</h2>
<div><pre><code><span>public</span> <span>class</span> <span>BSTree</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>{</span>

    <span>private</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> root<span>;</span>

    <span>public</span> <span>BSTree</span><span>(</span><span>)</span> <span>{</span>
    <span>}</span>
    
    <span>public</span> <span>class</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>T</span><span>></span><span>></span></span> <span>{</span>
        <span>T</span> value<span>;</span>
        <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> left<span>;</span>
        <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> right<span>;</span>

        <span>public</span> <span>BSTNode</span><span>(</span><span>T</span> value<span>,</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> left<span>,</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> right<span>)</span> <span>{</span>
            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
            <span>this</span><span>.</span>left <span>=</span> left<span>;</span>
            <span>this</span><span>.</span>right <span>=</span> right<span>;</span>
        <span>}</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h2 id="遍历方法"> 遍历方法</h2>
<h3 id="前序遍历"> 前序遍历</h3>
<div><pre><code><span>/**
 * 打印前序遍历
 */</span>
<span>public</span> <span>void</span> <span>printPreOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>"前序遍历：["</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        str<span>.</span><span>append</span><span>(</span><span>preOrder</span><span>(</span>root<span>)</span><span>)</span><span>;</span>
        str<span>.</span><span>deleteCharAt</span><span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    str<span>.</span><span>append</span><span>(</span><span>"]"</span><span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>StringBuilder</span> <span>preOrder</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>""</span><span>)</span><span>;</span>

    <span>StringBuilder</span> res <span>=</span> <span>preOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>;</span>
    res<span>.</span><span>append</span><span>(</span>node<span>.</span>value<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>.</span><span>append</span><span>(</span><span>","</span><span>)</span><span>;</span>
    res<span>.</span><span>append</span><span>(</span><span>preOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>)</span><span>;</span>

    <span>return</span> res<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="中序遍历"> 中序遍历</h3>
<div><pre><code><span>/**
 * 打印中序遍历
 */</span>
<span>public</span> <span>void</span> <span>printInOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>"中序遍历：["</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        str<span>.</span><span>append</span><span>(</span><span>inOrder</span><span>(</span>root<span>)</span><span>)</span><span>;</span>
        str<span>.</span><span>deleteCharAt</span><span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    str<span>.</span><span>append</span><span>(</span><span>"]"</span><span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>StringBuilder</span> <span>inOrder</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>""</span><span>)</span><span>;</span>

    <span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span>node<span>.</span>value<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>.</span><span>append</span><span>(</span><span>","</span><span>)</span><span>;</span>
    res<span>.</span><span>append</span><span>(</span><span>inOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>)</span><span>;</span>
    res<span>.</span><span>append</span><span>(</span><span>inOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>)</span><span>;</span>

    <span>return</span> res<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h3 id="后序遍历"> 后序遍历</h3>
<div><pre><code><span>/**
 * 打印后序遍历
 */</span>
<span>public</span> <span>void</span> <span>printPostOrder</span><span>(</span><span>)</span> <span>{</span>
    <span>StringBuilder</span> str <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>"后序遍历：["</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>root <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        str<span>.</span><span>append</span><span>(</span><span>postOrder</span><span>(</span>root<span>)</span><span>)</span><span>;</span>
        str<span>.</span><span>deleteCharAt</span><span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>
    str<span>.</span><span>append</span><span>(</span><span>"]"</span><span>)</span><span>;</span>

    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>StringBuilder</span> <span>postOrder</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>""</span><span>)</span><span>;</span>

    <span>StringBuilder</span> res <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>postOrder</span><span>(</span>node<span>.</span>left<span>)</span><span>)</span><span>;</span>
    res<span>.</span><span>append</span><span>(</span><span>postOrder</span><span>(</span>node<span>.</span>right<span>)</span><span>)</span><span>;</span>
    res<span>.</span><span>append</span><span>(</span>node<span>.</span>value<span>.</span><span>toString</span><span>(</span><span>)</span><span>)</span><span>.</span><span>append</span><span>(</span><span>","</span><span>)</span><span>;</span>

    <span>return</span> res<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><h2 id="查找方法"> 查找方法</h2>
<h3 id="查找特定值"> 查找特定值</h3>
<div><pre><code><span>/**
 * 查找
 *
 * @param value
 * @return
 */</span>
<span>public</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>search</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>search</span><span>(</span>root<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>search</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span> <span>||</span> value <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>
    <span>int</span> cmp <span>=</span> value<span>.</span><span>compareTo</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>node<span>.</span>left<span>,</span> value<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>search</span><span>(</span>node<span>.</span>right<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h3 id="查找最小值"> 查找最小值</h3>
<div><pre><code><span>/**
 * 找最小值
 *
 * @return
 */</span>
<span>public</span> <span>T</span> <span>searchMinValue</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>

    <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node <span>=</span> <span>searchMinValue</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> node <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> node<span>.</span>value<span>;</span>
<span>}</span>

<span>public</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>searchMinValue</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>node<span>.</span>left <span>!=</span> <span>null</span><span>)</span> node <span>=</span> node<span>.</span>left<span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="查找最大值"> 查找最大值</h3>
<div><pre><code><span>/**
 * 找最大值
 *
 * @return
 */</span>
<span>public</span> <span>T</span> <span>searchMaxValue</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>null</span><span>;</span>

    <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node <span>=</span> <span>searchMaxValue</span><span>(</span>root<span>)</span><span>;</span>
    <span>return</span> node <span>==</span> <span>null</span> <span>?</span> <span>null</span> <span>:</span> node<span>.</span>value<span>;</span>
<span>}</span>

<span>public</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> <span>searchMaxValue</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>while</span> <span>(</span>node<span>.</span>right <span>!=</span> <span>null</span><span>)</span> node <span>=</span> node<span>.</span>right<span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="插入节点"> 插入节点</h2>
<div><pre><code><span>/**
 * 插入节点 （去重）
 *
 * @param value
 * @return 是否插入成功
 */</span>
<span>public</span> <span>boolean</span> <span>insert</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>if</span> <span>(</span>root <span>==</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> <span>new</span> <span>BSTNode</span><span><span>&lt;</span><span>></span></span><span>(</span>value<span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>return</span> <span>insert</span><span>(</span>root<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>boolean</span> <span>insert</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
    <span>int</span> cmp <span>=</span> value<span>.</span><span>compareTo</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
            node<span>.</span>left <span>=</span> <span>new</span> <span>BSTNode</span><span>(</span>value<span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> <span>insert</span><span>(</span>node<span>.</span>left<span>,</span> value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
            node<span>.</span>right <span>=</span> <span>new</span> <span>BSTNode</span><span>(</span>value<span>,</span> <span>null</span><span>,</span> <span>null</span><span>)</span><span>;</span>
            <span>return</span> <span>true</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>return</span> <span>insert</span><span>(</span>node<span>.</span>right<span>,</span> value<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><h2 id="删除节点"> 删除节点</h2>
<div><pre><code><span>/**
 * 删除节点
 *
 * @param value
 * @return 是否删除成功
 */</span>
<span>public</span> <span>boolean</span> <span>delete</span><span>(</span><span>T</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>value <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>
    <span>return</span> <span>delete</span><span>(</span><span>null</span><span>,</span> root<span>,</span> value<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>boolean</span> <span>delete</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> pre<span>,</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>,</span> <span>T</span> value<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node <span>==</span> <span>null</span><span>)</span> <span>return</span> <span>false</span><span>;</span>

    <span>int</span> cmp <span>=</span> value<span>.</span><span>compareTo</span><span>(</span>node<span>.</span>value<span>)</span><span>;</span>
    <span>if</span> <span>(</span>cmp <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>delete</span><span>(</span>pre<span>,</span> node<span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>cmp <span>&lt;</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> <span>delete</span><span>(</span>node<span>,</span> node<span>.</span>left<span>,</span> value<span>)</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>delete</span><span>(</span>node<span>,</span> node<span>.</span>right<span>,</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>void</span> <span>delete</span><span>(</span><span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> pre<span>,</span> <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> node<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>node<span>.</span>right <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 右子树为空，直接接上左子树</span>
        node <span>=</span> node<span>.</span>left<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>node<span>.</span>left <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>// 左子树为空，直接接上右子树</span>
        node <span>=</span> node<span>.</span>right<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// 都不为空</span>
        <span>// 找到左子树中，最大的节点，并替换到删除节点位置处</span>
        <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> parent <span>=</span> node<span>;</span>
        <span>BSTNode</span><span><span>&lt;</span><span>T</span><span>></span></span> leftMaxValueNode <span>=</span> node<span>.</span>left<span>;</span>
        <span>while</span> <span>(</span>leftMaxValueNode<span>.</span>right <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            parent <span>=</span> leftMaxValueNode<span>;</span>
            leftMaxValueNode <span>=</span> leftMaxValueNode<span>.</span>right<span>;</span>
        <span>}</span>

        node<span>.</span>value <span>=</span> leftMaxValueNode<span>.</span>value<span>;</span>
        <span>if</span> <span>(</span>parent <span>==</span> node<span>)</span> <span>{</span>
            <span>// 如果替换节点，就是删除节点的左节点。将替换节点的左子树，替换删除节点的左子树</span>
            parent<span>.</span>left <span>=</span> leftMaxValueNode<span>.</span>left<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 否则，将替换节点的左子树，连接到其父亲节点的右子树上</span>
            parent<span>.</span>right <span>=</span> leftMaxValueNode<span>.</span>left<span>;</span>
        <span>}</span>
    <span>}</span>
        
    <span>if</span> <span>(</span>pre <span>==</span> <span>null</span><span>)</span> <span>{</span>
        root <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>ori <span>==</span> pre<span>.</span>left<span>)</span> <span>{</span>
        pre<span>.</span>left <span>=</span> node<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        pre<span>.</span>right <span>=</span> node<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-28T08:03:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 基本概念与常识</title>
    <id>https://notes.lllllan.cn/java/basic/1-concept/</id>
    <link href="https://notes.lllllan.cn/java/basic/1-concept/"/>
    <updated>2022-04-11T15:41:50.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://blog.csdn.net/qq_23191031/article/details/81677057" target="_blank" rel="noopener noreferrer">java是解释执行吗</a></li>
<li><a href="https://blog.csdn.net/ancientear/article/details/79483592" target="_blank" rel="noopener noreferrer">浅谈JDK、JRE、JVM区别与联系</a></li>
<li><a href="https://blog.csdn.net/a4171175/article/details/90735888" target="_blank" rel="noopener noreferrer">什么是字节码？采用字节码的最大好处是什么？</a></li>
</ul>
</div>
<h2 id="一、-java语言的特点"> 一、 Java语言的特点</h2>
<ol>
<li><strong>简单性</strong>：丢弃了C++中少用、难懂的特性，例如操作符重载、多继承、指针、内存管理等，不用手动管理对象的生命周期。</li>
<li><strong>面向对象</strong>：封装，继承，多态</li>
<li><strong>平台无关性</strong>：一次编译到处运行</li>
<li><strong>解释执行</strong>：编译成字节码文件，java解释器对字节码进行解释执行</li>
<li>多线程</li>
<li>分布式（强大、易于使用的联网能力）</li>
<li>高性能（相对其他高级语言，<a href="https://zhuanlan.zhihu.com/p/361250220" target="_blank" rel="noopener noreferrer">JIT</a>的发展）</li>
<li>健壮性（强类型机制、异常处理、垃圾回收机制）</li>
<li>安全性（安全机制以防止恶意代码的攻击）</li>
<li></li>
</ol>
<h3 id="_1-1-编译与解释并存"> 1.1 编译与解释并存</h3>
<p>由 Java 编写的程序需要先经过 <mark>编译</mark> 步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来 <mark>解释执行</mark></p>
<h3 id="_1-2-跨平台"> 1.2 跨平台</h3>
<p>java 代码被编译成字节码文件，字节码是平台无关的，是面向 JVM 编写的。</p>
<p>JVM 的接口是向下与硬件有关的，在不同平台上有不同的指令系统，才能支持字节码文件在不同的操作系统下解释执行，从而实现 Java 的跨平台性也就是可移植性</p>
<h2 id="二、jvm-jdk-jre"> 二、JVM &amp; JDK &amp; JRE</h2>
<ol>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li>
<li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 <u>Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</u>。但是，它不能用于创建新程序。</li>
<li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。</li>
</ol>
<div><p>JDK > JRE > JVM</p>
<p><a href="https://blog.csdn.net/ancientear/article/details/79483592" target="_blank" rel="noopener noreferrer">浅谈JDK、JRE、JVM区别与联系</a></p>
<ol>
<li>JVM不能单独执行class</li>
<li>JRE = JVM + lib（jvm工作需要的类库）。可以执行class</li>
<li>JDK包含JRE。可以开发、编译、执行</li>
</ol>
</div>
<p><img src="./README.assets/0cc3f4a15d3184391a98a7b1c58f6e5f_720w.jpg" alt="img" loading="lazy"></p>
<h3 id="_2-1-oracle-jdk-openjdk-不懂"> 2.1 Oracle JDK &amp; OpenJDK （不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java-basic-questions-01/#oracle-jdk-vs-openjdk" target="_blank" rel="noopener noreferrer">Java基础常见知识&amp;面试题总结(上) | JavaGuide</a></p>
<h2 id="三、字节码及优点"> 三、字节码及优点</h2>
<p>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<ul>
<li>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</li>
<li>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</li>
</ul>
<p><img src="./README.assets/java程序转变为机器代码的过程.3dbbbc5a.png" alt="Java程序转变为机器代码的过程" loading="lazy"></p>
<div><p>为什么</p>
<p>参考： <a href="https://blog.csdn.net/a4171175/article/details/90735888" target="_blank" rel="noopener noreferrer">什么是字节码？采用字节码的最大好处是什么？</a></p>
<p><strong>解释型语言</strong></p>
<ul>
<li>优点：程序运行时才进行翻译，容易维护 、方便快速部署、不用停机维护。</li>
<li>缺点：每次运行都要解释一遍，性能较低</li>
</ul>
<p><strong>编译型语言</strong></p>
<p>优点：编译器会对程序代码进行优化，并且只需要进行一次编译、效率较高</p>
<p>缺点：修个当个功能需要重新编译整个模块，不同的运行环境需要编译不同的机器码才能执行</p>
<p><strong>采用字节码：</strong></p>
<ol>
<li>先通过编译器对程序进行编译，会有一轮优化，能够一定程度上提高性能</li>
<li>字节码面向虚拟机， 可由不同平台的虚拟机直接解释执行，不需要重新编译，实现可移植的特点</li>
</ol>
</div>
<h2 id="四、java-是值传递"> 四、Java 是值传递</h2>
<h3 id="_4-1-值传递-引用传递"> 4.1 值传递 &amp; 引用传递</h3>
<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h3 id="_4-2-修改基本数据类型"> 4.2 修改基本数据类型</h3>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行交换函数，将a、b的值对换"</span><span>)</span><span>;</span>
        <span>int</span> tmp <span>=</span> a<span>;</span>
        a <span>=</span> b<span>;</span>
        b <span>=</span> tmp<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span> a <span>=</span> <span>1</span><span>;</span>
        <span>int</span> b <span>=</span> <span>2</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行前：a = "</span> <span>+</span> a <span>+</span> <span>", b = "</span> <span>+</span> b<span>)</span><span>;</span>

        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>swap</span><span>(</span>a<span>,</span> b<span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行后：a = "</span> <span>+</span> a <span>+</span> <span>", b = "</span> <span>+</span> b<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
执行前：a <span>=</span> <span>1</span><span>,</span> b <span>=</span> <span>2</span>
执行交换函数，将a、b的值对换
执行后：a <span>=</span> <span>1</span><span>,</span> b <span>=</span> <span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><ul>
<li>a和b只是从num1和num2复制得到了值，怎么操作都不会产生影响</li>
</ul>
<h3 id="_4-3-修改引用类型中的值"> 4.3 修改引用类型中的值</h3>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>void</span> <span>print</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> num <span>:</span> array<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span>num <span>+</span> <span>" "</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>""</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>swap</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行交换函数，将数组首尾两数对换"</span><span>)</span><span>;</span>
        <span>int</span> tmp <span>=</span> array<span>[</span><span>0</span><span>]</span><span>;</span>
        array<span>[</span><span>0</span><span>]</span> <span>=</span> array<span>[</span>array<span>.</span>length <span>-</span> <span>1</span><span>]</span><span>;</span>
        array<span>[</span>array<span>.</span>length <span>-</span> <span>1</span><span>]</span> <span>=</span> tmp<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"创建新的数组"</span><span>)</span><span>;</span>
        array <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>}</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>}</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"原数组："</span><span>)</span><span>;</span>
        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>print</span><span>(</span>arr<span>)</span><span>;</span>

        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>swap</span><span>(</span>arr<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"交换后数组："</span><span>)</span><span>;</span>
        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>print</span><span>(</span>arr<span>)</span><span>;</span>

        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>change</span><span>(</span>arr<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>"创建后数组："</span><span>)</span><span>;</span>
        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>.</span><span>print</span><span>(</span>arr<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span>
原数组：<span>1</span> <span>2</span> <span>3</span> 
执行交换函数，将数组首尾两数对换
交换后数组：<span>3</span> <span>2</span> <span>1</span> 
创建新的数组
创建后数组：<span>3</span> <span>2</span> <span>1</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br></div></div><ul>
<li>函数中的<code>int[] arr</code> 只是对数组 <strong>引用</strong> 的一个拷贝
<ul>
<li>对这个引用指向的数组对象就行内容修改，两个引用都能查看到</li>
<li>但是对这个 <strong>新的引用</strong> 创建新的数组，也不会影响原来的 数组引用 指向的数组对象。</li>
</ul>
</li>
</ul>
<p><img src="./README.assets/java-value-passing-02.ff1b76c9.png" alt="引用数据类型参数1" loading="lazy"></p>
<h3 id="_4-4-修改引用类型的对象"> 4.4 修改引用类型的对象</h3>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>

    <span>static</span> <span>class</span> <span>Student</span> <span>{</span>
        <span>private</span> <span>String</span> name<span>;</span>

        <span>public</span> <span>Student</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
            <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>}</span>

        <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
            <span>return</span> name<span>;</span>
        <span>}</span>

        <span>private</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
            <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>void</span> <span>swapName</span><span>(</span><span>Student</span> s1<span>,</span> <span>Student</span> s2<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"直接交换两人的姓名"</span><span>)</span><span>;</span>
        <span>String</span> name <span>=</span> s1<span>.</span><span>getName</span><span>(</span><span>)</span><span>;</span>
        s1<span>.</span><span>setName</span><span>(</span>s2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        s2<span>.</span><span>setName</span><span>(</span>name<span>)</span><span>;</span>
    <span>}</span>

    <span>static</span> <span>void</span> <span>swapStudent</span><span>(</span><span>Student</span> s1<span>,</span> <span>Student</span> s2<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"交换两个对象"</span><span>)</span><span>;</span>
        <span>Student</span> tmp <span>=</span> s1<span>;</span>
        s1 <span>=</span> s2<span>;</span>
        s2 <span>=</span> tmp<span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Student</span> xz <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"xiaoZhang"</span><span>)</span><span>;</span>
        <span>Student</span> xl <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"xiaoLi"</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xz："</span> <span>+</span> xz<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>", xl: "</span> <span>+</span> xl<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>swapName</span><span>(</span>xz<span>,</span> xl<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xz："</span> <span>+</span> xz<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>", xl: "</span> <span>+</span> xl<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>

        <span>swapStudent</span><span>(</span>xz<span>,</span> xl<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xz："</span> <span>+</span> xz<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>", xl: "</span> <span>+</span> xl<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
xz：xiaoZhang<span>,</span> xl<span>:</span> xiaoLi
直接交换两人的姓名
xz：xiaoLi<span>,</span> xl<span>:</span> xiaoZhang
交换两个对象
xz：xiaoLi<span>,</span> xl<span>:</span> xiaoZhang
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p><img src="./README.assets/java-value-passing-03.da4d0422.png" alt="引用数据类型参数2" loading="lazy"></p>
<h3 id="总结"> 总结</h3>
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
<h2 id="五、程序、进程和线程"> 五、程序、进程和线程</h2>
<p>简单来说， <mark>一个进程就是一个执行中的程序</mark> ，它在计算 机中一个指令接着一个指令地执行着，同时，每个进程还占有某些系统资源如 CPU 时间，内存空 间，文件，输入输出设备的使用权等等。换句话说，当程序在执行时，将会被操作系统载入内存 中。  <mark>线程是进程划分成的更小的运行单位</mark> 。线程和进程最大的不同在于基本上各进程是独立的，而 各线程则不一定，因为同一进程中的线程极有可能会相互影响。从另一角度来说，进程属于操作系 统的范畴，主要是同一段时间内，可以同时执行一个以上的程序，而线程则是在同一程序内几乎同 时执行一个以上的程序段。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">设计模式</title>
    <id>https://notes.lllllan.cn/framework/design-pattern/</id>
    <link href="https://notes.lllllan.cn/framework/design-pattern/"/>
    <updated>2022-04-17T07:25:28.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/128145128" target="_blank" rel="noopener noreferrer">快速记忆23种设计模式 - 知乎 (zhihu.com)</a></li>
</ul>
</div>
<p>设计模式（Design Pattern）是前辈们对代码开发经验的总结，是解决特定问题的一系列套路。</p>
<h2 id="设计模式的六大原则-solid"> 设计模式的六大原则（SOLID）</h2>
<ol start="0">
<li>
<p>总原则：开闭原则</p>
<p>一个软件实体，如类、模块和函数应该<strong>对扩展开放，对修改关闭</strong>。</p>
</li>
<li>
<p>单一职责原则</p>
<p>不要存在多于一个导致类变更的原因，也就是说每个类应该实现单一的职责，否则就应该把类拆分。</p>
</li>
<li>
<p>里氏替换原则</p>
<p><strong>子类对父类的方法尽量不要重写和重载</strong>。因为父类代表了定义好的结构，通过这个规范的接口与外界交互，子类不应该随便破坏它。</p>
</li>
<li>
<p>依赖倒置原则</p>
<p>面向接口编程，依赖于抽象而不依赖于具体。写代码时用到具体类时，不与具体类交互，而与具体类的上层接口交互。</p>
</li>
<li>
<p>接口隔离原则</p>
<p>每个接口中不存在子类用不到却必须实现的方法，如果不然，就要将接口拆分。使用多个隔离的接口，比使用单个接口（多个接口方法集合到一个的接口）要好。</p>
</li>
<li>
<p>迪米特法则（最少知道原则）</p>
<p>一个类对自己依赖的类知道的越少越好。无论被依赖的类多么复杂，都应该将逻辑封装在方法的内部，通过public方法提供给外部。这样当被依赖的类变化时，才能最小的影响该类。</p>
</li>
<li>
<p>合成复用原则</p>
<p>尽量使用对象组合/聚合，而不是继承关系达到软件复用的目的。</p>
</li>
</ol>
<h2 id="创建型模式"> 创建型模式</h2>
<h3 id="工厂模式"> 工厂模式</h3>
<p>工厂模式（Factory Pattern）是Java中最常用的设计模式之一。</p>
<p>在工厂模式中，我们在创建对象时不会对客户端暴露创建逻辑，并且是通过使用一个共同的接口来指向新创建的对象。</p>
<p>定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</p>
<blockquote>
<p>应用实例：您需要一辆汽车，可以直接从工厂里面提货，而不用去管这辆汽车是怎么做出来的，以及这个汽车里面的具体实现。而至于需要哪个牌子的汽车，就到哪个牌子的工厂。</p>
</blockquote>
<h3 id="抽象工厂模式"> 抽象工厂模式</h3>
<p>抽象工厂模式（Abstract Factory Pattern）是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂。</p>
<p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p>
<p>提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</p>
<blockquote>
<p>应用实例：对于一个家庭来说，可能有商务女装、商务男装、时尚女装、时尚男装，都是成套的，即一系列具体产品。假设一种情况，在您的家中，某一个衣柜（具体工厂）只能存放某一种这样的衣服（成套，一系列具体产品），每次拿这种成套的衣服时也自然要从这个衣柜中取出了。用 OO 的思想去理解，所有的衣柜（具体工厂）都是衣柜类的（抽象工厂）某一个，而每一件成套的衣服又包括具体的上衣（某一具体产品），裤子（某一具体产品），这些具体的上衣其实也都是上衣（抽象产品），具体的裤子也都是裤子（另一个抽象产品）。</p>
</blockquote>
<h3 id="单例模式"> 单例模式</h3>
<p>单例模式（Singleton Pattern）是Java中最简单的设计模式之一。</p>
<p>这种模式涉及到一个单一的类，该类负责创建自己的对象，同时确保只有单个对象被创建。这个类提供了一种访问其唯一的对象的方式，可以直接访问，不需要实例化该类的对象。</p>
<p>保证一个类仅有一个实例，并提供一个访问它的全局访问点。</p>
<blockquote>
<p>应用实例：一个班级只能有一个班主任。</p>
</blockquote>
<h3 id="建造者模式-构建者模式"> 建造者模式（构建者模式）</h3>
<p>建造者模式（Builder Pattern）使用多个简单的对象一步一步构建成一个复杂的对象。</p>
<p>一个Builder类会一步一步构造最终的对象。该Builder类是独立于其他对象的。</p>
<p>将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</p>
<blockquote>
<p>应用实例：
1、去肯德基，汉堡、可乐、薯条、炸鸡翅等是不变的，而其组合是经常变化的，生成出所谓的“套餐”；
2、Java 中的 StringBuilder。</p>
</blockquote>
<h3 id="原型模式"> 原型模式</h3>
<p>原型模式（Prototype Pattern）是用于创建重复的对象，同时又能保证性能。</p>
<p>这种模式是实现了一个原型接口，该接口用于创建当前对象的克隆。当直接创建对象的代价比较大时，则采用这种模式。例如，一个对象需要在一个高代价的数据库操作之后被创建。我们可以缓存该对象，在下一个请求时返回它的克隆，在需要的时候更新数据库，以此来减少数据库调用。</p>
<p>用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p>
<blockquote>
<p>应用实例：
1、细胞分裂；
2、Java中的 Object clone() 方法。</p>
</blockquote>
<h2 id="结构型模式"> 结构型模式</h2>
<h3 id="适配器模式"> 适配器模式</h3>
<p>适配器模式（Adapter Pattern）是作为两个不兼容的接口之间的桥梁。</p>
<p>这种模式涉及到一个单一的类，该类负责加入独立的或不兼容的接口功能。</p>
<p>将一个类的接口转换成客户希望的另外一个接口。适配器模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
<blockquote>
<p>应用实例：
1、读卡器是作为内存卡和笔记本之间的适配器。您将内存卡插入读卡器，再将读卡器插入笔记本，这样就可以通过笔记本来读取内存卡；
2、美国电器110V，中国220V，就要有一个变压器将110V转化为220V。</p>
</blockquote>
<h3 id="装饰器模式"> 装饰器模式</h3>
<p>装饰器模式（Decorator Pattern）允许向一个现有的对象添加新的功能，同时又不改变其结构。</p>
<p>这种模式创建了一个装饰类，用来包装原有的类，并在保持类方法签名完整性的前提下，提供了额外的功能。</p>
<p>动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</p>
<blockquote>
<p>应用实例：
1、孙悟空有72变，当他变成&quot;庙宇&quot;后，他的根本还是一只猴子，但是他又有了庙宇的功能；
2、将一个形状装饰上不同的颜色，同时又不改变形状。</p>
</blockquote>
<h3 id="代理模式"> 代理模式</h3>
<p>在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。</p>
<p>在代理模式中，我们创建具有现有对象的对象，以便向外界提供功能接口。</p>
<p>为其他对象提供一种代理以控制对这个对象的访问。</p>
<blockquote>
<p>应用实例：
1、Windows里面的快捷方式；
2、买火车票不一定在火车站买，也可以去代售点；
3、一张支票或银行存单是账户中资金的代理。支票在市场交易中用来代替现金，并提供对签发人账号上资金的控制；
4、Spring AOP。</p>
</blockquote>
<p>注意事项：</p>
<p>1、和适配器模式的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。</p>
<p>2、和装饰器模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。</p>
<h3 id="外观模式"> 外观模式</h3>
<p>外观模式（Facade Pattern）隐藏系统的复杂性，并向客户端提供了一个客户端可以访问系统的接口。</p>
<p>这种模式涉及到一个单一的类，该类提供了客户端请求的简化方法和对现有系统类方法的委托调用。</p>
<p>为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p>
<blockquote>
<p>应用实例：
去医院看病，可能要去挂号、门诊、划价、取药，让患者或患者家属觉得很复杂，如果有提供接待人员，只让接待人员来处理，就很方便。</p>
</blockquote>
<h3 id="桥接模式"> 桥接模式</h3>
<p>桥接模式（Bridge Pattern）是用于把抽象化与实现化解耦，使得二者可以独立变化。它通过提供抽象化和实现化之间的桥接结构，来实现二者的解耦。</p>
<p>这种模式涉及到一个作为桥接的接口，使得实体类的功能独立于接口实现类。这两种类型的类可被结构化改变而互不影响。</p>
<p>将抽象部分与实现部分分离，使它们都可以独立的变化。</p>
<p>又称为柄体（Handle and Body）模式或接口（Interface）模式。</p>
<blockquote>
<p>应用实例：
1、猪八戒从天蓬元帅转世投胎到猪，转世投胎的机制将尘世划分为两个等级，即：灵魂和肉体，前者相当于抽象化，后者相当于实现化。生灵通过功能的委派，调用肉体对象的功能，使得生灵可以动态地选择；
2、墙上的开关，可以看到的开关是抽象的，不用管里面具体怎么实现的；
3、如果要绘制不同的颜色，如红色、绿色、蓝色的矩形、圆形、椭圆、正方形，我们需要根据实际需要对形状和颜色进行组合，那么颜色、形状就是抽象部分，组合后的就是实现部分。</p>
</blockquote>
<p>注意事项：对于两个独立变化的维度，使用桥接模式再适合不过了。</p>
<h3 id="组合模式"> 组合模式</h3>
<p>组合模式（Composite Pattern），又叫部分整体模式，是用于把一组相似的对象当作一个单一的对象。组合模式依据树形结构来组合对象，用来表示部分以及整体层次。这种类型的设计模式属于结构型模式，它创建了<strong>对象组的树形结构</strong>。</p>
<p>这种模式创建了一个包含自己对象组的类。该类提供了修改相同对象组的方式。</p>
<p>将对象组合成树形结构以表示&quot;部分-整体&quot;的层次结构。组合模式使得用户对单个对象和组合对象的使用具有一致性。</p>
<blockquote>
<p>应用实例：
1、算术表达式包括操作数、操作符和另一个操作数，其中，另一个操作数也可以是操作数、操作符和另一个操作数。
2、在JAVAAWT和SWING中，对于Button和Checkbox是树叶，Container是树枝。</p>
</blockquote>
<h3 id="享元模式"> 享元模式</h3>
<p>享元模式（Flyweight Pattern）主要用于减少创建对象的数量，以减少内存占用和提高性能。这种类型的设计模式属于结构型模式，它提供了减少对象数量从而改善应用所需的对象结构的方式。</p>
<p>享元模式尝试重用现有的同类对象，如果未找到匹配的对象，则创建新对象。</p>
<p>运用共享技术有效地支持大量细粒度的对象。</p>
<blockquote>
<p>应用实例：
1、Java中的String，如果有则返回，如果没有则创建一个字符串保存在字符串缓存池里面；
2、数据库的数据池。</p>
</blockquote>
<h2 id="行为型模式"> 行为型模式</h2>
<h3 id="策略模式"> 策略模式</h3>
<p>在策略模式（Strategy Pattern）中，一个类的行为或其算法可以在运行时更改。</p>
<p>在策略模式中，我们创建表示各种策略的对象和一个行为随着策略对象改变而改变的context对象。策略对象改变context对象的执行算法。</p>
<p>定义一系列的算法，把它们一个个封装起来，并且使它们可相互替换。</p>
<blockquote>
<p>应用实例：
1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略；
2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。</p>
</blockquote>
<h3 id="模板模式"> 模板模式</h3>
<p>在模板模式（Template Pattern）中，一个抽象类公开定义了执行它的方法的方式/模板。它的子类可以按需要重写方法实现，但调用将以抽象类中定义的方式进行。</p>
<p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p>
<blockquote>
<p>应用实例：
1、在造房子的时候，地基、走线、水管都一样，只有在建筑的后期才有加壁橱加栅栏等差异；
2、西游记里面菩萨定好的81难，这就是一个顶层的逻辑骨架；
3、spring中对Hibernate的支持，将一些已经定好的方法封装起来，比如开启事务、获取Session、关闭Session等，程序员不重复写那些已经规范好的代码，直接丢一个实体就可以保存。</p>
</blockquote>
<h3 id="观察者模式"> 观察者模式</h3>
<p>当对象间存在一对多关系时，则使用观察者模式（ObserverPattern）。比如，当一个对象被修改时，则会自动通知它的依赖对象。</p>
<p>定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</p>
<blockquote>
<p>应用实例：
1、拍卖的时候，拍卖师观察最高标价，然后通知给其他竞价者竞价；
2、西游记里面悟空请求菩萨降服红孩儿，菩萨洒了一地水招来一个老乌龟，这个乌龟就是观察者，他观察菩萨洒水这个动作。</p>
</blockquote>
<h3 id="迭代器模式"> 迭代器模式</h3>
<p>迭代器模式（Iterator Pattern）是Java和.Net编程环境中非常常用的设计模式。这种模式用于顺序访问集合对象的元素，不需要知道集合对象的底层表示。</p>
<p>迭代器模式属于行为型模式。</p>
<p>提供一种方法顺序访问一个聚合对象中各个元素，而又无须暴露该对象的内部表示。</p>
<blockquote>
<p>应用实例：JAVA中的iterator。</p>
</blockquote>
<h3 id="责任链模式"> 责任链模式</h3>
<p>顾名思义，责任链模式（Chain of Responsibility Pattern）为请求创建了一个接收者对象的链。这种模式给予请求的类型，对请求的发送者和接收者进行解耦。</p>
<p>在这种模式中，通常每个接收者都包含对另一个接收者的引用。如果一个对象不能处理该请求，那么它会把相同的请求传给下一个接收者，依此类推。</p>
<p>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p>
<blockquote>
<p>应用实例：红楼梦中的&quot;击鼓传花&quot;。</p>
</blockquote>
<h3 id="命令模式"> 命令模式</h3>
<p>命令模式（Command Pattern）是一种数据驱动的设计模式。请求以命令的形式包裹在对象中，并传给调用对象。调用对象寻找可以处理该命令的合适的对象，并把该命令传给相应的对象，该对象执行命令。</p>
<p>将一个请求封装成一个对象，从而使您可以用不同的请求对客户进行参数化。</p>
<blockquote>
<p>应用实例：电视机是请求的接收者，遥控器是请求的发送者，遥控器上有一些按钮，不同的按钮对应电视机的不同操作。抽象命令角色由一个命令接口来扮演，有三个具体的命令类实现了抽象命令接口，这三个具体命令类分别代表三种操作：打开电视机、关闭电视机和切换频道。</p>
</blockquote>
<h3 id="备忘录模式"> 备忘录模式</h3>
<p>备忘录模式（Memento Pattern）保存一个对象的某个状态，以便在适当的时候恢复对象。</p>
<p>在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</p>
<blockquote>
<p>应用实例：
1、后悔药；
2、打游戏时的存档；
3、Windows里的ctri+z；
4、IE中的后退；
5、数据库的事务管理。</p>
</blockquote>
<h3 id="状态模式"> 状态模式</h3>
<p>在状态模式（State Pattern）中，类的行为是基于它的状态改变的。</p>
<p>在状态模式中，我们创建表示各种状态的对象和一个行为随着状态对象改变而改变的context对象。</p>
<p>允许对象在内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</p>
<blockquote>
<p>应用实例：
1、打篮球的时候运动员可以有正常状态、不正常状态和超常状态；
2、曾侯乙编钟中，'钟是抽象接口'，'钟A'等是具体状态，'曾侯乙编钟'是具体环境（Context）。</p>
</blockquote>
<h3 id="访问者模式"> 访问者模式</h3>
<p>在访问者模式（Visitor Pattern）中，我们使用了一个访问者类，它改变了元素类的执行算法。通过这种方式，元素的执行算法可以随着访问者改变而改变。根据模式，元素对象已接受访问者对象，这样访问者对象就可以处理元素对象上的操作。</p>
<p>主要将数据结构与数据操作分离。</p>
<p>主要解决：稳定的数据结构和易变的操作耦合问题。</p>
<blockquote>
<p>应用实例：您在朋友家做客，您是访问者，朋友接受您的访问，您通过朋友的描述，然后对朋友的描述做出一个判断，这就是访问者模式。</p>
</blockquote>
<h3 id="中介者模式"> 中介者模式</h3>
<p>中介者模式（Mediator Pattern）是用来降低多个对象和类之间的通信复杂性。这种模式提供了一个中介类，该类通常处理不同类之间的通信，并支持松耦合，使代码易于维护。</p>
<p>用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</p>
<blockquote>
<p>应用实例：
1、中国加入WTO之前是各个国家相互贸易，结构复杂，现在是各个国家通过WTO来互相贸易；
2、机场调度系统；
3、MVC框架，其中C（控制器）就是M（模型）和V（视图）的中介者。</p>
</blockquote>
<h3 id="解释器模式"> 解释器模式</h3>
<p>解释器模式（Interpreter Pattern）提供了评估语言的语法或表达式的方式。这种模式实现了一个表达式接口，该接口解释一个特定的上下文。这种模式被用在SQL解析、符号处理引擎等。</p>
<p>给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</p>
<blockquote>
<p>应用实例：编译器、运算表达式计算。</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-17T06:57:56.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">代理模式</title>
    <id>https://notes.lllllan.cn/framework/design-pattern/agent/</id>
    <link href="https://notes.lllllan.cn/framework/design-pattern/agent/"/>
    <updated>2022-04-17T06:57:56.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="http://c.biancheng.net/view/1359.html" target="_blank" rel="noopener noreferrer">代理模式（代理设计模式）详解 (biancheng.net)</a></li>
<li><a href="https://www.jianshu.com/p/9cdcf4e5c27d" target="_blank" rel="noopener noreferrer">设计模式之——代理模式</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1625434#:~:text=%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E6%98%AF%E4%B8%80%E7%A7%8D%E6%96%B9%E4%BE%BF%E8%BF%90%E8%A1%8C%E6%97%B6%E5%8A%A8%E6%80%81%E6%9E%84%E5%BB%BA%E4%BB%A3%E7%90%86%E3%80%81%E5%8A%A8%E6%80%81%E5%A4%84%E7%90%86%E4%BB%A3%E7%90%86%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8%E7%9A%84%E6%9C%BA%E5%88%B6%EF%BC%8C%E5%BE%88%E5%A4%9A%E5%9C%BA%E6%99%AF%E9%83%BD%E6%98%AF%E5%88%A9%E7%94%A8%E7%B1%BB%E4%BC%BC%E6%9C%BA%E5%88%B6%E5%81%9A%E5%88%B0%E7%9A%84%EF%BC%8C%E6%AF%94%E5%A6%82%E7%94%A8%E6%9D%A5%E5%8C%85%E8%A3%85RPC%E8%B0%83%E7%94%A8%E3%80%81%E9%9D%A2%E5%90%91%E5%88%87%E9%9D%A2%E7%9A%84%E7%BC%96%E7%A8%8B%EF%BC%88AOP%EF%BC%89,%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%E7%9A%84%E6%96%B9%E5%BC%8F%E5%BE%88%E5%A4%9A%EF%BC%8C%E6%AF%94%E5%A6%82JDK%E8%87%AA%E8%BA%AB%E6%8F%90%E4%BE%9B%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86%EF%BC%8C%E5%B0%B1%E6%98%AF%E4%B8%BB%E8%A6%81%E5%88%A9%E7%94%A8%E4%BA%86%E4%B8%8A%E9%9D%A2%E6%8F%90%E5%88%B0%E7%9A%84%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E3%80%82" target="_blank" rel="noopener noreferrer">谈谈反射机制，动态代理基于什么原理</a></li>
</ul>
</div>
<h2 id="代理模式"> 代理模式</h2>
<p>代理模式又叫委托模式，是为某个对象提供一个代理对象，并且由代理对象控制对原对象的访问。代理模式通俗来讲就是我们生活中常见的中介。</p>
<p><img src="./README.assets/1DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" loading="lazy"></p>
<h3 id="代理的优缺点"> 代理的优缺点</h3>
<p>代理模式的主要优点：</p>
<ol>
<li>将客户端与目标对象分离，业务类只需要关注业务本身逻辑，一定程度上降低了耦合度、保证了业务类的重用性</li>
<li>代理模式在客户端和目标对象之间，起到一个中介和保护目标对象的作用</li>
<li>可以不修改业务类的功能，通过代理对象来对目标功能进行扩展</li>
</ol>
<p>代理模式的主要缺点：</p>
<ul>
<li>代理模式会造成系统设计中类数量的增加</li>
<li>在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢</li>
<li>增加了系统的复杂度</li>
</ul>
<h3 id="代理的使用场景"> 代理的使用场景</h3>
<p>代理类主要负责为委托类预处理消息、过滤消息、把消息转发给委托类，以及事后对返回结果的处理等。代理类本身并不真正实现服务，而是通过调用委托类的相关方法，来提供特定的服务。真正的业务功能还是由委托类来实现，但是可以在业务功能执行的前后加入一些公共的服务。例如我们想给项目加入缓存、日志这些功能，我们就可以使用代理类来完成，而没必要打开已经封装好的委托类。</p>
<h2 id="静态代理"> 静态代理</h2>
<p><strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<h3 id="代码示例"> 代码示例</h3>
<p>静态代理实现步骤:</p>
<ol>
<li>
<p>定义一个接口及其实现类；</p>
</li>
<li>
<p>创建一个代理类同样实现这个接口</p>
</li>
<li>
<p>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</p>
</li>
<li>
<p>定义接口</p>
</li>
</ol>
<div><pre><code><span>public</span> <span>interface</span> <span>Subject</span> <span>{</span>
    <span>/**
     * 接口方法
     */</span>
    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol start="2">
<li>实现接口的具体类</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>ConcreteSubject</span> <span>implements</span> <span>Subject</span> <span>{</span>
    <span>/**
     * 具体的业务逻辑实现
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>//业务处理逻辑</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><ol start="3">
<li>代理类</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>Proxy</span> <span>implements</span> <span>Subject</span> <span>{</span>

    <span>/**
     * 要代理的实现类
     */</span>
    <span>private</span> <span>Subject</span> subject <span>=</span> <span>null</span><span>;</span>

    <span>/**
     * 默认代理自己
     */</span>
    <span>public</span> <span>Proxy</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>subject <span>=</span> <span>new</span> <span>Proxy</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Proxy</span><span>(</span><span>Subject</span> subject<span>)</span> <span>{</span>
        <span>this</span><span>.</span>subject <span>=</span> subject<span>;</span>
    <span>}</span>

    <span>/**
     * 构造函数，传递委托者
     *
     * @param objects 委托者
     */</span>
    <span>public</span> <span>Proxy</span><span>(</span><span>Object</span><span>.</span><span>.</span><span>.</span> objects<span>)</span> <span>{</span>
    <span>}</span>

    <span>/**
     * 实现接口方法
     */</span>
    <span>@Override</span>
    <span>public</span> <span>void</span> <span>request</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span><span>before</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>subject<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span><span>after</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 预处理
     */</span>
    <span>private</span> <span>void</span> <span>before</span><span>(</span><span>)</span> <span>{</span>
        <span>//do something</span>
    <span>}</span>

    <span>/**
     * 后处理
     */</span>
    <span>private</span> <span>void</span> <span>after</span><span>(</span><span>)</span> <span>{</span>
        <span>//do something</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br></div></div><ol start="4">
<li>客户端类</li>
</ol>
<div><pre><code><span>public</span> <span>class</span> <span>Client</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Subject</span> subject <span>=</span> <span>new</span> <span>ConcreteSubject</span><span>(</span><span>)</span><span>;</span>
        <span>Proxy</span> proxy <span>=</span> <span>new</span> <span>Proxy</span><span>(</span>subject<span>)</span><span>;</span>
        proxy<span>.</span><span>request</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="优缺点"> 优缺点</h3>
<p>优点：</p>
<ol>
<li>业务类只需要关注业务本身逻辑，保证了业务类的重用性（这是代理共有的优点）。</li>
<li>可以不修改业务类对象的功能，通过代理对象对目标功能进行扩展</li>
</ol>
<p>缺点：</p>
<ol>
<li>代理类和委托类实现了相同的接口。代理类需要一一实现委托类的功能方法，如果新增一个方法，所有代理类都需要手动实现这个方法，增加了维护的复杂度。</li>
<li>代理对象只服务于一种类型的对象，如果需要服务多类型的对象，就需要为每一种对象都创建对应的代理类。当程序规模稍大之后，静态代理将会非常麻烦。</li>
</ol>
<h2 id="动态代理"> 动态代理</h2>
<p><mark>动态代理是一种方便运行时动态构建代理、动态处理代理方法调用的机制</mark>，很多场景都是利用类似机制做到的，比如用来包装RPC调用、面向切面的编程（AOP） 实现动态代理的方式很多。</p>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的</strong></p>
<h3 id="jdk-动态代理"> JDK 动态代理</h3>
<p><a href="https://www.cnblogs.com/MOBIN/p/5597215.html" target="_blank" rel="noopener noreferrer">深度剖析JDK动态代理机制 - MOBIN</a></p>
<div><pre><code><span>// 业务接口</span>
<span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>

<span>// 业务类</span>
<span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>

<span>// JDK 动态代理类</span>
<span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>

    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> 
        <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>JdkProxyFactory</span> <span>{</span>
    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>
                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>
        <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>
		smsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="cglib-动态代理机制"> CGLIB 动态代理机制</h3>
<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB  (opens new window)</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener noreferrer">ASM  (opens new window)</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB  (opens new window)</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB  (opens new window)</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
  <span><span><span>&lt;</span>groupId</span><span>></span></span>cglib<span><span><span>&lt;/</span>groupId</span><span>></span></span>
  <span><span><span>&lt;</span>artifactId</span><span>></span></span>cglib<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
  <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><pre><code><span>class</span> <span>AliSmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>

<span>class</span> <span>DebugMethodInterceptor</span> <span>implements</span> <span>MethodInterceptor</span> <span>{</span>


    <span>/**
     * @param o           代理对象（增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */</span>
    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        
        <span>Object</span> object <span>=</span> methodProxy<span>.</span><span>invokeSuper</span><span>(</span>o<span>,</span> args<span>)</span><span>;</span>
        
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> object<span>;</span>
    <span>}</span>

<span>}</span>

<span>class</span> <span>CglibProxyFactory</span> <span>{</span>

    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>)</span> <span>{</span>
        <span>// 创建动态代理增强类</span>
        <span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置类加载器</span>
        enhancer<span>.</span><span>setClassLoader</span><span>(</span>clazz<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 设置被代理类</span>
        enhancer<span>.</span><span>setSuperclass</span><span>(</span>clazz<span>)</span><span>;</span>
        <span>// 设置方法拦截器</span>
        enhancer<span>.</span><span>setCallback</span><span>(</span><span>new</span> <span>DebugMethodInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 创建代理类</span>
        <span>return</span> enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Main</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>AliSmsService</span> aliSmsService <span>=</span> <span>(</span><span>AliSmsService</span><span>)</span> <span>CglibProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>AliSmsService</span><span>.</span><span>class</span><span>)</span><span>;</span>
        aliSmsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="对比"> 对比</h3>
<p><a href="https://zhuanlan.zhihu.com/p/106336169" target="_blank" rel="noopener noreferrer">Java：聊聊JDK和CGLib动态代理实现和区别 - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.cnblogs.com/sandaman2019/p/12636727.html" target="_blank" rel="noopener noreferrer">Cglib和jdk动态代理的区别 - 橙发 - 博客园 (cnblogs.com)</a></p>
<ul>
<li><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong></li>
<li>CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，<strong>因此不能代理声明为 final 类型的类和方法</strong></li>
<li>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</li>
</ul>
<h2 id="静态代理和动态代理的对比"> 静态代理和动态代理的对比</h2>
<ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T12:27:53.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 基础语法</title>
    <id>https://notes.lllllan.cn/java/basic/2-grammar/</id>
    <link href="https://notes.lllllan.cn/java/basic/2-grammar/"/>
    <updated>2022-04-11T15:48:25.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/382239048" target="_blank" rel="noopener noreferrer">还不知道泛型是什么？这一篇深入浅出泛型教学！</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/259368621" target="_blank" rel="noopener noreferrer">详解Java 中 static 的作用 - 知乎 (zhihu.com)</a></li>
</ul>
</div>
<h2 id="一、静态方法为什么不能调用非静态方法"> 一、静态方法为什么不能调用非静态方法？</h2>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<div><p>为什么要用静态方法？</p>
<ul>
<li><strong>更方便</strong>：静态方法的好处就是不用生成类的实例就可以直接调用。</li>
<li><strong>降低消耗</strong>：只需要通过其类名就可以访问，不需要再消耗资源反复创建对象。</li>
</ul>
</div>
<h2 id="二、常见语法"> 二、常见语法</h2>
<h3 id="_2-1-操作符"> 2.1  操作符 +=</h3>
<p><code>+=</code> 操作符会进行隐式自动类型转换</p>
<div><pre><code><span>byte</span> a <span>=</span> <span>127</span><span>;</span>
<span>byte</span> b <span>=</span> <span>127</span><span>;</span>
a <span>=</span> a <span>+</span> b<span>;</span> <span>// Error:(5, 15) java: 不兼容的类型: 从int转换到byte可能会有损失</span>
a <span>+=</span> b<span>;</span>    <span>// a = -2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><pre><code><span>short</span> a <span>=</span> <span>1</span><span>;</span>
a <span>=</span> a <span>+</span> <span>1</span><span>;</span> <span>// Error:(4, 15) java: 不兼容的类型: 从int转换到short可能会有损失</span>
a <span>+=</span> <span>1</span><span>;</span>    <span>// a = 2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>运算中的 <code>1</code> 默认是 <code>int</code>类型，那么将 <code>int</code> 类型赋值给 <code>short</code> 类型时，会出现类型转换错误。</p>
<p>而对于 <code>+=</code>，是 Java 语言规定的运算符， Java 编译器自己会进行特殊处理</p>
<h3 id="_2-2-switch-能否作用在-byte、long、string上"> 2.2 switch 能否作用在  <code>byte</code>、<code>long</code>、<code>String</code>上？</h3>
<p>switch 中放的只能是一个整数表达式或枚举常量。而整数表达式可以是 <code>int</code> 或 <code>Integer</code></p>
<ul>
<li>由于 <code>byte</code>、<code>short</code>、<code>char</code> 都可以隐式转换为 <code>int</code>，因此这些类型以及他们的包装类都是可以用的。</li>
<li><code>long</code> 不可以</li>
<li><code>String</code> 在 JDK1.7 之后可以使用</li>
</ul>
<h2 id="三、常见关键字"> 三、常见关键字</h2>
<h3 id="_3-1-instanceof-关键字的作用"> 3.1 instanceof 关键字的作用</h3>
<p><code>instanceof</code>  严格来说是Java中的一个双目运算符，用来测试一个对象是否为一个类的实例，用法 为：</p>
<div><pre><code><span>boolean</span> result <span>=</span> obj <span>instanceof</span> <span>Class</span>
</code></pre>
<div><span>1</span><br></div></div><p>​		其中 obj 为一个对象，Class 表示一个类或者一个接口，当 obj 为 Class 的对象，或者是其直接 或间接子类，或者是其接口的实现类，结果result 都返回 true，否则返回false。</p>
<p>​		 注意：编译器会检查 obj 是否能转换成右边的class类型，如果不能转换则直接报错，如果不能 确定类型，则通过编译，具体看运行时定。</p>
<div><pre><code><span>int</span> i <span>=</span> <span>0</span><span>;</span> 
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>instanceof</span> <span>Integer</span><span>)</span><span>;</span><span>//编译不通过 i必须是引用类型，不能是基本类型 </span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i <span>instanceof</span> <span>Object</span><span>)</span><span>;</span><span>//编译不通过</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>Integer</span> integer <span>=</span> <span>new</span> <span>Integer</span><span>(</span><span>1</span><span>)</span><span>;</span> 
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>integer <span>instanceof</span> <span>Integer</span><span>)</span><span>;</span><span>//true </span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>//false ,在 JavaSE规范 中对 instanceof 运算符的规定就是：如果 obj 为 null，那么将返 回 false。 </span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>null</span> <span>instanceof</span> <span>Object</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_3-2-final有哪些用法"> 3.2 final有哪些用法</h3>
<ol>
<li>被final修饰的类不可以被继承</li>
<li>被final修饰的方法不可以被重写</li>
<li>被final修饰的方法，JVM会尝试将其内联，以提高运行效率</li>
<li>被final修饰的变量不可以被改变。如果修饰引用，那么表示引用不可变，引用指向的内容可变</li>
<li>被final修饰的常量，在编译阶段会存入常量池中</li>
</ol>
<h3 id="_3-3-static-的作用"> 3.3 static 的作用</h3>
<ol>
<li>static 成员变量/成员方法：称为静态变量和静态方法，属于类而非实例。因此可以通过 <code>类名.静态变量名/静态方法名</code> 的方式来获取变量或者调用，而不用创建实例</li>
<li>static 代码块：称为静态代码块，会在JVM加载类时执行，可以做一些类成员变量的初始化工作</li>
<li>static 内部类：称为静态内部类，静态内部类只能访问外部类的静态方法和静态变量，而不能访问其实例变量。</li>
</ol>
<h2 id="四、重载和重写的区别"> 四、重载和重写的区别</h2>
<h3 id="_4-1-重载"> 4.1 重载：</h3>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<h3 id="_4-2-重写"> 4.2 重写</h3>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<div><p>重写一个 private 或者 static 方法？</p>
<p>重写，又称覆盖，是在 <mark>运行时绑定</mark> 的。</p>
<ul>
<li>子类不能访问或使用父类中的 private 方法，因此不能实现重写</li>
<li>static 方法是编译时静态绑定的，就算子类中再写了一个同名同参的相同方法，也只是两个毫不相干的方法，不能称为重写。</li>
</ul>
<p><img src="./README.assets/image-20220308083039176.png" alt="image-20220308083039176" loading="lazy"></p>
<div><p>方法的重写发生在运行时</p>
<p>因为在编译时，编译器是无法知道我们到底是调用父类的方法还是子类的方法，相反的，只有在实际运行的时候，我们才知道应该调用哪个方法。这个也是java运行时多态的体现。</p>
<p>静态方法在类加载时就出现了，和重写不在同一个时期。通过 IDEA 也可以发现，普通方法 <code>print()</code> 的重写，方法左边有一个图标标识，而静态方法 <code>staticPrint()</code> 的两个方法，两者之间没有关系。</p>
</div>
</div>
<div><p>父类的私有属性、方法以及构造器都是不能被重写的。</p>
</div>
<h3 id="_4-3-总结"> 4.3 总结</h3>
<p>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</p>
<table>
<thead>
<tr>
<th style="text-align:left">区别点</th>
<th style="text-align:left">重载方法</th>
<th style="text-align:left">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">发生范围</td>
<td style="text-align:left">同一个类</td>
<td style="text-align:left">子类</td>
</tr>
<tr>
<td style="text-align:left">参数列表</td>
<td style="text-align:left">必须修改</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">返回类型</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td style="text-align:left">异常</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td style="text-align:left">发生阶段</td>
<td style="text-align:left">编译期</td>
<td style="text-align:left">运行期</td>
</tr>
</tbody>
</table>
<h2 id="五、泛型"> 五、泛型</h2>
<p>下面部分转载自 <a href="https://zhuanlan.zhihu.com/p/382239048" target="_blank" rel="noopener noreferrer">还不知道泛型是什么？这一篇深入浅出泛型教学！</a></p>
<h3 id="_5-1-为什么会有泛型"> 5.1 为什么会有泛型</h3>
<blockquote>
<p>早期的Object类型可以接收任意的对象类型，但是在实际的使用中，会有类型转换的问题。也就存在这隐患，所以Java提供了<strong>泛型</strong>来解决这个安全问题。</p>
</blockquote>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>//测试一下泛型的经典案例</span>
    <span>ArrayList</span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span>(</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>"helloWorld"</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>"taiziyenezha"</span><span>)</span><span>;</span>
    arrayList<span>.</span><span>add</span><span>(</span><span>88</span><span>)</span><span>;</span><span>//由于集合没有做任何限定，任何类型都可以给其中存放</span>

    <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> arrayList<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>//需求：打印每个字符串的长度,就要把对象转成String类型</span>
        <span>String</span> str <span>=</span> <span>(</span><span>String</span><span>)</span> arrayList<span>.</span><span>get</span><span>(</span>i<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>.</span><span>length</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>运行这段代码，程序在运行时发生了异常：<code>Exception in thread &quot;main&quot; java.lang.ClassCastException: java.lang.Integer cannot be cast to java.lang.String</code>
发生了数据类型转换异常，这是为什么？</p>
<p>由于ArrayList可以存放任意类型的元素。例子中添加了一个String类型，添加了一个Integer类型，再使用时都以String的方式使用，导致取出时强制转换为String类型后，引发了ClassCastException，因此程序崩溃了。</p>
<p>这显然不是我们所期望的，如果程序有潜在的错误，我们更期望在编译时被告知错误，而不是在运行时报异常。而为了解决类似这样的问题（在编译阶段就可以解决），在jdk1.5后，泛型应运而生。让你在设计API时可以指定类或方法支持泛型，这样我们使用API的时候也变得更为简洁，并得到了编译时期的语法检查。</p>
<p>我们将第一行声明初始化ArrayList的代码更改一下，编译器就会在编译阶段就能够帮我们发现类似这样的问题。现在再看看效果。</p>
<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>String</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>"helloWorld"</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>"taiziyenezha"</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>88</span><span>)</span><span>;</span><span>// 在编译阶段，编译器就会报错这样可以避免了我们类型强转时出现异常。</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_5-2-什么是泛型"> 5.2 什么是泛型</h3>
<p><strong>泛型</strong>：是一种把明确类型的工作推迟到创建对象或者调用方法的时候才去明确的特殊的类型。也就是说在泛型使用过程中，操作的数据类型被指定为一个参数，而这种参数类型可以用在<strong>类、方法和接口</strong>中，分别被称为<code>泛型类</code>、<code>泛型方法</code>、<code>泛型接口</code>。</p>
<div><p>一般在创建对象时，将未知的类型确定具体的类型。当没有指定泛型时，默认类型为Object类型。</p>
</div>
<h3 id="_5-3-泛型的好处"> 5.3 泛型的好处</h3>
<ul>
<li>避免了类型强转的麻烦。</li>
<li>它提供了编译期的<strong>类型安全</strong>，确保在泛型类型（通常为泛型集合）上只能使用正确类型的对象，避免了在运行时出现ClassCastException。</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 注解</title>
    <id>https://notes.lllllan.cn/java/basic/6-annotation/</id>
    <link href="https://notes.lllllan.cn/java/basic/6-annotation/"/>
    <updated>2022-04-10T01:45:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p><a href="https://zhuanlan.zhihu.com/p/37701743" target="_blank" rel="noopener noreferrer">java 注解-最通俗易懂的讲解</a></p>
</li>
</ul>
</div>
<h2 id="一、注解是什么"> 一、注解是什么</h2>
<p><strong>初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。</strong></p>
<h2 id="二、注解的作用"> 二、注解的作用</h2>
<ul>
<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。</li>
<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取
值得注意的是，注解不是代码本身的一部分。</li>
</ul>
<h2 id="三、注解的语法、定义、运用"> 三、注解的语法、定义、运用</h2>
<p>暂且不谈，等到练习中认识即可</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 数据类型</title>
    <id>https://notes.lllllan.cn/java/basic/3-data/</id>
    <link href="https://notes.lllllan.cn/java/basic/3-data/"/>
    <updated>2022-04-11T16:08:28.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
</ul>
</div>
<h2 id="一、数据类型"> 一、数据类型</h2>
<p><img src="./README.assets/5-1ZZZ91512493.jpg" alt="Java数据类型结构图" loading="lazy"></p>
<table>
<thead>
<tr>
<th>类型名称</th>
<th>关键字</th>
<th>占用内存</th>
<th>取值范围</th>
</tr>
</thead>
<tbody>
<tr>
<td>字节型</td>
<td>byte</td>
<td>1 字节</td>
<td>-128~127</td>
</tr>
<tr>
<td>短整型</td>
<td>short</td>
<td>2 字节</td>
<td>-32768~32767</td>
</tr>
<tr>
<td>整型</td>
<td>int</td>
<td>4 字节</td>
<td>-2147483648~2147483647</td>
</tr>
<tr>
<td>长整型</td>
<td>long</td>
<td>8 字节</td>
<td>-9223372036854775808L~9223372036854775807L</td>
</tr>
<tr>
<td>布尔型</td>
<td>boolean</td>
<td>1 字节</td>
<td>true 或 false</td>
</tr>
<tr>
<td>字符型</td>
<td>char</td>
<td>2 字节</td>
<td>ISO 单一字符集</td>
</tr>
<tr>
<td>单精度浮点型</td>
<td>float</td>
<td>4 字节</td>
<td>+/-3.4E+38F（6~7 个有效位）</td>
</tr>
<tr>
<td>双精度浮点型</td>
<td>double</td>
<td>8 字节</td>
<td>+/-1.8E+308 (15 个有效位）</td>
</tr>
</tbody>
</table>
<div><p>各种数据的存放位置</p>
<ul>
<li>只要是全局变量，就全都存放在堆中。</li>
<li>如果是局部变量，基本数据类型和引用存放在栈中，对象实体存放在堆中。</li>
</ul>
</div>
<h2 id="二、变量"> 二、变量</h2>
<h3 id="_2-1-成员变量和局部变量的区别"> 2.1 成员变量和局部变量的区别</h3>
<p><img src="./README.assets/image-20220116180214826.png" alt="image-20220116180214826" loading="lazy"></p>
<h3 id="_2-2-静态变量和实例变量的区别"> 2.2  静态变量和实例变量的区别</h3>
<ul>
<li>静态变量：被 <code>static</code> 修饰，也称类变量。它属于类，因此不管创建多少个对象，该静态变量在内存中有且仅有一个拷贝。静态变量可以实现多个对象共享内存</li>
<li>实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问得到</li>
</ul>
<h2 id="三、包装类"> 三、包装类</h2>
<h3 id="_3-1-integer-和-int-的区别"> 3.1 Integer 和 int 的区别？</h3>
<ol>
<li>int 是 Java 的⼋种基本数据类型之⼀，⽽ <code>Integer</code> 是 Java 为 int 类型提供的封装类</li>
<li>int 型变量的默认值是 0，Integer 变量的默认值是 null，这⼀点说明 Integer 可以区分出未赋值和值为 0 的 区分</li>
<li>Integer 变量必须实例化后才可以使⽤，⽽ int 不需要。</li>
</ol>
<h3 id="_3-2-integer-之间的比较"> 3.2 Integer 之间的比较</h3>
<ol>
<li>两个 <code>new()</code> 出来的 <code>Integer</code> 进行比较：因为是两个对象，进行比较的其内存地址，结果均为 false</li>
<li><code>Integer</code> 和 <code>int</code> 进行比较：包装类和基本数据类型进行比较时，会对包装类进行拆包装为基本数据类型，所以最后是两个 <code>int</code> 在比较。只要数值相等就为 true</li>
<li>非new生成的 <code>Integer</code> 和 <code>new integer()</code> 进行比较：前者指向 Java 常量池中的对象、后者指向堆中的对象，内存地址不同，结果均为 false</li>
<li>两个非new生成的 <code>Integer</code> 进行比较：如果数值相等并且变量值在 <code>[-128, 127]</code> 之间，比较结果为 true，否则为 false。</li>
</ol>
<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> var0<span>)</span> <span>{</span> 
    <span>return</span> var0 <span>>=</span> <span>-</span><span>128</span> <span>&amp;&amp;</span> var0 <span>&lt;=</span> <span>Integer<span>.</span>IntegerCache</span><span>.</span>high <span>?</span>
		<span>Integer<span>.</span>IntegerCache</span><span>.</span>cache<span>[</span>var0 <span>+</span> <span>128</span><span>]</span> <span>:</span> <span>new</span> <span>Integer</span><span>(</span>var0<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_3-3-包装类的常量池"> 3.3 包装类的常量池</h3>
<p><code>Byte</code>、<code>Short</code>、<code>Integer</code>、<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>解释来说呢，大概就是以上几种类型中，创建的对象大小在约定的范围之内，该对象会在cache中长生（如果已存在将会复用）。</p>
<ul>
<li>节省内存空间：常量池中所有相同的对象常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<h3 id="_3-4-装箱和拆箱"> 3.4 装箱和拆箱</h3>
<p>⾃动装箱是 Java 编译器在基本数据类型和对应得包装类之间做的⼀个转化。⽐如：把 int 转化成 Integer，double 转化成 Double 等等。反之就是⾃动拆箱。</p>
<p>原始类型：boolean、char、byte、short、int、long、float、double</p>
<p>封装类型：Boolean、Character、Byte、Short、Integer、Long、Float、Double</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 异常</title>
    <id>https://notes.lllllan.cn/java/basic/7-exception/</id>
    <link href="https://notes.lllllan.cn/java/basic/7-exception/"/>
    <updated>2022-04-11T16:34:02.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://www.cnblogs.com/ThinkVenus/p/6805495.html" target="_blank" rel="noopener noreferrer">什么是java OOM？如何分析及解决oom问题？</a></li>
</ul>
</div>
<h2 id="一、异常类层次结构图"> 一、异常类层次结构图</h2>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<ul>
<li>
<p><strong><code>Exception</code></strong> ：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常</strong>(必须处理) 和 <strong>不受检查异常</strong>(可以不处理)。</p>
</li>
<li>
<p><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择<strong>线程终止</strong>。</p>
</li>
</ul>
<p><img src="./README.assets/Java异常类层次结构图2-16463581576452-16463582756464.png" alt="img" loading="lazy"></p>
<h3 id="_1-1-受检查异常"> 1.1 受检查异常</h3>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码</p>
<p><code>IOException</code>、<code>FileNotFoundException</code> 、<code>SQLException</code></p>
<p><img src="./README.assets/image-20220304094533701.png" alt="image-20220304094533701" loading="lazy"></p>
<h3 id="_1-2-不受检查异常"> 1.2 不受检查异常</h3>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h2 id="二、throwable-类常用方法"> 二、Throwable 类常用方法</h2>
<ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h2 id="三、try-catch-finally"> 三、try-catch-finally</h2>
<ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<strong><code>finally</code> 语句块将在方法返回之前被执行。</strong></li>
</ul>
<h3 id="_3-1-try-catch-中含有return-finally还会执行吗"> 3.1 try/catch 中含有return，finally还会执行吗</h3>
<p>结论：</p>
<ol>
<li>不管有没有出现异常，finally块中代码都会执行</li>
<li>当try和catch中有return时，finally仍然会执行</li>
<li>finally是在return后面的表达式运算后执行的（此时并没有返回运算后的值，而是先把要返回的 值保存起来，管finally中的代码怎么样，返回的值都不会改变，任然是之前保存的值），所以函数 返回值是在finally执行前确定的</li>
<li>finally中最好不要包含return，否则程序会提前退出，返回值不是try或catch中保存的返回值。</li>
</ol>
<div><p>Tips</p>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>
<p>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</p>
</li>
<li>
<p>程序所在的线程死亡。</p>
</li>
<li>
<p>关闭 CPU。</p>
</li>
</ol>
</div>
<h3 id="_3-2-使用-try-with-resources-来代替try-catch-finally"> 3.2 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<div><pre><code><span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"test.txt"</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> fnfe<span>)</span> <span>{</span>
    fnfe<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="四、outofmemoryerror"> 四、OutOfMemoryError</h2>
<p>部分参考自 <a href="https://www.cnblogs.com/ThinkVenus/p/6805495.html" target="_blank" rel="noopener noreferrer">什么是java OOM？如何分析及解决oom问题？</a></p>
<p>OOM，全称“Out Of Memory”，翻译成中文就是“内存用完了”，来源于java.lang.OutOfMemoryError。看下关于的官方说明： Thrown when the Java Virtual Machine cannot allocate an object because it is out of memory, and no more memory could be made available by the garbage collector. 意思就是说，当JVM因为没有足够的内存来为对象分配空间并且垃圾回收器也已经没有空间可回收时，就会抛出这个error</p>
<h3 id="_4-1-堆溢出"> 4.1 堆溢出</h3>
<p>一般的异常信息：<code>java.lang.OutOfMemoryError:Java heap spacess。</code></p>
<p>java堆用于存储对象实例，我们只要 <mark>不断的创建对象</mark>，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，就会在对象数量达到最大堆容量限制后产生内存溢出异常。</p>
<h3 id="_4-2-虚拟机栈和方法栈溢出"> 4.2 虚拟机栈和方法栈溢出</h3>
<p><mark>如果线程请求的栈深度大于虚拟机所允许的最大深度</mark>，将抛出 <code>StackOverflowError</code> 异常。</p>
<p><mark>如果虚拟机在扩展栈时无法申请到足够的内存空间</mark>，则抛出 <code>OutOfMemoryError</code> 异常</p>
<p>这里需要注意当栈的大小越大可分配的线程数就越少。</p>
<h3 id="_4-3-运行时常量池溢出"> 4.3 运行时常量池溢出</h3>
<p>异常信息：<code>java.lang.OutOfMemoryError:PermGenspace</code>
如果要向运行时常量池中添加内容，最简单的做法就是使用 <code>String.intern()</code> 这个 <code>Native</code> 方法。该方法的作用是：如果池中已经包含一个等于此 String 的字符串，则返回代表池中这个字符串的 String 对象；否则，将此 String 对象包含的字符串添加到常量池中，并且返回此 String 对象的引用。由于常量池分配在方法区内，我们可以通过 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code> 限制方法区的大小，从而间接限制其中常量池的容量</p>
<h3 id="_4-4-方法区溢出"> 4.4 方法区溢出</h3>
<p>异常信息：<code>java.lang.OutOfMemoryError:PermGenspace</code></p>
<p>方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。也有可能是方法区中保存的 class 对象没有被及时回收掉或者 class 信息占用的内存超过了我们配置。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 面向对象</title>
    <id>https://notes.lllllan.cn/java/basic/4-object/</id>
    <link href="https://notes.lllllan.cn/java/basic/4-object/"/>
    <updated>2022-04-16T06:31:12.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/75265007" target="_blank" rel="noopener noreferrer">2分钟让你明白什么是面向对象编程</a></li>
<li><a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener noreferrer">String为什么不可变 - 梦醒点灯</a></li>
<li><a href="https://www.jianshu.com/p/a343dae4a818" target="_blank" rel="noopener noreferrer">一文理解哈希冲突四种解决方法 - 简书 (jianshu.com)</a></li>
</ul>
</div>
<h2 id="一、面向对象和面向过程的区别"> 一、面向对象和面向过程的区别</h2>
<p><strong>面向过程：</strong></p>
<p>面向过程的思想会将一件事情，拆分成一个个更具体的小任务，由一个个方法去完成他们。只要按顺序执行这些方法，就能完成这件事情。</p>
<p><strong>面向对象：</strong></p>
<p>面向对象的思想会把事物抽象成对象的概念，把一件事情拆分成一个个更具体的小问题，交由不同的对象分别完成以解决问题。</p>
<p>更详细生动的说明详见 <a href="https://zhuanlan.zhihu.com/p/75265007" target="_blank" rel="noopener noreferrer">2分钟让你明白什么是面向对象编程</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">项目名称</th>
<th style="text-align:center">面向对象程序设计</th>
<th style="text-align:center">面向过程程序设计（也叫结构化编程）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。</td>
<td style="text-align:center">面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现main()函数中所要用到的其他方法。</td>
</tr>
<tr>
<td style="text-align:center">特点</td>
<td style="text-align:center">封装、继承、多态</td>
<td style="text-align:center">算法+数据结构</td>
</tr>
<tr>
<td style="text-align:center">优势</td>
<td style="text-align:center">适用于大型复杂系统，方便复用、</td>
<td style="text-align:center">适用于简单系统，容易理解</td>
</tr>
<tr>
<td style="text-align:center">劣势</td>
<td style="text-align:center">比较抽象、性能比面向过程低</td>
<td style="text-align:center">难以应对复杂系统，难以复用，不易维护、不易扩展</td>
</tr>
<tr>
<td style="text-align:center">对比</td>
<td style="text-align:center">易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td>
<td style="text-align:center">性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素</td>
</tr>
<tr>
<td style="text-align:center">设计语言</td>
<td style="text-align:center">Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等</td>
<td style="text-align:center">C、Fortran</td>
</tr>
</tbody>
</table>
<ul>
<li>
<p>因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。</p>
</li>
<li>
<p>因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</li>
</ul>
<div><p>面向对象易维护、易复用、易扩展。面向过程性能相对较高。</p>
</div>
<h2 id="二、面向对象三大特征"> 二、面向对象三大特征</h2>
<h3 id="_2-1-封装"> 2.1 封装</h3>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<div><p>封装的好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高代码的复用性</li>
<li>提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）</li>
</ul>
</div>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span><span>//id属性私有化</span>
    <span>private</span> <span>String</span> name<span>;</span><span>//name属性私有化</span>

    <span>//获取id的方法</span>
    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span> <span>return</span> id<span>;</span> <span>}</span>

    <span>//设置id的方法</span>
    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span> <span>this</span><span>.</span>id <span>=</span> id<span>;</span> <span>}</span>

    <span>//获取name的方法</span>
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span> <span>return</span> name<span>;</span> <span>}</span>

    <span>//设置name的方法</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span> <span>this</span><span>.</span>name <span>=</span> name<span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_2-2-继承"> 2.2 继承</h3>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<div><p>继承的优点</p>
<ol>
<li>提高代码的复用性</li>
<li>提高代码的易维护性</li>
<li>提高代码的可扩展性</li>
<li>使代码结构清晰</li>
</ol>
</div>
<div><p>继承的缺点</p>
<ol>
<li>高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类</li>
<li>破坏封装性、降低灵活性</li>
</ol>
</div>
<h3 id="_2-3-多态"> 2.3 多态</h3>
<p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间</strong>才能确定；</li>
<li>多态不能调用“<strong>只在子类存在但在父类不存在</strong>”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是<strong>子类覆盖</strong>的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<div><p>多态存在的必要条件</p>
<ol>
<li>要有继承</li>
<li>要有重写</li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
</div>
<div><p>多态的好处</p>
<ol>
<li>提高了代码的可扩展性</li>
<li>可替换性</li>
<li>接口性：向子类提供共同接口，由子类来完善或覆盖</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
</div>
<h2 id="三、对象和引用"> 三、对象和引用</h2>
<h3 id="_3-1-对象实体和对象引用"> 3.1 对象实体和对象引用</h3>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）；一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="_3-2-对象相等和引用相等"> 3.2 对象相等和引用相等</h3>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="_3-3-四种引用-强弱软虚"> 3.3 四种引用，强弱软虚</h3>
<ul>
<li>
<p>强引用</p>
<p>强引用是平常中使用最多的引用，强引用在程序内存不足（OOM）的时候也不会被回收，使用 方式：</p>
<div><pre><code><span>String</span> str <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"str"</span><span>)</span><span>;</span> 
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>str<span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></li>
<li>
<p>软引用</p>
<p><strong>软引用在程序内存不足时会被回收</strong>，使用方式：</p>
<div><pre><code><span>// 注意：wrf这个引用也是强引用，它是指向SoftReference这个对象的， </span>
<span>// 这里的软引用指的是指向new String("str")的引用，也就是SoftReference类中T </span>
<span>SoftReference</span> wrf <span>=</span> <span>new</span> <span>SoftReference</span><span>(</span><span>new</span> <span>String</span><span>(</span><span>"str"</span><span>)</span><span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可用场景： 创建缓存的时候，创建的对象放进缓存中，当内存不足时，JVM就会回收早先创建 的对象。</p>
</li>
<li>
<p>弱引用</p>
<p>弱引用就是只要JVM<strong>垃圾回收器发现了它就会将之回收</strong>，使用方式：</p>
<div><pre><code><span>WeakReference</span> wrf <span>=</span> <span>new</span> <span>WeakReference</span><span>(</span>str<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>可用场景： Java源码中的 java.util.WeakHashMap 中的 key 就是使用弱引用，我的理解就是， 一旦我不需要某个引用，JVM会自动帮我处理它，这样我就不需要做其它操作。</p>
</li>
<li>
<p>虚引用</p>
<p>虚引用的回收机制跟弱引用差不多，但是它被回收之前，会被放入 ReferenceQueue 中。注意 哦，其它引用是被JVM回收后才被传入 ReferenceQueue 中的。由于这个机制，所以虚引用大多 被用于引用销毁前的处理工作。还有就是，虚引用创建的时候，必须带有 ReferenceQueue ， 使用例子：</p>
<div><pre><code><span>PhantomReference</span> prf <span>=</span> <span>new</span> <span>PhantomReference</span><span>(</span><span>new</span> <span>String</span><span>(</span><span>"str"</span><span>)</span><span>,</span> <span>new</span> <span>ReferenceQueue</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span> 
</code></pre>
<div><span>1</span><br></div></div><p>可用场景： 对象销毁前的一些操作，比如说资源释放等。 Object.finalize() 虽然也可以做这 类动作，但是这个方式即不安全又低效</p>
</li>
</ul>
<h3 id="_3-4-创建对象的四种方式"> 3.4 创建对象的四种方式</h3>
<ol>
<li>new创建新对象</li>
<li>通过反射机制</li>
<li>采用clone机制</li>
<li>通过序列化机制</li>
</ol>
<h2 id="四、抽象类和接口的区别"> 四、抽象类和接口的区别</h2>
<ol>
<li>抽象类中可以定义构造函数，接口不能定义构造函数</li>
<li>抽象类中可以有抽象方法和具体方法，接口中只能有抽象方法</li>
<li>抽象类中的成员权限可以是 <code>public</code>、默认、<code>protected</code>，<strong>抽象方法不能被 <code>private</code> 修饰</strong>，具体方法可以；接口中的成员只能是 <code>public</code></li>
<li>抽象类中可以包含静态方法（<strong>具体方法可以是静态的，抽象方法不行</strong>），接口中不能包含静态方法（因为接口中定义的方法就是为了让实现类去实现，但是静态方法必须在编译时实现）</li>
</ol>
<div><p>JDK8 的改变</p>
<ol>
<li>允许在接口中包含具体实现的方法，使用 <code>default</code> 修饰</li>
<li>因为允许具体实现的方法，接口中也就允许有静态方法</li>
</ol>
</div>
<h2 id="五、比较方法"> 五、比较方法</h2>
<h3 id="_5-1-和-equals-的区别"> 5.1 == 和 equals() 的区别</h3>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<div><p>Java 只有值传递</p>
<p>所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</div>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<div><p>Object.equals()</p>
<p>如果没有对该方法进行重写，<code>Object</code> 中的 <code>equals()</code> 方法仍然是 == 比较。</p>
</div>
<h3 id="_5-2-hashcode-与-equals"> 5.2 hashCode() 与 equals()</h3>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>更多解释见  <a href="https://javaguide.cn/java/basis/java-basic-questions-01/#hashcode-%E4%B8%8E-equals" target="_blank" rel="noopener noreferrer">Java基础常见知识&amp;面试题总结(上) | JavaGuide</a></p>
<div><p>hashCode的作用</p>
<p>hashCode和equals有一个相同的作用，就是用作比较：</p>
<ul>
<li>equals 为true的两个对象相等，false则两个对象不相等</li>
<li>hashCode 相同的两个对象不一定相等，但不同的两个对象一定不相等</li>
</ul>
</div>
<div><p>为什么要有 hashCode？</p>
<p><strong>效率</strong>
当一个对象逐渐复杂时，equals方法中的判定条件也会逐渐复杂，这个时候比较两个对象是否相等依旧使用equals的话，就会变得低效。</p>
<p>因此引出hashCode，通过一定的计算方式，为每个对象分配一个“哈希码”，让相等的对象都拥有相同的哈希码。之后需要比较两个对象的时候，先比较哈希码，如果哈希码都不相同，两个对象一定不相等。如果哈希码相同，再继续使用equals确定对象是否相等。</p>
<p>hashCode 方法相对与 equals 会更加高效，通过这两步判断，来确定两个对象是否相等</p>
</div>
<h2 id="六、构造方法"> 六、构造方法</h2>
<h3 id="_6-1-构造方法的特点"> 6.1 构造方法的特点</h3>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<div><p>Tips</p>
<p>构造方法不能被 override（重写），但是可以 overload（重载），所以你可以看到一个类中有多个构造函数的情况。</p>
</div>
<h3 id="_6-2-无参构造函数的作用"> 6.2 无参构造函数的作用</h3>
<ol>
<li>不写任何构造器，也会有一个默认的无参构造。但如果写了有参构造，就必须另写一个无参构造，否则就无法执行无参构造。</li>
<li>子类的构造当中，如果没有指定 super() 来调用父类中某个构造方法，则会调用父类中的无参构。如果这个时候父类中存在有参构造而没有无参构造，就会出错。</li>
</ol>
<h3 id="_6-3-构造器是否可以被重写"> 6.3 构造器是否可以被重写？</h3>
<p>父类的私有属性、方法以及构造器都是不能被重写的。</p>
<h2 id="七、-string、stringbuffer、stringbuilder"> 七、 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code></h2>
<h3 id="_7-1-string-为什么是不可变的"> 7.1 <code>String</code> 为什么是不可变的</h3>
<p>详细参考 <a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener noreferrer">String为什么不可变 - 梦醒点灯</a></p>
<p>在Java中String类其实就是对字符数组的封装。</p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h3 id="_7-2-string-真的不可变吗"> 7.2 <code>String</code> 真的不可变吗？</h3>
<p>以下内容转载自 <a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener noreferrer">String为什么不可变 - 梦醒点灯</a></p>
<p>String的成员变量是private final 的，也就是初始化之后不可改变。那么在这几个成员中， value比较特殊，因为他是一个引用变量，而不是真正的对象。value是final修饰的，也就是说final不能再指向其他数组对象，那么我能改变value指向的数组吗？</p>
<p><strong>反射</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>testReflection</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
     
    <span>//创建字符串"Hello World"， 并赋给引用s</span>
    <span>String</span> s <span>=</span> <span>"Hello World"</span><span>;</span> 
     
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s = "</span> <span>+</span> s<span>)</span><span>;</span> <span>//Hello World</span>
     
    <span>//获取String类中的value字段</span>
    <span>Field</span> valueFieldOfString <span>=</span> <span>String</span><span>.</span><span>class</span><span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
     
    <span>//改变value属性的访问权限</span>
    valueFieldOfString<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
     
    <span>//获取s对象上的value属性的值</span>
    <span>char</span><span>[</span><span>]</span> value <span>=</span> <span>(</span><span>char</span><span>[</span><span>]</span><span>)</span> valueFieldOfString<span>.</span><span>get</span><span>(</span>s<span>)</span><span>;</span>
     
    <span>//改变value所引用的数组中的第5个字符</span>
    value<span>[</span><span>5</span><span>]</span> <span>=</span> <span>'_'</span><span>;</span>
     
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"s = "</span> <span>+</span> s<span>)</span><span>;</span>  <span>//Hello_World</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><p>打印结果为：</p>
<div><pre><code>s <span>=</span> <span>Hello</span> <span>World</span>
s <span>=</span> <span>Hello_World</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>在这个过程中，s始终引用的同一个String对象，但是再反射前后，这个String对象发生了变化， 也就是说，通过反射是可以修改所谓的【不可变】对象的。但是一般我们不这么做。这个反射的实例还可以说明一个问题：如果一个对象，他组合的其他对象的状态是可以改变的，那么这个对象很可能不是不可变对象。例如一个Car对象，它组合了一个Wheel对象，虽然这个Wheel对象声明成了private final 的，但是这个Wheel对象内部的状态可以改变， 那么就不能很好的保证Car对象不可变。</p>
<h3 id="_7-3-stringbuffer、stringbuilder"> 7.3 <code>StringBuffer</code>、<code>StringBuilder</code></h3>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> value<span>;</span>
    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>
        str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> value<span>,</span> count<span>)</span><span>;</span>
        count <span>+=</span> len<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
  	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_7-4-线程安全性"> 7.4 线程安全性</h3>
<div><p>Tips</p>
<p><code>String</code>、<code>StringBuffer</code> 是线程安全的，<code>StringBuilder</code> 非线程安全。</p>
</div>
<ul>
<li><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</li>
<li><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。
<ul>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li>
<li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
</li>
</ul>
<h3 id="_7-5-性能"> 7.5 性能</h3>
<p><code>StringBuilder</code> &gt; <code>StringBuffer</code> &gt; <code>String</code></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h2 id="八、-object-类的常见方法"> 八、 <code>Object</code> 类的常见方法</h2>
<div><pre><code><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>
<span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span>
    
<span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> 
    
<span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span>
    
<span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>
<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span>
    
<span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span>

<span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//实例被垃圾回收器回收的时候触发的操作</span>
<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h2 id="九、深拷贝和浅拷贝、引用拷贝"> 九、深拷贝和浅拷贝、引用拷贝</h2>
<div><p>Tips</p>
<p><strong>浅拷贝</strong>：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用仍然指 向原来的对象。换言之，<mark>浅拷贝仅仅复制所考虑的对象，而不复制它所引用的对象</mark></p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</div>
<p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="./README.assets/shallow&amp;deep-copy.64ee0760.png" alt="img" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - IO</title>
    <id>https://notes.lllllan.cn/java/basic/8-io/</id>
    <link href="https://notes.lllllan.cn/java/basic/8-io/"/>
    <updated>2022-04-10T01:45:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
<li><a href="https://blog.csdn.net/lisulong1/article/details/52269262" target="_blank" rel="noopener noreferrer">Java序列化之排除被序列化字段(transient/静态变量</a></li>
</ul>
</div>
<h2 id="一、-反-序列化"> 一、（反）序列化</h2>
<p>理解序列化 -&gt; <a href="https://zhuanlan.zhihu.com/p/40462507" target="_blank" rel="noopener noreferrer">序列化理解起来很简单</a></p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h3 id="_1-1-为什么要序列化"> 1.1 为什么要序列化？</h3>
<blockquote>
<p>序列化最终的目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p>
</blockquote>
<p>我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</p>
<p>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则 <strong>（序列化）</strong>，那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来 <strong>（反序列化）</strong></p>
<p>如果我们要把一栋房子从一个地方运输到另一个地方去，<strong>序列化</strong>就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，<strong>反序列化</strong>就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</p>
<h3 id="_1-2-什么时候需要序列化"> 1.2 什么时候需要序列化？</h3>
<p>凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。</p>
<p>本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。</p>
<h2 id="二、如果有些字段不想进行序列化"> 二、如果有些字段不想进行序列化</h2>
<p>参考 <a href="https://blog.csdn.net/lisulong1/article/details/52269262" target="_blank" rel="noopener noreferrer">Java序列化之排除被序列化字段(transient/静态变量</a></p>
<p>我们都知道一个对象只要实现了Serilizable接口，这个对象就可以被序列化，java的这种序列化模式为开发者提供了很多便利，我们可以不必关系具体序列化的过程，只要这个类实现了Serilizable接口，这个类的所有属性和方法都会自动序列化。</p>
<p>然而在实际开发过程中，我们常常会遇到这样的问题，这个类的有些属性需要序列化，而其他属性不需要被序列化，打个比方，<strong>如果一个用户有一些敏感信息（如密码，银行卡号等），为了安全起见，不希望在网络操作（主要涉及到序列化操作，本地序列化缓存也适用）中被传输</strong>，这些信息对应的变量就可以加上transient关键字。换句话说，这个字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。</p>
<p>总之，java 的transient关键字为我们提供了便利，你只需要实现Serilizable接口，将不需要序列化的属性前添加关键字transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</p>
<p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p>
<p>transient 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化 时，被 transient 修饰的变量值不会被持久化和恢复。transient 只能修饰变量，不能修饰类和方 法。</p>
<h2 id="三、获取用键盘输入常用的两种方法"> 三、获取用键盘输入常用的两种方法</h2>
<ol>
<li><code>Scanner</code></li>
</ol>
<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>String</span> s  <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>
input<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li><code>BufferedReader</code></li>
</ol>
<div><pre><code><span>BufferedReader</span> input <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>
<span>String</span> s <span>=</span> input<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h2 id="四、io流分类"> 四、IO流分类</h2>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流（<strong>对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写</strong>）。</li>
</ul>
<p><img src="./README.assets/IO-操作方式分类.png" alt="IO-操作方式分类" loading="lazy"></p>
<p><img src="./README.assets/IO-操作对象分类.png" alt="IO-操作对象分类" loading="lazy"></p>
<h2 id="五、字符流的意义"> 五、字符流的意义</h2>
<p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java - 反射</title>
    <id>https://notes.lllllan.cn/java/basic/5-reflection/</id>
    <link href="https://notes.lllllan.cn/java/basic/5-reflection/"/>
    <updated>2022-04-10T01:45:19.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></li>
</ul>
</div>
<h2 id="一、什么是反射"> 一、什么是反射</h2>
<p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。</p>
<p>而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）语言的一个关键性质。</p>
<h2 id="二、反射能做什么"> 二、反射能做什么？</h2>
<p>我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！</p>
<h2 id="三、反射机制优缺点"> 三、反射机制优缺点</h2>
<ul>
<li><strong>优点</strong> ： 可以让代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h2 id="四、反射的应用场景"> 四、反射的应用场景</h2>
<ul>
<li>模块化的开发，通过反射去调用对应的字节码</li>
<li>框架中大量使用动态代理，而动态代理依赖反射机制实现</li>
<li>注解的实现也用到了反射</li>
</ul>
<p><strong>JDBC的数据库连接</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>String</span> DBDRIVER <span>=</span> <span>"com.mysql.jdbc.Driver"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBURL <span>=</span> <span>"jdbc:mysql://localhost:3306/test"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBUSER <span>=</span> <span>"root"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBPASS <span>=</span> <span>""</span><span>;</span>  

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>  
    <span>Connection</span> con <span>=</span> <span>null</span><span>;</span>
    <span>Class</span><span>.</span><span>forName</span><span>(</span>DBDRIVER<span>)</span><span>;</span> <span>//1、使用CLASS 类加载驱动程序 ,反射机制的体现 </span>
    con <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>DBURL<span>,</span>DBUSER<span>,</span>DBPASS<span>)</span><span>;</span> <span>//2、连接数据库  </span>
    <span>.</span><span>.</span><span>.</span>
    con<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> <span>// 3、关闭数据库  </span>
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="五、反射的使用"> 五、反射的使用</h2>
<h3 id="_5-1-获取-class-对象的四种方式"> 5.1 获取 Class 对象的四种方式</h3>
<p><strong>1.知道具体类的情况下可以使用</strong></p>
<div><pre><code><span>Class</span> <span>class</span> <span>=</span> <span>TargetObject</span><span>.</span><span>class</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2.通过 <code>Class.forName()</code> 传入类的路径获取</strong></p>
<div><pre><code><span>Class</span> <span>class</span> <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>3.通过对象实例 <code>instance.getClass()</code> 获取</strong></p>
<div><pre><code><span>TargetObject</span> o <span>=</span> <span>new</span> <span>TargetObject</span><span>(</span><span>)</span><span>;</span>
<span>Class</span> <span>class</span> <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取</strong></p>
<div><pre><code><span>Class</span> <span>class</span> <span>=</span> <span>ClassLoader</span><span>.</span><span>loadClass</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_5-2-反射的基本操作"> 5.2 反射的基本操作</h3>
<p><strong>1.定义一个类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>TargetObject</span> <span>{</span>
    <span>private</span> <span>String</span> value<span>;</span>

    <span>public</span> <span>TargetObject</span><span>(</span><span>)</span> <span>{</span>
        value <span>=</span> <span>"JavaGuide"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>publicMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I love "</span> <span>+</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>privateMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"value is "</span> <span>+</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>2.使用反射来操作这个类的方法及参数</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span><span>,</span> <span>NoSuchMethodException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InstantiationException</span><span>,</span> <span>InvocationTargetException</span><span>,</span> <span>NoSuchFieldException</span> <span>{</span>
        <span>/**
         * 获取TargetObject类的Class对象并且创建TargetObject类实例
         */</span>
        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
        <span>TargetObject</span> targetObject <span>=</span> <span>(</span><span>TargetObject</span><span>)</span> tagetClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>/**
         * 获取所有类中所有定义的方法
         */</span>
        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> tagetClass<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>/**
         * 获取指定方法并调用
         */</span>
        <span>Method</span> publicMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"publicMethod"</span><span>,</span>
                <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>

        publicMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 获取指定参数并对参数进行修改
         */</span>
        <span>Field</span> field <span>=</span> tagetClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
        <span>//为了对类中的参数进行修改我们取消安全检查</span>
        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        field<span>.</span><span>set</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 调用 private 方法
         */</span>
        <span>Method</span> privateMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"privateMethod"</span><span>)</span><span>;</span>
        <span>//为了调用private方法我们取消安全检查</span>
        privateMethod<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        privateMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>3.输出结果</strong></p>
<div><pre><code>publicMethod
privateMethod
<span>I</span> love <span>JavaGuide</span>
value is <span>JavaGuide</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">常见面试题</title>
    <id>https://notes.lllllan.cn/java/basic/</id>
    <link href="https://notes.lllllan.cn/java/basic/"/>
    <updated>2022-04-16T06:31:12.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.cnblogs.com/54chensongxia/p/12470446.html" target="_blank" rel="noopener noreferrer">什么是fail-fast - 程序员自由之路 - 博客园 (cnblogs.com)</a></li>
</ul>
</div>
<h2 id="java程序是如何执行的"> Java程序是如何执行的</h2>
<ol>
<li>Java 代码编译成字节码。Java 源代码 → 词法分析器 → 语义分析器 → 字节码</li>
<li>Java 虚拟机使用类加载器装在 class 文件</li>
<li>字节码校验，解释器翻译成机器码</li>
</ol>
<p><img src="./README.assets/5-1ZZ41409331Y.png" alt="img" loading="lazy"></p>
<h2 id="哈希冲突的解决办法"> 哈希冲突的解决办法</h2>
<p><a href="https://www.jianshu.com/p/a343dae4a818" target="_blank" rel="noopener noreferrer">一文理解哈希冲突四种解决方法 - 简书 (jianshu.com)</a></p>
<p><a href="https://blog.csdn.net/weixin_41167848/article/details/91356737" target="_blank" rel="noopener noreferrer">哈希冲突_Juliussss的博客-CSDN博客_哈希冲突</a></p>
<p>哈希是通过对数据进行再压缩，提高效率的一种解决方法。但由于通过哈希函数产生的哈希值是有限的，而数据可能比较多，导致经过哈希函数处理后仍然有不同的数据对应相同的索引值。这时候就产生了哈希冲突<strong>两个值都需要同一个地址索引位置</strong>）。</p>
<p>解决办法：</p>
<ol>
<li>开放地址方法（再散列法）
<ol>
<li>线性探测</li>
<li>平方探测</li>
<li>伪随机探测</li>
</ol>
</li>
<li>链式地址法</li>
<li>再哈希法</li>
<li>创建公共溢出区</li>
</ol>
<h2 id="fail-fast-机制"> fail-fast 机制</h2>
<p><strong>fail-fast是一种错误检测机制，一旦检测到可能发生错误，就立马抛出异常，程序不继续往下执行。</strong></p>
<p>在集合当中，会维护一个 <code>modCount</code>值，当使用 add、remove 等涉及改变集合元素个数的方法时就会修改这个值；而集合在遍历过程中，发现这个值和原先不同，表示可能有另一个线程在对这个集合进行操作（只是可能，因为自己也可以操作）。又因为很多集合是不保证线程安全的（保证线程安全代表着效率降低，这是一种取舍），于是通过 fail-fast 这种机制，检测到有可能出现错误，就抛出异常，不让程序继续往下执行。</p>
<p><a href="https://www.cnblogs.com/54chensongxia/p/12470446.html" target="_blank" rel="noopener noreferrer">什么是fail-fast - 程序员自由之路 - 博客园 (cnblogs.com)</a></p>
<p><a href="https://blog.csdn.net/chenssy/article/details/38151189" target="_blank" rel="noopener noreferrer">Java提高篇（三四）-----fail-fast机制_Java 技术驿站的博客-CSDN博客_fail fast</a></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-10T01:42:13.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第一章、进程与线程的基本概念</title>
    <id>https://notes.lllllan.cn/java/concurrent/1/1/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/1/1/"/>
    <updated>2022-04-18T07:24:57.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/blob/develop/article/01/1.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第一章 - GitHub</a></li>
<li><a href="https://blog.csdn.net/whl_program/article/details/70217354" target="_blank" rel="noopener noreferrer">进程和线程的由来与区别</a></li>
<li><a href="https://www.cnblogs.com/jijijiefang/articles/7222955.html" target="_blank" rel="noopener noreferrer">线程的几种状态转换</a></li>
</ul>
</div>
<h2 id="一、进程的由来"> 一、进程的由来</h2>
<h3 id="_1-1-操作系统"> 1.1 操作系统</h3>
<p>人力计算（成本大、错误多） → 计算机计算（一条指令一个操作）</p>
<p>当用户在思考或者输入时，计算机就在等待。显然这样<strong>效率低下，在很多时候，计算机都处在等待状态</strong>。</p>
<h3 id="_1-2-批处理操作体统"> 1.2 批处理操作体统</h3>
<p>→ 批处理操作系统（指令清单，逐条执行）</p>
<p>但是由于批处理操作系统的 <strong>指令运行方式仍然是串行的，内存中始终只有一个程序在运行</strong>，后面的程序需要等待前面的程序执行完成后才能开始执行，而前面的程序有时会由于 I/O 操作、网络等 原因阻塞，所以<strong>批处理操作效率也不高</strong></p>
<blockquote>
<p>假如有两个任务 A 和 B，需要读取大量的数据输入（I/O 操作），而其实CPU只能处在等待状态，等任务 A 读取完数据再能继续进行，这样就白白浪费了 CPU 资源。</p>
</blockquote>
<h3 id="_1-3-进程"> 1.3 进程</h3>
<p>这时候，人们就发明了进程，用进程来对应一个程序，每个进程来对应一定的内存地址空间。此时，CPU 采用时间片轮转的方式运行进程：CPU 为每个进程分配一个时间段，称作它的时间片。如果在时间片结束时进程还在运行，则暂停这个进程的运行，并且 CPU 分配给另一个进程（这个过程叫做 <strong>上下文切换</strong>）。如果进程在时间片结束前阻塞或结束，则CPU立即进行切换，不用等待时间片用完。</p>
<div><p>进程</p>
<p>进程就是应用程序在内存中分配的空间，也就是正在运行的程序，各个进程之间互不干扰</p>
</div>
<h2 id="二、线程的由来"> 二、线程的由来</h2>
<p>进程：一段时间只能做一件事情，效率低下</p>
<blockquote>
<p>比如当你使用杀毒软件中的扫描病毒功能时，在扫描病毒结束之前，无法使用杀毒软件中清理垃圾的功能，这显然无法满足人们的要求。</p>
</blockquote>
<p>于是人们又提出了线程的概念，让一个线程执行一个子任务，这样一个进程就包含了多个线程，每个线程负责一个单独的子任 务。</p>
<blockquote>
<p>使用线程之后，事情就变得简单多了。当用户使用扫描病毒功能时，就让扫描病毒这个线程去执行。同时，如果用户又使用清理垃圾功能，那么可以先暂停扫描病毒线程，先响应用户的清理垃圾的操作，让清理垃圾这个线程去执行。响应完后再切换回来，接着执行扫描病毒线程。</p>
</blockquote>
<h2 id="三、进程和线程的区别"> 三、进程和线程的区别</h2>
<p>进程是一个独立的运行环境，而线程是在进程中执行的一个任务。他们两个本质的区别是 <mark>是否单独占有内存地址空间及其它系统资源（比如 I/O）</mark></p>
<ul>
<li>进程单独占有一定的内存地址空间，所以进程间存在内存隔离，数据是分开的，<strong>数据共享复杂但是同步简单</strong>，各个进程之间互不干扰；而线程共享所属进程占有的内存地址空间和资源，数据共享简单，但是同步复杂。</li>
<li>进程单独占有一定的内存地址空间，一个进程出现问题不会影响其他进程，不影响主程序的稳定性，<strong>可靠性高</strong>；一个线程崩溃可能影响整个程序的稳定性， 可靠性较低。</li>
<li>进程单独占有一定的内存地址空间，进程的创建和销毁不仅需要保存寄存器和栈信息，还需要资源的分配回收以及页调度，<strong>开销较大</strong>；线程只需要保存寄存器和栈信息，开销较小</li>
</ul>
<p>另外一个重要区别是，<mark>进程是操作系统进行资源分配的基本单位，而线程是操作系统进行调度的基本单位</mark>，即 CPU 分配时间的单位 。</p>
<h2 id="四、多进程和多线程"> 四、多进程和多线程</h2>
<p>多进程方式确实可以实现并发，但使用多线程，有以下几个好处：</p>
<ul>
<li>进程间的通信比较复杂，而线程间的 <strong>通信比较简单</strong>，通常情况下，我们需要使用共享资源，这些资源在线程间的通信比较容易。</li>
<li>进程是重量级的，而线程是轻量级的，故多线程方式的 <strong>系统开销更小</strong>。</li>
</ul>
<h2 id="五、上下文切换"> 五、上下文切换</h2>
<div><p>上下文切换</p>
<p>（有时也称做进程切换或任务切换）是指 CPU 从一个进程（或线程） 切换到另一个进程（或线程）。</p>
<p><mark>上下文是指某一时间点 CPU 寄存器和程序计数器的内容</mark></p>
</div>
<p>CPU 通过为每个线程分配 CPU 时间片来实现多线程机制。CPU 通过时间片分配算法来循环执行任务，当前任务执行一个时间片后会切换到下一个任务。 但是，在切换前会保存上一个任务的状态，以便下次切换回这个任务时，可以再加载这个任务的状态。所以任务从保存到再加载的过程就是一次上下文切换。 上下文切换通常是计算密集型的，意味着此操作会 <strong>消耗大量的 CPU 时间，故线程也不是越多越好</strong>。如何减少系统中上下文切换次数，是提升多线程性能的一个重点课题。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第二章、Java多线程入门类和接口</title>
    <id>https://notes.lllllan.cn/java/concurrent/1/2/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/1/2/"/>
    <updated>2022-04-18T07:29:17.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/01/2.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第二章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、thread-类和-runnable-接口"> 一、Thread 类和 Runnable 接口</h2>
<p>JDK提供了 <code>Thread</code> 类和 <code>Runnable</code> 接口来让我们实 现自己的【线程】类。</p>
<ul>
<li>继承 <code>Thread</code> 类，并重写 <code>run</code> 方法；</li>
<li>实现 <code>Runnable</code> 接口的 <code>run</code> 方法；</li>
</ul>
<h3 id="_1-1-继承-thread-类"> 1.1 继承 Thread 类</h3>
<p>注意要调用 start() 方法后，该线程才算启动</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"MyThread"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Thread</span> myThread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>
        myThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><blockquote>
<p>我们在程序里面调用了 <code>start()</code> 方法后，虚拟机会先为我们创建一个线程，然 后等到这个线程第一次得到时间片时再调用 <code>run()</code> 方法。</p>
<p><mark>注意不可多次调用 <code>start()</code> 方法。在第一次调用 <code>start()</code> 方法后，再次调用 <code>start()</code> 方法会抛出<code>IllegalThreadStateException</code>异常。</mark></p>
</blockquote>
<h3 id="_1-2-实现-runnable-接口"> 1.2 实现 Runnable 接口</h3>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Runnable</span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Runnable 是一个函数式接口，这意味着我们可以使用Java 8的函数式编程来简化代码。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"MyThread"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>// Java 8 函数式编程，可以省略MyThread类</span>
        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Java 8 匿名内部类"</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="二、thread-类"> 二、Thread 类</h2>
<h3 id="_2-1-thread-的构造方法"> 2.1 Thread 的构造方法</h3>
<div><pre><code><span>// Thread类源码</span>
<span>// 片段1 - init方法</span>
<span>private</span> <span>void</span> <span>init</span><span>(</span><span>ThreadGroup</span> g<span>,</span> <span>Runnable</span> target<span>,</span> <span>String</span> name<span>,</span>
                  <span>long</span> stackSize<span>,</span> <span>AccessControlContext</span> acc<span>,</span>
                  <span>boolean</span> inheritThreadLocals<span>)</span>
    
<span>// 片段2 - 构造函数调用init方法</span>
<span>public</span> <span>Thread</span><span>(</span><span>Runnable</span> target<span>)</span> <span>{</span>
    <span>init</span><span>(</span><span>null</span><span>,</span> target<span>,</span> <span>"Thread-"</span> <span>+</span> <span>nextThreadNum</span><span>(</span><span>)</span><span>,</span> <span>0</span><span>)</span><span>;</span>
<span>}</span>
<span>// 片段3 - 使用在init方法里初始化AccessControlContext类型的私有属性</span>
<span>this</span><span>.</span>inheritedAccessControlContext <span>=</span> 
    acc <span>!=</span> <span>null</span> <span>?</span> acc <span>:</span> <span>AccessController</span><span>.</span><span>getContext</span><span>(</span><span>)</span><span>;</span>

<span>// 片段4 - 两个对用于支持ThreadLocal的私有属性</span>
<span>ThreadLocal<span>.</span>ThreadLocalMap</span> threadLocals <span>=</span> <span>null</span><span>;</span>
<span>ThreadLocal<span>.</span>ThreadLocalMap</span> inheritableThreadLocals <span>=</span> <span>null</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>
<p>g：线程组，指定这个线程是在哪个线程组下</p>
</li>
<li>
<p>target：指定要执行的任务</p>
</li>
<li>
<p>name：线程的名字，多个线程的名字是可以重复的。如果不指定名字，见片段2</p>
</li>
<li>
<p>acc：见片段3，用于初始化私有变量 <code>inheritedAccessControlContext</code></p>
<blockquote>
<p>这个变量有点神奇。它是一个私有变量，但是在 Thread 类里只 有 init 方法对它进行初始化，在 exit 方法把它设为 null 。其它没有任何地方使用它。一般我们是不会使用它的，那什么时候会使用到这个变量呢？可以参考这个stackoverflow的问题：<a href="https://stackoverflow.com/questions/13516766/restricting-permissions-of-threads-that-execute-third-party-software" target="_blank" rel="noopener noreferrer">java - Restricting permissions of threads that execute third party software - Stack Overflow</a></p>
</blockquote>
</li>
<li>
<p>inheritThreadLocals：可继承的 ThreadLocal ，见片段4， Thread 类里面有两个私有属性来支持 ThreadLocal ，我们会在后面的章节介绍 ThreadLocal 的概念</p>
</li>
</ul>
<p>实际情况下，我们大多是直接调用下面两个构造方法：</p>
<div><pre><code><span>Thread</span><span>(</span><span>Runnable</span> target<span>)</span> 
<span>Thread</span><span>(</span><span>Runnable</span> target<span>,</span> <span>String</span> name<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-2-thread-类的几个常用方法"> 2.2 Thread 类的几个常用方法</h3>
<ul>
<li><code>currentThread()</code>：静态方法，返回对当前正在执行的线程对象的引用；</li>
<li><code>start()</code>：开始执行线程的方法，java虚拟机会调用线程内的run()方法；</li>
<li><code>yield()</code>：指的是当前线程愿意让出对当前处理器的占用。这里需要注意的是，<mark>就算当前线程调用了yield() 方法，程序在调度的时候，也还有可能继续运行这个线程的</mark></li>
<li><code>sleep()</code>：静态方法，使当前线程睡眠一段时间；</li>
<li><code>join()</code>：使当前线程等待另一个线程执行完毕之后再继续执行，内部调用的是 Object类的wait方法实现的</li>
</ul>
<h2 id="三、thread类与runnable接口的比较"> 三、Thread类与Runnable接口的比较</h2>
<ul>
<li>由于 Java【单继承，多实现】的特性，Runnable 接口使用起来比 Thread <strong>更灵活</strong>。</li>
<li>Runnable 接口出现更符合面向对象，将线程单独进行对象的封装。</li>
<li>Runnable 接口出现，<strong>降低了线程对象和线程任务的耦合性</strong>。</li>
<li>如果使用线程时不需要使用 Thread 类的诸多方法，显然使用 Runnable 接口 <strong>更为轻量</strong>。</li>
</ul>
<p>我们通常优先使用【实现 Runnable 接口】这种方式来自定义线程类</p>
<h2 id="四、callable、future与futuretask"> 四、Callable、Future与FutureTask</h2>
<p>通常来说，我们使用 Runnable 和 Thread 来创建一个新的线程。但是它们有一个弊端，<strong>就是 run 方法是没有返回值</strong>的。而有时候我们希望开启一个线程去执行一个任务，并且这个任务执行完成后有一个返回值。</p>
<p>JDK提供了 <code>Callable</code> 接口与 <code>Future</code> 接口为我们解决这个问题，这也是所谓的 <mark>异步模型</mark></p>
<h3 id="_4-1-callable接口"> 4.1 Callable接口</h3>
<p><code>Callable</code> 与 <code>Runnable</code> 类似，同样是只有一个抽象方法的函数式接口。不同的 是， Callable 提供的方法是有<strong>返回值的，而且支持泛型。</strong></p>
<div><pre><code><span>@FunctionalInterface</span>
<span>public</span> <span>interface</span> <span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>
    <span>V</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><code>Callable</code> 一般是配合线程池工具 <code>ExecutorService</code> 来使用的。 这里只介绍 <code>ExecutorService</code> 可以使用 <code>submit</code> 方法来让一个 <code>Callable</code> 接口执行。它会返回一 个 <code>Future</code> ，我们后续的程序可以通过这个 Future 的 get 方法得到结果。</p>
<div><pre><code><span>// 自定义Callable</span>
<span>class</span> <span>Task</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>Integer</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>// 模拟计算需要一秒</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>return</span> <span>2</span><span>;</span>
    <span>}</span>
    	
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>// 使用</span>
        <span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>
        <span>Task</span> task <span>=</span> <span>new</span> <span>Task</span><span>(</span><span>)</span><span>;</span>
        <span>Future</span><span><span>&lt;</span><span>Integer</span><span>></span></span> result <span>=</span> executor<span>.</span><span>submit</span><span>(</span>task<span>)</span><span>;</span>
        <span>// 注意调用get方法会阻塞当前线程，直到得到结果。</span>
        <span>// 所以实际编码中建议使用可以设置超时时间的重载get方法。</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>result<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span> 
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code><span>2</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_4-2-future接口"> 4.2 Future接口</h3>
<div><pre><code><span>public</span> <span>abstract</span> <span>interface</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>
    <span>public</span> <span>abstract</span> <span>boolean</span> <span>cancel</span><span>(</span><span>boolean</span> paramBoolean<span>)</span><span>;</span>
    <span>public</span> <span>abstract</span> <span>boolean</span> <span>isCancelled</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>abstract</span> <span>boolean</span> <span>isDone</span><span>(</span><span>)</span><span>;</span>
    <span>public</span> <span>abstract</span> <span>V</span> <span>get</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>;</span>
    <span>public</span> <span>abstract</span> <span>V</span> <span>get</span><span>(</span><span>long</span> paramLong<span>,</span> <span>TimeUnit</span> paramTimeUnit<span>)</span>
        <span>throws</span> <span>InterruptedException</span><span>,</span> <span>ExecutionException</span><span>,</span> <span>TimeoutException</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>cancel 方法是试图取消一个线程的执行。</p>
<p>注意是 <strong>试图取消</strong>，并不一定能取消成功。因为任务可能已完成、已取消、或者一些其它因素不能取消，存在取消失败的可能。</p>
<p>boolean 类型的返回值是【是否取消成功】的意思。参数 <code>paramBoolean</code> 表示 <strong>是否采用中断的方式取消线程执行</strong>。</p>
<p>所以有时候，为了让任务有能够取消的功能，就使用 <code>Callable</code> 来代替 <code>Runnable</code> 。如果为了可取消性而使用 <code>Future</code> 但又不提供可用的结果，则可以声明 Future 形式类型、并返回 null 作为底层任务的结果。</p>
<h3 id="_4-3-futuretask类"> 4.3 FutureTask类</h3>
<p><code>Future</code> 接口有一个实现类叫 <code>FutureTask</code> 。</p>
<p><code>FutureTask</code> 是实现 的 <code>RunnableFuture</code> 接口的，而 <code>RunnableFuture</code> 接口同时继承了 <code>Runnable</code> 接口 和 <code>Future</code> 接口</p>
<div><pre><code><span>public</span> <span>interface</span> <span>RunnableFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>extends</span> <span>Runnable</span><span>,</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>
    <span>/**
 	 * Sets this Future to the result of its computation
 	 * unless it has been cancelled.
 	 */</span>
    <span>void</span> <span>run</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>Future 只是 一个接口，而它里面的 <code>cancel</code> ，<code>get</code> ， <code>isDone</code> 等方法要自己实现起来都是非常复杂的。所以JDK提供了一个 FutureTask 类来供我们使用。</p>
<div><pre><code><span>// 自定义Callable，与上面一样</span>
<span>class</span> <span>Task</span> <span>implements</span> <span>Callable</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>{</span>
    <span>@Override</span>
    <span>public</span> <span>Integer</span> <span>call</span><span>(</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>// 模拟计算需要一秒</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>return</span> <span>2</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>
        <span>// 使用</span>
        <span>ExecutorService</span> executor <span>=</span> <span>Executors</span><span>.</span><span>newCachedThreadPool</span><span>(</span><span>)</span><span>;</span>
        <span>FutureTask</span><span><span>&lt;</span><span>Integer</span><span>></span></span> futureTask <span>=</span> <span>new</span> <span>FutureTask</span><span><span>&lt;</span><span>></span></span><span>(</span><span>new</span> <span>Task</span><span>(</span><span>)</span><span>)</span><span>;</span>
        executor<span>.</span><span>submit</span><span>(</span>futureTask<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>futureTask<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><ul>
<li>调用 submit 方法是没有返回值的。 这里实际上是调用的 submit(Runnable task) 方法，而上面的 Demo，调用的 是 submit(Callable task) 方法。</li>
<li>是使用 FutureTask 直接取 get 取值，而上面的Demo是通过 submit 方法 返回的 Future 去取值</li>
<li>在很多高并发的环境下，有可能 Callable 和 FutureTask 会创建多次。FutureTask 能够在高并发环境下确保任务只执行一此</li>
</ul>
<h3 id="_4-4-futuretask的几个状态"> 4.4 FutureTask的几个状态</h3>
<div><pre><code><span>/**
 *
 * state可能的状态转变路径如下：
 * NEW -> COMPLETING -> NORMAL
 * NEW -> COMPLETING -> EXCEPTIONAL
 * NEW -> CANCELLED
 * NEW -> INTERRUPTING -> INTERRUPTED
 */</span>
<span>private</span> <span>volatile</span> <span>int</span> state<span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> NEW <span>=</span> <span>0</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> COMPLETING <span>=</span> <span>1</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> NORMAL <span>=</span> <span>2</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> EXCEPTIONAL <span>=</span> <span>3</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> CANCELLED <span>=</span> <span>4</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> INTERRUPTING <span>=</span> <span>5</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> INTERRUPTED <span>=</span> <span>6</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>state 表示任务的运行状态，初始状态为 NEW。运行状态只会在 <code>set</code>、 <code>setException</code>、<code>cancel</code> 方法中终止。COMPLETING、INTERRUPTING 是任务完成后的瞬时状态。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十章、CAS与原子操作</title>
    <id>https://notes.lllllan.cn/java/concurrent/2/10/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/2/10/"/>
    <updated>2022-04-18T13:53:14.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/02/10.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、乐观锁与悲观锁的概念"> 一、乐观锁与悲观锁的概念</h2>
<p>锁可以从不同的角度分类。其中，乐观锁和悲观锁是一种分类方式。</p>
<div><p>悲观锁</p>
<p>悲观锁就是我们常说的锁。对于悲观锁来说，它总是认为每次访问共享资源时会发生冲突，所以必须对每次数据操作加上锁，以保证临界区的程序同一时间只能有一个线程在执行。</p>
</div>
<div><p>乐观锁</p>
<p>乐观锁又称为【无锁】，顾名思义，它是乐观派。乐观锁总是假设对共享资源的访问没有冲突，线程可以不停地执行，无需加锁也无需等待。而一旦多个线程发生冲突，乐观锁通常是使用一种称为 <mark>CAS</mark> 的技术来保证线程执行的安全性。</p>
<p>由于无锁操作中没有锁的存在，因此不可能出现死锁的情况，也就是说 <mark>乐观锁天生免疫死锁</mark></p>
</div>
<p>乐观锁多用于【读多写少】的环境，避免频繁加锁影响性能；而悲观锁多用于【写多读少】的环境，避免频繁失败和重试影响性能。</p>
<h2 id="二、cas的概念"> 二、CAS的概念</h2>
<p>CAS的全称是：比较并交换（Compare And Swap）。在CAS中，有这样三个值：</p>
<ul>
<li>V：要更新的变量(var)</li>
<li>E：预期值(expected)</li>
<li>N：新值(new)</li>
</ul>
<p>比较并交换的过程如下：</p>
<p>判断 V 是否等于 E，如果等于，将 V 的值设置为 N；如果不等，说明已经有其它线程更新了 V，则当前线程放弃更新，什么都不做。</p>
<p>所以这里的 <strong>预期值 E 本质上指的是【旧值】</strong>。</p>
<p>CAS 是一种原子操作，它是一种系统原语，是一条 CPU 的原子指令，从 CPU 层面保证它的原子性</p>
<p><mark>当多个线程同时使用 CAS 操作一个变量时，只有一个会胜出，并成功更新，其余均会失败，但失败的线程并不会被挂起，仅是被告知失败，并且允许再次尝试，当然也允许失败的线程放弃操作</mark></p>
<h2 id="三、java实现cas的原理-unsafe类"> 三、Java实现CAS的原理 - Unsafe类</h2>
<p>前面提到，CAS 是一种原子操作。那么 Java 是怎样来使用 CAS 的呢？我们知道，在 Java 中，如果一个方法是 native 的，那 Java 就不负责具体实现它，而是交给底层的 JVM 使用c或者 c++ 去实现。</p>
<p>在 Java 中，有一个 <code>Unsafe</code> 类，它在 <code>sun.misc</code> 包中。它里面是一些 <code>native</code> 方法，其中就有几个关于 CAS 的：</p>
<div><pre><code><span>boolean</span> <span>compareAndSwapObject</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span><span>Object</span> expected<span>,</span> <span>Object</span> x<span>)</span><span>;</span>
<span>boolean</span> <span>compareAndSwapInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span><span>int</span> expected<span>,</span><span>int</span> x<span>)</span><span>;</span>
<span>boolean</span> <span>compareAndSwapLong</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span><span>long</span> expected<span>,</span><span>long</span> x<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>当然，他们都是 <code>public native</code> 的。</p>
<p>Unsafe 中对 CAS 的实现是 C++ 写的，它的具体实现和操作系统、CPU 都有关系。</p>
<p>Linux 的 X86 下主要是通过 <code>cmpxchgl</code> 这个指令在 CPU 级完成 CAS 操作的，但在多处理器情况下必须使用 <code>lock</code> 指令加锁来完成。当然不同的操作系统和处理器的实现会有所不同，大家可以自行了解。</p>
<p>当然，Unsafe 类里面还有其它方法用于不同的用途。比如支持线程挂起和恢复的 <code>park</code> 和 <code>unpark</code>，  LockSupport 类底层就是调用了这两个方法。还有支持反射操作的 <code>allocateInstance()</code> 方法。</p>
<h2 id="四、原子操作-atomicinteger类源码简析"> 四、原子操作-AtomicInteger类源码简析</h2>
<p>上面介绍了 Unsafe 类的几个支持 CAS 的方法。那Java具体是如何使用这几个方法来实现原子操作的呢？</p>
<p>JDK 提供了一些用于原子操作的类，在 <code>java.util.concurrent.atomic</code> 包下面。在 JDK 11 中，有如下17个类：</p>
<p><img src="./README.assets/原子类.jpg" alt="原子类" loading="lazy"></p>
<p>从名字就可以看得出来这些类大概的用途：</p>
<ul>
<li>原子更新基本类型</li>
<li>原子更新数组</li>
<li>原子更新引用</li>
<li>原子更新字段（属性）</li>
</ul>
<p>这里我们以<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法为例，来看看Java是如何实现原子操作的。</p>
<p>先看看这个方法的源码：</p>
<div><pre><code><span>public</span> <span>final</span> <span>int</span> <span>getAndAdd</span><span>(</span><span>int</span> delta<span>)</span> <span>{</span>
    <span>return</span> <span>U</span><span>.</span><span>getAndAddInt</span><span>(</span><span>this</span><span>,</span> VALUE<span>,</span> delta<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这里的U其实就是一个<code>Unsafe</code>对象：</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span><span>jdk<span>.</span>internal<span>.</span>misc<span>.</span></span>Unsafe</span> <span>U</span> <span>=</span> <span><span>jdk<span>.</span>internal<span>.</span>misc<span>.</span></span>Unsafe</span><span>.</span><span>getUnsafe</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>所以其实<code>AtomicInteger</code>类的<code>getAndAdd(int delta)</code>方法是调用<code>Unsafe</code>类的方法来实现的：</p>
<div><pre><code><span>@HotSpotIntrinsicCandidate</span>
<span>public</span> <span>final</span> <span>int</span> <span>getAndAddInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span> <span>int</span> delta<span>)</span> <span>{</span>
    <span>int</span> v<span>;</span>
    <span>do</span> <span>{</span>
        v <span>=</span> <span>getIntVolatile</span><span>(</span>o<span>,</span> offset<span>)</span><span>;</span>
    <span>}</span> <span>while</span> <span>(</span><span>!</span><span>weakCompareAndSetInt</span><span>(</span>o<span>,</span> offset<span>,</span> v<span>,</span> v <span>+</span> delta<span>)</span><span>)</span><span>;</span>
    <span>return</span> v<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><blockquote>
<p>注：这个方法是在JDK 1.8才新增的。在JDK1.8之前，<code>AtomicInteger</code>源码实现有所不同，是基于for死循环的，有兴趣的读者可以自行了解一下。</p>
</blockquote>
<p>我们来一步步解析这段源码。首先，对象<code>o</code>是<code>this</code>，也就是一个<code>AtomicInteger</code>对象。然后<code>offset</code>是一个常量<code>VALUE</code>。这个常量是在<code>AtomicInteger</code>类中声明的：</p>
<div><pre><code><span>private</span> <span>static</span> <span>final</span> <span>long</span> VALUE <span>=</span> <span>U</span><span>.</span><span>objectFieldOffset</span><span>(</span><span>AtomicInteger</span><span>.</span><span>class</span><span>,</span> <span>"value"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>同样是调用的<code>Unsafe</code>的方法。从方法名字上来看，是得到了一个对象字段偏移量。</p>
<blockquote>
<p>用于获取某个字段相对Java对象的“起始地址”的偏移量。</p>
<p>一个java对象可以看成是一段内存，各个字段都得按照一定的顺序放在这段内存里，同时考虑到对齐要求，可能这些字段不是连续放置的，</p>
<p>用这个方法能准确地告诉你某个字段相对于对象的起始内存地址的字节偏移量，因为是相对偏移量，所以它其实跟某个具体对象又没什么太大关系，跟class的定义和虚拟机的内存模型的实现细节更相关。</p>
</blockquote>
<p>继续看源码。前面我们讲到，CAS是“无锁”的基础，它允许更新失败。所以经常会与while循环搭配，在失败后不断去重试。</p>
<p>这里声明了一个v，也就是要返回的值。从<code>getAndAddInt</code>来看，它返回的应该是原来的值，而新的值的<code>v + delta</code>。</p>
<p>这里使用的是<strong>do-while循环</strong>。这种循环不多见，它的目的是<strong>保证循环体内的语句至少会被执行一遍</strong>。这样才能保证return 的值<code>v</code>是我们期望的值。</p>
<p>循环体的条件是一个CAS方法：</p>
<div><pre><code><span>public</span> <span>final</span> <span>boolean</span> <span>weakCompareAndSetInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span>
                                          <span>int</span> expected<span>,</span>
                                          <span>int</span> x<span>)</span> <span>{</span>
    <span>return</span> <span>compareAndSetInt</span><span>(</span>o<span>,</span> offset<span>,</span> expected<span>,</span> x<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>final</span> <span>native</span> <span>boolean</span> <span>compareAndSetInt</span><span>(</span><span>Object</span> o<span>,</span> <span>long</span> offset<span>,</span>
                                             <span>int</span> expected<span>,</span>
                                             <span>int</span> x<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>可以看到，最终其实是调用的我们之前说到了CAS <code>native</code>方法。那为什么要经过一层<code>weakCompareAndSetInt</code>呢？从JDK源码上看不出来什么。在JDK 8及之前的版本，这两个方法是一样的。</p>
<blockquote>
<p>而在JDK 9开始，这两个方法上面增加了@HotSpotIntrinsicCandidate注解。这个注解允许HotSpot VM自己来写汇编或IR编译器来实现该方法以提供性能。也就是说虽然外面看到的在JDK9中weakCompareAndSet和compareAndSet底层依旧是调用了一样的代码，但是不排除HotSpot VM会手动来实现weakCompareAndSet真正含义的功能的可能性。</p>
</blockquote>
<p>根据本文第一篇参考文章（<a href="http://www.importnew.com/27596.html" target="_blank" rel="noopener noreferrer">对 volatile、compareAndSet、weakCompareAndSet 的一些思考</a>），它跟<code>volatile</code>有关。</p>
<p>简单来说，<code>weakCompareAndSet</code>操作仅保留了<code>volatile</code>自身变量的特性，而除去了happens-before规则带来的内存语义。也就是说，<code>weakCompareAndSet</code> <strong>无法保证处理操作目标的volatile变量外的其他变量的执行顺序( 编译器和处理器为了优化程序性能而对指令序列进行重新排序 )，同时也无法保证这些变量的可见性。</strong> 这在一定程度上可以提高性能。</p>
<p>再回到循环条件上来，可以看到它是在不断尝试去用CAS更新。如果更新失败，就继续重试。那为什么要把获取“旧值”v的操作放到循环体内呢？其实这也很好理解。前面我们说了，CAS如果旧值V不等于预期值E，它就会更新失败。说明旧的值发生了变化。那我们当然需要返回的是被其他线程改变之后的旧值了，因此放在了do循环体内。</p>
<h2 id="五、cas实现原子操作的三大问题"> 五、CAS实现原子操作的三大问题</h2>
<p>这里介绍一下 CAS 实现原子操作的三大问题及其解决方案。</p>
<h3 id="_5-1-aba问题"> 5.1 ABA问题</h3>
<p>所谓 ABA 问题，就是一个值原来是 A，变成了 B，又变回了 A。这个时候使用 CAS 是检查不出变化的，但实际上却被更新了两次。</p>
<p>ABA 问题的解决思路是在变量前面追加上 <strong>版本号或者时间戳</strong>。从 JDK 1.5 开始，JDK 的 atomic 包里提供了一个类 <code>AtomicStampedReference</code> 类来解决 ABA 问题。</p>
<p>这个类的 <code>compareAndSet</code> 方法的作用是首先检查当前引用是否等于预期引用，并且检查当前标志是否等于预期标志，如果二者都相等，才使用 CAS 设置为新的值和标志。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>compareAndSet</span><span>(</span><span>V</span>   expectedReference<span>,</span>
                             <span>V</span>   newReference<span>,</span>
                             <span>int</span> expectedStamp<span>,</span>
                             <span>int</span> newStamp<span>)</span> <span>{</span>
    <span>Pair</span><span><span>&lt;</span><span>V</span><span>></span></span> current <span>=</span> pair<span>;</span>
    <span>return</span>
        expectedReference <span>==</span> current<span>.</span>reference <span>&amp;&amp;</span>
        expectedStamp <span>==</span> current<span>.</span>stamp <span>&amp;&amp;</span>
        <span>(</span><span>(</span>newReference <span>==</span> current<span>.</span>reference <span>&amp;&amp;</span>
          newStamp <span>==</span> current<span>.</span>stamp<span>)</span> <span>||</span>
         <span>casPair</span><span>(</span>current<span>,</span> <span>Pair</span><span>.</span><span>of</span><span>(</span>newReference<span>,</span> newStamp<span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_5-2-循环时间长开销大"> 5.2 循环时间长开销大</h3>
<p>CAS 多与自旋结合。如果自旋 CAS 长时间不成功，会占用大量的 CPU 资源。</p>
<p>解决思路是让 JVM 支持处理器提供的 <strong>pause指令</strong>。</p>
<p>pause 指令能让自旋失败时 cpu 睡眠一小段时间再继续自旋，从而使得读操作的频率低很多，为解决内存顺序冲突而导致的 CPU 流水线重排的代价也会小很多。</p>
<h3 id="_5-3-只能保证一个共享变量的原子操作"> 5.3 只能保证一个共享变量的原子操作</h3>
<p>这个问题你可能已经知道怎么解决了。有两种解决方案：</p>
<ol>
<li>使用 JDK 1.5 开始就提供的 <code>AtomicReference</code> 类保证对象之间的原子性，把多个变量放到一个对象里面进行 CAS 操作；</li>
<li>使用锁。锁内的临界区代码可以保证只有当前线程能操作。</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第四章、Java线程的状态及主要转化方法</title>
    <id>https://notes.lllllan.cn/java/concurrent/1/4/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/1/4/"/>
    <updated>2022-04-18T07:50:37.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/01/4.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第四章 - GitHub</a></li>
<li><a href="https://blog.csdn.net/sspudding/article/details/89220595" target="_blank" rel="noopener noreferrer">线程状态转换图及各部分介绍</a></li>
<li><a href="https://blog.csdn.net/a543760828/article/details/119886943" target="_blank" rel="noopener noreferrer">面试问题——阻塞和等待状态的区别</a></li>
</ul>
</div>
<h2 id="一、操作系统中的线程状态转换"> 一、操作系统中的线程状态转换</h2>
<blockquote>
<p>在现在的操作系统中，线程是被视为轻量级进程的，所以 <strong>操作系统线程的状态其实和操作系统进程的状态是一致的</strong>。</p>
</blockquote>
<p><img src="./README.assets/系统进程状态转换图.png" alt="系统进程状态转换图" loading="lazy"></p>
<p>操作系统线程主要有以下三个状态：</p>
<ul>
<li>就绪状态(ready)：线程正在等待使用 CPU，经调度程序调用之后可进入 running 状态。</li>
<li>执行状态(running)：线程正在使用 CPU。</li>
<li>等待状态(waiting)：线程经过等待事件的调用或者正在等待其他资源（如 I/O）。</li>
</ul>
<h2 id="二、java-线程的六个状态"> 二、Java 线程的六个状态</h2>
<p><img src="./README.assets/线程状态转换图.png" alt="线程状态转换图" loading="lazy"></p>
<div><pre><code><span>// Thread.State 源码</span>
<span>public</span> <span>enum</span> <span>State</span> <span>{</span>
    NEW<span>,</span>
    RUNNABLE<span>,</span>
    BLOCKED<span>,</span>
    WAITING<span>,</span>
    TIMED_WAITING<span>,</span>
    TERMINATED<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_2-1-new"> 2.1 NEW</h3>
<p>处于 NEW 状态的线程此时尚未启动。这里的尚未启动指的是 <strong>还没调用 Thread 实例的 start() 方法。</strong></p>
<div><pre><code><span>private</span> <span>void</span> <span>testStateNew</span><span>(</span><span>)</span> <span>{</span>
    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span><span>}</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>thread<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出 NEW </span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><div><p>关于 start() 的两个引申问题</p>
<ol>
<li>
<p>反复调用同一个线程的 start() 方法是否可行？</p>
<blockquote>
<p>不行。在调用一次 start() 之后，threadStatus 的值会改变（threadStatus !=0），此时再次调用 start() 方法会抛出 IllegalThreadStateException 异常。</p>
</blockquote>
</li>
<li>
<p>假如一个线程执行完毕（此时处于 TERMINATED 状态），再次调用这个线程的 start() 方法是否可行？</p>
<blockquote>
<p>不行</p>
</blockquote>
</li>
</ol>
</div>
<CodeGroup>
<CodeGroupItem title="start() 源码">
<div><div><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>synchronized</span> <span>void</span> <span>start</span><span>(</span><span>)</span> <span>{</span>
    <span>if</span> <span>(</span>threadStatus <span>!=</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>

    group<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>

    <span>boolean</span> started <span>=</span> <span>false</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>start0</span><span>(</span><span>)</span><span>;</span>
        started <span>=</span> <span>true</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>if</span> <span>(</span><span>!</span>started<span>)</span> <span>{</span>
                group<span>.</span><span>threadStartFailed</span><span>(</span><span>this</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> ignore<span>)</span> <span>{</span>

        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="查看当前线程状态的源码">
<div><pre><code>// Thread.getState方法源码：
public State <span>getState</span><span>(</span><span>)</span> <span>{</span>
    // get current thread state
    <span>return</span> sun.misc.VM.toThreadState<span>(</span>threadStatus<span>)</span><span>;</span>
<span>}</span>

// sun.misc.VM 源码：
public static State toThreadState<span>(</span>int var0<span>)</span> <span>{</span>
    <span>if</span> <span>((</span>var0 <span>&amp;</span> <span>4</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> State.RUNNABLE<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>((</span>var0 <span>&amp;</span> <span>1024</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> State.BLOCKED<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>((</span>var0 <span>&amp;</span> <span>16</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> State.WAITING<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>((</span>var0 <span>&amp;</span> <span>32</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> State.TIMED_WAITING<span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>((</span>var0 <span>&amp;</span> <span>2</span><span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>return</span> State.TERMINATED<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>(</span>var0 <span>&amp;</span> <span>1</span><span>)</span> <span>==</span> <span>0</span> ? State.NEW <span>:</span> State.RUNNABLE<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p><mark>在 start() 内部，这里有一个 threadStatus 的变量。如果它不等于 0，调用 start() 是会直接抛出异常的。</mark></p>
<h3 id="_2-2-runnable"> 2.2  RUNNABLE</h3>
<p>表示当前线程正在运行中。处于 RUNNABLE 状态的线程在 Java 虚拟机中运行，也有可能在等待 CPU 分配资源。</p>
<div><p>Java 的 Runnable</p>
<p>Java 线程的 <strong>RUNNABLE</strong> 状态其实是包括了传统操作系统线程的 <strong>ready</strong> 和 <strong>running</strong> 两个状态的。</p>
</div>
<div><pre><code><span>/**
 * Thread state for a runnable thread.  A thread in the runnable
 * state is executing in the Java virtual machine but it may
 * be waiting for other resources from the operating system
 * such as processor.
 */</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_2-3-blocked"> 2.3 BLOCKED</h3>
<p>阻塞状态。处于 BLOCKED 状态的线程 <mark>正等待锁的释放</mark> 以进入同步区。</p>
<h3 id="_2-4-waiting"> 2.4 WAITING</h3>
<p>等待状态。<mark>原本获得锁</mark> 的线程被要求等待，变成RUNNABLE状态需要其他线程唤醒。</p>
<p>调用如下 3 个方法会使线程进入等待状态：</p>
<ul>
<li>Object.wait()：使当前线程处于等待状态直到另一个线程唤醒它；</li>
<li>Thread.join()：等待线程执行完毕，底层调用的是 Object 实例的 wait 方法；</li>
<li>LockSupport.park()：除非获得调用许可，否则禁用当前线程进行线程调度</li>
</ul>
<h3 id="_2-5-timed-waiting"> 2.5 TIMED_WAITING</h3>
<p>超时等待状态。 <mark>线程等待一个具体的时间，时间到后会被自动唤醒。</mark></p>
<p>调用如下方法会使线程进入超时等待状态：</p>
<ul>
<li>Thread.sleep(long millis)：使当前线程睡眠指定时间；</li>
<li>Object.wait(long timeout)：线程休眠指定时间，等待期间可以通过 notify()/notifyAll() 唤醒；</li>
<li>Thread.join(long millis)：等待当前线程最多执行 millis 毫秒，如果 millis 为 0，则会一直执行；</li>
<li>LockSupport.parkNanos(long nanos)： 除非获得调用许可，否则禁用当前线程进行线程调度指定时间；</li>
<li>LockSupport.parkUntil(long deadline)：同上，也是禁止线程进行调度指定时间；</li>
</ul>
<div><p>阻塞、等待和超时等待</p>
<p><strong>阻塞</strong></p>
<p>Java 文档将 <strong>BLOCKED</strong> 状态正式定义为：【被阻塞等待监视器锁的线程处于此状态】</p>
<p>举个栗子：你出门需要开车，但是车已经被你老爸开走了，你想要用车就必须等你老爸回来。</p>
<p>你是线程 <strong>T1</strong>，你老爸是线程 <strong>T2</strong>，锁是汽车。<strong>T1</strong> 在锁（即汽车）上被 <strong>BLOCKED</strong>，因为 <strong>T2</strong> 已经获得了这个锁。</p>
<hr>
<p><strong>等待</strong></p>
<p>Java 文档将 <strong>WAITING</strong> 状态正式定义为：【无限期等待另一个线程执行特定操作的线程处于此状态】</p>
<p>还是这个栗子：你老爸回来之后车空闲了，你本来都已经上车了，但是你老妈叫你等她把饭做好，然后让你把便当带走。</p>
<p>你是线程 <strong>T1</strong>，老妈是线程 <strong>T2</strong>。你松开了锁（上了车又下来了），并进入 WAITING 状态。直到老妈（即<strong>T2</strong>）把便当做好给你，你会一直被困在这个 <strong>WAITING</strong> 状态。</p>
<hr>
<p><strong>超时等待</strong></p>
<p>还是这个栗子：老妈的便当还没做好，但是你上班快迟到了，最多只能再等她五分钟，五分钟后不管便当能不能做好，都要开车离开了。</p>
<p>你是线程 <strong>T1</strong>，老妈是线程 <strong>T2</strong>，你只等待五分钟，并进入 TIMED_WAITING 状态。五分钟后将不再等待。</p>
</div>
<h3 id="_2-6-terminated"> 2.6 TERMINATED</h3>
<p>终止状态。此时线程已执行完毕。</p>
<h2 id="三、线程状态的转换"> 三、线程状态的转换</h2>
<p><img src="./README.assets/线程状态转换图.png" alt="线程状态转换图" loading="lazy"></p>
<h3 id="_3-1-blocked与runnable状态的转换"> 3.1 BLOCKED与RUNNABLE状态的转换</h3>
<p>处于 BLOCKED 状态的线程是因为在等待锁的释放。假如这里有两个线程 a 和 b，a 线程提前获得了锁并且暂未释放锁，此时 b 就处于 BLOCKED 状态</p>
<div><pre><code><span>@Test</span>
<span>public</span> <span>void</span> <span>blockedTest</span><span>(</span><span>)</span> <span>{</span>

    <span>Thread</span> a <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>testMethod</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>,</span> <span>"a"</span><span>)</span><span>;</span>
    <span>Thread</span> b <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>testMethod</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span><span>,</span> <span>"b"</span><span>)</span><span>;</span>

    a<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    b<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>":"</span> <span>+</span> a<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出？</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>b<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>":"</span> <span>+</span> b<span>.</span><span>getState</span><span>(</span><span>)</span><span>)</span><span>;</span> <span>// 输出？</span>
<span>}</span>

<span>// 同步方法争夺锁</span>
<span>private</span> <span>synchronized</span> <span>void</span> <span>testMethod</span><span>(</span><span>)</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000L</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>初看之下，大家可能会觉得线程 a 会先调用同步方法，同步方法内又调用了 Thread.sleep() 方法，必然会输出 TIMED_WAITING ，而线程 b 因为等待线程 a 释放锁所以必然会输出 BLOCKED。</p>
<p>其实不然，有两点需要值得大家注意，一是 <strong>在测试方法 blockedTest() 内还有一个 main 线程</strong>，二是<strong>启动线程后执行 run 方法还是需要消耗一定时间的</strong>。</p>
<blockquote>
<p>测试方法的 main 线程只保证了 a，b 两个线程调用 start() 方法（转化为 RUNNABLE 状态），如果 CPU 执行效率高一点，还没等两个线程真正开始争夺锁，就已经打印此时两个线程的状态（RUNNABLE）了。</p>
<p>当然，如果 CPU 执行效率低一点，其中某个线程也是可能打印出 BLOCKED 状态的（此时两个线程已经开始争夺锁了）。</p>
</blockquote>
<p>这时你可能又会问了，要是我想要打印出 BLOCKED 状态我该怎么处理呢？BLOCKED状态的产生需要两个线程争夺锁才行。那我们处理下测试方法里的 main 线程就可以了，让它“休息一会儿”，调用一下 <code>Thread.sleep()</code> 方法。</p>
<p>这里需要注意的是 main 线程休息的时间，要保证在线程争夺锁的时间内，不要等到前一个线程锁都释放了你再去争夺锁，此时还是得不到BLOCKED状态的。</p>
<p>我们把上面的测试方法blockedTest()改动一下：</p>
<div><pre><code>public void blockedTest() throws InterruptedException {
    ······
    a.start();
    Thread.sleep(1000L); // 需要注意这里main线程休眠了1000毫秒，而testMethod()里休眠了2000毫秒
    b.start();
    System.out.println(a.getName() + &quot;:&quot; + a.getState()); // 输出？
    System.out.println(b.getName() + &quot;:&quot; + b.getState()); // 输出？
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>在这个例子中两个线程的状态转换如下</p>
<ul>
<li>a的状态转换过程：RUNNABLE（<code>a.start()</code>） -&gt; TIMED_WATING（<code>Thread.sleep()</code>）-&gt;RUNABLE（sleep()时间到）-&gt;<em>BLOCKED(未抢到锁)</em> -&gt; TERMINATED</li>
<li>b的状态转换过程：RUNNABLE（<code>b.start()</code>) -&gt; <em>BLOCKED(未抢到锁)</em> -&gt;TERMINATED</li>
</ul>
<blockquote>
<p>斜体表示可能出现的状态， 大家可以在自己的电脑上多试几次看看输出。同样，这里的输出也可能有多钟结果。</p>
</blockquote>
<h3 id="_3-2-waiting状态与runnable状态的转换"> 3.2 WAITING状态与RUNNABLE状态的转换</h3>
<p><strong>Object.wait()</strong></p>
<blockquote>
<p>调用 <code>wait()</code> 方法前线程 <mark>必须持有对象的锁。</mark></p>
<p>线程调用 <code>wait()</code> 方法时， <mark>会释放当前的锁</mark>，直到有其他线程调用 <code>notify()/notifyAll()</code> 方法唤醒等待锁的线程。</p>
<p>需要注意的是，其他线程调用 <code>notify()</code> 方法只会唤醒<strong>单个等待锁的线程</strong>，<u>如有有多个线程都在等待这个锁的话不一定会唤醒到之前调用wait()方法的线程。</u></p>
<p>同样，调用 <code>notifyAll()</code> 方法唤醒所有等待锁的线程之后，也不一定会马上把时间片分给刚才放弃锁的那个线程，具体要看系统的调度。</p>
</blockquote>
<p><strong>Thread.join()</strong></p>
<blockquote>
<p>调用 <code>join()</code> 方法，会一直等待这个线程执行完毕（转换为TERMINATED状态）。</p>
</blockquote>
<p>我们再把上面的例子线程启动那里改变一下：</p>
<div><pre><code>public void blockedTest() {
    ······
    a.start();
    a.join();
    b.start();
    System.out.println(a.getName() + &quot;:&quot; + a.getState()); // 输出 TERMINATED
    System.out.println(b.getName() + &quot;:&quot; + b.getState());
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>要是没有调用join方法，main线程不管a线程是否执行完毕都会继续往下走。</p>
<p>a线程启动之后马上调用了join方法，这里main线程就会等到a线程执行完毕，所以这里a线程打印的状态固定是<strong>TERMINATED</strong>。</p>
<p>至于b线程的状态，有可能打印RUNNABLE（尚未进入同步方法），也有可能打印TIMED_WAITING（进入了同步方法）。</p>
<h3 id="_3-3-timed-waiting与runnable状态转换"> 3.3 TIMED_WAITING与RUNNABLE状态转换</h3>
<p>TIMED_WAITING与WAITING状态类似，只是TIMED_WAITING状态等待的时间是指定的。</p>
<p><strong>Thread.sleep(long)</strong></p>
<blockquote>
<p>使当前线程睡眠指定时间。需要注意这里的“睡眠”只是暂时使线程停止执行， <mark>并不会释放锁</mark>。时间到后，线程会重新进入RUNNABLE状态。</p>
</blockquote>
<p><strong>Object.wait(long)</strong></p>
<blockquote>
<p>wait(long)方法使线程进入TIMED_WAITING状态。这里的wait(long)方法与无参方法wait()相同的地方是，都可以通过其他线程调用notify()或notifyAll()方法来唤醒。</p>
<p>不同的地方是，有参方法wait(long)就算其他线程不来唤醒它，经过指定时间long之后它会自动唤醒，拥有去争夺锁的资格。</p>
</blockquote>
<p><strong>Thread.join(long)</strong></p>
<blockquote>
<p>join(long)使当前线程执行指定时间，并且使线程进入TIMED_WAITING状态。</p>
<p>我们再来改一改刚才的示例:</p>
</blockquote>
<div><pre><code>public void blockedTest() {
    ······
    a.start();
    a.join(1000L);
    b.start();
    System.out.println(a.getName() + &quot;:&quot; + a.getState()); // 输出 TIEMD_WAITING
    System.out.println(b.getName() + &quot;:&quot; + b.getState());
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>这里调用a.join(1000L)，因为是指定了具体a线程执行的时间的，并且执行时间是小于a线程sleep的时间，所以a线程状态输出TIMED_WAITING。</p>
<p>b线程状态仍然不固定（RUNNABLE 或 BLOCKED）。</p>
<h3 id="_3-4-线程中断"> 3.4 线程中断</h3>
<blockquote>
<p>在某些情况下，我们在线程启动后发现并不需要它继续执行下去时，需要中断线程。目前在Java里还没有安全直接的方法来停止线程，但是Java提供了线程中断机制来处理需要中断线程的情况。</p>
<p>线程中断机制是一种协作机制。需要注意，通过中断操作并不能直接终止一个线程，而是通知需要被中断的线程自行处理。</p>
</blockquote>
<p>简单介绍下Thread类里提供的关于线程中断的几个方法：</p>
<ul>
<li>Thread.interrupt()：中断线程。这里的中断线程并不会立即停止线程，而是设置线程的中断状态为true（默认是flase）；</li>
<li>Thread.currentThread().isInterrupted()：测试当前线程是否被中断。线程的中断状态受这个方法的影响，意思是调用一次使线程中断状态设置为true，连续调用两次会使得这个线程的中断状态重新转为false；</li>
<li>Thread.isInterrupted()：测试当前线程是否被中断。与上面方法不同的是调用这个方法并不会影响线程的中断状态。</li>
</ul>
<blockquote>
<p>在线程中断机制里，当其他线程通知需要被中断的线程后，线程中断的状态被设置为true，但是具体被要求中断的线程要怎么处理，完全由被中断线程自己而定，可以在合适的实际处理中断请求，也可以完全不处理继续执行下去。</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第三章、线程组和线程优先级</title>
    <id>https://notes.lllllan.cn/java/concurrent/1/3/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/1/3/"/>
    <updated>2022-04-18T07:40:55.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/01/3.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第三章 - GitHub</a></li>
<li><a href="https://www.cnblogs.com/xiarongjin/p/8310144.html" target="_blank" rel="noopener noreferrer">守护线程(Daemon Thread)</a></li>
</ul>
</div>
<h2 id="一、线程组"> 一、线程组</h2>
<p>Java 中用 ThreadGroup 来表示线程组，我们可以使用线程组对线程进行批量控制。</p>
<p><mark>每个 Thread 必然存在于一个 ThreadGroup 中，Thread 不能独立于 ThreadGroup 存在。</mark> 执行 main() 方法线程的名字是 main，如果在 new Thread 时没有显式指定，那么默认将父线程（当前执行 new Thread 的线程）线程组设置为自己的线程组。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Thread</span> testThread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"testThread当前线程组名字："</span> <span>+</span>
                               <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"testThread线程名字："</span> <span>+</span>
                               <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>

        testThread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行main所在线程的线程组名字： "</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"执行main方法线程名字："</span> <span>+</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><div><pre><code>执行main所在线程的线程组名字： main
执行main方法线程名字：main
testThread当前线程组名字：main
testThread线程名字：<span>Thread</span><span>-</span><span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>ThreadGroup 管理着它下面的 Thread，ThreadGroup 是一个标准的 <mark>向下引用</mark> 的树状结构，这样设计的原因是 <strong>防止【上级】线程被【下级】线程引用而无法有效地被GC回收</strong>。</p>
<h2 id="二、线程的优先级"> 二、线程的优先级</h2>
<p>Java 中线程优先级可以指定，范围是 1~10（<strong>数字越大优先级越高</strong>）。但是并不是所有的操作系统都支持 10 级优先级的划分（比如有些操作系统只支持 3 级划分：低，中，高），Java 只是给操作系统一个优先级的 <strong>参考值</strong>，线程最终 <strong>在操作系统的优先级</strong> 是多少还是由操作系统决定。</p>
<p>Java 默认的线程优先级为 <strong>5</strong>，线程的执行顺序由调度程序来决定，线程的优先级会在线程被调用之前设定。</p>
<p>通常情况下，高优先级的线程将会比低优先级的线程有 <strong>更高的几率</strong> 得到执行。</p>
<h3 id="_2-1-设置线程优先级"> 2.1 设置线程优先级</h3>
<p>我们使用方法<code>Thread</code>类的<code>setPriority()</code>实例方法来设定线程的优先级。</p>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Thread</span> a <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是默认线程优先级："</span><span>+</span>a<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Thread</span> b <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>)</span><span>;</span>
        b<span>.</span><span>setPriority</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是设置过的线程优先级："</span><span>+</span>b<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><div><pre><code>我是默认线程优先级：<span>5</span>
我是设置过的线程优先级：<span>10</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_2-2-优先级只是参考"> 2.2 优先级只是参考</h3>
<div><p>设置优先级指定线程执行的顺序？</p>
<p>既然有 1-10 的级别来设定了线程的优先级，这时候可能有些读者会问，那么我是不是可以在业务实现的时候，采用这种方法来指定一些线程执行的先后顺序？</p>
<p>对于这个问题，我们的答案是：No!</p>
<p>Java 中的优先级来说不是特别的可靠，<strong>Java程序中对线程所设置的优先级只是给操作系统一个建议，操作系统不一定会采纳。而真正的调用顺序，是由操作系统的线程调度算法决定的</strong>。</p>
</div>
<div><pre><code><span>public</span> <span>class</span> <span>Demo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>class</span> <span>T1</span> <span>extends</span> <span>Thread</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>super</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"当前执行的线程是：%s，优先级：%d"</span><span>,</span>
                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span>
                    <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>IntStream</span><span>.</span><span>range</span><span>(</span><span>1</span><span>,</span> <span>10</span><span>)</span><span>.</span><span>forEach</span><span>(</span>i <span>-></span> <span>{</span>
            <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>T1</span><span>(</span><span>)</span><span>)</span><span>;</span>
            thread<span>.</span><span>setPriority</span><span>(</span>i<span>)</span><span>;</span>
            thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><div><pre><code>当前执行的线程是：<span>Thread</span><span>-</span><span>17</span>，优先级：<span>9</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>1</span>，优先级：<span>1</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>13</span>，优先级：<span>7</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>11</span>，优先级：<span>6</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>15</span>，优先级：<span>8</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>7</span>，优先级：<span>4</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>9</span>，优先级：<span>5</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>3</span>，优先级：<span>2</span>
当前执行的线程是：<span>Thread</span><span>-</span><span>5</span>，优先级：<span>3</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>Java 提供一个 <strong>线程调度器</strong> 来监视和控制处于 <strong>RUNNABLE状态</strong> 的线程。线程的调度策略采用 <mark><strong>抢占式</strong></mark> ，优先级高的线程比优先级低的线程会有更大的几率优先执行。在优先级相同的情况下，按照【先到先得】的原则。每个 Java 程序都有一个默认的主线程，就是通过 JVM 启动的第一个线程 main 线程。</p>
<p>还有一种线程称为 <strong>守护线程（Daemon）</strong>，守护线程默认的优先级比较低。</p>
<h3 id="_2-3-守护线程"> 2.3 守护线程</h3>
<div><p>守护线程</p>
<p>所谓守护线程，是指在程序运行的时候在后台提供一种通用服务的线程，比如垃圾回收线程就是一个很称职的守护者，并且这种线程并不属于程序中不可或缺的部分。</p>
<p>用户线程和守护线程两者几乎没有区别，唯一的不同之处就在于虚拟机的离开：如果用户线程已经全部退出运行了，只剩下守护线程存在了，虚拟机也就退出了。 因为没有了被守护者，守护线程也就没有工作可做了，也就没有继续运行程序的必要了。</p>
<p>一个线程默认是非守护线程，可以通过 Thread 类的 setDaemon(boolean on) 来设置。</p>
</div>
<h3 id="_2-4-线程和线程组的优先级"> 2.4 线程和线程组的优先级</h3>
<p>个线程必然存在于一个线程组中，那么当线程和线程组的优先级不一致的时候将会怎样呢？</p>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>ThreadGroup</span> threadGroup <span>=</span> <span>new</span> <span>ThreadGroup</span><span>(</span><span>"t1"</span><span>)</span><span>;</span>
    threadGroup<span>.</span><span>setMaxPriority</span><span>(</span><span>6</span><span>)</span><span>;</span>
    <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span>threadGroup<span>,</span><span>"thread"</span><span>)</span><span>;</span>
    thread<span>.</span><span>setPriority</span><span>(</span><span>9</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是线程组的优先级"</span><span>+</span>threadGroup<span>.</span><span>getMaxPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是线程的优先级"</span><span>+</span>thread<span>.</span><span>getPriority</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><div><pre><code>我是线程组的优先级<span>6</span>
我是线程的优先级<span>6</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>所以，如果某个线程优先级大于线程所在 <strong>线程组的最大优先级</strong>，那么该线程的优先级将会失效，取而代之的是线程组的最大优先级。</p>
<h2 id="三、线程组的常用方法"> 三、线程组的常用方法</h2>
<h3 id="_3-1-获取当前的线程组名字"> 3.1 获取当前的线程组名字</h3>
<div><pre><code><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="_3-2-复制线程组"> 3.2 复制线程组</h3>
<div><pre><code><span>// 获取当前的线程组</span>
<span>ThreadGroup</span> threadGroup <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>;</span>
<span>// 复制一个线程组到一个线程数组（获取Thread信息）</span>
<span>Thread</span><span>[</span><span>]</span> threads <span>=</span> <span>new</span> <span>Thread</span><span>[</span>threadGroup<span>.</span><span>activeCount</span><span>(</span><span>)</span><span>]</span><span>;</span>
threadGroup<span>.</span><span>enumerate</span><span>(</span>threads<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h3 id="_3-3-线程组统一异常处理"> 3.3 线程组统一异常处理</h3>
<div><pre><code><span>package</span> <span>com<span>.</span>func<span>.</span>axc<span>.</span>threadgroup</span><span>;</span>
 
<span>public</span> <span>class</span> <span>ThreadGroupDemo</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>ThreadGroup</span> threadGroup1 <span>=</span> <span>new</span> <span>ThreadGroup</span><span>(</span><span>"group1"</span><span>)</span> <span>{</span>
            <span>// 继承ThreadGroup并重新定义以下方法</span>
            <span>// 在线程成员抛出unchecked exception</span>
            <span>// 会执行此方法</span>
            <span>public</span> <span>void</span> <span>uncaughtException</span><span>(</span><span>Thread</span> t<span>,</span> <span>Throwable</span> e<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>t<span>.</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>": "</span> <span>+</span> e<span>.</span><span>getMessage</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>
        
        <span>// 这个线程是threadGroup1的一员</span>
		<span>Thread</span> thread1 <span>=</span> <span>new</span> <span>Thread</span><span>(</span>threadGroup1<span>,</span> <span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>// 抛出unchecked异常</span>
                <span>throw</span> <span>new</span> <span>RuntimeException</span><span>(</span><span>"测试异常"</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>;</span>
        
		thread1<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h2 id="四、线程组数据结构"> 四、线程组数据结构</h2>
<h3 id="_4-1-threadgroup-源码中的成员变量"> 4.1  ThreadGroup 源码中的成员变量</h3>
<div><pre><code><span>public</span> <span>class</span> <span>ThreadGroup</span> <span>implements</span> <span>Thread<span>.</span>UncaughtExceptionHandler</span> <span>{</span>
    <span>private</span> <span>final</span> <span>ThreadGroup</span> parent<span>;</span>	<span>// 父亲ThreadGroup</span>
    <span>String</span> name<span>;</span> 						<span>// ThreadGroupr 的名称</span>
    <span>int</span> maxPriority<span>;</span> 					<span>// 线程最大优先级</span>
    <span>boolean</span> destroyed<span>;</span> 					<span>// 是否被销毁</span>
    <span>boolean</span> daemon<span>;</span> 					<span>// 是否守护线程</span>
    <span>boolean</span> vmAllowSuspension<span>;</span> 			<span>// 是否可以中断</span>
 
    <span>int</span> nUnstartedThreads <span>=</span> <span>0</span><span>;</span> 			<span>// 还未启动的线程</span>
    <span>int</span> nthreads<span>;</span> 						<span>// ThreadGroup中线程数目</span>
    <span>Thread</span> threads<span>[</span><span>]</span><span>;</span> 					<span>// ThreadGroup中的线程</span>
 
    <span>int</span> ngroups<span>;</span> 						<span>// 线程组数目</span>
    <span>ThreadGroup</span> groups<span>[</span><span>]</span><span>;</span> 				<span>// 线程组数组</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_4-2-构造函数"> 4.2 构造函数</h3>
<div><pre><code><span>// 私有构造函数</span>
<span>private</span> <span>ThreadGroup</span><span>(</span><span>)</span> <span>{</span> 
    <span>this</span><span>.</span>name <span>=</span> <span>"system"</span><span>;</span>
    <span>this</span><span>.</span>maxPriority <span>=</span> <span>Thread</span><span>.</span>MAX_PRIORITY<span>;</span>
    <span>this</span><span>.</span>parent <span>=</span> <span>null</span><span>;</span>
<span>}</span>

<span>// 默认是以当前 ThreadGroup 传入作为 parent  </span>
<span>// ThreadGroup，新线程组的父线程组是目前正在运行线程的线程组。</span>
<span>public</span> <span>ThreadGroup</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
    <span>this</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>,</span> name<span>)</span><span>;</span>
<span>}</span>

<span>// 构造函数</span>
<span>public</span> <span>ThreadGroup</span><span>(</span><span>ThreadGroup</span> parent<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
    <span>this</span><span>(</span><span>checkParentAccess</span><span>(</span>parent<span>)</span><span>,</span> parent<span>,</span> name<span>)</span><span>;</span>
<span>}</span>

<span>// 私有构造函数，主要的构造函数</span>
<span>private</span> <span>ThreadGroup</span><span>(</span><span>Void</span> unused<span>,</span> <span>ThreadGroup</span> parent<span>,</span> <span>String</span> name<span>)</span> <span>{</span>
    <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>this</span><span>.</span>maxPriority <span>=</span> parent<span>.</span>maxPriority<span>;</span>
    <span>this</span><span>.</span>daemon <span>=</span> parent<span>.</span>daemon<span>;</span>
    <span>this</span><span>.</span>vmAllowSuspension <span>=</span> parent<span>.</span>vmAllowSuspension<span>;</span>
    <span>this</span><span>.</span>parent <span>=</span> parent<span>;</span>
    parent<span>.</span><span>add</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><h3 id="_4-3-checkparentaccess方法"> 4.3 checkParentAccess方法</h3>
<div><pre><code><span>// 检查parent ThreadGroup</span>
<span>private</span> <span>static</span> <span>Void</span> <span>checkParentAccess</span><span>(</span><span>ThreadGroup</span> parent<span>)</span> <span>{</span>
    parent<span>.</span><span>checkAccess</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>null</span><span>;</span>
<span>}</span>

<span>// 判断当前运行的线程是否具有修改线程组的权限</span>
<span>public</span> <span>final</span> <span>void</span> <span>checkAccess</span><span>(</span><span>)</span> <span>{</span>
    <span>SecurityManager</span> security <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>security <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        security<span>.</span><span>checkAccess</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>这里涉及到 <code>SecurityManager</code> 这个类，它是 Java 的安全管理器，它允许应用程序在执行一个可能不安全或敏感的操作前确定该操作是什么，以及是否是在允许执行该操作的安全上下文中执行它。应用程序可以允许或不允许该操作。</p>
<p>比如引入了第三方类库，但是并不能保证它的安全性。</p>
<p>其实 Thread 类也有一个 checkAccess() 方法，不过是用来当前运行的线程是否有权限修改被调用的这个线程实例。（Determines if the currently running thread has permission to modify this thread.）</p>
<h2 id="五、总结"> 五、总结</h2>
<p>总结来说，线程组是一个树状的结构，每个线程组下面可以有多个线程或者线程组。线程组可以起到统一控制线程的优先级和检查线程的权限的作用。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第五章、Java线程间的通信</title>
    <id>https://notes.lllllan.cn/java/concurrent/1/5/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/1/5/"/>
    <updated>2022-04-18T08:06:09.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/01/5.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第五章 - GitHub</a></li>
</ul>
</div>
<p>一般来讲，线程内部有自己私有的线程上下文，互不干扰。但是当我们需要多个线程之间相互协作的时候，就需要我们掌握 Java 线程的通信方式。</p>
<h2 id="一、锁与同步"> 一、锁与同步</h2>
<p><mark>线程同步是线程之间按照 <strong>一定的顺序</strong> 执行。</mark></p>
<div><pre><code><span>public</span> <span>class</span> <span>NoneLock</span> <span>{</span>

    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread A "</span> <span>+</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread B "</span> <span>+</span> i<span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>执行这个程序，你会在控制台看到，线程 A 和线程 B 各自独立工作，输出自己的打印值。如下是我的电脑上某一次运行的结果。每一次运行结果都会不一样。</p>
<p>那我现在有一个需求，我想等 A 先执行完之后，再由 B 去执行，怎么办呢？最简单的方式就是使用一个【对象锁】：在Java中，<mark>锁的概念都是基于对象的，所以我们又经常称它为对象锁</mark></p>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>ObjectLock</span> <span>{</span>
    <span>private</span> <span>static</span> <span>Object</span> lock <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>

    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread A "</span> <span>+</span> i<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>100</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Thread B "</span> <span>+</span> i<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>10</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>这里声明了一个名字为 <code>lock</code> 的对象锁。我们在 <code>ThreadA</code> 和 <code>ThreadB</code> 内需要同步的代码块里，都是用 <code>synchronized</code> 关键字加上了同一个对象锁 <code>lock</code>。</p>
<p>同一时间只有一个线程持有一个锁，那么线程 B 就会等线程 A 执行完成后释放 <code>lock</code>，线程 B 才能获得锁 <code>lock</code>。</p>
<blockquote>
<p>这里在主线程里使用 sleep 方法睡眠了 10 毫秒，是为了防止线程 B 先得到锁。因为如果同时 start，线程 A 和线程 B 都是出于就绪状态，操作系统可能会先让 B 运行。这样就会先输出 B 的内容，然后 B 执行完成之后自动释放锁，线程 A 再执行。</p>
</blockquote>
<h2 id="二、等待-通知机制"> 二、等待/通知机制</h2>
<p>上面一种基于“锁”的方式，线程需要不断地去尝试获得锁，如果失败了，再继续尝试。这可能会耗费服务器资源。</p>
<p>而等待/通知机制是另一种方式。</p>
<p>Java 多线程的等待/通知机制是基于 <code>Object</code> 类的 <code>wait()</code> 方法和 <code>notify()</code>、 <code>notifyAll()</code> 方法来实现的。</p>
<blockquote>
<p>notify() 方法会随机叫醒一个正在等待的线程，而 notifyAll() 会叫醒所有正在等待的线程。</p>
</blockquote>
<p>前面我们讲到，一个锁同一时刻只能被一个线程持有。而假如线程 A 现在持有了一个锁 <code>lock</code> 并开始执行，它可以使用 <code>lock.wait()</code> 让自己进入等待状态。这个时候，<code>lock</code> 这个锁是被释放了的。</p>
<p>这时，线程 B 获得了 <code>lock</code> 这个锁并开始执行，它可以在某一时刻，使用 <code>lock.notify()</code>，通知之前持有 <code>lock</code> 锁并进入等待状态的线程A，说“线程A你不用等了，可以往下执行了”。</p>
<blockquote>
<p>需要注意的是，这个时候线程 B 并没有释放锁 <code>lock</code>，除非线程 B 这个时候使用 <code>lock.wait()</code> 释放锁，或者线程 B 执行结束自行释放锁，线程 A 才能得到<code>lock</code>锁。</p>
<p><mark>notify 方法并不会让线程释放锁</mark></p>
</blockquote>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>WaitAndNotify</span> <span>{</span>
    <span>private</span> <span>static</span> <span>Object</span> lock <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>

    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    <span>try</span> <span>{</span>
                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ThreadA: "</span> <span>+</span> i<span>)</span><span>;</span>
                        lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
                        lock<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>
                <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>5</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                    <span>try</span> <span>{</span>
                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ThreadB: "</span> <span>+</span> i<span>)</span><span>;</span>
                        lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
                        lock<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span>
                lock<span>.</span><span>notify</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span><span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 输出：</span>
<span>ThreadA</span><span>:</span> <span>0</span>
<span>ThreadB</span><span>:</span> <span>0</span>
<span>ThreadA</span><span>:</span> <span>1</span>
<span>ThreadB</span><span>:</span> <span>1</span>
<span>ThreadA</span><span>:</span> <span>2</span>
<span>ThreadB</span><span>:</span> <span>2</span>
<span>ThreadA</span><span>:</span> <span>3</span>
<span>ThreadB</span><span>:</span> <span>3</span>
<span>ThreadA</span><span>:</span> <span>4</span>
<span>ThreadB</span><span>:</span> <span>4</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br></div></div><p>在这个 Demo 里，线程 A 和线程 B 首先打印出自己需要的东西，然后使用 <code>notify()</code> 方法叫醒另一个正在等待的线程，然后自己使用 <code>wait()</code> 方法陷入等待并释放 <code>lock</code> 锁。</p>
<blockquote>
<p>需要注意的是等待/通知机制使用的是使用同一个对象锁，如果你两个线程使用的是不同的对象锁，那它们之间是不能用等待/通知机制通信的。</p>
</blockquote>
<h2 id="三、信号量"> 三、信号量</h2>
<p>JDK 提供了一个类似于【信号量】功能的类 <code>Semaphore</code>。但本文不是要介绍这个类，而是介绍一种基于 <code>volatile</code> 关键字的自己实现的信号量通信。</p>
<div><p>volatile关键字</p>
<p>能够保证内存的可见性，如果用 volatile 关键字声明了一个变量，在一个线程里面改变了这个变量的值，那其它线程是立马可见更改后的值的。</p>
</div>
<p>比如我现在有一个需求，我想让线程 A 输出 0，然后线程 B 输出 1，再然后线程 A 输出 2…以此类推。我应该怎样实现呢？</p>
<CodeGroup>
<CodeGroupItem title="不使用 volatile">
<div><pre><code>public class Signal <span>{</span>
    private static int signal <span>=</span> <span>0</span><span>;</span>

    static class ThreadA implements Runnable <span>{</span>
        @Override
        public void <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>signal <span>&lt;</span> <span>5</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>signal % <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    System.out.println<span>(</span><span>"threadA: "</span> + signal<span>)</span><span>;</span>
                    signal++<span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    static class ThreadB implements Runnable <span>{</span>
        @Override
        public void <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>signal <span>&lt;</span> <span>5</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>signal % <span>2</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                    System.out.println<span>(</span><span>"threadB: "</span> + signal<span>)</span><span>;</span>
                    signal <span>=</span> signal + <span>1</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    public static void main<span>(</span>String<span>[</span><span>]</span> args<span>)</span> throws InterruptedException <span>{</span>
        new Thread<span>(</span>new ThreadA<span>(</span><span>))</span>.start<span>(</span><span>)</span><span>;</span>
        Thread.sleep<span>(</span><span>1000</span><span>)</span><span>;</span>
        new Thread<span>(</span>new ThreadB<span>(</span><span>))</span>.start<span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

// 输出：
threadA: <span>0</span>
threadB: <span>1</span>
// 一直运行但不输出
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div></CodeGroupItem>
<CodeGroupItem title="使用volatile">
<div><pre><code>public class Signal <span>{</span>
    private static volatile int signal <span>=</span> <span>0</span><span>;</span>

    static class ThreadA implements Runnable <span>{</span>
        @Override
        public void <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>signal <span>&lt;</span> <span>5</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>signal % <span>2</span> <span>==</span> <span>0</span><span>)</span> <span>{</span>
                    System.out.println<span>(</span><span>"threadA: "</span> + signal<span>)</span><span>;</span>
                    signal++<span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    static class ThreadB implements Runnable <span>{</span>
        @Override
        public void <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>while</span> <span>(</span>signal <span>&lt;</span> <span>5</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>signal % <span>2</span> <span>==</span> <span>1</span><span>)</span> <span>{</span>
                    System.out.println<span>(</span><span>"threadB: "</span> + signal<span>)</span><span>;</span>
                    signal <span>=</span> signal + <span>1</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    public static void main<span>(</span>String<span>[</span><span>]</span> args<span>)</span> throws InterruptedException <span>{</span>
        new Thread<span>(</span>new ThreadA<span>(</span><span>))</span>.start<span>(</span><span>)</span><span>;</span>
        Thread.sleep<span>(</span><span>1000</span><span>)</span><span>;</span>
        new Thread<span>(</span>new ThreadB<span>(</span><span>))</span>.start<span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

// 输出：
threadA: <span>0</span>
threadB: <span>1</span>
threadA: <span>2</span>
threadB: <span>3</span>
threadA: <span>4</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br></div></div></CodeGroupItem>
</CodeGroup>
<p>我们可以看到，使用了一个 <code>volatile</code> 变量 <code>signal</code> 来实现了【信号量】的模型。这里需要注意的是， <code>volatile</code> 变量需要进行原子操作。</p>
<p>而  <code>signal++</code> 并不是一个原子操作，所以我们在实际开发中，会根据需要使用 <code>synchronized</code> 给它【上锁】，或者是使用 <code>AtomicInteger</code> 等原子类。并且上面的程序也 <strong>并不是线程安全的</strong>，因为执行 <code>while</code> 语句后，可能当前线程就暂停等待时间片了，等线程醒来，可能 signal 已经大于等于 5 了。</p>
<blockquote>
<p>这种实现方式并不一定高效，本例只是演示信号量</p>
</blockquote>
<h3 id="信号量的应用场景"> 信号量的应用场景：</h3>
<p>假如在一个停车场中，车位是我们的公共资源，线程就如同车辆，而看门的管理员就是起的【信号量】的作用。</p>
<p>因为在这种场景下，多个线程（超过2个）需要相互合作，我们用简单的【锁】和【等待通知机制】就不那么方便了。这个时候就可以用到信号量。</p>
<h2 id="四、管道"> 四、管道</h2>
<p>管道是基于【管道流】的通信方式。JDK 提供了 <code>PipedWriter</code>、 <code>PipedReader</code>、 <code>PipedOutputStream</code>、 <code>PipedInputStream</code>。其中，前面两个是基于字符的，后面两个是基于字节流的。</p>
<p>这里的示例代码使用的是基于字符的：</p>
<div><div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>Pipe</span> <span>{</span>
    <span>static</span> <span>class</span> <span>ReaderThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>private</span> <span>PipedReader</span> reader<span>;</span>

        <span>public</span> <span>ReaderThread</span><span>(</span><span>PipedReader</span> reader<span>)</span> <span>{</span>
            <span>this</span><span>.</span>reader <span>=</span> reader<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"this is reader"</span><span>)</span><span>;</span>
            <span>int</span> receive <span>=</span> <span>0</span><span>;</span>
            <span>try</span> <span>{</span>
                <span>while</span> <span>(</span><span>(</span>receive <span>=</span> reader<span>.</span><span>read</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>-</span><span>1</span><span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>print</span><span>(</span><span>(</span><span>char</span><span>)</span>receive<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>static</span> <span>class</span> <span>WriterThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>

        <span>private</span> <span>PipedWriter</span> writer<span>;</span>

        <span>public</span> <span>WriterThread</span><span>(</span><span>PipedWriter</span> writer<span>)</span> <span>{</span>
            <span>this</span><span>.</span>writer <span>=</span> writer<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"this is writer"</span><span>)</span><span>;</span>
            <span>int</span> receive <span>=</span> <span>0</span><span>;</span>
            <span>try</span> <span>{</span>
                writer<span>.</span><span>write</span><span>(</span><span>"test"</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span> <span>finally</span> <span>{</span>
                <span>try</span> <span>{</span>
                    writer<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>IOException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>IOException</span><span>,</span> <span>InterruptedException</span> <span>{</span>
        <span>PipedWriter</span> writer <span>=</span> <span>new</span> <span>PipedWriter</span><span>(</span><span>)</span><span>;</span>
        <span>PipedReader</span> reader <span>=</span> <span>new</span> <span>PipedReader</span><span>(</span><span>)</span><span>;</span>
        writer<span>.</span><span>connect</span><span>(</span>reader<span>)</span><span>;</span> <span>// 这里注意一定要连接，才能通信</span>

        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ReaderThread</span><span>(</span>reader<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>WriterThread</span><span>(</span>writer<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>// 输出：</span>
<span>this</span> is reader
<span>this</span> is writer
test
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br></div></div><p>我们通过线程的构造函数，传入了 <code>PipedWrite</code> 和 <code>PipedReader</code> 对象。可以简单分析一下这个示例代码的执行流程：</p>
<ol>
<li>线程 ReaderThread 开始执行，</li>
<li>线程 ReaderThread 使用管道 reader.read() 进入【阻塞】，</li>
<li>线程 WriterThread 开始执行，</li>
<li>线程 WriterThread 用 writer.write(&quot;test&quot;) 往管道写入字符串，</li>
<li>线程 WriterThread 使用 writer.close() 结束管道写入，并执行完毕，</li>
<li>线程 ReaderThread 接受到管道输出的字符串并打印，</li>
<li>线程 ReaderThread 执行完毕。</li>
</ol>
<h3 id="管道通信的应用场景"> 管道通信的应用场景：</h3>
<p>这个很好理解。使用管道多半与 I/O 流相关。当我们一个线程需要先另一个线程发送一个信息（比如字符串）或者文件等等时，就需要使用管道通信了。</p>
<h2 id="五、其它通信相关"> 五、其它通信相关</h2>
<p>以上介绍了一些线程间通信的基本原理和方法。除此以外，还有一些与线程通信相关的知识点，这里一并介绍。</p>
<h3 id="_5-1-join方法"> 5.1 join方法</h3>
<p>join() 方法是 Thread 类的一个实例方法。它的作用是让当前线程陷入【等待】状态，<strong>等join的这个线程执行完成后，再继续执行当前线程。</strong></p>
<p>有时候，主线程创建并启动了子线程，如果子线程中需要进行大量的耗时运算，主线程往往将早于子线程结束之前结束。</p>
<p>如果主线程想等待子线程执行完毕后，获得子线程中的处理完的某个数据，就要用到 join 方法了。</p>
<p>示例代码：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>Join</span> <span>{</span>
    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是子线程，我先睡一秒"</span><span>)</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"我是子线程，我睡完了一秒"</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>Thread</span> thread <span>=</span> <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span><span>)</span><span>)</span><span>;</span>
        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        thread<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"如果不加join方法，我会先被打出来，加了就不一样了"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><blockquote>
<p>注意 join() 方法有两个重载方法，一个是 join(long)， 一个是 join(long, int)。</p>
<p>实际上，通过源码你会发现，join() 方法及其重载方法底层都是利用了 wait(long) 这个方法。</p>
<p>对于 join(long, int)，通过查看源码(JDK 1.8)发现，底层并没有精确到纳秒，而是对第二个参数做了简单的判断和处理。</p>
</blockquote>
<h3 id="_5-2-sleep方法"> 5.2 sleep方法</h3>
<p>sleep 方法是 Thread 类的一个静态方法。它的作用是让 <strong>当前线程睡眠一段时间</strong>。它有这样两个方法：</p>
<ul>
<li>Thread.sleep(long)</li>
<li>Thread.sleep(long, int)</li>
</ul>
<blockquote>
<p>同样，查看源码(JDK 1.8)发现，第二个方法貌似只对第二个参数做了简单的处理，没有精确到纳秒。实际上还是调用的第一个方法。</p>
</blockquote>
<p>这里需要强调一下： <mark>sleep 方法是不会释放当前的锁的，而 wait 方法会。</mark> 这也是最常见的一个多线程面试题。</p>
<div><p>sleep 和 wait 的区别</p>
<ul>
<li>
<p>sleep 方法是不会释放当前的锁的，而 wait 方法会</p>
</li>
<li>
<p>wait 可以指定时间，也可以不指定；而 sleep 必须指定时间。</p>
</li>
<li>
<p>wait 释放 cpu 资源，同时释放锁； <mark>sleep 释放cpu资源，但是不释放锁，所以易死锁</mark></p>
</li>
<li>
<p>wait 必须放在同步块或同步方法中，而 sleep 可以在任意位置。</p>
</li>
</ul>
</div>
<h3 id="_5-3-threadlocal类"> 5.3 ThreadLocal类</h3>
<p>ThreadLocal 是一个本地线程副本变量工具类。内部是一个<strong>弱引用</strong>的 Map 来维护。这里不详细介绍它的原理，而是只是介绍它的使用，以后有独立章节来介绍 ThreadLocal 类的原理。</p>
<p>有些朋友称 ThreadLocal 为 <strong>线程本地变量</strong> 或 <strong>线程本地存储</strong>。严格来说，ThreadLocal 类并不属于多线程间的通信，而是让每个线程有自己【独立】的变量，线程之间互不影响。它为每个线程都创建一个 <strong>副本</strong>，每个线程可以访问自己内部的副本变量。</p>
<p>ThreadLocal 类最常用的就是 set 方法和 get 方法。示例代码：</p>
<div><div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>ThreadLocalDemo</span> <span>{</span>
    <span>static</span> <span>class</span> <span>ThreadA</span> <span>implements</span> <span>Runnable</span> <span>{</span>
        <span>private</span> <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>;</span>

        <span>public</span> <span>ThreadA</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>)</span> <span>{</span>
            <span>this</span><span>.</span>threadLocal <span>=</span> threadLocal<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            threadLocal<span>.</span><span>set</span><span>(</span><span>"A"</span><span>)</span><span>;</span>
            <span>try</span> <span>{</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ThreadA输出："</span> <span>+</span> threadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>static</span> <span>class</span> <span>ThreadB</span> <span>implements</span> <span>Runnable</span> <span>{</span>
            <span>private</span> <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>;</span>

            <span>public</span> <span>ThreadB</span><span>(</span><span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal<span>)</span> <span>{</span>
                <span>this</span><span>.</span>threadLocal <span>=</span> threadLocal<span>;</span>
            <span>}</span>

            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                threadLocal<span>.</span><span>set</span><span>(</span><span>"B"</span><span>)</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"ThreadB输出："</span> <span>+</span> threadLocal<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
            <span>ThreadLocal</span><span><span>&lt;</span><span>String</span><span>></span></span> threadLocal <span>=</span> <span>new</span> <span>ThreadLocal</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadA</span><span>(</span>threadLocal<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>ThreadB</span><span>(</span>threadLocal<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>// 输出：</span>
<span>ThreadA</span>输出：<span>A</span>
<span>ThreadB</span>输出：<span>B</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br></div></div><p>可以看到，虽然两个线程使用的同一个 ThreadLocal 实例（通过构造方法传入），但是它们各自可以存取自己当前线程的一个值。</p>
<div><p>应用场景</p>
<p>那 ThreadLocal 有什么作用呢？如果只是单纯的想要线程隔离，在每个线程中声明一个私有变量就好了呀，为什么要使用 ThreadLocal？</p>
<p>如果开发者希望将类的某个静态变量（user ID 或者 transaction ID）与线程状态关联，则可以考虑使用 ThreadLocal。</p>
<p>最常见的 ThreadLocal 使用场景为用来解决数据库连接、Session 管理等。数据库连接和 Session 管理涉及多个复杂对象的初始化和关闭。如果在每个线程中声明一些私有变量来进行操作，那这个线程就变得不那么【轻量】了，需要频繁的创建和关闭连接。</p>
</div>
<h3 id="_5-4-inheritablethreadlocal"> 5.4 InheritableThreadLocal</h3>
<p>InheritableThreadLocal 类与 ThreadLocal 类稍有不同，Inheritable 是继承的意思。它不仅仅是当前线程可以存取副本值，而且它的子线程也可以存取这个副本值。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第八章、volatile</title>
    <id>https://notes.lllllan.cn/java/concurrent/2/8/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/2/8/"/>
    <updated>2022-04-18T08:34:40.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/02/8.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第八章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、基本概念"> 一、基本概念</h2>
<h3 id="_1-1-内存可见性"> 1.1 内存可见性</h3>
<p>在 Java 内存模型那一章我们介绍了 JMM 有一个主内存，每个线程有自己私有的工作内存，工作内存中保存了一些变量在主内存的拷贝。</p>
<p><strong>内存可见性，指的是线程之间的可见性，当一个线程修改了共享变量时，另一个线程可以读取到这个修改后的值</strong>。</p>
<h3 id="_1-2-重排序"> 1.2 重排序</h3>
<p>为优化程序性能，对原有的指令执行顺序进行优化重新排序。重排序可能发生在多个阶段，比如编译重排序、CPU重排序等。</p>
<h3 id="_1-3-happens-before规则"> 1.3 happens-before规则</h3>
<p>是一个给程序员使用的规则，只要程序员在写代码的时候遵循 happens-before 规则，JVM就能保证指令在多线程之间的顺序性符合程序员的预期。</p>
<h2 id="二、volatile的内存语义"> 二、volatile的内存语义</h2>
<div><p>volatile 主要功能：</p>
<ul>
<li>保证变量的 <strong>内存可见性</strong></li>
<li>禁止 volatile 变量与普通变量 <strong>重排序</strong>（JSR133提出，Java 5 开始才有这个“增强的volatile内存语义”）</li>
</ul>
</div>
<h3 id="_2-1-内存可见性"> 2.1 内存可见性</h3>
<p>以一段示例代码开始：</p>
<div><pre><code><span>public</span> <span>class</span> <span>VolatileExample</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>0</span><span>;</span>
    <span>volatile</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span>
    
    <span>public</span> <span>void</span> <span>writer</span><span>(</span><span>)</span> <span>{</span>
        a <span>=</span> <span>1</span><span>;</span> <span>// step 1</span>
        flag <span>=</span> <span>true</span><span>;</span> <span>// step 2</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>reader</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>flag<span>)</span> <span>{</span> <span>// step 3</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>a<span>)</span><span>;</span> <span>// step 4</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p>在这段代码里，我们使用 <code>volatile</code> 关键字修饰了一个 <code>boolean</code> 类型的变量 <code>flag</code>。</p>
<p>所谓内存可见性，指的是当一个线程对 <code>volatile</code> 修饰的变量进行 <strong>写操作</strong>（比如step 2）时，JMM 会立即把该线程对应的本地内存中的共享变量的值刷新到主内存；当一个线程对 <code>volatile</code> 修饰的变量进行 <strong>读操作</strong>（比如step 3）时，JMM会把立即该线程对应的本地内存置为无效，从主内存中读取共享变量的值。</p>
<blockquote>
<p>在这一点上，volatile与锁具有相同的内存效果，volatile变量的写和锁的释放具有相同的内存语义，volatile变量的读和锁的获取具有相同的内存语义。</p>
</blockquote>
<p>假设在时间线上，线程 A 先执行方法 <code>writer</code> 方法，线程 B 后执行 <code>reader</code> 方法。那必然会有下图：</p>
<p><img src="./README.assets/volatile内存示意图.jpg" alt="volatile内存示意图" loading="lazy"></p>
<p>而如果 <code>flag</code> 变量 <strong>没有</strong> 用 <code>volatile</code> 修饰，在 step 2，线程 A 的本地内存里面的变量就不会立即更新到主内存，那随后线程B也同样不会去主内存拿最新的值，仍然使用线程B本地内存缓存的变量的值 <code>a = 0，flag = false</code>。</p>
<h3 id="_2-2-禁止重排序"> 2.2 禁止重排序</h3>
<p>在JSR-133之前的旧的Java内存模型中，是允许 volatile 变量与普通变量重排序的。那上面的案例中，可能就会被重排序成下列时序来执行：</p>
<ol>
<li>线程 A 写 volatile 变量，step 2，设置 flag 为 true；</li>
<li>线程 B 读同一个 volatile，step 3，读取到 flag 为 true；</li>
<li>线程 B 读普通变量，step 4，读取到 a = 0；</li>
<li>线程 A 修改普通变量，step 1，设置 a = 1；</li>
</ol>
<p>可见，如果 volatile 变量与普通变量发生了重排序，虽然 volatile 变量能保证内存可见性，也可能导致普通变量读取错误。</p>
<p>所以在旧的内存模型中，volatile 的【写-读】就不能与锁的【释放-获取】具有相同的内存语义了。为了提供一种比锁更轻量级的 <strong>线程间的通信机制</strong>，<strong>JSR-133</strong> 专家组决定增强volatile的内存语义：严格限制编译器和处理器对volatile变量与普通变量的重排序。</p>
<p>编译器还好说，JVM 是怎么还能限制处理器的重排序的呢？它是通过 <strong>内存屏障</strong> 来实现的。</p>
<div><p>内存屏障</p>
<p>硬件层面，内存屏障分两种：读屏障（Load Barrier）和写屏障（Store Barrier）。内存屏障有两个作用：</p>
<ol>
<li>阻止屏障两侧的指令重排序；</li>
<li>强制把写缓冲区/高速缓存中的脏数据等写回主内存，或者让缓存中相应的数据失效。</li>
</ol>
<blockquote>
<p>注意这里的缓存主要指的是CPU缓存，如L1，L2等</p>
</blockquote>
</div>
<p>编译器在<strong>生成字节码时</strong>，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。编译器选择了一个<strong>比较保守的JMM内存屏障插入策略</strong>，这样可以保证在任何处理器平台，任何程序中都能得到正确的volatile内存语义。这个策略是：</p>
<ul>
<li>在每个volatile写操作前插入一个StoreStore屏障；</li>
<li>在每个volatile写操作后插入一个StoreLoad屏障；</li>
<li>在每个volatile读操作后插入一个LoadLoad屏障；</li>
<li>在每个volatile读操作后再插入一个LoadStore屏障。</li>
</ul>
<p>大概示意图是这个样子：</p>
<p><img src="./README.assets/内存屏障-16473466483002.png" alt="内存屏障" loading="lazy"></p>
<blockquote>
<p>再逐个解释一下这几个屏障。注：下述Load代表读操作，Store代表写操作</p>
<p><strong>LoadLoad屏障</strong>：对于这样的语句Load1; LoadLoad; Load2，在Load2及后续读取操作要读取的数据被访问前，保证Load1要读取的数据被读取完毕。
<strong>StoreStore屏障</strong>：对于这样的语句Store1; StoreStore; Store2，在Store2及后续写入操作执行前，这个屏障会把Store1强制刷新到内存，保证Store1的写入操作对其它处理器可见。
<strong>LoadStore屏障</strong>：对于这样的语句Load1; LoadStore; Store2，在Store2及后续写入操作被刷出前，保证Load1要读取的数据被读取完毕。
<strong>StoreLoad屏障</strong>：对于这样的语句Store1; StoreLoad; Load2，在Load2及后续所有读取操作执行前，保证Store1的写入对所有处理器可见。它的开销是四种屏障中最大的（冲刷写缓冲器，清空无效化队列）。在大多数处理器的实现中，这个屏障是个万能屏障，兼具其它三种内存屏障的功能</p>
</blockquote>
<p>对于连续多个volatile变量读或者连续多个volatile变量写，编译器做了一定的优化来提高性能，比如：</p>
<blockquote>
<p>第一个volatile读;</p>
<p>LoadLoad屏障；</p>
<p>第二个volatile读；</p>
<p>LoadStore屏障</p>
</blockquote>
<p>再介绍一下volatile与普通变量的重排序规则:</p>
<ol>
<li>如果第一个操作是volatile读，那无论第二个操作是什么，都不能重排序；</li>
<li>如果第二个操作是volatile写，那无论第一个操作是什么，都不能重排序；</li>
<li>如果第一个操作是volatile写，第二个操作是volatile读，那不能重排序。</li>
</ol>
<p>举个例子，我们在案例中step 1，是普通变量的写，step 2是volatile变量的写，那符合第2个规则，这两个steps不能重排序。而step 3是volatile变量读，step 4是普通变量读，符合第1个规则，同样不能重排序。</p>
<p>但如果是下列情况：第一个操作是普通变量读，第二个操作是volatile变量读，那是可以重排序的：</p>
<div><pre><code><span>// 声明变量</span>
<span>int</span> a <span>=</span> <span>0</span><span>;</span> <span>// 声明普通变量</span>
<span>volatile</span> <span>boolean</span> flag <span>=</span> <span>false</span><span>;</span> <span>// 声明volatile变量</span>

<span>// 以下两个变量的读操作是可以重排序的</span>
<span>int</span> i <span>=</span> a<span>;</span> <span>// 普通变量读</span>
<span>boolean</span> j <span>=</span> flag<span>;</span> <span>// volatile变量读</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="三、volatile的用途"> 三、volatile的用途</h2>
<p>从 volatile 的内存语义上来看，volatile 可以保证内存可见性且禁止重排序。</p>
<p>在保证内存可见性这一点上，volatile 有着与锁相同的内存语义，所以可以作为一个【轻量级】的锁来使用。但由于 volatile 仅仅保证对单个 volatile 变量的读/写具有原子性，而锁可以保证整个 <strong>临界区代码</strong> 的执行具有原子性。所以 <strong>在功能上，锁比 volatile 更强大；在性能上，volatile 更有优势</strong>。</p>
<p>在禁止重排序这一点上，volatile 也是非常有用的。比如我们熟悉的单例模式，其中有一种实现方式是【双重锁检查】，比如这样的代码：</p>
<div><div><br><br><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>Singleton</span> <span>{</span>

    <span>private</span> <span>static</span> <span>Singleton</span> instance<span>;</span> <span>// 不使用volatile关键字</span>
    
    <span>// 双重锁检验</span>
    <span>public</span> <span>static</span> <span>Singleton</span> <span>getInstance</span><span>(</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// 第7行</span>
            <span>synchronized</span> <span>(</span><span>Singleton</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span>instance <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// 第10行</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> instance<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>如果这里的变量声明不使用volatile关键字，是可能会发生错误的。它可能会被重排序：</p>
<div><pre><code>instance <span>=</span> <span>new</span> <span>Singleton</span><span>(</span><span>)</span><span>;</span> <span>// 第10行</span>

<span>// 可以分解为以下三个步骤</span>
<span>1</span> memory <span>=</span> <span>allocate</span><span>(</span><span>)</span><span>;</span><span>// 分配内存 相当于c的malloc</span>
<span>2</span> <span>ctorInstanc</span><span>(</span>memory<span>)</span> <span>//初始化对象</span>
<span>3</span> s <span>=</span> memory <span>//设置s指向刚分配的地址</span>

<span>// 上述三个步骤可能会被重排序为 1-3-2，也就是：</span>
<span>1</span> memory <span>=</span> <span>allocate</span><span>(</span><span>)</span><span>;</span><span>// 分配内存 相当于c的malloc</span>
<span>3</span> s <span>=</span>memory <span>//设置s指向刚分配的地址</span>
<span>2</span> <span>ctorInstanc</span><span>(</span>memory<span>)</span> <span>//初始化对象</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>而一旦假设发生了这样的重排序，比如线程 A 在第 10 行执行了步骤 1 和步骤 3，但是步骤 2 还没有执行完。这个时候另一个线程B执行到了第 7 行，它会判定 instance 不为空，然后直接返回了一个未初始化完成的 instance！</p>
<p>所以JSR-133对volatile做了增强后，volatile的禁止重排序功能还是非常有用的。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第七章、重排序与happens-before</title>
    <id>https://notes.lllllan.cn/java/concurrent/2/7/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/2/7/"/>
    <updated>2022-04-18T08:34:40.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/02/7.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第七章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、什么是重排序"> 一、什么是重排序</h2>
<p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<h3 id="_1-1-为什么指令重排序可以提高性能"> 1.1 为什么指令重排序可以提高性能？</h3>
<p>简单地说，每一个指令都会包含多个步骤，每个步骤可能使用不同的硬件。因此，<strong>流水线技术</strong>产生了，它的原理是指令 1 还没有执行完，就可以开始执行指令 2，而不用等到指令 1 执行结束之后再执行指令 2，这样就大大提高了效率。</p>
<p>但是，流水线技术最害怕 <strong>中断</strong>，恢复中断的代价是比较大的，所以我们要想尽办法不让流水线中断。指令重排就是减少中断的一种技术。</p>
<p>我们分析一下下面这个代码的执行情况：</p>
<div><pre><code>a = b + c;
d = e - f ;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>先加载 b、c（<strong>注意，即有可能先加载b，也有可能先加载c</strong>），但是在执行 add(b, c) 的时候，需要等待 b、c 装载结束才能继续执行，也就是增加了停顿，那么后面的指令也会依次有停顿,这降低了计算机的执行效率。</p>
<p>为了减少这个停顿，我们可以先加载 e 和 f，然后再去加载 add(b, c)，这样做对程序（串行）是没有影响的，但却减少了停顿。既然 add(b, c) 需要停顿，那还不如去做一些有意义的事情。</p>
<p>综上所述，<strong>指令重排对于提高CPU处理性能十分必要。虽然由此带来了乱序的问题，但是这点牺牲是值得的。</strong></p>
<h3 id="_1-2-指令重排"> 1.2 指令重排</h3>
<ul>
<li>
<p><strong>编译器优化重排</strong></p>
<p>编译器在 <strong>不改变单线程程序语义</strong> 的前提下，可以重新安排语句的执行顺序。</p>
</li>
<li>
<p><strong>指令并行重排</strong></p>
<p>现代处理器采用了指令级并行技术来将多条指令重叠执行。如果 <strong>不存在数据依赖性</strong> （即后一个执行的语句无需依赖前面执行的语句的结果），处理器可以改变语句对应的机器指令的执行顺序。</p>
</li>
<li>
<p><strong>内存系统重排</strong></p>
<p>由于处理器使用缓存和读写缓存冲区，这使得加载(load)和存储(store)操作看上去可能是在乱序执行，因为三级缓存的存在，导致内存与缓存的数据同步存在时间差。</p>
</li>
</ul>
<p><strong>指令重排可以保证串行语义一致，但是没有义务保证多线程间的语义也一致</strong>。所以在多线程下，指令重排序可能会导致一些问题。</p>
<h2 id="二、顺序一致性模型与jmm的保证"> 二、顺序一致性模型与JMM的保证</h2>
<p>顺序一致性模型是一个 <strong>理论参考模型</strong>，内存模型在设计的时候都会以顺序一致性内存模型作为参考。</p>
<h3 id="_2-1-数据竞争与顺序一致性"> 2.1 数据竞争与顺序一致性</h3>
<p>当程序未正确同步的时候，就可能存在数据竞争。</p>
<div><p>数据竞争</p>
<p>在一个线程中写一个变量，在另一个线程读同一个变量，并且写和读没有通过同步来排序。</p>
</div>
<p>如果程序中包含了数据竞争，那么运行的结果往往充满了<strong>不确定性</strong>，比如读发生在了写之前，可能就会读到错误的值；如果一个线程程序能够正确同步，那么就不存在数据竞争。</p>
<p>Java 内存模型（JMM）对于正确同步多线程程序的内存一致性做了以下保证：</p>
<blockquote>
<p><strong>如果程序是正确同步的，程序的执行将具有顺序一致性</strong>。 即程序的执行结果和该程序在顺序一致性模型中执行的结果相同。</p>
</blockquote>
<p>这里的同步包括了使用 <code>volatile</code>、<code>final</code>、<code>synchronized</code> 等关键字来实现<strong>多线程下的同步</strong>。</p>
<p>如果程序员没有正确使用 <code>volatile</code>、<code>final</code>、<code>synchronized</code>，那么即便是使用了同步（单线程下的同步），JMM 也不会有内存可见性的保证，可能会导致你的程序出错，并且具有不可重现性，很难排查。</p>
<p>所以如何正确使用<code>volatile</code>、<code>final</code>、<code>synchronized</code>，是程序员应该去了解的。</p>
<h3 id="_2-2-顺序一致性模型"> 2.2 顺序一致性模型</h3>
<p><a href="./../../def/sequential-consistency/">顺序一致性的理解</a></p>
<p>顺序一致性内存模型是一个<strong>理想化的理论参考模型</strong>，它为程序员提供了极强的内存可见性保证。</p>
<div><p>顺序一致性模型 两大特性</p>
<ul>
<li>一个线程中的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。</li>
<li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是<strong>原子性的，且立刻对所有线程可见</strong>。</li>
</ul>
</div>
<p>为了理解这两个特性，我们举个例子，假设有两个线程A和B并发执行，线程A有3个操作，他们在程序中的顺序是<code>A1-&gt;A2-&gt;A3</code>，线程B也有3个操作，<code>B1-&gt;B2-&gt;B3</code>。</p>
<p>假设<strong>正确使用了同步</strong>，A 线程的 3 个操作执行后释放锁，B 线程获取同一个锁。那么在 <strong>顺序一致性模型</strong> 中的执行效果如下所示：</p>
<p><img src="./README.assets/正确同步.png" alt="正确同步" loading="lazy"></p>
<p>操作的执行整体上有序，并且两个线程都只能看到这个执行顺序。</p>
<p>假设 <strong>没有使用同步</strong>，那么在 <strong>顺序一致性模型</strong> 中的执行效果如下所示：</p>
<p><img src="./README.assets/没有正确同步.png" alt="没有正确同步" loading="lazy"></p>
<p>操作的执行整体上无序，但是两个线程都只能看到这个执行顺序。之所以可以得到这个保证，是因为顺序一致性模型中的 <strong>每个操作必须立即对任意线程可见</strong>。</p>
<p><strong>但是JMM没有这样的保证。</strong></p>
<p>比如，在当前线程把写过的数据缓存在本地内存中，在没有刷新到主内存之前，这个写操作仅对当前线程可见；从其他线程的角度来观察，这个写操作根本没有被当前线程所执行。只有当前线程把本地内存中写过的数据刷新到主内存之后，这个写操作才对其他线程可见。在这种情况下，当前线程和其他线程看到的执行顺序是不一样的。</p>
<h3 id="_2-3-jmm中同步程序的顺序一致性效果"> 2.3 JMM中同步程序的顺序一致性效果</h3>
<p>在顺序一致性模型中，所有操作完全按照程序的顺序串行执行。但是JMM中，<mark>临界区内（同步块或同步方法中）</mark> 的代码可以发生重排序（但不允许临界区内的代码【逃逸】到临界区之外，因为会破坏锁的内存语义）。</p>
<p><strong>虽然线程 A 在临界区做了重排序，但是因为锁的特性，线程 B 无法观察到线程 A 在临界区的重排序。这种重排序既提高了执行效率，又没有改变程序的执行结果。</strong></p>
<p>同时，JMM会在退出临界区和进入临界区做特殊的处理，使得在临界区内程序获得与顺序一致性模型相同的内存视图。</p>
<p><strong>由此可见，JMM的具体实现方针是：在不改变（正确同步的）程序执行结果的前提下，尽量为编译期和处理器的优化打开方便之门</strong>。</p>
<h3 id="_2-4-jmm中未同步程序的顺序一致性效果"> 2.4 JMM中未同步程序的顺序一致性效果</h3>
<p>对于未同步的多线程程序，JMM只提供<strong>最小安全性</strong>：线程读取到的值，要么是之前某个线程写入的值，要么是默认值，不会无中生有。</p>
<p>为了实现这个安全性，JVM在堆上分配对象时，首先会对内存空间清零，然后才会在上面分配对象（这两个操作是同步的）。</p>
<p><strong>JMM没有保证未同步程序的执行结果与该程序在顺序一致性中执行结果一致。因为如果要保证执行结果一致，那么JMM需要禁止大量的优化，对程序的执行性能会产生很大的影响。</strong></p>
<div><p>未同步程序在JMM和顺序一致性内存模型中的执行特性有如下差异：</p>
<ol>
<li>顺序一致性保证单线程内的操作会按程序的顺序执行；JMM不保证单线程内的操作会按程序的顺序执行。（因为重排序，但是JMM保证单线程下的重排序不影响执行结果）</li>
<li>顺序一致性模型保证所有线程只能看到一致的操作执行顺序，而JMM不保证所有线程能看到一致的操作执行顺序。（因为JMM不保证所有操作立即可见）</li>
<li>顺序一致性模型保证对所有的内存读写操作都具有原子性，而JMM不保证对64位的long型和double型变量的写操作具有原子性。</li>
</ol>
</div>
<h2 id="三、happens-before"> 三、happens-before</h2>
<h3 id="_3-1-什么是-happens-before"> 3.1 什么是 happens-before</h3>
<blockquote>
<p>一方面，程序员需要JMM提供一个强的内存模型来编写代码；另一方面，编译器和处理器希望JMM对它们的束缚越少越好，这样它们就可以最可能多的做优化来提高性能，希望的是一个弱的内存模型。</p>
</blockquote>
<p>JMM考虑了这两种需求，并且找到了平衡点，对编译器和处理器来说，<strong>只要不改变程序的执行结果（单线程程序和正确同步了的多线程程序），编译器和处理器怎么优化都行。</strong></p>
<p>而对于程序员，JMM 提供了 <mark>happens-before规则（JSR-133规范）</mark> ，满足了程序员的需求 —— <mark>简单易懂，并且提供了足够强的内存可见性保证</mark>。 换言之，程序员只要遵循 happens-before 规则，那他写的程序就能保证在 JMM 中具有强的内存可见性。</p>
<p>JMM 使用 happens-before 的概念来定制两个操作之间的执行顺序。这两个操作可以在一个线程以内，也可以是不同的线程之间。因此，JMM 可以通过 happens-before 关系向程序员提供跨线程的内存可见性保证。</p>
<div><p>happens-before 关系定义</p>
<ol>
<li>如果一个操作 happens-before 另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。</li>
<li><strong>两个操作之间存在 happens-before 关系，并不意味着 Java 平台的具体实现必须要按照 happens-before 关系指定的顺序来执行。如果重排序之后的执行结果，与按 happens-before 关系来执行的结果一致，那么 JMM 也允许这样的重排序。</strong></li>
</ol>
</div>
<div><p>as-if-serial</p>
<p>happens-before 关系本质上和 as-if-serial 语义是一回事。</p>
<p><mark>不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变</mark></p>
<p>happens-before 关系保证正确同步的多线程程序的执行结果不被重排序改变。</p>
</div>
<p>总之，<strong>如果操作A happens-before操作B，那么操作A在内存上所做的操作对操作B都是可见的，不管它们在不在一个线程。</strong></p>
<h3 id="_3-2-天然的happens-before关系"> 3.2 天然的happens-before关系</h3>
<p>在Java中，有以下天然的happens-before关系：</p>
<ul>
<li>程序顺序规则：一个线程中的每一个操作，happens-before于该线程中的任意后续操作。</li>
<li>监视器锁规则：对一个锁的解锁，happens-before于随后对这个锁的加锁。</li>
<li>volatile变量规则：对一个volatile域的写，happens-before于任意后续对这个volatile域的读。</li>
<li>传递性：如果A happens-before B，且B happens-before C，那么A happens-before C。</li>
<li>start规则：如果线程A执行操作ThreadB.start()启动线程B，那么A线程的ThreadB.start（）操作happens-before于线程B中的任意操作、</li>
<li>join规则：如果线程A执行操作ThreadB.join（）并成功返回，那么线程B中的任意操作happens-before于线程A从ThreadB.join()操作成功返回。</li>
</ul>
<p>举例：</p>
<div><pre><code>int a = 1; // A操作
int b = 2; // B操作
int sum = a + b;// C 操作
System.out.println(sum);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>根据以上介绍的happens-before规则，假如只有一个线程，那么不难得出：</p>
<div><pre><code>1&gt; A happens-before B 
2&gt; B happens-before C 
3&gt; A happens-before C
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>注意，真正在执行指令的时候，其实JVM有可能对操作A &amp; B进行重排序，因为无论先执行A还是B，他们都对对方是可见的，并且不影响执行结果。</p>
<p>如果这里发生了重排序，这在视觉上违背了 happens-before 原则，但是JMM是允许这样的重排序的。</p>
<p>所以，我们只关心 happens-before 规则，不用关心JVM到底是怎样执行的。只要确定操作A happens-before操作B就行了。</p>
<p>重排序有两类，JMM对这两类重排序有不同的策略：</p>
<ul>
<li>会改变程序执行结果的重排序，比如 A -&gt; C，JMM要求编译器和处理器都禁止这种重排序。</li>
<li>不会改变程序执行结果的重排序，比如 A -&gt; B，JMM对编译器和处理器不做要求，允许这种重排序。</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第六章、Java内存模型基础知识</title>
    <id>https://notes.lllllan.cn/java/concurrent/2/6/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/2/6/"/>
    <updated>2022-04-18T08:16:26.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/02/6.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第六章 - GitHub</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/29881777" target="_blank" rel="noopener noreferrer">Java内存模型（JMM）总结</a></li>
</ul>
</div>
<h2 id="一、并发编程模型的两个关键问题"> 一、并发编程模型的两个关键问题</h2>
<ul>
<li>线程间如何通信？即：线程之间以何种机制来交换信息</li>
<li>线程间如何同步？即：线程以何种机制来控制不同线程间操作发生的相对顺序</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">如何通信</th>
<th style="text-align:center">如何同步</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">消息传递并发模型</td>
<td style="text-align:center">线程之间<strong>没有公共状态</strong>，线程间的通信必须通过发送消息来显示进行通信</td>
<td style="text-align:center">发送消息天然同步，因为发送消息总是在接收消息之前，因此同步是隐式的</td>
</tr>
<tr>
<td style="text-align:center">共享内存并发模型</td>
<td style="text-align:center">线程之间共享程序的公共状态，通过<strong>写-读内存中的公共状态</strong>进行隐式通信</td>
<td style="text-align:center"><strong>必须显式指定代码需要在线程之间互斥执行</strong></td>
</tr>
</tbody>
</table>
<p><mark>在Java中，使用的是共享内存并发模型</mark></p>
<h2 id="二、java内存模型的抽象结构"> 二、Java内存模型的抽象结构</h2>
<h3 id="_2-1-运行时内存的划分"> 2.1 运行时内存的划分</h3>
<p><img src="./README.assets/Java运行时数据区.png" alt="Java运行时数据区" loading="lazy"></p>
<p>对于每一个线程来说，栈都是私有的，而堆是共有的。</p>
<p>也就是说在栈中的变量（局部变量、方法定义参数、异常处理器参数）不会在线程之间共享，也就不会有内存可见性（下文会说到）的问题，也不受内存模型的影响。而在堆中的变量是共享的，本文称为共享变量。</p>
<p>所以，<strong>内存可见性是针对的共享变量。</strong></p>
<h3 id="_2-2-既然堆是共享的-为什么在堆中会有内存不可见问题"> 2.2 既然堆是共享的，为什么在堆中会有内存不可见问题？</h3>
<blockquote>
<p>这是因为现代计算机为了高效，<strong>往往会在高速缓存区中缓存共享变量</strong>，因为 cpu 访问缓存区比访问内存要快得多。</p>
</blockquote>
<p><mark>线程之间的共享变量存在主内存中，每个线程都有一个私有的本地内存，存储了该线程以读、写共享变量的副本</mark>。本地内存是 Java 内存模型的一个抽象概念，并不真实存在。它涵盖了缓存、写缓冲区、寄存器等。</p>
<p>Java 线程之间的通信由 Java 内存模型（简称 JMM）控制，从抽象的角度来说，JMM 定义了线程和主内存之间的抽象关系。JMM 的抽象示意图如图所示：</p>
<div><p>JMM</p>
<p>我们常说的 JVM 内存模式指的是 JVM 的内存分区；而 Java 内存模式是一种 <mark>虚拟机规范</mark>。</p>
<p>Java 虚拟机规范中定义了 Java 内存模型（Java Memory Model，JMM），用于屏蔽掉各种硬件和操作系统的内存访问差异，以 <strong>实现让Java程序在各种平台下都能达到一致的并发效果</strong>，JMM 规范了 Java 虚拟机与计算机内存是如何协同工作的：规定了一个线程如何和何时可以看到由其他线程修改过后的共享变量的值，以及在必须时如何同步的访问共享变量。</p>
</div>
<p><img src="./README.assets/JMM抽象示意图.jpg" alt="JMM抽象示意图" loading="lazy"></p>
<p>从图中可以看出：</p>
<ol>
<li>所有的共享变量都存在主内存中。</li>
<li>每个线程 <strong>都保存了一份该线程使用到的共享变量的副本</strong>。</li>
<li>如果线程 A 与线程 B 之间要通信的话，必须经历下面 2 个步骤：
<ol>
<li>线程 A 将本地内存 A 中更新过的共享变量刷新到主内存中去。</li>
<li>线程 B 到主内存中去读取线程 A 之前已经更新过的共享变量。</li>
</ol>
</li>
</ol>
<p><strong>所以，线程 A 无法直接访问线程 B 的工作内存，线程间通信必须经过主内存。</strong></p>
<p>注意，根据 JMM 的规定，<strong>线程对共享变量的所有操作都必须在自己的本地内存中进行，不能直接从主内存中读取</strong>。</p>
<p>所以线程 B 并不是直接去主内存中读取共享变量的值，而是先在本地内存 B 中找到这个共享变量，发现这个共享变量已经被更新了，然后本地内存B去主内存中读取这个共享变量的新值，并拷贝到本地内存B中，最后线程B再读取本地内存 B 中的新值。</p>
<p>那么怎么知道这个共享变量的被其他线程更新了呢？这就是 JMM 的功劳了，也是 JMM 存在的必要性之一。<strong>JMM 通过控制主内存与每个线程的本地内存之间的交互，来提供内存可见性保证</strong>。</p>
<div><p>Info</p>
<p>Java 中的 volatile 关键字可以保证多线程操作共享变量的可见性以及禁止指令重排序，synchronized 关键字不仅保证可见性，同时也保证了原子性（互斥性）。</p>
<p>更底层，JMM通过<strong>内存屏障</strong>来实现内存的可见性以及禁止重排序。为了程序员的方便理解，提出了 happens-before，它更加的简单易懂，从而避免了程序员为了理解内存可见性而去学习复杂的重排序规则以及这些规则的具体实现方法。</p>
</div>
<h3 id="_2-3-jmm与java内存区域划分的区别与联系"> 2.3 JMM与Java内存区域划分的区别与联系</h3>
<ul>
<li>
<p>区别</p>
<p>两者是不同的概念层次。JMM 是抽象的，他是用来描述一组规则，通过这个规则来控制各个变量的访问方式，围绕原子性、有序性、可见性等展开的。而 Java 运行时内存的划分是具体的，是 JVM 运行 Java 程序时，必要的内存划分。</p>
</li>
<li>
<p>联系</p>
<p>都存在私有数据区域和共享数据区域。一般来说，JMM 中的主内存属于共享数据区域，他是包含了堆和方法区；同样，JMM 中的本地内存属于私有数据区域，包含了程序计数器、本地方法栈、虚拟机栈。</p>
</li>
</ul>
<p><strong>实际上，他们表达的是同一种含义，这里不做区分。</strong></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十三章、阻塞队列</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/13/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/13/"/>
    <updated>2022-03-18T14:28:14.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/13.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十三章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、阻塞队列的由来"> 一、阻塞队列的由来</h2>
<p>我们假设一种场景，生产者一直生产资源，消费者一直消费资源，资源存储在一个缓冲池中，生产者将生产的资源存进缓冲池中，消费者从缓冲池中拿到资源进行消费，这就是大名鼎鼎的<strong>生产者-消费者模式</strong>。</p>
<p>该模式能够简化开发过程，一方面消除了生产者类与消费者类之间的代码依赖性，另一方面将生产数据的过程与使用数据的过程解耦简化负载。</p>
<p>我们自己coding实现这个模式的时候，因为需要让<strong>多个线程操作共享变量</strong>（即资源），所以很容易引发<strong>线程安全问题</strong>，造成<strong>重复消费</strong>和<strong>死锁</strong>，尤其是生产者和消费者存在多个的情况。另外，当缓冲池空了，我们需要阻塞消费者，唤醒生产者；当缓冲池满了，我们需要阻塞生产者，唤醒消费者，这些个<strong>等待-唤醒</strong>逻辑都需要自己实现。（这块不明白的同学，可以看最下方结语部分的链接）</p>
<p>这么容易出错的事情，JDK当然帮我们做啦，这就是阻塞队列(BlockingQueue)，<strong>你只管往里面存、取就行，而不用担心多线程环境下存、取共享变量的线程安全问题。</strong></p>
<div><p>BlockingQueue</p>
<p>是 <code>Java util.concurrent</code> 包下重要的数据结构，区别于普通的队列，BlockingQueue提供了<strong>线程安全的队列访问方式</strong>，并发包下很多高级同步类的实现都是基于BlockingQueue实现的。</p>
</div>
<p>BlockingQueue一般用于生产者-消费者模式，生产者是往队列里添加元素的线程，消费者是从队列里拿元素的线程。<strong>BlockingQueue就是存放元素的容器</strong>。</p>
<h2 id="二、blockingqueue的操作方法"> 二、BlockingQueue的操作方法</h2>
<p>阻塞队列提供了四组不同的方法用于插入、移除、检查元素：</p>
<table>
<thead>
<tr>
<th style="text-align:center">方法\处理方式</th>
<th style="text-align:center">抛出异常</th>
<th style="text-align:center">返回特殊值</th>
<th style="text-align:center">一直阻塞</th>
<th style="text-align:center">超时退出</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">插入方法</td>
<td style="text-align:center">add(e)</td>
<td style="text-align:center">offer(e)</td>
<td style="text-align:center"><strong>put(e)</strong></td>
<td style="text-align:center">offer(e,time,unit)</td>
</tr>
<tr>
<td style="text-align:center">移除方法</td>
<td style="text-align:center">remove()</td>
<td style="text-align:center">poll()</td>
<td style="text-align:center"><strong>take()</strong></td>
<td style="text-align:center">poll(time,unit)</td>
</tr>
<tr>
<td style="text-align:center">检查方法</td>
<td style="text-align:center">element()</td>
<td style="text-align:center">peek()</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
<ul>
<li>抛出异常：如果试图的操作无法立即执行，抛异常。当阻塞队列满时候，再往队列里插入元素，会抛出 <code>IllegalStateException(“Queue full”)</code> 异常。当队列为空时，从队列里获取元素时会抛出 <code>NoSuchElementException</code> 异常 。</li>
<li>返回特殊值：如果试图的操作无法立即执行，返回一个特殊值，通常是 <code>true / false</code>。</li>
<li>一直阻塞：如果试图的操作无法立即执行，则一直阻塞或者响应中断。</li>
<li>超时退出：如果试图的操作无法立即执行，该方法调用将会发生阻塞，直到能够执行，但等待时间不会超过给定值。返回一个特定值以告知该操作是否成功，通常是 <code>true / false</code> 。</li>
</ul>
<div><p>Tips</p>
<ul>
<li><strong>不能往阻塞队列中插入null</strong>，会抛出空指针异常。</li>
<li>可以访问阻塞队列中的任意元素，调用remove(o)可以将队列之中的特定对象移除，但并不高效，尽量避免使用。</li>
</ul>
</div>
<h2 id="三、blockingqueue的实现类-记不住"> 三、BlockingQueue的实现类（记不住）</h2>
<h3 id="_3-1-arrayblockingqueue"> 3.1 ArrayBlockingQueue</h3>
<p>由<strong>数组</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是数组，故具有数组的特性。</p>
<div><pre><code><span>public</span> <span>ArrayBlockingQueue</span><span>(</span><span>int</span> capacity<span>,</span> <span>boolean</span> fair<span>)</span><span>{</span>
 <span>//..省略代码</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>可以初始化队列大小， 且一旦初始化不能改变。构造方法中的fair表示控制对象的内部锁是否采用公平锁，默认是<strong>非公平锁</strong>。</p>
<h3 id="_3-2-linkedblockingqueue"> 3.2 LinkedBlockingQueue</h3>
<p>由<strong>链表</strong>结构组成的<strong>有界</strong>阻塞队列。内部结构是链表，具有链表的特性。默认队列的大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。此队列按照<strong>先进先出</strong>的原则对元素进行排序。</p>
<h3 id="_3-3-delayqueue"> 3.3 DelayQueue</h3>
<p>该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素。注入其中的元素必须实现  <code>java.util.concurrent.Delayed</code> 接口。</p>
<p>DelayQueue 是一个没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</p>
<h3 id="_3-4-priorityblockingqueue"> 3.4 PriorityBlockingQueue</h3>
<p>基于优先级的无界阻塞队列（优先级的判断通过构造函数传入的Compator对象来决定），内部控制线程同步的锁采用的是 <strong>非公平锁</strong>。</p>
<div><pre><code><span>public</span> <span>PriorityBlockingQueue</span><span>(</span><span>int</span> initialCapacity<span>,</span>
                                 <span>Comparator</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> comparator<span>)</span> <span>{</span>
        <span>this</span><span>.</span>lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span> <span>//默认构造方法-非公平锁</span>
        <span>.</span><span>.</span><span>.</span><span>//其余代码略</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><div><p>Tips</p>
<p><strong>PriorityBlockingQueue</strong>不会阻塞数据生产者（因为队列是无界的），而只会在没有可消费的数据时，阻塞数据的消费者。因此使用的时候要特别注意，<strong>生产者生产数据的速度绝对不能快于消费者消费数据的速度，否则时间一长，会最终耗尽所有的可用堆内存空间。<strong>对于使用默认大小的</strong>LinkedBlockingQueue</strong>也是一样的。</p>
</div>
<h3 id="_3-5-synchronousqueue"> 3.5 SynchronousQueue</h3>
<p>这个队列比较特殊，<strong>没有任何内部容量</strong>，甚至连一个队列的容量都没有。并且每个 put 必须等待一个 take，反之亦然。</p>
<p>需要区别容量为1的ArrayBlockingQueue、LinkedBlockingQueue。</p>
<p>以下方法的返回值，可以帮助理解这个队列：</p>
<ul>
<li>iterator() 永远返回空，因为里面没有东西</li>
<li>peek() 永远返回null</li>
<li>put() 往queue放进去一个element以后就一直wait直到有其他thread进来把这个element取走。</li>
<li>offer() 往queue里放一个element后立即返回，如果碰巧这个element被另一个thread取走了，offer方法返回true，认为offer成功；否则返回false。</li>
<li>take() 取出并且remove掉queue里的element，取不到东西他会一直等。</li>
<li>poll() 取出并且remove掉queue里的element，只有到碰巧另外一个线程正在往queue里offer数据或者put数据的时候，该方法才会取到东西。否则立即返回null。</li>
<li>isEmpty() 永远返回true</li>
<li>remove()&amp;removeAll() 永远返回false</li>
</ul>
<h2 id="四、阻塞队列的原理"> 四、阻塞队列的原理</h2>
<p>阻塞队列的原理很简单，利用了Lock锁的多条件（Condition）阻塞控制。接下来我们分析ArrayBlockingQueue JDK 1.8 的源码。</p>
<h3 id="构造器"> <strong>构造器</strong></h3>
<p>除了初始化队列的大小和是否是公平锁之外，还对同一个锁（lock）初始化了两个监视器，分别是 <code>notEmpty</code> 和 <code>notFull</code> 。这两个监视器的作用目前可以简单理解为标记分组：</p>
<ul>
<li>当该线程是 put 操作时，给他加上监视器notFull，标记这个线程是一个生产者；</li>
<li>当线程是 take 操作时，给他加上监视器notEmpty，标记这个线程是消费者。</li>
</ul>
<div><pre><code><span>//数据元素数组</span>
<span>final</span> <span>Object</span><span>[</span><span>]</span> items<span>;</span>

<span>//下一个待取出元素索引</span>
<span>int</span> takeIndex<span>;</span>

<span>//下一个待添加元素索引</span>
<span>int</span> putIndex<span>;</span>

<span>//元素个数</span>
<span>int</span> count<span>;</span>

<span>//内部锁</span>
<span>final</span> <span>ReentrantLock</span> lock<span>;</span>

<span>//消费者监视器</span>
<span>private</span> <span>final</span> <span>Condition</span> notEmpty<span>;</span>
<span>//生产者监视器</span>
<span>private</span> <span>final</span> <span>Condition</span> notFull<span>;</span>  

<span>public</span> <span>ArrayBlockingQueue</span><span>(</span><span>int</span> capacity<span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>
    <span>//..省略其他代码</span>
    lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span>fair<span>)</span><span>;</span>
    notEmpty <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>
    notFull <span>=</span>  lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h3 id="put操作的源码"> put操作的源码</h3>
<div><pre><code><span>public</span> <span>void</span> <span>put</span><span>(</span><span>E</span> e<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>checkNotNull</span><span>(</span>e<span>)</span><span>;</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    
    <span>// 1.自旋拿锁</span>
    lock<span>.</span><span>lockInterruptibly</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>// 2.判断队列是否满了</span>
        <span>while</span> <span>(</span>count <span>==</span> items<span>.</span>length<span>)</span>
            <span>// 2.1如果满了，阻塞该线程，并标记为notFull线程，</span>
            <span>// 等待notFull的唤醒，唤醒之后继续执行while循环。</span>
            notFull<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
        <span>// 3.如果没有满，则进入队列</span>
        <span>enqueue</span><span>(</span>e<span>)</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>void</span> <span>enqueue</span><span>(</span><span>E</span> x<span>)</span> <span>{</span>
    <span>// assert lock.getHoldCount() == 1;</span>
    <span>// assert items[putIndex] == null;</span>
    <span>final</span> <span>Object</span><span>[</span><span>]</span> items <span>=</span> <span>this</span><span>.</span>items<span>;</span>
    items<span>[</span>putIndex<span>]</span> <span>=</span> x<span>;</span>
    <span>if</span> <span>(</span><span>++</span>putIndex <span>==</span> items<span>.</span>length<span>)</span>
        putIndex <span>=</span> <span>0</span><span>;</span>
    count<span>++</span><span>;</span>
    <span>// 4 唤醒一个等待的线程</span>
    notEmpty<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>总结put的流程：</p>
<ol>
<li>所有执行put操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>
<li>判断阻塞队列是否满了，如果满了，则调用await方法阻塞这个线程，并标记为notFull（生产者）线程，同时释放lock锁,等待被消费者线程唤醒。</li>
<li>如果没有满，则调用enqueue方法将元素put进阻塞队列。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>
<li>唤醒一个标记为notEmpty（消费者）的线程。</li>
</ol>
<h3 id="take操作的源码"> take操作的源码</h3>
<div><pre><code><span>public</span> <span>E</span> <span>take</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    lock<span>.</span><span>lockInterruptibly</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>while</span> <span>(</span>count <span>==</span> <span>0</span><span>)</span>
            notEmpty<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
        <span>return</span> <span>dequeue</span><span>(</span><span>)</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>private</span> <span>E</span> <span>dequeue</span><span>(</span><span>)</span> <span>{</span>
    <span>// assert lock.getHoldCount() == 1;</span>
    <span>// assert items[takeIndex] != null;</span>
    <span>final</span> <span>Object</span><span>[</span><span>]</span> items <span>=</span> <span>this</span><span>.</span>items<span>;</span>
    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>E</span> x <span>=</span> <span>(</span><span>E</span><span>)</span> items<span>[</span>takeIndex<span>]</span><span>;</span>
    items<span>[</span>takeIndex<span>]</span> <span>=</span> <span>null</span><span>;</span>
    <span>if</span> <span>(</span><span>++</span>takeIndex <span>==</span> items<span>.</span>length<span>)</span>
        takeIndex <span>=</span> <span>0</span><span>;</span>
    count<span>--</span><span>;</span>
    <span>if</span> <span>(</span>itrs <span>!=</span> <span>null</span><span>)</span>
        itrs<span>.</span><span>elementDequeued</span><span>(</span><span>)</span><span>;</span>
    notFull<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> x<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>take操作和put操作的流程是类似的，总结一下take操作的流程：</p>
<ol>
<li>所有执行take操作的线程竞争lock锁，拿到了lock锁的线程进入下一步，没有拿到lock锁的线程自旋竞争锁。</li>
<li>判断阻塞队列是否为空，如果是空，则调用await方法阻塞这个线程，并标记为notEmpty（消费者）线程，同时释放lock锁,等待被生产者线程唤醒。</li>
<li>如果没有空，则调用dequeue方法。注意这一步的线程还有一种情况是第二步中阻塞的线程被唤醒且又拿到了lock锁的线程。</li>
<li>唤醒一个标记为notFull（生产者）的线程。</li>
</ol>
<div><p>Tips</p>
<ol>
<li>put和take操作都需要<strong>先获取锁</strong>，没有获取到锁的线程会被挡在第一道大门之外自旋拿锁，直到获取到锁。</li>
<li>就算拿到锁了之后，也<strong>不一定</strong>会顺利进行put/take操作，需要判断<strong>队列是否可用</strong>（是否满/空），如果不可用，则会被阻塞，<strong>并释放锁</strong>。</li>
<li>在第2点被阻塞的线程会被唤醒，但是在唤醒之后，<strong>依然需要拿到锁</strong>才能继续往下执行，否则，自旋拿锁，拿到锁了再while判断队列是否可用（这也是为什么不用if判断，而使用while判断的原因）。</li>
</ol>
</div>
<h2 id="五、示例和使用场景"> 五、示例和使用场景</h2>
<h3 id="生产者-消费者模型"> 生产者-消费者模型</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Test</span> <span>{</span>
    <span>private</span> <span>int</span> queueSize <span>=</span> <span>10</span><span>;</span>
    <span>private</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span> queue <span>=</span> <span>new</span> <span>ArrayBlockingQueue</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span>queueSize<span>)</span><span>;</span>
     
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span>  <span>{</span>
        <span>Test</span> test <span>=</span> <span>new</span> <span>Test</span><span>(</span><span>)</span><span>;</span>
        <span>Producer</span> producer <span>=</span> test<span>.</span><span>new</span> <span>Producer</span><span>(</span><span>)</span><span>;</span>
        <span>Consumer</span> consumer <span>=</span> test<span>.</span><span>new</span> <span>Consumer</span><span>(</span><span>)</span><span>;</span>
         
        producer<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        consumer<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
     
    <span>class</span> <span>Consumer</span> <span>extends</span> <span>Thread</span><span>{</span>
         
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>consume</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
         
        <span>private</span> <span>void</span> <span>consume</span><span>(</span><span>)</span> <span>{</span>
            <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>
                <span>try</span> <span>{</span>
                    queue<span>.</span><span>take</span><span>(</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"从队列取走一个元素，队列剩余"</span><span>+</span>queue<span>.</span><span>size</span><span>(</span><span>)</span><span>+</span><span>"个元素"</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
     
    <span>class</span> <span>Producer</span> <span>extends</span> <span>Thread</span><span>{</span>
         
        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>produce</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
         
        <span>private</span> <span>void</span> <span>produce</span><span>(</span><span>)</span> <span>{</span>
            <span>while</span><span>(</span><span>true</span><span>)</span><span>{</span>
                <span>try</span> <span>{</span>
                    queue<span>.</span><span>put</span><span>(</span><span>1</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"向队列取中插入一个元素，队列剩余空间："</span><span>+</span><span>(</span>queueSize<span>-</span>queue<span>.</span><span>size</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br></div></div><p>下面是这个例子的输出片段：</p>
<div><pre><code>从队列取走一个元素，队列剩余0个元素
从队列取走一个元素，队列剩余0个元素
向队列取中插入一个元素，队列剩余空间：9
向队列取中插入一个元素，队列剩余空间：9
向队列取中插入一个元素，队列剩余空间：9
向队列取中插入一个元素，队列剩余空间：8
向队列取中插入一个元素，队列剩余空间：7
向队列取中插入一个元素，队列剩余空间：6
向队列取中插入一个元素，队列剩余空间：5
向队列取中插入一个元素，队列剩余空间：4
向队列取中插入一个元素，队列剩余空间：3
向队列取中插入一个元素，队列剩余空间：2
向队列取中插入一个元素，队列剩余空间：1
向队列取中插入一个元素，队列剩余空间：0
从队列取走一个元素，队列剩余1个元素
从队列取走一个元素，队列剩余9个元素
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>注意，这个例子中的输出结果看起来可能有问题，比如有几行在插入一个元素之后，队列的剩余空间不变。这是由于<strong>System.out.println语句没有锁</strong>。考虑到这样的情况：线程1在执行完put/take操作后立即失去CPU时间片，然后切换到线程2执行put/take操作，执行完毕后回到线程1的System.out.println语句并输出，发现这个时候阻塞队列的size已经被线程2改变了，所以这个时候输出的size并不是当时线程1执行完put/take操作之后阻塞队列的size，但可以确保的是size不会超过10个。实际上使用阻塞队列是没有问题的。</p>
<h3 id="线程池中使用阻塞队列"> 线程池中使用阻塞队列</h3>
<div><pre><code> <span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
                           <span>int</span> maximumPoolSize<span>,</span>
                           <span>long</span> keepAliveTime<span>,</span>
                           <span>TimeUnit</span> unit<span>,</span>
                           <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>)</span> <span>{</span>
        <span>this</span><span>(</span>corePoolSize<span>,</span> maximumPoolSize<span>,</span> keepAliveTime<span>,</span> unit<span>,</span> workQueue<span>,</span>
             <span>Executors</span><span>.</span><span>defaultThreadFactory</span><span>(</span><span>)</span><span>,</span> defaultHandler<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>Java中的线程池就是使用阻塞队列实现的，我们在了解阻塞队列之后，无论是使用Executors类中已经提供的线程池，还是自己通过ThreadPoolExecutor实现线程池，都会更加得心应手，想要了解线程池的同学，可以看<a href="./../12/">第十二章</a>：线程池原理。</p>
<blockquote>
<p>注：上面提到了生产者-消费者模式，大家可以参考<a href="http://note.youdao.com/noteshare?id=b4babef5d090f87cea8a97632f380c00" target="_blank" rel="noopener noreferrer">生产者-消费者模型</a>，可以更好的理解阻塞队列。</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T14:28:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十一章、AQS（不懂）</title>
    <id>https://notes.lllllan.cn/java/concurrent/2/11/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/2/11/"/>
    <updated>2022-04-18T14:38:22.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/02/11.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十一章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、aqs简介"> 一、AQS简介</h2>
<p><strong>AQS</strong> 是 <code>AbstractQueuedSynchronizer</code> 的简称，即 <code>抽象队列同步器</code>，从字面意思上理解:</p>
<ul>
<li>抽象：抽象类，只实现一些主要逻辑，有些方法由子类实现；</li>
<li>队列：使用先进先出（FIFO）队列存储数据；</li>
<li>同步：实现了同步的功能。</li>
</ul>
<p>那 AQS 有什么用呢？<strong>AQS是 一个用来构建锁和同步器的框架，使用 AQS 能简单且高效地构造出应用广泛的同步器</strong>，比如我们提到的 ReentrantLock，Semaphore，ReentrantReadWriteLock，SynchronousQueue，FutureTask 等等皆是基于AQS的。</p>
<p>当然，我们自己也能利用 AQS 非常轻松容易地构造出符合我们自己需求的同步器，只要子类实现它的几个 <code>protected</code> 方法就可以了</p>
<h2 id="二、aqs的数据结构"> 二、AQS的数据结构</h2>
<p>AQS 内部使用了一个 <code>volatile</code> 的变量 <code>state</code> 来作为资源的标识。同时定义了几个获取和改变 <code>state</code> 的<code>protected</code> 方法，子类可以覆盖这些方法来实现自己的逻辑：</p>
<div><pre><code><span>getState</span><span>(</span><span>)</span>
<span>setState</span><span>(</span><span>)</span>
<span>compareAndSetState</span><span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>这三种操作均是 <strong>原子操作</strong>，其中 <code>compareAndSetState</code> 的实现依赖于 <code>Unsafe</code> 的 <code>compareAndSwapInt()</code> 方法。</p>
<p>而 AQS 类本身实现的是一些排队和阻塞的机制，比如具体线程等待队列的维护（如获取资源失败入队/唤醒出队等）。它内部使用了一个先进先出（FIFO）的双端队列，并使用了两个指针 head 和 tail 用于标识队列的头部和尾部。其数据结构如图：</p>
<p><img src="./README.assets/AQS数据结构-16475883302572.png" alt="AQS数据结构" loading="lazy"></p>
<p><strong>但它并不是直接储存线程，而是储存拥有线程的 Node 节点。</strong></p>
<h2 id="三、资源共享模式"> 三、资源共享模式</h2>
<p>资源有两种共享模式，或者说两种同步方式：</p>
<ul>
<li>独占模式（Exclusive）：资源是独占的，一次只能一个线程获取。如 <code>ReentrantLock</code>。</li>
<li>共享模式（Share）：同时可以被多个线程获取，具体的资源个数可以通过参数指定。如<code>Semaphore/CountDownLatch</code>。</li>
</ul>
<p>一般情况下，子类只需要根据需求实现其中一种模式，当然也有同时实现两种模式的同步类，如<code>ReadWriteLock</code>。</p>
<p>AQS 中关于这两种资源共享模式的定义源码（均在内部类Node中）。我们来看看 Node 的结构：</p>
<div><pre><code><span>static</span> <span>final</span> <span>class</span> <span>Node</span> <span>{</span>
    <span>// 标记一个结点（对应的线程）在共享模式下等待</span>
    <span>static</span> <span>final</span> <span>Node</span> SHARED <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>)</span><span>;</span>
    <span>// 标记一个结点（对应的线程）在独占模式下等待</span>
    <span>static</span> <span>final</span> <span>Node</span> EXCLUSIVE <span>=</span> <span>null</span><span>;</span> 

    <span>// waitStatus的值，表示该结点（对应的线程）已被取消</span>
    <span>static</span> <span>final</span> <span>int</span> CANCELLED <span>=</span> <span>1</span><span>;</span> 
    <span>// waitStatus的值，表示后继结点（对应的线程）需要被唤醒</span>
    <span>static</span> <span>final</span> <span>int</span> SIGNAL <span>=</span> <span>-</span><span>1</span><span>;</span>
    <span>// waitStatus的值，表示该结点（对应的线程）在等待某一条件</span>
    <span>static</span> <span>final</span> <span>int</span> CONDITION <span>=</span> <span>-</span><span>2</span><span>;</span>
    <span>/**
      * waitStatus的值，表示有资源可用，
      * 新head结点需要继续唤醒后继结点
      *（共享模式下，多线程并发释放资源，而head唤醒其后继结点后，需要把多出来的资源留给后面的结点；
      * 设置新的head结点时，会继续唤醒其后继结点）
      */</span>
    <span>static</span> <span>final</span> <span>int</span> PROPAGATE <span>=</span> <span>-</span><span>3</span><span>;</span>

    <span>// 等待状态，取值范围，-3，-2，-1，0，1</span>
    <span>volatile</span> <span>int</span> waitStatus<span>;</span>
    <span>volatile</span> <span>Node</span> prev<span>;</span> <span>// 前驱结点</span>
    <span>volatile</span> <span>Node</span> next<span>;</span> <span>// 后继结点</span>
    <span>volatile</span> <span>Thread</span> thread<span>;</span> <span>// 结点对应的线程</span>
    <span>Node</span> nextWaiter<span>;</span> <span>// 等待队列里下一个等待条件的结点</span>

    
    <span>// 判断共享模式的方法</span>
    <span>final</span> <span>boolean</span> <span>isShared</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> nextWaiter <span>==</span> SHARED<span>;</span>
    <span>}</span>
    
    <span>Node</span><span>(</span><span>Thread</span> thread<span>,</span> <span>Node</span> mode<span>)</span> <span>{</span>     <span>// Used by addWaiter</span>
        <span>this</span><span>.</span>nextWaiter <span>=</span> mode<span>;</span>
        <span>this</span><span>.</span>thread <span>=</span> thread<span>;</span>
    <span>}</span>
    
    <span>// 其它方法忽略，可以参考具体的源码</span>
<span>}</span>

<span>// AQS里面的addWaiter私有方法</span>
<span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>
    <span>// 使用了Node的这个构造函数</span>
    <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>
    <span>// 其它代码省略</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><blockquote>
<p>注意：通过 Node 我们可以实现两个队列，一是通过 prev 和 next 实现 CLH 队列（线程同步队列，双向队列），二是 nextWaiter 实现 Condition 条件上的等待线程队列（单向队列），这个 Condition 主要用在 ReentrantLock 类中。</p>
</blockquote>
<h2 id="四、aqs的主要方法源码解析"> 四、AQS的主要方法源码解析</h2>
<div><p>模板方法模式</p>
<p>什么是模板方法模式 （<mark>保留</mark>）</p>
</div>
<p>AQS 的设计是基于 <strong>模板方法模式</strong> 的，它有一些方法必须要子类去实现的，它们主要有：</p>
<ul>
<li><code>isHeldExclusively()</code>：该线程是否正在独占资源。只有用到 condition 才需要去实现它。</li>
<li><code>tryAcquire(int)</code>：独占方式。尝试获取资源，成功则返回 true，失败则返回 false。</li>
<li><code>tryRelease(int)</code>：独占方式。尝试释放资源，成功则返回 true，失败则返回 false。</li>
<li><code>tryAcquireShared(int)</code>：共享方式。尝试获取资源。负数表示失败；0表示成功，但没有剩余可用资源；正数表示成功，且有剩余资源。</li>
<li><code>tryReleaseShared(int)</code>：共享方式。尝试释放资源，如果释放后允许唤醒后续等待结点返回true，否则返回false。</li>
</ul>
<p>这些方法虽然都是 <mark><code>protected</code></mark> 方法，但是它们并没有在 AQS 具体实现，而是直接抛出异常（这里不使用抽象方法的目的是：<mark>避免强迫子类中把所有的抽象方法都实现一遍，减少无用功，这样子类只需要实现自己关心的抽象方法即可</mark> ，比如 Semaphore 只需要实现 tryAcquire 方法而不用实现其余不需要用到的模版方法）：</p>
<div><pre><code><span>protected</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
    <span>throw</span> <span>new</span> <span>UnsupportedOperationException</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>而 AQS 实现了一系列主要的逻辑。下面我们从源码来分析一下获取和释放资源的主要逻辑：</p>
<h3 id="获取资源"> 获取资源</h3>
<p>获取资源的入口是 acquire(int arg) 方法。arg是要获取的资源的个数，在独占模式下始终为1。我们先来看看这个方法的逻辑：</p>
<div><pre><code><span>public</span> <span>final</span> <span>void</span> <span>acquire</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>!</span><span>tryAcquire</span><span>(</span>arg<span>)</span> <span>&amp;&amp;</span> <span>acquireQueued</span><span>(</span><span>addWaiter</span><span>(</span><span>Node</span><span>.</span>EXCLUSIVE<span>)</span><span>,</span> arg<span>)</span><span>)</span>
        <span>selfInterrupt</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>首先调用 tryAcquire(arg )尝试去获取资源。前面提到了这个方法是在子类具体实现的。</p>
<p>如果获取资源失败，就通过 addWaiter(Node.EXCLUSIVE) 方法把这个线程插入到等待队列中。其中传入的参数代表要插入的 Node 是独占式的。这个方法的具体实现：</p>
<div><pre><code><span>private</span> <span>Node</span> <span>addWaiter</span><span>(</span><span>Node</span> mode<span>)</span> <span>{</span>
    <span>// 生成该线程对应的Node节点</span>
    <span>Node</span> node <span>=</span> <span>new</span> <span>Node</span><span>(</span><span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>,</span> mode<span>)</span><span>;</span>
    <span>// 将Node插入队列中</span>
    <span>Node</span> pred <span>=</span> tail<span>;</span>
    <span>if</span> <span>(</span>pred <span>!=</span> <span>null</span><span>)</span> <span>{</span>
        node<span>.</span>prev <span>=</span> pred<span>;</span>
        <span>// 使用CAS尝试，如果成功就返回</span>
        <span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>pred<span>,</span> node<span>)</span><span>)</span> <span>{</span>
            pred<span>.</span>next <span>=</span> node<span>;</span>
            <span>return</span> node<span>;</span>
        <span>}</span>
    <span>}</span>
    <span>// 如果等待队列为空或者上述CAS失败，再自旋CAS插入</span>
    <span>enq</span><span>(</span>node<span>)</span><span>;</span>
    <span>return</span> node<span>;</span>
<span>}</span>

<span>// 自旋CAS插入等待队列</span>
<span>private</span> <span>Node</span> <span>enq</span><span>(</span><span>final</span> <span>Node</span> node<span>)</span> <span>{</span>
    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>Node</span> t <span>=</span> tail<span>;</span>
        <span>if</span> <span>(</span>t <span>==</span> <span>null</span><span>)</span> <span>{</span> <span>// Must initialize</span>
            <span>if</span> <span>(</span><span>compareAndSetHead</span><span>(</span><span>new</span> <span>Node</span><span>(</span><span>)</span><span>)</span><span>)</span>
                tail <span>=</span> head<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            node<span>.</span>prev <span>=</span> t<span>;</span>
            <span>if</span> <span>(</span><span>compareAndSetTail</span><span>(</span>t<span>,</span> node<span>)</span><span>)</span> <span>{</span>
                t<span>.</span>next <span>=</span> node<span>;</span>
                <span>return</span> t<span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><blockquote>
<p>上面的两个函数比较好理解，就是在队列的尾部插入新的Node节点，但是需要注意的是由于AQS中会存在多个线程同时争夺资源的情况，因此肯定会出现多个线程同时插入节点的操作，在这里是通过CAS自旋的方式保证了操作的线程安全性。</p>
</blockquote>
<p>OK，现在回到最开始的aquire(int arg)方法。现在通过addWaiter方法，已经把一个Node放到等待队列尾部了。而处于等待队列的结点是从头结点一个一个去获取资源的。具体的实现我们来看看acquireQueued方法</p>
<div><pre><code><span>final</span> <span>boolean</span> <span>acquireQueued</span><span>(</span><span>final</span> <span>Node</span> node<span>,</span> <span>int</span> arg<span>)</span> <span>{</span>
    <span>boolean</span> failed <span>=</span> <span>true</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>boolean</span> interrupted <span>=</span> <span>false</span><span>;</span>
        <span>// 自旋</span>
        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
            <span>final</span> <span>Node</span> p <span>=</span> node<span>.</span><span>predecessor</span><span>(</span><span>)</span><span>;</span>
            <span>// 如果node的前驱结点p是head，表示node是第二个结点，就可以尝试去获取资源了</span>
            <span>if</span> <span>(</span>p <span>==</span> head <span>&amp;&amp;</span> <span>tryAcquire</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
                <span>// 拿到资源后，将head指向该结点。</span>
                <span>// 所以head所指的结点，就是当前获取到资源的那个结点或null。</span>
                <span>setHead</span><span>(</span>node<span>)</span><span>;</span> 
                p<span>.</span>next <span>=</span> <span>null</span><span>;</span> <span>// help GC</span>
                failed <span>=</span> <span>false</span><span>;</span>
                <span>return</span> interrupted<span>;</span>
            <span>}</span>
            <span>// 如果自己可以休息了，就进入waiting状态，直到被unpark()</span>
            <span>if</span> <span>(</span><span>shouldParkAfterFailedAcquire</span><span>(</span>p<span>,</span> node<span>)</span> <span>&amp;&amp;</span>
                <span>parkAndCheckInterrupt</span><span>(</span><span>)</span><span>)</span>
                interrupted <span>=</span> <span>true</span><span>;</span>
        <span>}</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>if</span> <span>(</span>failed<span>)</span>
            <span>cancelAcquire</span><span>(</span>node<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><blockquote>
<p>这里parkAndCheckInterrupt方法内部使用到了LockSupport.park(this)，顺便简单介绍一下park。</p>
<p>LockSupport类是Java 6 引入的一个类，提供了基本的线程同步原语。LockSupport实际上是调用了Unsafe类里的函数，归结到Unsafe里，只有两个函数：</p>
<ul>
<li>park(boolean isAbsolute, long time)：阻塞当前线程</li>
<li>unpark(Thread jthread)：使给定的线程停止阻塞</li>
</ul>
</blockquote>
<p>所以<strong>结点进入等待队列后，是调用park使它进入阻塞状态的。只有头结点的线程是处于活跃状态的</strong>。</p>
<p>当然，获取资源的方法除了acquire外，还有以下三个：</p>
<ul>
<li>acquireInterruptibly：申请可中断的资源（独占模式）</li>
<li>acquireShared：申请共享模式的资源</li>
<li>acquireSharedInterruptibly：申请可中断的资源（共享模式）</li>
</ul>
<blockquote>
<p>可中断的意思是，在线程中断时可能会抛出<code>InterruptedException</code></p>
</blockquote>
<p>总结起来的一个流程图：</p>
<p><img src="./README.assets/acquire流程.png" alt="acquire流程" loading="lazy"></p>
<h3 id="释放资源"> 释放资源</h3>
<p>释放资源相比于获取资源来说，会简单许多。在AQS中只有一小段实现。源码：</p>
<div><pre><code><span>public</span> <span>final</span> <span>boolean</span> <span>release</span><span>(</span><span>int</span> arg<span>)</span> <span>{</span>
    <span>if</span> <span>(</span><span>tryRelease</span><span>(</span>arg<span>)</span><span>)</span> <span>{</span>
        <span>Node</span> h <span>=</span> head<span>;</span>
        <span>if</span> <span>(</span>h <span>!=</span> <span>null</span> <span>&amp;&amp;</span> h<span>.</span>waitStatus <span>!=</span> <span>0</span><span>)</span>
            <span>unparkSuccessor</span><span>(</span>h<span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>

<span>private</span> <span>void</span> <span>unparkSuccessor</span><span>(</span><span>Node</span> node<span>)</span> <span>{</span>
    <span>// 如果状态是负数，尝试把它设置为0</span>
    <span>int</span> ws <span>=</span> node<span>.</span>waitStatus<span>;</span>
    <span>if</span> <span>(</span>ws <span>&lt;</span> <span>0</span><span>)</span>
        <span>compareAndSetWaitStatus</span><span>(</span>node<span>,</span> ws<span>,</span> <span>0</span><span>)</span><span>;</span>
    <span>// 得到头结点的后继结点head.next</span>
    <span>Node</span> s <span>=</span> node<span>.</span>next<span>;</span>
    <span>// 如果这个后继结点为空或者状态大于0</span>
    <span>// 通过前面的定义我们知道，大于0只有一种可能，就是这个结点已被取消</span>
    <span>if</span> <span>(</span>s <span>==</span> <span>null</span> <span>||</span> s<span>.</span>waitStatus <span>></span> <span>0</span><span>)</span> <span>{</span>
        s <span>=</span> <span>null</span><span>;</span>
        <span>// 等待队列中所有还有用的结点，都向前移动</span>
        <span>for</span> <span>(</span><span>Node</span> t <span>=</span> tail<span>;</span> t <span>!=</span> <span>null</span> <span>&amp;&amp;</span> t <span>!=</span> node<span>;</span> t <span>=</span> t<span>.</span>prev<span>)</span>
            <span>if</span> <span>(</span>t<span>.</span>waitStatus <span>&lt;=</span> <span>0</span><span>)</span>
                s <span>=</span> t<span>;</span>
    <span>}</span>
    <span>// 如果后继结点不为空，</span>
    <span>if</span> <span>(</span>s <span>!=</span> <span>null</span><span>)</span>
        <span>LockSupport</span><span>.</span><span>unpark</span><span>(</span>s<span>.</span>thread<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十四章、锁接口和类</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/14/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/14/"/>
    <updated>2022-03-19T07:32:43.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/14.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十四章 - GitHub</a></li>
</ul>
</div>
<p>前面我们介绍了Java原生的锁——基于对象的锁，它一般是配合 <code>synchronized</code> 关键字来使用的。实际上，Java在 <code>java.util.concurrent.locks</code> 包下，还为我们提供了几个关于锁的类和接口。它们有更强大的功能或更高的性能。</p>
<h2 id="一、synchronized的不足之处"> 一、synchronized的不足之处</h2>
<p>我们先来看看 <code>synchronized</code> 有什么不足之处。</p>
<ul>
<li>如果临界区是只读操作，其实可以多线程一起执行，但使用synchronized的话，<strong>同一时间只能有一个线程执行</strong>。</li>
<li>synchronized无法知道线程有没有成功获取到锁</li>
<li>使用synchronized，如果临界区因为IO或者sleep方法等原因阻塞了，而当前线程又没有释放锁，就会导致<strong>所有线程等待</strong>。</li>
</ul>
<p>而这些都是locks包下的锁可以解决的。</p>
<h2 id="二、锁的几种分类"> 二、锁的几种分类</h2>
<p>锁可以根据以下几种方式来进行分类，下面我们逐一介绍。</p>
<h3 id="_2-1-可重入锁和非可重入锁"> 2.1 可重入锁和非可重入锁</h3>
<div><p>重入锁</p>
<p>顾名思义。就是支持重新进入的锁，也就是说这个锁支持一个<strong>线程对资源重复加锁</strong>。</p>
</div>
<p><mark><code>synchronized</code> 关键字就是使用的重入锁</mark>。比如说，你在一个 <code>synchronized</code> 实例方法里面调用另一个本实例的 <code>synchronized</code> 实例方法，它可以重新进入这个锁，不会出现任何异常。</p>
<p>如果我们自己在继承AQS实现同步器的时候，没有考虑到占有锁的线程再次获取锁的场景，可能就会导致线程阻塞，那这个就是一个“非可重入锁”。</p>
<p><code>ReentrantLock</code> 的中文意思就是可重入锁。也是本文后续要介绍的重点类。</p>
<h3 id="_2-2-公平锁与非公平锁"> 2.2 公平锁与非公平锁</h3>
<div><p>公平锁</p>
<p>这里的“公平”，其实通俗意义来说就是“先来后到”，也就是FIFO。如果对一个锁来说，先对锁获取请求的线程一定会先被满足，后对锁获取请求的线程后被满足，那这个锁就是公平的。反之，那就是不公平的。</p>
</div>
<p>一般情况下，<strong>非公平锁能提升一定的效率。但是非公平锁可能会发生线程饥饿（有一些线程长时间得不到锁）的情况</strong>。所以要根据实际的需求来选择非公平锁和公平锁。</p>
<p>ReentrantLock支持非公平锁和公平锁两种。</p>
<h3 id="_2-3-读写锁和排它锁"> 2.3 读写锁和排它锁</h3>
<p>我们前面讲到的 <mark><code>synchronized</code> 用的锁和 <code>ReentrantLock</code>，其实都是“排它锁”。</mark></p>
<div><p>排它锁</p>
<p>锁在同一时刻只允许一个线程进行访问。</p>
</div>
<p>而读写锁可以在同一时刻允许多个读线程访问。Java提供了 <code>ReentrantReadWriteLock</code> 类作为读写锁的默认实现，内部维护了两个锁：一个读锁，一个写锁。通过分离读锁和写锁，使得在“读多写少”的环境下，大大地提高了性能。</p>
<p><mark>即使用读写锁，在写线程访问时，所有的读线程和其它写线程均被阻塞</mark></p>
<h2 id="三、jdk中有关锁的一些接口和类-保留"> 三、JDK中有关锁的一些接口和类（保留）</h2>
<p>众所周知，JDK中关于并发的类大多都在 <code>java.util.concurrent</code>（以下简称juc）包下。而juc.locks包看名字就知道，是提供了一些并发锁的工具类的。前面我们介绍的AQS（AbstractQueuedSynchronizer）就是在这个包下。下面分别介绍一下这个包下的类和接口以及它们之间的关系。</p>
<h3 id="_3-1-抽象类aqs-aqls-aos"> 3.1 抽象类AQS/AQLS/AOS</h3>
<p>这三个抽象类有一定的关系，所以这里放到一起讲。</p>
<p>首先我们看<strong>AQS</strong>（<code>AbstractQueuedSynchronizer</code>），之前专门有章节介绍这个类，它是在JDK 1.5 发布的，提供了一个“队列同步器”的基本功能实现。而AQS里面的“资源”是用一个 <code>int</code> 类型的数据来表示的，有时候我们的业务需求资源的数量超出了 <code>int</code> 的范围，所以在JDK 1.6 中，多了一个<strong>AQLS</strong>（<code>AbstractQueuedLongSynchronizer</code>）。它的代码跟AQS几乎一样，只是把资源的类型变成了 <code>long</code> 类型。</p>
<p>AQS和AQLS都继承了一个类叫<strong>AOS</strong>（<code>AbstractOwnableSynchronizer</code>）。这个类也是在JDK 1.6 中出现的。这个类只有几行简单的代码。从源码类上的注释可以知道，它是用于表示锁与持有者之间的关系（独占模式）。可以看一下它的主要方法：</p>
<div><pre><code><span>// 独占模式，锁的持有者  </span>
<span>private</span> <span>transient</span> <span>Thread</span> exclusiveOwnerThread<span>;</span>  

<span>// 设置锁持有者  </span>
<span>protected</span> <span>final</span> <span>void</span> <span>setExclusiveOwnerThread</span><span>(</span><span>Thread</span> t<span>)</span> <span>{</span>  
    exclusiveOwnerThread <span>=</span> t<span>;</span>  
<span>}</span>  

<span>// 获取锁的持有线程  </span>
<span>protected</span> <span>final</span> <span>Thread</span> <span>getExclusiveOwnerThread</span><span>(</span><span>)</span> <span>{</span>  
    <span>return</span> exclusiveOwnerThread<span>;</span>  
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_3-2-接口condition-lock-readwritelock"> 3.2 接口Condition/Lock/ReadWriteLock</h3>
<p>juc.locks包下共有三个接口：<code>Condition</code>、<code>Lock</code>、<code>ReadWriteLock</code>。其中，Lock和ReadWriteLock从名字就可以看得出来，分别是锁和读写锁的意思。Lock接口里面有一些获取锁和释放锁的方法声明，而ReadWriteLock里面只有两个方法，分别返回“读锁”和“写锁”：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>ReadWriteLock</span> <span>{</span>
    <span>Lock</span> <span>readLock</span><span>(</span><span>)</span><span>;</span>
    <span>Lock</span> <span>writeLock</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>Lock接口中有一个方法是可以获得一个 Condition`:</p>
<div><pre><code><span>Condition</span> <span>newCondition</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p>之前我们提到了每个对象都可以用继承自 <code>Object</code> 的<strong>wait/notify</strong>方法来实现<strong>等待/通知机制</strong>。而Condition接口也提供了类似Object监视器的方法，通过与<strong>Lock</strong>配合来实现等待/通知模式。</p>
<p>那为什么既然有Object的监视器方法了，还要用Condition呢？这里有一个二者简单的对比：</p>
<table>
<thead>
<tr>
<th>对比项</th>
<th>Object监视器</th>
<th>Condition</th>
</tr>
</thead>
<tbody>
<tr>
<td>前置条件</td>
<td>获取对象的锁</td>
<td>调用Lock.lock获取锁，调用Lock.newCondition获取Condition对象</td>
</tr>
<tr>
<td>调用方式</td>
<td>直接调用，比如object.notify()</td>
<td>直接调用，比如condition.await()</td>
</tr>
<tr>
<td>等待队列的个数</td>
<td>一个</td>
<td>多个</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁进入等待状态，在等待状态中不中断</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入超时等待状态</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>当前线程释放锁并进入等待状态直到将来的某个时间</td>
<td>不支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的一个线程</td>
<td>支持</td>
<td>支持</td>
</tr>
<tr>
<td>唤醒等待队列中的全部线程</td>
<td>支持</td>
<td>支持</td>
</tr>
</tbody>
</table>
<p>Condition和Object的wait/notify基本相似。其中，Condition的await方法对应的是Object的wait方法，而Condition的<strong>signal/signalAll</strong>方法则对应Object的notify/notifyAll()。但Condition类似于Object的等待/通知机制的加强版。我们来看看主要的方法：</p>
<table>
<thead>
<tr>
<th>方法名称</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>await()</td>
<td>当前线程进入等待状态直到被通知（signal）或者中断；当前线程进入运行状态并从await()方法返回的场景包括：（1）其他线程调用相同Condition对象的signal/signalAll方法，并且当前线程被唤醒；（2）其他线程调用interrupt方法中断当前线程；</td>
</tr>
<tr>
<td>awaitUninterruptibly()</td>
<td>当前线程进入等待状态直到被通知，在此过程中对中断信号不敏感，不支持中断当前线程</td>
</tr>
<tr>
<td>awaitNanos(long)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果返回值小于等于0，可以认定就是超时了</td>
</tr>
<tr>
<td>awaitUntil(Date)</td>
<td>当前线程进入等待状态，直到被通知、中断或者超时。如果没到指定时间被通知，则返回true，否则返回false</td>
</tr>
<tr>
<td>signal()</td>
<td>唤醒一个等待在Condition上的线程，被唤醒的线程在方法返回前必须获得与Condition对象关联的锁</td>
</tr>
<tr>
<td>signalAll()</td>
<td>唤醒所有等待在Condition上的线程，能够从await()等方法返回的线程必须先获得与Condition对象关联的锁</td>
</tr>
</tbody>
</table>
<h3 id="_3-3-reentrantlock"> 3.3 ReentrantLock</h3>
<p><code>ReentrantLock</code> 是一个非抽象类，它是Lock接口的JDK默认实现，实现了锁的基本功能。从名字上看，它是一个”可重入“锁，从源码上看，它内部有一个抽象类 <code>Sync</code>，是继承了AQS，自己实现的一个同步器。同时，ReentrantLock内部有两个非抽象类 <code>NonfairSync</code> 和 <code>FairSync</code>，它们都继承了Sync。从名字上看得出，分别是”非公平同步器“和”公平同步器“的意思。这意味着ReentrantLock可以支持”公平锁“和”非公平锁“。</p>
<p>通过看这两个同步器的源码可以发现，它们的实现都是”独占“的。都调用了AOS的 <code>setExclusiveOwnerThread</code> 方法，所以ReentrantLock的锁是”独占“的，也就是说，它的锁都是”排他锁“，不能共享。</p>
<p>在ReentrantLock的构造方法里，可以传入一个 <code>boolean</code> 类型的参数，来指定它是否是一个公平锁，默认情况下是非公平的。这个参数一旦实例化后就不能修改，只能通过 <code>isFair()</code> 方法来查看。</p>
<h3 id="_3-4-reentrantreadwritelock"> 3.4 ReentrantReadWriteLock</h3>
<p>这个类也是一个非抽象类，它是ReadWriteLock接口的JDK默认实现。它与ReentrantLock的功能类似，同样是可重入的，支持非公平锁和公平锁。不同的是，它还支持”读写锁“。</p>
<p>ReentrantReadWriteLock内部的结构大概是这样：</p>
<div><pre><code><span>// 内部结构</span>
<span>private</span> <span>final</span> <span>ReentrantReadWriteLock<span>.</span>ReadLock</span> readerLock<span>;</span>
<span>private</span> <span>final</span> <span>ReentrantReadWriteLock<span>.</span>WriteLock</span> writerLock<span>;</span>
<span>final</span> <span>Sync</span> sync<span>;</span>
<span>abstract</span> <span>static</span> <span>class</span> <span>Sync</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>{</span>
    <span>// 具体实现</span>
<span>}</span>
<span>static</span> <span>final</span> <span>class</span> <span>NonfairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>
    <span>// 具体实现</span>
<span>}</span>
<span>static</span> <span>final</span> <span>class</span> <span>FairSync</span> <span>extends</span> <span>Sync</span> <span>{</span>
    <span>// 具体实现</span>
<span>}</span>
<span>public</span> <span>static</span> <span>class</span> <span>ReadLock</span> <span>implements</span> <span>Lock</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>
    <span>private</span> <span>final</span> <span>Sync</span> sync<span>;</span>
    <span>protected</span> <span>ReadLock</span><span>(</span><span>ReentrantReadWriteLock</span> lock<span>)</span> <span>{</span>
            sync <span>=</span> lock<span>.</span>sync<span>;</span>
    <span>}</span>
    <span>// 具体实现</span>
<span>}</span>
<span>public</span> <span>static</span> <span>class</span> <span>WriteLock</span> <span>implements</span> <span>Lock</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>
    <span>private</span> <span>final</span> <span>Sync</span> sync<span>;</span>
    <span>protected</span> <span>WriteLock</span><span>(</span><span>ReentrantReadWriteLock</span> lock<span>)</span> <span>{</span>
            sync <span>=</span> lock<span>.</span>sync<span>;</span>
    <span>}</span>
    <span>// 具体实现</span>
<span>}</span>

<span>// 构造方法，初始化两个锁</span>
<span>public</span> <span>ReentrantReadWriteLock</span><span>(</span><span>boolean</span> fair<span>)</span> <span>{</span>
    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>)</span><span>;</span>
    readerLock <span>=</span> <span>new</span> <span>ReadLock</span><span>(</span><span>this</span><span>)</span><span>;</span>
    writerLock <span>=</span> <span>new</span> <span>WriteLock</span><span>(</span><span>this</span><span>)</span><span>;</span>
<span>}</span>

<span>// 获取读锁和写锁的方法</span>
<span>public</span> <span>ReentrantReadWriteLock<span>.</span>WriteLock</span> <span>writeLock</span><span>(</span><span>)</span> <span>{</span> <span>return</span> writerLock<span>;</span> <span>}</span>
<span>public</span> <span>ReentrantReadWriteLock<span>.</span>ReadLock</span>  <span>readLock</span><span>(</span><span>)</span>  <span>{</span> <span>return</span> readerLock<span>;</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br></div></div><p>可以看到，它同样是内部维护了两个同步器。且维护了两个Lock的实现类ReadLock和WriteLock。从源码可以发现，这两个内部类用的是外部类的同步器。</p>
<p>ReentrantReadWriteLock实现了读写锁，但它有一个小弊端，就是在“写”操作的时候，其它线程不能写也不能读。我们称这种现象为“写饥饿”，将在后文的StampedLock类继续讨论这个问题。</p>
<h3 id="_3-5-stampedlock"> 3.5 StampedLock</h3>
<p><code>StampedLock</code> 类是在Java 8 才发布的，也是Doug Lea大神所写，有人号称它为锁的性能之王。它没有实现Lock接口和ReadWriteLock接口，但它其实是实现了“读写锁”的功能，并且性能比ReentrantReadWriteLock更高。StampedLock还把读锁分为了“乐观读锁”和“悲观读锁”两种。</p>
<p>前面提到了ReentrantReadWriteLock会发生“写饥饿”的现象，但StampedLock不会。它是怎么做到的呢？它的核心思想在于，<strong>在读的时候如果发生了写，应该通过重试的方式来获取新的值，而不应该阻塞写操作。这种模式也就是典型的无锁编程思想，和CAS自旋的思想一样</strong>。这种操作方式决定了StampedLock在读线程非常多而写线程非常少的场景下非常适用，同时还避免了写饥饿情况的发生。</p>
<p>这里篇幅有限，就不介绍StampedLock的源码了，只是分析一下官方提供的用法（在JDK源码类声明的上方或Javadoc里可以找到）。</p>
<div><pre><code><span>class</span> <span>Point</span> <span>{</span>
   <span>private</span> <span>double</span> x<span>,</span> y<span>;</span>
   <span>private</span> <span>final</span> <span>StampedLock</span> sl <span>=</span> <span>new</span> <span>StampedLock</span><span>(</span><span>)</span><span>;</span>

   <span>// 写锁的使用</span>
   <span>void</span> <span>move</span><span>(</span><span>double</span> deltaX<span>,</span> <span>double</span> deltaY<span>)</span> <span>{</span>
     <span>long</span> stamp <span>=</span> sl<span>.</span><span>writeLock</span><span>(</span><span>)</span><span>;</span> <span>// 获取写锁</span>
     <span>try</span> <span>{</span>
       x <span>+=</span> deltaX<span>;</span>
       y <span>+=</span> deltaY<span>;</span>
     <span>}</span> <span>finally</span> <span>{</span>
       sl<span>.</span><span>unlockWrite</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放写锁</span>
     <span>}</span>
   <span>}</span>

   <span>// 乐观读锁的使用</span>
   <span>double</span> <span>distanceFromOrigin</span><span>(</span><span>)</span> <span>{</span>
     <span>long</span> stamp <span>=</span> sl<span>.</span><span>tryOptimisticRead</span><span>(</span><span>)</span><span>;</span> <span>// 获取乐观读锁</span>
     <span>double</span> currentX <span>=</span> x<span>,</span> currentY <span>=</span> y<span>;</span>
     <span>if</span> <span>(</span><span>!</span>sl<span>.</span><span>validate</span><span>(</span>stamp<span>)</span><span>)</span> <span>{</span> <span>// //检查乐观读锁后是否有其他写锁发生，有则返回false</span>
        stamp <span>=</span> sl<span>.</span><span>readLock</span><span>(</span><span>)</span><span>;</span> <span>// 获取一个悲观读锁</span>
        <span>try</span> <span>{</span>
          currentX <span>=</span> x<span>;</span>
          currentY <span>=</span> y<span>;</span>
        <span>}</span> <span>finally</span> <span>{</span>
           sl<span>.</span><span>unlockRead</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放悲观读锁</span>
        <span>}</span>
     <span>}</span>
     <span>return</span> <span>Math</span><span>.</span><span>sqrt</span><span>(</span>currentX <span>*</span> currentX <span>+</span> currentY <span>*</span> currentY<span>)</span><span>;</span>
   <span>}</span>

   <span>// 悲观读锁以及读锁升级写锁的使用</span>
   <span>void</span> <span>moveIfAtOrigin</span><span>(</span><span>double</span> newX<span>,</span> <span>double</span> newY<span>)</span> <span>{</span>
     <span>long</span> stamp <span>=</span> sl<span>.</span><span>readLock</span><span>(</span><span>)</span><span>;</span> <span>// 悲观读锁</span>
     <span>try</span> <span>{</span>
       <span>while</span> <span>(</span>x <span>==</span> <span>0.0</span> <span>&amp;&amp;</span> y <span>==</span> <span>0.0</span><span>)</span> <span>{</span>
         <span>// 读锁尝试转换为写锁：转换成功后相当于获取了写锁，转换失败相当于有写锁被占用</span>
         <span>long</span> ws <span>=</span> sl<span>.</span><span>tryConvertToWriteLock</span><span>(</span>stamp<span>)</span><span>;</span> 
           
         <span>if</span> <span>(</span>ws <span>!=</span> <span>0L</span><span>)</span> <span>{</span> <span>// 如果转换成功</span>
           stamp <span>=</span> ws<span>;</span> <span>// 读锁的票据更新为写锁的</span>
           x <span>=</span> newX<span>;</span>
           y <span>=</span> newY<span>;</span>
           <span>break</span><span>;</span>
         <span>}</span>
         <span>else</span> <span>{</span> <span>// 如果转换失败</span>
           sl<span>.</span><span>unlockRead</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放读锁</span>
           stamp <span>=</span> sl<span>.</span><span>writeLock</span><span>(</span><span>)</span><span>;</span> <span>// 强制获取写锁</span>
         <span>}</span>
       <span>}</span>
     <span>}</span> <span>finally</span> <span>{</span>
       sl<span>.</span><span>unlock</span><span>(</span>stamp<span>)</span><span>;</span> <span>// 释放所有锁</span>
     <span>}</span>
   <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><blockquote>
<p>乐观读锁的意思就是先假定在这个锁获取期间，共享变量不会被改变，既然假定不会被改变，那就不需要上锁。在获取乐观读锁之后进行了一些操作，然后又调用了validate方法，这个方法就是用来验证tryOptimisticRead之后，是否有写操作执行过，如果有，则获取一个悲观读锁，这里的悲观读锁和ReentrantReadWriteLock中的读锁类似，也是个共享锁。</p>
</blockquote>
<p>可以看到，StampedLock获取锁会返回一个 <code>long</code> 类型的变量，释放锁的时候再把这个变量传进去。简单看看源码：</p>
<div><pre><code><span>// 用于操作state后获取stamp的值</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> LG_READERS <span>=</span> <span>7</span><span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> RUNIT <span>=</span> <span>1L</span><span>;</span>               <span>//0000 0000 0001</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> WBIT  <span>=</span> <span>1L</span> <span>&lt;&lt;</span> LG_READERS<span>;</span> <span>//0000 1000 0000</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> RBITS <span>=</span> WBIT <span>-</span> <span>1L</span><span>;</span>        <span>//0000 0111 1111</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> RFULL <span>=</span> RBITS <span>-</span> <span>1L</span><span>;</span>       <span>//0000 0111 1110</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> ABITS <span>=</span> RBITS <span>|</span> WBIT<span>;</span>     <span>//0000 1111 1111</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> SBITS <span>=</span> <span>~</span>RBITS<span>;</span>           <span>//1111 1000 0000</span>

<span>// 初始化时state的值</span>
<span>private</span> <span>static</span> <span>final</span> <span>long</span> ORIGIN <span>=</span> WBIT <span>&lt;&lt;</span> <span>1</span><span>;</span>       <span>//0001 0000 0000</span>

<span>// 锁共享变量state</span>
<span>private</span> <span>transient</span> <span>volatile</span> <span>long</span> state<span>;</span>
<span>// 读锁溢出时用来存储多出的读锁</span>
<span>private</span> <span>transient</span> <span>int</span> readerOverflow<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>StampedLock用这个long类型的变量的前7位（LG_READERS）来表示读锁，每获取一个悲观读锁，就加1（RUNIT），每释放一个悲观读锁，就减1。而悲观读锁最多只能装128个（7位限制），很容易溢出，所以用一个int类型的变量来存储溢出的悲观读锁。</p>
<p>写锁用state变量剩下的位来表示，每次获取一个写锁，就加0000 1000 0000（WBIT）。需要注意的是，<strong>写锁在释放的时候，并不是减WBIT，而是再加WBIT</strong>。这是为了<strong>让每次写锁都留下痕迹</strong>，解决CAS中的ABA问题，也为<strong>乐观锁检查变化</strong>validate方法提供基础。</p>
<p>乐观读锁就比较简单了，并没有真正改变state的值，而是在获取锁的时候记录state的写状态，在操作完成后去检查state的写状态部分是否发生变化，上文提到了，每次写锁都会留下痕迹，也是为了这里乐观锁检查变化提供方便。</p>
<p>总的来说，StampedLock的性能是非常优异的，基本上可以取代ReentrantReadWriteLock的作用。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T14:45:13.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十二章、线程池原理</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/12/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/12/"/>
    <updated>2022-04-11T07:58:43.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/12.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十二章 - GitHub</a></li>
<li><a href="https://www.jianshu.com/p/7ab4ae9443b9" target="_blank" rel="noopener noreferrer">Java线程池的使用</a></li>
<li><a href="https://blog.csdn.net/qq_40093255/article/details/116990431" target="_blank" rel="noopener noreferrer">java线程池使用最全详解</a></li>
</ul>
</div>
<h2 id="一、为什么要使用线程池"> 一、为什么要使用线程池</h2>
<div><p>线程池的优点</p>
<ol>
<li>降低资源的消耗。线程本身是一种资源，创建和销毁线程会有CPU开销，线程池可以<strong>复用已创建的线程</strong>。</li>
<li>提高任务执行的响应速度。任务执行时，可以不必等到线程创建完之后再执行。</li>
<li>方便线程并发数的管控。线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率</li>
<li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li>
</ol>
</div>
<div><p>线程池的缺点</p>
<ol>
<li>频繁的线程创建和销毁会占用更多的CPU和内存</li>
<li>频繁的线程创建和销毁会对GC产生比较大的压力</li>
<li>线程太多，线程切换带来的开销将不可忽视</li>
<li>线程太少，多核CPU得不到充分利用，是一种浪费</li>
</ol>
</div>
<h2 id="二、线程池的原理"> 二、线程池的原理</h2>
<p>Java中的线程池顶层接口是 <code>Executor</code> 接口，<code>ThreadPoolExecutor</code> 是这个接口的实现类。</p>
<p>我们先看看 <code>ThreadPoolExecutor</code> 类。</p>
<h3 id="_2-1-threadpoolexecutor提供的构造方法"> 2.1 ThreadPoolExecutor提供的构造方法</h3>
<p>一共有四个构造方法：</p>
<div><pre><code><span>// 五个参数的构造函数</span>
<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
                          <span>int</span> maximumPoolSize<span>,</span>
                          <span>long</span> keepAliveTime<span>,</span>
                          <span>TimeUnit</span> unit<span>,</span>
                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>)</span>

<span>// 六个参数的构造函数-1</span>
<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
                          <span>int</span> maximumPoolSize<span>,</span>
                          <span>long</span> keepAliveTime<span>,</span>
                          <span>TimeUnit</span> unit<span>,</span>
                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>
                          <span>ThreadFactory</span> threadFactory<span>)</span>

<span>// 六个参数的构造函数-2</span>
<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
                          <span>int</span> maximumPoolSize<span>,</span>
                          <span>long</span> keepAliveTime<span>,</span>
                          <span>TimeUnit</span> unit<span>,</span>
                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>
                          <span>RejectedExecutionHandler</span> handler<span>)</span>

<span>// 七个参数的构造函数</span>
<span>public</span> <span>ThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span>
                          <span>int</span> maximumPoolSize<span>,</span>
                          <span>long</span> keepAliveTime<span>,</span>
                          <span>TimeUnit</span> unit<span>,</span>
                          <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> workQueue<span>,</span>
                          <span>ThreadFactory</span> threadFactory<span>,</span>
                          <span>RejectedExecutionHandler</span> handler<span>)</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><div><p>核心线程</p>
<p>核心线程：线程池中有两类线程，核心线程和非核心线程。</p>
<ul>
<li>核心线程默认情况下会一直存在于线程池中，即使这个核心线程什么都不干（铁饭碗）</li>
<li>非核心线程如果长时间的闲置，就会被销毁（临时工）。</li>
</ul>
</div>
<p>涉及到5~7个参数，我们先看看必须的5个参数是什么意思：</p>
<ul>
<li>
<p><strong>int corePoolSize</strong>：该线程池中<strong>核心线程数最大值</strong></p>
</li>
<li>
<p><strong>int maximumPoolSize</strong>：该线程池中<strong>线程总数最大值</strong> 。</p>
<blockquote>
<p>该值等于核心线程数量 + 非核心线程数量。</p>
</blockquote>
</li>
<li>
<p><strong>long keepAliveTime</strong>：<strong>非核心线程闲置超时时长</strong>。</p>
<blockquote>
<p>非核心线程如果处于闲置状态超过该值，就会被销毁。如果设置 <code>allowCoreThreadTimeOut(true)</code>，则会也作用于核心线程。</p>
</blockquote>
</li>
<li>
<p><strong>TimeUnit unit</strong>：keepAliveTime的单位。</p>
<p>TimeUnit是一个枚举类型 ，包括以下属性：</p>
<blockquote>
<p>NANOSECONDS ： 1微毫秒 = 1微秒 / 1000</p>
<p>MICROSECONDS ： 1微秒 = 1毫秒 / 1000</p>
<p>MILLISECONDS ： 1毫秒 = 1秒 /1000</p>
<p>SECONDS ： 秒</p>
<p>MINUTES ： 分</p>
<p>HOURS ： 小时</p>
<p>DAYS ： 天</p>
</blockquote>
</li>
<li>
<p><strong>BlockingQueue workQueue</strong>：阻塞队列，维护着<strong>等待执行的Runnable任务对象</strong>。</p>
<p>常用的几个阻塞队列：</p>
<ol>
<li>
<p><strong>LinkedBlockingQueue</strong></p>
<p>链式阻塞队列，底层数据结构是链表，默认大小是<code>Integer.MAX_VALUE</code>，也可以指定大小。</p>
</li>
<li>
<p><strong>ArrayBlockingQueue</strong></p>
<p>数组阻塞队列，底层数据结构是数组，需要指定队列的大小。</p>
</li>
<li>
<p><strong>SynchronousQueue</strong></p>
<p>同步队列，内部容量为0，每个put操作必须等待一个take操作，反之亦然。</p>
</li>
<li>
<p><strong>DelayQueue</strong></p>
<p>延迟队列，该队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素 。</p>
</li>
</ol>
</li>
</ul>
<hr>
<p>还有两个非必须的参数。</p>
<ul>
<li>
<p><strong>ThreadFactory threadFactory</strong></p>
<blockquote>
<p>创建线程的工厂 ，用于批量创建线程，统一在创建线程时设置一些参数，如是否守护线程、线程的优先级等。如果不指定，会新建一个默认的线程工厂。</p>
</blockquote>
</li>
</ul>
<div><pre><code><span>static</span> <span>class</span> <span>DefaultThreadFactory</span> <span>implements</span> <span>ThreadFactory</span> <span>{</span>
    <span>// 省略属性</span>
    <span>// 构造函数</span>
    <span>DefaultThreadFactory</span><span>(</span><span>)</span> <span>{</span>
        <span>SecurityManager</span> s <span>=</span> <span>System</span><span>.</span><span>getSecurityManager</span><span>(</span><span>)</span><span>;</span>
        group <span>=</span> <span>(</span>s <span>!=</span> <span>null</span><span>)</span> <span>?</span> s<span>.</span><span>getThreadGroup</span><span>(</span><span>)</span> <span>:</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getThreadGroup</span><span>(</span><span>)</span><span>;</span>
        namePrefix <span>=</span> <span>"pool-"</span> <span>+</span> poolNumber<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span> <span>+</span> <span>"-thread-"</span><span>;</span>
    <span>}</span>
    
    <span>// 省略</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><ul>
<li><strong>RejectedExecutionHandler handler</strong></li>
</ul>
<div><p>拒绝处理策略</p>
<p>线程数量大于最大线程数就会采用拒绝处理策略，四种拒绝处理的策略为 ：</p>
<ol>
<li>
<p><strong>ThreadPoolExecutor.AbortPolicy</strong>：<strong>默认拒绝处理策略</strong>，丢弃任务并抛出RejectedExecutionException异常。</p>
</li>
<li>
<p><strong>ThreadPoolExecutor.DiscardPolicy</strong>：丢弃新来的任务，但是不抛出异常。</p>
</li>
<li>
<p><strong>ThreadPoolExecutor.DiscardOldestPolicy</strong>：丢弃队列头部（最旧的）的任务，然后重新尝试执行程序（如果再次失败，重复此过程）。</p>
</li>
<li>
<p><strong>ThreadPoolExecutor.CallerRunsPolicy</strong>：由调用线程处理该任务。</p>
</li>
</ol>
</div>
<h3 id="_2-2-threadpoolexecutor的策略"> 2.2 ThreadPoolExecutor的策略</h3>
<p>线程池本身有一个 <mark>调度线程</mark> ，这个线程就是用于管理布控整个线程池里的各种任务和事务，例如<strong>创建线程、销毁线程、任务队列管理、线程队列管理</strong>等等。</p>
<p>故线程池也有自己的状态。<code>ThreadPoolExecutor</code>类中使用了一些<code>final int</code>常量变量来表示线程池的状态 ，分别为RUNNING、SHUTDOWN、STOP、TIDYING 、TERMINATED。</p>
<div><pre><code><span>// runState is stored in the high-order bits</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> RUNNING    <span>=</span> <span>-</span><span>1</span> <span>&lt;&lt;</span> COUNT_BITS<span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> SHUTDOWN   <span>=</span>  <span>0</span> <span>&lt;&lt;</span> COUNT_BITS<span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> STOP       <span>=</span>  <span>1</span> <span>&lt;&lt;</span> COUNT_BITS<span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> TIDYING    <span>=</span>  <span>2</span> <span>&lt;&lt;</span> COUNT_BITS<span>;</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> TERMINATED <span>=</span>  <span>3</span> <span>&lt;&lt;</span> COUNT_BITS<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ul>
<li>
<p>线程池创建后处于<strong>RUNNING</strong>状态。</p>
</li>
<li>
<p>调用 <code>shutdown()</code> 方法后处于<strong>SHUTDOWN</strong>状态，线程池不能接受新的任务，清除一些空闲 worker，不会等待阻塞队列的任务完成。</p>
</li>
<li>
<p>调用 <code>shutdownNow()</code> 方法后处于<strong>STOP</strong>状态，线程池不能接受新的任务，中断所有线程，阻塞队列中没有被执行的任务全部丢弃。此时，<code>poolsize = 0</code> ,阻塞队列的 size 也为0。</p>
</li>
<li>
<p>当所有的任务已终止，ctl 记录的 &quot;任务数量&quot; 为0，线程池会变为<strong>TIDYING</strong>状态。接着会执行 <code>terminated()</code> 函数。</p>
<blockquote>
<p>ThreadPoolExecutor中有一个控制状态的属性叫<code>ctl</code>，它是一个AtomicInteger类型的变量。线程池状态就是通过AtomicInteger类型的成员变量<code>ctl</code>来获取的。</p>
<p>获取的<code>ctl</code>值传入<code>runStateOf</code>方法，与<code>~CAPACITY</code>位与运算(<code>CAPACITY</code>是低29位全1的int变量)。</p>
<p><code>~CAPACITY</code>在这里相当于掩码，用来获取ctl的高3位，表示线程池状态；而另外的低29位用于表示工作线程数</p>
</blockquote>
</li>
<li>
<p>线程池处在TIDYING状态时，<strong>执行完terminated()方法之后</strong>，就会由 <strong>TIDYING -&gt; TERMINATED</strong>， 线程池被设置为TERMINATED状态。</p>
</li>
</ul>
<h3 id="_2-3-线程池主要的任务处理流程"> 2.3 线程池主要的任务处理流程</h3>
<p>处理任务的核心方法是<code>execute</code>，我们看看 JDK 1.8 源码中<code>ThreadPoolExecutor</code>是如何处理线程任务的：</p>
<div><pre><code><span>// JDK 1.8 </span>
<span>public</span> <span>void</span> <span>execute</span><span>(</span><span>Runnable</span> command<span>)</span> <span>{</span>
    <span>// 0.如果没有线程，抛出空指针异常</span>
    <span>if</span> <span>(</span>command <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    
    <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
    
    <span>// 1.当前线程数小于corePoolSize,则调用 addWorker 创建核心线程执行任务</span>
    <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>c<span>)</span> <span>&lt;</span> corePoolSize<span>)</span> <span>{</span>
       <span>if</span> <span>(</span><span>addWorker</span><span>(</span>command<span>,</span> <span>true</span><span>)</span><span>)</span>
           <span>return</span><span>;</span>
       c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>// 2.如果不小于corePoolSize，则将任务添加到 workQueue 队列。</span>
    <span>if</span> <span>(</span><span>isRunning</span><span>(</span>c<span>)</span> <span>&amp;&amp;</span> workQueue<span>.</span><span>offer</span><span>(</span>command<span>)</span><span>)</span> <span>{</span>
        <span>int</span> recheck <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        
        <span>// 2.1 如果isRunning返回false(状态检查)，则remove这个任务，然后执行拒绝策略。</span>
        <span>if</span> <span>(</span><span>!</span><span>isRunning</span><span>(</span>recheck<span>)</span> <span>&amp;&amp;</span> <span>remove</span><span>(</span>command<span>)</span><span>)</span>
            <span>reject</span><span>(</span>command<span>)</span><span>;</span>
        
        <span>// 2.2 线程池处于running状态，但是没有线程，则创建线程</span>
        <span>else</span> <span>if</span> <span>(</span><span>workerCountOf</span><span>(</span>recheck<span>)</span> <span>==</span> <span>0</span><span>)</span>
            <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>// 3.如果放入workQueue失败，则创建非核心线程执行任务，</span>
    <span>// 如果这时创建非核心线程失败(当前线程总数不小于maximumPoolSize时)，就会执行拒绝策略。</span>
    <span>else</span> <span>if</span> <span>(</span><span>!</span><span>addWorker</span><span>(</span>command<span>,</span> <span>false</span><span>)</span><span>)</span>
         <span>reject</span><span>(</span>command<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p><code>ctl.get()</code>是获取线程池状态，用<code>int</code>类型表示。第二步中，入队前进行了一次<code>isRunning</code>判断，入队之后，又进行了一次<code>isRunning</code>判断。</p>
<div><p>为什么要二次检查线程池的状态?</p>
<p>在多线程的环境下，线程池的状态是时刻发生变化的。很有可能刚获取线程池状态后线程池状态就改变了。判断是否将<code>command</code>加入<code>workqueue</code>是线程池之前的状态。倘若没有二次检查，万一线程池处于非<strong>RUNNING</strong>状态（在多线程环境下很有可能发生），那么<code>command</code>永远不会执行。</p>
</div>
<p><strong>总结一下处理流程</strong></p>
<ol>
<li>线程总数量 &lt; corePoolSize，无论线程是否空闲，都会新建一个核心线程执行任务（让核心线程数量快速达到corePoolSize，在核心线程数量 &lt; corePoolSize时）。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>线程总数量 &gt;= corePoolSize时，新来的线程任务会进入任务队列中等待，然后空闲的核心线程会依次去缓存队列中取任务来执行（体现了<strong>线程复用</strong>）。</li>
<li>当缓存队列满了，说明这个时候任务已经多到爆棚，需要一些“临时工”来执行这些任务了。于是会创建非核心线程去执行这个任务。<strong>注意，这一步需要获得全局锁。</strong></li>
<li>缓存队列满了， 且总线程数达到了maximumPoolSize，则会采取上面提到的拒绝策略进行处理。</li>
</ol>
<p>整个过程如图所示：</p>
<p><img src="./README.assets/线程池主要的处理流程-16475906044531.png" alt="线程池主要的处理流程" loading="lazy"></p>
<h3 id="_2-4-如何做到线程复用的-有点复杂"> 2.4 如何做到线程复用的 （有点复杂）</h3>
<p>我们知道，一个线程在创建的时候会指定一个线程任务，当执行完这个线程任务之后，线程自动销毁。但是线程池却可以复用线程，即一个线程执行完线程任务后不销毁，继续执行另外的线程任务。那么，线程池如何做到线程复用呢？</p>
<p>ThreadPoolExecutor在创建线程时，会将线程封装成<strong>工作线程worker</strong>,并放入<strong>工作线程组</strong>中，然后这个worker反复从阻塞队列中拿任务去执行。</p>
<p>这里的<code>addWorker</code>方法是在上面提到的<code>execute</code>方法里面调用的，先看看上半部分：</p>
<div><pre><code><span>// ThreadPoolExecutor.addWorker方法源码上半部分</span>
<span>private</span> <span>boolean</span> <span>addWorker</span><span>(</span><span>Runnable</span> firstTask<span>,</span> <span>boolean</span> core<span>)</span> <span>{</span>
    retry<span>:</span>
    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>c<span>)</span><span>;</span>

        <span>// Check if queue empty only if necessary.</span>
        <span>if</span> <span>(</span>rs <span>>=</span> SHUTDOWN <span>&amp;&amp;</span> <span>!</span><span>(</span>rs <span>==</span> SHUTDOWN <span>&amp;&amp;</span> firstTask <span>==</span> <span>null</span> <span>&amp;&amp;</span> <span>!</span>workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span>
            <span>return</span> <span>false</span><span>;</span>

        <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
            <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>c<span>)</span><span>;</span>
            <span>if</span> <span>(</span>wc <span>>=</span> CAPACITY <span>||</span>
                <span>// 1.如果core是ture,证明需要创建的线程为核心线程，则先判断当前线程是否大于核心线程</span>
                <span>// 如果core是false,证明需要创建的是非核心线程，则先判断当前线程数是否大于总线程数</span>
                <span>// 如果不小于，则返回false</span>
                wc <span>>=</span> <span>(</span>core <span>?</span> corePoolSize <span>:</span> maximumPoolSize<span>)</span><span>)</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>if</span> <span>(</span><span>compareAndIncrementWorkerCount</span><span>(</span>c<span>)</span><span>)</span>
                <span>break</span> retry<span>;</span>
            c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>  <span>// Re-read ctl</span>
            <span>if</span> <span>(</span><span>runStateOf</span><span>(</span>c<span>)</span> <span>!=</span> rs<span>)</span>
                <span>continue</span> retry<span>;</span>
            <span>// else CAS failed due to workerCount change; retry inner loop</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>上半部分主要是判断线程数量是否超出阈值，超过了就返回false。我们继续看下半部分:</p>
<div><pre><code>    <span>// ThreadPoolExecutor.addWorker方法源码下半部分</span>
    <span>boolean</span> workerStarted <span>=</span> <span>false</span><span>;</span>
    <span>boolean</span> workerAdded <span>=</span> <span>false</span><span>;</span>
    <span>Worker</span> w <span>=</span> <span>null</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>// 1.创建一个worker对象</span>
        w <span>=</span> <span>new</span> <span>Worker</span><span>(</span>firstTask<span>)</span><span>;</span>
        
        <span>// 2.实例化一个Thread对象</span>
        <span>final</span> <span>Thread</span> t <span>=</span> w<span>.</span>thread<span>;</span>
        <span>if</span> <span>(</span>t <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 3.线程池全局锁</span>
            <span>final</span> <span>ReentrantLock</span> mainLock <span>=</span> <span>this</span><span>.</span>mainLock<span>;</span>
            mainLock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
            <span>try</span> <span>{</span>
                <span>// Recheck while holding lock.</span>
                <span>// Back out on ThreadFactory failure or if</span>
                <span>// shut down before lock acquired.</span>
                <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>

                <span>if</span> <span>(</span>rs <span>&lt;</span> SHUTDOWN <span>||</span> <span>(</span>rs <span>==</span> SHUTDOWN <span>&amp;&amp;</span> firstTask <span>==</span> <span>null</span><span>)</span><span>)</span> <span>{</span>
                    <span>if</span> <span>(</span>t<span>.</span><span>isAlive</span><span>(</span><span>)</span><span>)</span> <span>// precheck that t is startable</span>
                        <span>throw</span> <span>new</span> <span>IllegalThreadStateException</span><span>(</span><span>)</span><span>;</span>
                    workers<span>.</span><span>add</span><span>(</span>w<span>)</span><span>;</span>
                    <span>int</span> s <span>=</span> workers<span>.</span><span>size</span><span>(</span><span>)</span><span>;</span>
                    <span>if</span> <span>(</span>s <span>></span> largestPoolSize<span>)</span>
                        largestPoolSize <span>=</span> s<span>;</span>
                    workerAdded <span>=</span> <span>true</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>finally</span> <span>{</span>
                mainLock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
            <span>if</span> <span>(</span>workerAdded<span>)</span> <span>{</span>
                <span>// 4.启动这个线程</span>
                t<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
                workerStarted <span>=</span> <span>true</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>if</span> <span>(</span><span>!</span> workerStarted<span>)</span>
            <span>addWorkerFailed</span><span>(</span>w<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> workerStarted<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br></div></div><p>创建<code>worker</code>对象，并初始化一个<code>Thread</code>对象，然后启动这个线程对象。</p>
<p>我们接着看看<code>Worker</code>类，仅展示部分源码：</p>
<div><pre><code><span>// Worker类部分源码</span>
<span>private</span> <span>final</span> <span>class</span> <span>Worker</span> <span>extends</span> <span>AbstractQueuedSynchronizer</span> <span>implements</span> <span>Runnable</span><span>{</span>
    <span>final</span> <span>Thread</span> thread<span>;</span>
    <span>Runnable</span> firstTask<span>;</span>
    
    <span>Worker</span><span>(</span><span>Runnable</span> firstTask<span>)</span> <span>{</span>
        <span>setState</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span> <span>// inhibit interrupts until runWorker</span>
        <span>this</span><span>.</span>firstTask <span>=</span> firstTask<span>;</span>
        <span>this</span><span>.</span>thread <span>=</span> <span>getThreadFactory</span><span>(</span><span>)</span><span>.</span><span>newThread</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>runWorker</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>}</span>
    <span>//其余代码略...</span>
<span>}</span>    
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>Worker</code>类实现了<code>Runnable</code>接口，所以<code>Worker</code>也是一个线程任务。在构造方法中，创建了一个线程，线程的任务就是自己。故<code>addWorker</code>方法调用addWorker方法源码下半部分中的第4步<code>t.start</code>，会触发<code>Worker</code>类的<code>run</code>方法被JVM调用。</p>
<p>我们再看看<code>runWorker</code>的逻辑：</p>
<div><pre><code><span>// Worker.runWorker方法源代码</span>
<span>final</span> <span>void</span> <span>runWorker</span><span>(</span><span>Worker</span> w<span>)</span> <span>{</span>
    <span>Thread</span> wt <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
    <span>Runnable</span> task <span>=</span> w<span>.</span>firstTask<span>;</span>
    w<span>.</span>firstTask <span>=</span> <span>null</span><span>;</span>
    
    <span>// 1.线程启动之后，通过unlock方法释放锁</span>
    w<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span> <span>// allow interrupts</span>
    <span>boolean</span> completedAbruptly <span>=</span> <span>true</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>// 2.Worker执行firstTask或从workQueue中获取任务，如果getTask方法不返回null,循环不退出</span>
        <span>while</span> <span>(</span>task <span>!=</span> <span>null</span> <span>||</span> <span>(</span>task <span>=</span> <span>getTask</span><span>(</span><span>)</span><span>)</span> <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 2.1进行加锁操作，保证thread不被其他线程中断（除非线程池被中断）</span>
            w<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
            <span>// If pool is stopping, ensure thread is interrupted;</span>
            <span>// if not, ensure thread is not interrupted.  This</span>
            <span>// requires a recheck in second case to deal with</span>
            <span>// shutdownNow race while clearing interrupt</span>
            <span>// 2.2检查线程池状态，倘若线程池处于中断状态，当前线程将中断。 </span>
            <span>if</span> <span>(</span><span>(</span><span>runStateAtLeast</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> STOP<span>)</span> <span>||</span>
                 <span>(</span><span>Thread</span><span>.</span><span>interrupted</span><span>(</span><span>)</span> <span>&amp;&amp;</span>
                  <span>runStateAtLeast</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>,</span> STOP<span>)</span><span>)</span><span>)</span> <span>&amp;&amp;</span>
                <span>!</span>wt<span>.</span><span>isInterrupted</span><span>(</span><span>)</span><span>)</span>
                wt<span>.</span><span>interrupt</span><span>(</span><span>)</span><span>;</span>
            <span>try</span> <span>{</span>
                <span>// 2.3执行beforeExecute </span>
                <span>beforeExecute</span><span>(</span>wt<span>,</span> task<span>)</span><span>;</span>
                <span>Throwable</span> thrown <span>=</span> <span>null</span><span>;</span>
                <span>try</span> <span>{</span>
                    <span>// 2.4执行任务</span>
                    task<span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>RuntimeException</span> x<span>)</span> <span>{</span>
                    thrown <span>=</span> x<span>;</span> <span>throw</span> x<span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>Error</span> x<span>)</span> <span>{</span>
                    thrown <span>=</span> x<span>;</span> <span>throw</span> x<span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>Throwable</span> x<span>)</span> <span>{</span>
                    thrown <span>=</span> x<span>;</span> <span>throw</span> <span>new</span> <span>Error</span><span>(</span>x<span>)</span><span>;</span>
                <span>}</span> <span>finally</span> <span>{</span>
                    <span>// 2.5执行afterExecute方法 </span>
                    <span>afterExecute</span><span>(</span>task<span>,</span> thrown<span>)</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>finally</span> <span>{</span>
                task <span>=</span> <span>null</span><span>;</span>
                w<span>.</span>completedTasks<span>++</span><span>;</span>
                <span>// 2.6解锁操作</span>
                w<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
        completedAbruptly <span>=</span> <span>false</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>processWorkerExit</span><span>(</span>w<span>,</span> completedAbruptly<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>首先去执行创建这个worker时就有的任务，当执行完这个任务后，worker的生命周期并没有结束，在<code>while</code>循环中，worker会不断地调用<code>getTask</code>方法从<strong>阻塞队列</strong>中获取任务然后调用<code>task.run()</code>执行任务,从而达到<strong>复用线程</strong>的目的。只要<code>getTask</code>方法不返回<code>null</code>,此线程就不会退出。</p>
<p>当然，核心线程池中创建的线程想要拿到阻塞队列中的任务，先要判断线程池的状态，如果<strong>STOP</strong>或者<strong>TERMINATED</strong>，返回<code>null</code>。</p>
<p>最后看看<code>getTask</code>方法的实现:</p>
<div><pre><code><span>// Worker.getTask方法源码</span>
<span>private</span> <span>Runnable</span> <span>getTask</span><span>(</span><span>)</span> <span>{</span>
    <span>boolean</span> timedOut <span>=</span> <span>false</span><span>;</span> <span>// Did the last poll() time out?</span>

    <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>int</span> c <span>=</span> ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> rs <span>=</span> <span>runStateOf</span><span>(</span>c<span>)</span><span>;</span>

        <span>// Check if queue empty only if necessary.</span>
        <span>if</span> <span>(</span>rs <span>>=</span> SHUTDOWN <span>&amp;&amp;</span> <span>(</span>rs <span>>=</span> STOP <span>||</span> workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>decrementWorkerCount</span><span>(</span><span>)</span><span>;</span>
            <span>return</span> <span>null</span><span>;</span>
        <span>}</span>

        <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>c<span>)</span><span>;</span>

        <span>// Are workers subject to culling?</span>
        <span>// 1.allowCoreThreadTimeOut变量默认是false,核心线程即使空闲也不会被销毁</span>
        <span>// 如果为true,核心线程在keepAliveTime内仍空闲则会被销毁。 </span>
        <span>boolean</span> timed <span>=</span> allowCoreThreadTimeOut <span>||</span> wc <span>></span> corePoolSize<span>;</span>
		<span>// 2.如果运行线程数超过了最大线程数，但是缓存队列已经空了，这时递减worker数量。 </span>
　　　　 <span>// 如果有设置允许线程超时或者线程数量超过了核心线程数量，</span>
        <span>// 并且线程在规定时间内均未poll到任务且队列为空则递减worker数量</span>
        <span>if</span> <span>(</span><span>(</span>wc <span>></span> maximumPoolSize <span>||</span> <span>(</span>timed <span>&amp;&amp;</span> timedOut<span>)</span><span>)</span>
            <span>&amp;&amp;</span> <span>(</span>wc <span>></span> <span>1</span> <span>||</span> workQueue<span>.</span><span>isEmpty</span><span>(</span><span>)</span><span>)</span><span>)</span> <span>{</span>
            <span>if</span> <span>(</span><span>compareAndDecrementWorkerCount</span><span>(</span>c<span>)</span><span>)</span>
                <span>return</span> <span>null</span><span>;</span>
            <span>continue</span><span>;</span>
        <span>}</span>

        <span>try</span> <span>{</span>
            <span>// 3.如果timed为true(想想哪些情况下timed为true),则会调用workQueue的poll方法获取任务.</span>
            <span>// 超时时间是keepAliveTime。如果超过keepAliveTime时长，</span>
            <span>// poll返回了null，上边提到的while循序就会退出，线程也就执行完了。</span>
            <span>// 如果timed为false（allowCoreThreadTimeOut为false</span>
            <span>// 且wc > corePoolSize为false），则会调用workQueue的take方法阻塞在当前。</span>
            <span>// 队列中有任务加入时，线程被唤醒，take方法返回任务，并执行。</span>
            <span>Runnable</span> r <span>=</span> timed <span>?</span>
                workQueue<span>.</span><span>poll</span><span>(</span>keepAliveTime<span>,</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span> <span>:</span>
                workQueue<span>.</span><span>take</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>r <span>!=</span> <span>null</span><span>)</span>
                <span>return</span> r<span>;</span>
            timedOut <span>=</span> <span>true</span><span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> retry<span>)</span> <span>{</span>
            timedOut <span>=</span> <span>false</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br></div></div><p>核心线程的会一直卡在<code>workQueue.take</code>方法，被阻塞并挂起，不会占用CPU资源，直到拿到<code>Runnable</code> 然后返回（当然如果<strong>allowCoreThreadTimeOut</strong>设置为<code>true</code>,那么核心线程就会去调用<code>poll</code>方法，因为<code>poll</code>可能会返回<code>null</code>,所以这时候核心线程满足超时条件也会被销毁）。</p>
<p>非核心线程会workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) ，如果超时还没有拿到，下一次循环判断<strong>compareAndDecrementWorkerCount</strong>就会返回<code>null</code>,Worker对象的<code>run()</code>方法循环体的判断为<code>null</code>,任务结束，然后线程被系统回收 。</p>
<h2 id="三、四种常见的线程池"> 三、四种常见的线程池</h2>
<p><code>Executors</code>类中提供的几个静态方法来创建线程池。大家到了这一步，如果看懂了前面讲的<code>ThreadPoolExecutor</code>构造方法中各种参数的意义，那么一看到<code>Executors</code>类中提供的线程池的源码就应该知道这个线程池是干嘛的。</p>
<h3 id="_3-1-newcachedthreadpool"> 3.1 newCachedThreadPool</h3>
<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newCachedThreadPool</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>
                                  <span>60L</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>,</span>
                                  <span>new</span> <span>SynchronousQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>CacheThreadPool</code>的<strong>运行流程</strong>如下：</p>
<ol>
<li>提交任务进线程池。</li>
<li>因为 <code>corePoolSize</code> 为 0 的关系，<mark>不创建核心线程</mark>，线程池最大为 <code>Integer.MAX_VALUE</code> 。</li>
<li>尝试将任务添加到 <code>SynchronousQueue</code> 队列。</li>
<li>如果 <code>SynchronousQueue</code> 入列成功，等待被当前运行的线程空闲后拉取执行。如果当前没有空闲线程，那么就创建一个非核心线程，然后从SynchronousQueue拉取任务并在当前线程执行。</li>
<li>如果 <code>SynchronousQueue</code> 已有任务在等待，入列操作将会阻塞。</li>
</ol>
<p>当需要执行很多<strong>短时间</strong>的任务时，CacheThreadPool 的线程复用率比较高， 会显著的<strong>提高性能</strong>。而且线程60s后会回收，意味着即使没有任务进来，CacheThreadPool 并不会占用很多资源。</p>
<h3 id="_3-2-newfixedthreadpool"> 3.2 newFixedThreadPool</h3>
<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newFixedThreadPool</span><span>(</span><span>int</span> nThreads<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ThreadPoolExecutor</span><span>(</span>nThreads<span>,</span> nThreads<span>,</span>
                                      <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                      <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>核心线程数量和总线程数量相等，都是传入的参数 <code>nThreads</code> ，所以 <mark>只能创建核心线程，不能创建非核心线程</mark> 。因为 <code>LinkedBlockingQueue</code> 的默认大小是 <code>Integer.MAX_VALUE</code> ，故如果核心线程空闲，则交给核心线程处理；如果核心线程不空闲，则入列等待，直到核心线程空闲。</p>
<div><p>与 CachedThreadPool 的区别：</p>
<ul>
<li>因为 corePoolSize == maximumPoolSize ，所以 <strong><code>FixedThreadPool</code> 只会创建核心线程</strong>。 而另一边因为 corePoolSize = 0，所以 <strong><code>CachedThreadPool</code> 只会创建非核心线程</strong>。</li>
<li>在 getTask() 方法，如果队列里没有任务可取，线程会一直阻塞在 LinkedBlockingQueue.take() ， <code>FixedThreadPool</code> 线程不会被回收。 <code>CachedThreadPool</code> 会在60s后收回。</li>
<li>由于线程不会被回收，会一直卡在阻塞，所以<strong>没有任务的情况下， FixedThreadPool占用资源更多</strong>。</li>
<li><strong>都几乎不会触发拒绝策略</strong>，但是原理不同。<u><code>FixedThreadPool</code> 是因为阻塞队列可以很大</u>（最大为Integer最大值），故几乎不会触发拒绝策略；<u><code>CachedThreadPool</code> 是因为线程池很大</u>（最大为Integer最大值），几乎不会导致线程数量大于最大线程数，故几乎不会触发拒绝策略。</li>
</ul>
</div>
<h3 id="_3-3-newsinglethreadexecutor"> 3.3 newSingleThreadExecutor</h3>
<div><pre><code><span>public</span> <span>static</span> <span>ExecutorService</span> <span>newSingleThreadExecutor</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>FinalizableDelegatedExecutorService</span>
        <span>(</span><span>new</span> <span>ThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>1</span><span>,</span>
                                <span>0L</span><span>,</span> <span>TimeUnit</span><span>.</span>MILLISECONDS<span>,</span>
                                <span>new</span> <span>LinkedBlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><mark>有且仅有一个核心线程</mark>（ corePoolSize = maximumPoolSize = 1），使用了LinkedBlockingQueue（容量很大），所以，<strong>不会创建非核心线程</strong>。所有任务按照<strong>先来先执行</strong>的顺序执行。如果这个唯一的线程不空闲，那么新来的任务会存储在任务队列里等待执行。</p>
<h3 id="_3-4-newscheduledthreadpool"> 3.4 newScheduledThreadPool</h3>
<p>创建一个定长线程池，支持定时及周期性任务执行。</p>
<div><pre><code><span>public</span> <span>static</span> <span>ScheduledExecutorService</span> <span>newScheduledThreadPool</span><span>(</span><span>int</span> corePoolSize<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>ScheduledThreadPoolExecutor</span><span>(</span>corePoolSize<span>)</span><span>;</span>
<span>}</span>

<span>//ScheduledThreadPoolExecutor():</span>
<span>public</span> <span>ScheduledThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>)</span> <span>{</span>
    <span>super</span><span>(</span>corePoolSize<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span>
          DEFAULT_KEEPALIVE_MILLIS<span>,</span> MILLISECONDS<span>,</span>
          <span>new</span> <span>DelayedWorkQueue</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>四种常见的线程池基本够我们使用了，但是《阿里巴巴开发手册》不建议我们直接使用Executors类中的线程池，而是通过<code>ThreadPoolExecutor</code>的方式，这样的处理方式让写的同学需要更加明确线程池的运行规则，规避资源耗尽的风险。</p>
<p>但如果你及团队本身对线程池非常熟悉，又确定业务规模不会大到资源耗尽的程度（比如线程数量或任务队列长度可能达到Integer.MAX_VALUE）时，其实是可以使用JDK提供的这几个接口的，它能让我们的代码具有更强的可读性。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十五章、并发容器集合</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/15/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/15/"/>
    <updated>2022-03-19T08:02:56.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/15.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十五章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、同步容器与并发容器"> 一、同步容器与并发容器</h2>
<p>我们知道在 <code>java.util</code> 包下提供了一些容器类，而 <code>Vector</code> 和 <code>Hashtable</code> 是线程安全的容器类，但是这些容器实现同步的方式是通过对方法加锁(sychronized)方式实现的，这样读写均需要锁操作，导致性能低下。</p>
<p>而即使是Vector这样线程安全的类，在面对多线程下的复合操作的时候也是需要通过客户端加锁的方式保证原子性。如下面例子说明:</p>
<div><pre><code><span>public</span> <span>class</span> <span>TestVector</span> <span>{</span>
	<span>private</span> <span>Vector</span><span><span>&lt;</span><span>String</span><span>></span></span> vector<span>;</span>

	<span>//方法一</span>
	<span>public</span>  <span>Object</span> <span>getLast</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>
	    <span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
	    <span>return</span> vector<span>.</span><span>get</span><span>(</span>lastIndex<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//方法二</span>
	<span>public</span>  <span>void</span> <span>deleteLast</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>
	    <span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
	    vector<span>.</span><span>remove</span><span>(</span>lastIndex<span>)</span><span>;</span>
	<span>}</span>
	
	<span>//方法三</span>
	<span>public</span>  <span>Object</span> <span>getLastSysnchronized</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>
		<span>synchronized</span><span>(</span>vector<span>)</span><span>{</span>
			<span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
			<span>return</span> vector<span>.</span><span>get</span><span>(</span>lastIndex<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>

	<span>//方法四</span>
	<span>public</span>  <span>void</span> <span>deleteLastSysnchronized</span><span>(</span><span>Vector</span> vector<span>)</span> <span>{</span>
		<span>synchronized</span> <span>(</span>vector<span>)</span><span>{</span>
			<span>int</span> lastIndex <span>=</span> vector<span>.</span><span>size</span><span>(</span><span>)</span> <span>-</span> <span>1</span><span>;</span>
			vector<span>.</span><span>remove</span><span>(</span>lastIndex<span>)</span><span>;</span>
		<span>}</span>
	<span>}</span>
	
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>如果方法一和方法二为一个组合的话。那么当方法一获取到了<code>vector</code>的size之后，方法二已经执行完毕，这样就导致程序的错误。</p>
<div><p>疑问</p>
<p>那为什么还说 Vector 是线程安全的？</p>
</div>
<p>如果方法三与方法四组合的话。通过锁机制保证了在<code>vector</code>上的操作的原子性。</p>
<p>并发容器是Java 5 提供的在多线程编程下用于代替同步容器，针对不同的应用场景进行设计，提高容器的并发访问性，同时定义了线程安全的复合操作。</p>
<h2 id="二、并发容器类介绍"> 二、并发容器类介绍</h2>
<p>整体架构(列举常用的容器类)</p>
<p><img src="./README.assets/并发容器-16476160116323.png" alt="并发容器" loading="lazy"></p>
<p>其中，阻塞队列（<code>BlockingQueue</code>）在<a href="./../13/">第十三章</a>有介绍，<code>CopyOnWrite</code> 容器（<code>CopyOnWritexxx</code>）在<a href="./../16/">第十六章</a>有</p>
<p>下面分别介绍一些常用的并发容器类和接口，因篇幅原因，这里只介绍这些类的用途和基本的原理，不做过多的源码解析。</p>
<h3 id="_2-1-并发map"> 2.1 并发Map</h3>
<h4 id="concurrentmap接口"> ConcurrentMap接口</h4>
<p>ConcurrentMap接口继承了Map接口，在Map接口的基础上又定义了四个方法：</p>
<div><pre><code><span>public</span> <span>interface</span> <span>ConcurrentMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>extends</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>{</span>

    <span>//插入元素</span>
    <span>V</span> <span>putIfAbsent</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span><span>;</span>

    <span>//移除元素</span>
    <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> key<span>,</span> <span>Object</span> value<span>)</span><span>;</span>

    <span>//替换元素</span>
    <span>boolean</span> <span>replace</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> oldValue<span>,</span> <span>V</span> newValue<span>)</span><span>;</span>

    <span>//替换元素</span>
    <span>V</span> <span>replace</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span><span>;</span>
    
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><ul>
<li><strong>putIfAbsent：</strong> 与原有put方法不同的是，<u>putIfAbsent方法中如果插入的key相同，则不替换原有的value值；</u></li>
<li><strong>remove：</strong> 与原有remove方法不同的是，新remove方法中增加了对value的判断，<u>如果要删除的 <code>key-value</code> 不能与Map中原有的 <code>key-value</code> 对应上，则不会删除该元素;</u></li>
<li><strong>replace(K,V,V)：</strong> 增加了对value值的判断，如果 <code>key-oldValue</code> 能与Map中原有的key-value对应上，才进行替换操作；</li>
<li><strong>replace(K,V)：</strong> 与上面的 <code>replace</code> 不同的是，此 replace 不会对Map中原有的 <code>key-value</code> 进行比较，如果key存在则直接替换；</li>
</ul>
<hr>
<h4 id="concurrenthashmap类"> ConcurrentHashMap类</h4>
<p><code>ConcurrentHashMap</code> 同HashMap一样也是基于散列表的map，但是它提供了一种与 <code>Hashtable</code> 完全不同的加锁策略，提供更高效的并发性和伸缩性。</p>
<p>ConcurrentHashMap在JDK 1.7 和JDK 1.8中有一些区别。这里我们分开介绍一下。</p>
<p><strong>JDK 1.7</strong></p>
<p>ConcurrentHashMap在JDK 1.7中，提供了一种粒度更细的加锁机制来实现在多线程下更高的性能，这种机制叫 <mark>分段锁(Lock Striping)</mark> 。</p>
<p>提供的优点是：<strong>在并发环境下将实现更高的吞吐量，而在单线程环境下只损失非常小的性能</strong>。</p>
<p>可以这样理解分段锁，就是<strong>将数据分段，对每一段数据分配一把锁</strong>。当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</p>
<p>有些方法需要跨段，比如 <code>size()、isEmpty()、containsValue()</code>，它们可能需要锁定整个表而不仅仅是某个段，这需要按顺序锁定所有段，操作完毕后，又按顺序释放所有段的锁。如下图：</p>
<p><img src="./README.assets/分段锁机制-16476152209892.png" alt="分段锁机制" loading="lazy"></p>
<p>ConcurrentHashMap是由Segment数组结构和 <code>HashEntry</code> 数组结构组成。Segment是一种可重入锁 <code>ReentrantLock</code> ，HashEntry则用于存储键值对数据。</p>
<p>一个ConcurrentHashMap里包含一个Segment数组，Segment的结构和HashMap类似，是一种数组和链表结构， 一个Segment里包含一个HashEntry数组，每个HashEntry是一个链表结构的元素， 每个Segment守护着一个HashEntry数组里的元素，当对HashEntry数组的数据进行修改时，必须首先获得它对应的Segment锁。</p>
<div><p>ConcurrentHashMap 1.8 优化</p>
<ul>
<li>同HashMap一样，链表也会在长度达到8的时候转化为红黑树，这样可以提升大量冲突时候的查询效率；</li>
<li>以某个位置的头结点（链表的头结点或红黑树的root结点）为锁，配合自旋+CAS避免不必要的锁开销，进一步提升并发性能。</li>
</ul>
</div>
<hr>
<h4 id="concurrentnavigablemap-接口与-concurrentskiplistmap类"> ConcurrentNavigableMap 接口与 ConcurrentSkipListMap类</h4>
<p><code>ConcurrentNavigableMap</code> 接口继承了 <code>NavigableMap</code> 接口，这个接口提供了针对给定搜索目标返回最接近匹配项的导航方法。</p>
<p><code>ConcurrentNavigableMap</code> 接口的主要实现类是 <code>ConcurrentSkipListMap</code> 类。从名字上来看，它的底层使用的是跳表（<code>SkipList</code>）的数据结构。关于跳表的数据结构这里不做太多介绍，它是一种”空间换时间“的数据结构，可以使用CAS来保证并发安全性。</p>
<h3 id="_2-2-并发queue"> 2.2 并发Queue</h3>
<p>JDK并没有提供线程安全的List类，因为对List来说，<strong>很难去开发一个通用并且没有并发瓶颈的线程安全的List</strong>。因为即使简单的读操作，拿contains() 这样一个操作来说，很难想到搜索的时候如何避免锁住整个list。</p>
<p>所以退一步，JDK提供了对队列和双端队列的线程安全的类：ConcurrentLinkedQueue和ConcurrentLinkedDeque。因为队列相对于List来说，有更多的限制。这两个类是使用CAS来实现线程安全的。</p>
<h3 id="_2-3-并发set"> 2.3 并发Set</h3>
<p>JDK提供了ConcurrentSkipListSet，是线程安全的有序的集合。底层是使用ConcurrentSkipListMap实现。</p>
<p>谷歌的guava框架实现了一个线程安全的ConcurrentHashSet：</p>
<div><pre><code><span>Set</span><span><span>&lt;</span><span>String</span><span>></span></span> s <span>=</span> <span>Sets</span><span>.</span><span>newConcurrentHashSet</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T15:08:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第九章、synchronized与锁</title>
    <id>https://notes.lllllan.cn/java/concurrent/2/9/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/2/9/"/>
    <updated>2022-04-18T13:08:35.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/02/9.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第九章 - GitHub</a></li>
</ul>
</div>
<p><strong>Java 多线程的锁都是基于对象的</strong>，Java 中的每一个对象都可以作为一个锁。</p>
<p>还有一点需要注意的是，我们常听到的 <strong>类锁</strong> 其实也是对象锁。</p>
<p>Java 类只有一个 Class 对象（可以有多个实例对象，多个实例共享这个 Class 对象），而 Class 对象也是特殊的Java 对象。所以我们常说的类锁，其实就是 Class 对象的锁。</p>
<h2 id="一、synchronized关键字"> 一、Synchronized关键字</h2>
<p>说到锁，我们通常会谈到 <code>synchronized</code> 这个关键字。它翻译成中文就是【同步】的意思。</p>
<p>我们通常使用 <code>synchronized</code>关键字来给一段代码或一个方法上锁。它通常有以下三种形式：</p>
<ul>
<li>关键字在实例方法上，锁为当前实例</li>
<li>关键字在静态方法上，锁为当前 Class 对象</li>
<li>关键字在代码块上，锁为括号里面的对象</li>
</ul>
<div><div><div>&nbsp;</div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br></div><pre><code><span>// 关键字在实例方法上，锁为当前实例</span>
<span>public</span> <span>synchronized</span> <span>void</span> <span>instanceLock</span><span>(</span><span>)</span> <span>{</span>
    <span>// code</span>
<span>}</span>

<span>// 关键字在静态方法上，锁为当前Class对象</span>
<span>public</span> <span>static</span> <span>synchronized</span> <span>void</span> <span>classLock</span><span>(</span><span>)</span> <span>{</span>
    <span>// code</span>
<span>}</span>

<span>// 关键字在代码块上，锁为括号里面的对象</span>
<span>public</span> <span>void</span> <span>blockLock</span><span>(</span><span>)</span> <span>{</span>
    <span>Object</span> o <span>=</span> <span>new</span> <span>Object</span><span>(</span><span>)</span><span>;</span>
    <span>synchronized</span> <span>(</span>o<span>)</span> <span>{</span>
        <span>// code</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><div><p>临界区</p>
<p>指的是某一块代码区域，它同一时刻只能由一个线程执行。在上面的例子中，如果 <code>synchronized</code> 关键字在方法上，那临界区就是整个方法内部。而如果是使用 synchronized 代码块，那临界区就指的是代码块内部的区域。</p>
</div>
<p>通过上面的例子我们可以看到，下面这两个写法其实是等价的作用：</p>
<div><pre><code>// 关键字在实例方法上，锁为当前实例
public synchronized void instanceLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    synchronized (this) {
        // code
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>同理，下面这两个方法也应该是等价的：</p>
<div><pre><code>// 关键字在静态方法上，锁为当前Class对象
public static synchronized void classLock() {
    // code
}

// 关键字在代码块上，锁为括号里面的对象
public void blockLock() {
    synchronized (this.getClass()) {
        // code
    }
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h2 id="二、锁"> 二、锁</h2>
<p>Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了【偏向锁】和【轻量级锁】。在Java 6 以前，所有的锁都是【重量级】锁。所以在Java 6 及其以后，一个对象其实有四种锁状态，它们级别由低到高依次是：</p>
<ol>
<li>无锁状态</li>
<li>偏向锁状态</li>
<li>轻量级锁状态</li>
<li>重量级锁状态</li>
</ol>
<p>无锁就是没有对资源进行锁定，任何线程都可以尝试去修改它，无锁在这里不再细讲。</p>
<p>几种锁会随着竞争情况逐渐升级，锁的升级很容易发生，但是锁降级发生的条件会比较苛刻， <mark>锁降级发生在 Stop The World 期间，当 JVM 进入安全点的时候，会检查是否有闲置的锁，然后进行降级</mark> 。</p>
<blockquote>
<p>关于锁降级有两点说明：</p>
<ol>
<li>
<p>不同于大部分文章说锁不能降级，实际上HotSpot JVM 是支持锁降级的 - <a href="https://www.jianshu.com/p/9932047a89be" target="_blank" rel="noopener noreferrer">Java锁优化--JVM锁降级</a></p>
</li>
<li>
<p>上面提到的 Stop The World 期间，以及安全点，这些知识是属于 JVM 的知识范畴，本文不做细讲。</p>
</li>
</ol>
</blockquote>
<p>下面分别介绍这几种锁以及它们之间的升级。</p>
<h2 id="三、java对象头"> 三、Java对象头</h2>
<p>前面我们提到，Java 的锁都是基于对象的。首先我们来看看一个对象的【锁】的信息是存放在什么地方的。</p>
<p>每个 Java 对象都有对象头。如果是非数组类型，则用 2 个字宽来存储对象头，如果是数组，则会用 3 个字宽来存储对象头。在 32 位处理器中，一个字宽是 32 位；在 64 位虚拟机中，一个字宽是 64 位。对象头的内容如下表：</p>
<table>
<thead>
<tr>
<th>长度</th>
<th>内容</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>32/64bit</td>
<td>Mark Word</td>
<td>存储对象的 hashCode 或锁信息等</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Class Metadata Address</td>
<td>存储到对象类型数据的指针</td>
</tr>
<tr>
<td>32/64bit</td>
<td>Array length</td>
<td>数组的长度（如果是数组）</td>
</tr>
</tbody>
</table>
<p>我们主要来看看Mark Word的格式：</p>
<table>
<thead>
<tr>
<th>锁状态</th>
<th>29 bit 或 61 bit</th>
<th>1 bit 是否是偏向锁？</th>
<th>2 bit 锁标志位</th>
</tr>
</thead>
<tbody>
<tr>
<td>无锁</td>
<td></td>
<td>0</td>
<td>01</td>
</tr>
<tr>
<td>偏向锁</td>
<td>线程ID</td>
<td>1</td>
<td>01</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>指向栈中锁记录的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>00</td>
</tr>
<tr>
<td>重量级锁</td>
<td>指向互斥量（重量级锁）的指针</td>
<td>此时这一位不用于标识偏向锁</td>
<td>10</td>
</tr>
<tr>
<td>GC标记</td>
<td></td>
<td>此时这一位不用于标识偏向锁</td>
<td>11</td>
</tr>
</tbody>
</table>
<p>可以看到，当对象状态为偏向锁时，<code>Mark Word</code> 存储的是偏向的线程ID；当状态为轻量级锁时，<code>Mark Word</code> 存储的是指向线程栈中 <code>Lock Record</code> 的指针；当状态为重量级锁时，<code>Mark Word</code> 为指向堆中的 monitor 对象的指针。</p>
<h2 id="四、偏向锁"> 四、偏向锁</h2>
<p><mark>Hotspot 的作者经过以往的研究发现大多数情况下 <strong>锁不仅不存在多线程竞争，而且总是由同一线程多次获得</strong>，于是引入了偏向锁。</mark></p>
<p>偏向锁会偏向于第一个访问锁的线程，如果在接下来的运行过程中，该锁没有被其他的线程访问，则持有偏向锁的线程将永远不需要触发同步。也就是说，<strong>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能。</strong></p>
<blockquote>
<p>大白话就是对锁置个变量，如果发现为 true，代表资源无竞争，则无需再走各种加锁/解锁流程。如果为 false，代表存在其他线程竞争资源，那么就会走后面的流程。</p>
</blockquote>
<h3 id="实现原理"> 实现原理</h3>
<p>一个线程在第一次进入同步块时，<strong>会在对象头和栈帧中的锁记录里存储锁的偏向的线程</strong>ID。当下次该线程进入这个同步块时，会去检查锁的 <mark>Mark Word</mark> 里面是不是放的自己的线程ID。</p>
<p>如果是，表明该线程已经获得了锁，以后该线程在进入和退出同步块时不需要花费 CAS 操作来加锁和解锁 ；如果不是，就代表有另一个线程来竞争这个偏向锁。这个时候会尝试使用 CAS 来替换 Mark Word 里面的线程 ID 为新线程的 ID，这个时候要分两种情况：</p>
<ul>
<li>成功，表示之前的线程不存在了， Mark Word 里面的线程 ID 为新线程的 ID，锁不会升级，仍然为偏向锁；</li>
<li>失败，表示之前的线程仍然存在，那么暂停之前的线程，<strong>设置偏向锁标识为 0，并设置锁标志位为 00，升级为轻量级锁，会按照轻量级锁的方式进行竞争锁</strong>。</li>
</ul>
<div><p>CAS: Compare and Swap</p>
<p><a href="http://localhost:8080/java/concurrent/2/10/" target="_blank" rel="noopener noreferrer">第十章、CAS与原子操作 | lllllan</a></p>
<p>比较并交换。用于在硬件层面上提供原子性操作。在 Intel 处理器中，比较并交换通过指令 cmpxchg 实现。 比较是否和给定的数值一致，如果一致则修改，不一致则不修改。</p>
</div>
<p>线程竞争偏向锁的过程如下：</p>
<p><img src="./README.assets/偏向锁2.png" alt="偏向锁2" loading="lazy"></p>
<p>图中涉及到了 lock record 指针指向当前堆栈中的最近一个 lock record，是轻量级锁按照先来先服务的模式进行了轻量级锁的加锁。</p>
<h3 id="撤销偏向锁"> 撤销偏向锁</h3>
<p>偏向锁使用了一种 <strong>等到竞争出现才释放锁的机制</strong>，所以当其他线程尝试竞争偏向锁时， 持有偏向锁的线程才会释放锁。</p>
<p>偏向锁升级成轻量级锁时，会暂停拥有偏向锁的线程，重置偏向锁标识，这个过程看起来容易，实则开销还是很大的，大概的过程如下：</p>
<ol>
<li>在一个安全点（在这个时间点上没有字节码正在执行）停止拥有锁的线程。</li>
<li>遍历线程栈，如果存在锁记录的话，需要修复锁记录和 Mark Word，使其变成无锁状态。</li>
<li>唤醒被停止的线程，将当前锁升级成轻量级锁。</li>
</ol>
<p>所以，如果应用程序里所有的锁通常处于竞争状态，那么偏向锁就会是一种累赘，对于这种情况，我们可以一开始就把偏向锁这个默认功能给关闭：</p>
<div><pre><code><span>-</span>XX<span>:</span><span>UseBiasedLocking</span><span>=</span><span>false</span>
</code></pre>
<div><span>1</span><br></div></div><p>下面这个经典的图总结了偏向锁的获得和撤销：</p>
<p><img src="./README.assets/偏向锁.png" alt="偏向锁" loading="lazy"></p>
<h2 id="五、轻量级锁"> 五、轻量级锁</h2>
<p><mark>多个线程在不同时段获取同一把锁，即不存在锁竞争的情况，也就没有线程阻塞。针对这种情况，JVM 采用轻量级锁来避免线程的阻塞与唤醒。</mark></p>
<h3 id="轻量级锁的加锁"> 轻量级锁的加锁</h3>
<p>JVM 会为每个线程在当前线程的栈帧中创建用于存储锁记录的空间，我们称为【Displaced Mark Word】。如果一个线程获得锁的时候发现是轻量级锁，会把锁的 Mark Word 复制到自己的 Displaced Mark Word 里面。</p>
<p>然后线程尝试用 CAS 将锁的 Mark Word 替换为指向锁记录的指针。如果成功，当前线程获得锁，如果失败，表示 Mark Word 已经被替换成了其他线程的锁记录，说明在与其它线程竞争锁，<mark>当前线程就尝试使用 <strong>自旋</strong> 来获取锁</mark>。</p>
<div><p>自旋</p>
<p>不断尝试去获取锁，一般用循环来实现。</p>
</div>
<p><strong>自旋是需要消耗 CPU 的，如果一直获取不到锁的话，那该线程就一直处在自旋状态，白白浪费 CPU 资源</strong>。解决这个问题最简单的办法就是指定自旋的次数，例如让其循环 10 次，如果还没获取到锁就进入阻塞状态。</p>
<p>但是 JDK 采用了更聪明的方式——适应性自旋</p>
<div><p>适应性自旋</p>
<p>简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
</div>
<p>自旋也不是一直进行下去的，如果自旋到一定程度（和 JVM、操作系统相关），依然没有获取到锁，称为自旋失败，那么这个线程会阻塞。<mark>同时这个锁就会升级成重量级锁</mark>。</p>
<h3 id="轻量级锁的释放"> 轻量级锁的释放</h3>
<p>在释放锁时，当前线程会使用 CAS 操作将 Displaced Mark Word 的内容复制回锁的 Mark Word 里面。如果没有发生竞争，那么这个复制的操作会成功。如果有其他线程因为自旋多次导致轻量级锁升级成了重量级锁，那么 CAS 操作会失败，此时会释放锁并唤醒被阻塞的线程。</p>
<p>一张图说明加锁和释放锁的过程：</p>
<p><img src="./README.assets/轻量级锁流程图.png" alt="轻量级锁流程图" loading="lazy"></p>
<h2 id="六、重量级锁"> 六、重量级锁</h2>
<p><mark>重量级锁依赖于操作系统的【互斥量（mutex）】实现的，而操作系统中线程间状态的转换需要相对比较长的时间，所以重量级锁效率很低，但被阻塞的线程不会消耗 CPU。</mark></p>
<p>前面说到，每一个对象都可以当做一个锁，当多个线程同时请求某个对象锁时，对象锁会设置几种状态用来区分请求的线程：</p>
<div><pre><code>Contention List：所有请求锁的线程将被首先放置到该竞争队列
Entry List：Contention List中那些有资格成为候选人的线程被移到Entry List
Wait Set：那些调用wait方法被阻塞的线程被放置到Wait Set
OnDeck：任何时刻最多只能有一个线程正在竞争锁，该线程称为OnDeck
Owner：获得锁的线程称为Owner
!Owner：释放锁的线程
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>当一个线程尝试获得锁时，如果该锁已经被占用，则会将该线程封装成一个 <code>ObjectWaiter</code> 对象插入到 Contention List 的队列的队首，然后调用 <code>park</code> 函数挂起当前线程。</p>
<p>当线程释放锁时，会从 Contention List 或 Entry List 中挑选一个线程唤醒，被选中的线程叫做 <code>Heir presumptive</code> 即假定继承人，假定继承人被唤醒后会尝试获得锁，但 <mark><code>synchronized</code>是非公平的，所以假定继承人不一定能获得锁</mark> 。这是因为对于重量级锁，线程先自旋尝试获得锁，这样做的目的是为了减少执行操作系统同步操作带来的开销。如果自旋不成功再进入等待队列。这对那些已经在等待队列中的线程来说，稍微显得不公平，还有一个不公平的地方是自旋线程可能会抢占了 Ready 线程的锁。</p>
<p>如果线程获得锁后调用 <code>Object.wait</code> 方法，则会将线程加入到 WaitSet 中，当被 <code>Object.notify</code> 唤醒后，会将线程从 WaitSet 移动到 Contention List 或 EntryList 中去。需要注意的是，<mark>当调用一个锁对象的<code>wait</code>或<code>notify</code>方法时，<strong>如当前锁的状态是偏向锁或轻量级锁则会先膨胀成重量级锁</strong>。</mark></p>
<h2 id="七、总结锁的升级流程"> 七、总结锁的升级流程</h2>
<p>每一个线程在准备获取共享资源时：</p>
<ol>
<li>
<p>检查 MarkWord 里面是不是放的自己的ThreadId，如果是，表示当前线程是处于 <mark>【偏向锁】</mark></p>
</li>
<li>
<p>如果 MarkWord 不是自己的 ThreadId，<strong>锁升级</strong>，这时候，用 CAS 来执行切换，新的线程根据 MarkWord 里面现有的 ThreadId，通知之前线程暂停，之前线程将 Markword 的内容置为空。</p>
</li>
<li>
<p>两个线程都把锁对象的 HashCode 复制到自己新建的用于存储锁的记录空间，接着开始通过 CAS 操作， 把锁对象的 MarKword 的内容修改为自己新建的记录空间的地址的方式竞争 MarkWord。成功执行 CAS 的获得资源，失败的则进入自旋 。</p>
</li>
<li>
<p>自旋的线程在自旋过程中，成功获得资源（即之前获的资源的线程执行完成并释放了共享资源），则整个状态依然处于 <mark>轻量级锁</mark> 的状态.</p>
</li>
<li>
<p>如果自旋失败，进入 <mark>重量级锁</mark> 的状态，这个时候，自旋的线程进行阻塞，等待之前线程执行完成并唤醒自己。</p>
</li>
</ol>
<h2 id="八、-各种锁的优缺点对比"> 八、 各种锁的优缺点对比</h2>
<p>下表来自《Java并发编程的艺术》：</p>
<table>
<thead>
<tr>
<th>锁</th>
<th>优点</th>
<th>缺点</th>
<th>适用场景</th>
</tr>
</thead>
<tbody>
<tr>
<td>偏向锁</td>
<td>加锁和解锁不需要额外的消耗，和执行非同步方法比仅存在纳秒级的差距。</td>
<td>如果线程间存在锁竞争，会带来额外的锁撤销的消耗。</td>
<td>适用于只有一个线程访问同步块场景。</td>
</tr>
<tr>
<td>轻量级锁</td>
<td>竞争的线程不会阻塞，提高了程序的响应速度。</td>
<td>如果始终得不到锁竞争的线程使用自旋会消耗CPU。</td>
<td>追求响应时间。同步块执行速度非常快。</td>
</tr>
<tr>
<td>重量级锁</td>
<td>线程竞争不使用自旋，不会消耗CPU。</td>
<td>线程阻塞，响应时间缓慢。</td>
<td>追求吞吐量。同步块执行时间较长。</td>
</tr>
</tbody>
</table>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十六章、CopyOnWrite容器</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/16/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/16/"/>
    <updated>2022-03-19T08:02:56.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/16.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十六章 - GitHub</a></li>
</ul>
</div>
<h2 id="什么是copyonwrite容器"> 什么是CopyOnWrite容器</h2>
<p>在说到 <code>CopyOnWrite</code> 容器之前我们先来谈谈什么是 <code>CopyOnWrite</code> 机制，CopyOnWrite是计算机设计领域中的一种优化策略，也是一种在并发场景下常用的设计思想——写入时复制思想。</p>
<div><p>写入时复制思想</p>
<p>就是当有多个调用者同时去请求一个资源数据的时候，有一个调用者出于某些原因需要对当前的数据源进行修改，这个时候系统将会复制一个当前数据源的副本给调用者修改。</p>
</div>
<p><code>CopyOnWrite</code> 容器即 <strong>写时复制的容器</strong> ，当我们往一个容器中添加元素的时候，不直接往容器中添加，而是将当前容器进行copy，复制出来一个新的容器，然后向新容器中添加我们需要的元素，最后将原容器的引用指向新容器。</p>
<p>这样做的好处在于， <mark>我们可以在并发的场景下对容器进行&quot;读操作&quot;而不需要&quot;加锁&quot;，从而达到读写分离的目的</mark> 。从JDK 1.5 开始Java并发包里提供了两个使用 <code>CopyOnWrite</code> 机制实现的并发容器 ，分别是 <code>CopyOnWriteArrayList</code> 和 <code>CopyOnWriteArraySet</code>  。</p>
<h2 id="copyonwritearraylist"> CopyOnWriteArrayList</h2>
<div><p>优点</p>
<p><code>CopyOnWriteArrayList</code> 经常被用于 “<strong>读多写少</strong>” 的并发场景，是因为 <code>CopyOnWriteArrayList</code> 无需任何同步措施，大大增强了读的性能。在Java中遍历线程非安全的 List (如：<code>ArrayList</code> 和 <code>LinkedList</code> )的时候，若中途有别的线程对 List 容器进行修改，那么会抛出 <code>ConcurrentModificationException</code> 异常。<code>CopyOnWriteArrayList</code> 由于其 &quot;<strong>读写分离</strong>&quot;，遍历和修改操作分别作用在不同的 List 容器，所以在使用迭代器遍历的时候，则不会抛出异常。</p>
</div>
<div><p>缺点</p>
<ul>
<li>
<p><code>CopyOnWriteArrayList</code> 每次执行写操作都会将原容器进行拷贝一份，数据量大的时候，内存会存在较大的压力，可能会引起频繁 <code>Full GC</code>（ZGC因为没有使用Full GC）</p>
</li>
<li>
<p><code>CopyOnWriteArrayList</code> 由于实现的原因，写和读分别作用在不同新老容器上，在写操作执行过程中，读不会阻塞， <strong>但读取到的却是老容器的数据</strong>。</p>
</li>
</ul>
</div>
<p>现在我们来看一下 <code>CopyOnWriteArrayList</code> 的 <code>add</code> 操作源码，它的逻辑很清晰，就是先把原容器进行copy，然后在新的副本上进行“写操作”，最后再切换引用，在此过程中是加了锁的。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>

    <span>// ReentrantLock加锁，保证线程安全</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>
        <span>// 拷贝原容器，长度为原容器长度加一</span>
        <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>// 在新副本上执行添加操作</span>
        newElements<span>[</span>len<span>]</span> <span>=</span> e<span>;</span>
        <span>// 将原容器引用指向新副本</span>
        <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>// 解锁</span>
        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><p>我们再来看一下 <code>remove</code> 操作的源码，<code>remove</code> 的逻辑是将要 <code>remove</code> 元素之外的其他元素拷贝到新的副本中，然后再将原容器的引用指向新的副本中，因为remove操作也是 “写操作” 所以也是要加锁的。</p>
<div><pre><code><span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>

    <span>// 加锁</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
        <span>Object</span><span>[</span><span>]</span> elements <span>=</span> <span>getArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> elements<span>.</span>length<span>;</span>
        <span>E</span> oldValue <span>=</span> <span>get</span><span>(</span>elements<span>,</span> index<span>)</span><span>;</span>
        <span>int</span> numMoved <span>=</span> len <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>==</span> <span>0</span><span>)</span>
            <span>// 如果要删除的是列表末端数据，拷贝前len-1个数据到新副本上，再切换引用</span>
            <span>setArray</span><span>(</span><span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elements<span>,</span> len <span>-</span> <span>1</span><span>)</span><span>)</span><span>;</span>
        <span>else</span> <span>{</span>
            <span>// 否则，将要删除元素之外的其他元素拷贝到新副本中，并切换引用</span>
            <span>Object</span><span>[</span><span>]</span> newElements <span>=</span> <span>new</span> <span>Object</span><span>[</span>len <span>-</span> <span>1</span><span>]</span><span>;</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elements<span>,</span> <span>0</span><span>,</span> newElements<span>,</span> <span>0</span><span>,</span> index<span>)</span><span>;</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elements<span>,</span> index <span>+</span> <span>1</span><span>,</span> newElements<span>,</span> index<span>,</span> numMoved<span>)</span><span>;</span>
            <span>setArray</span><span>(</span>newElements<span>)</span><span>;</span>
        <span>}</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span> <span>finally</span> <span>{</span>
        <span>// 解锁</span>
        lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>我们再来看看 <code>CopyOnWriteArrayList</code> 效率最高的读操作的源码</p>
<div><pre><code><span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>return</span> <span>get</span><span>(</span><span>getArray</span><span>(</span><span>)</span><span>,</span> index<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code> <span>private</span> <span>E</span> <span>get</span><span>(</span><span>Object</span><span>[</span><span>]</span> a<span>,</span> <span>int</span> index<span>)</span> <span>{</span>
     <span>return</span> <span>(</span><span>E</span><span>)</span> a<span>[</span>index<span>]</span><span>;</span>
 <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>由上可见“读操作”是没有加锁，直接读取。</p>
<h2 id="copyonwrite-的业务中实现"> CopyOnWrite 的业务中实现</h2>
<p>接下来，我们结合具体业务场景来实现一个 <code>CopyOnWriteMap</code> 的并发容器并且使用它。</p>
<div><pre><code><span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Collection</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Map</span></span><span>;</span>
<span>import</span> <span><span>java<span>.</span>util<span>.</span></span><span>Set</span></span><span>;</span>

<span>public</span> <span>class</span> <span>CopyOnWriteMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> <span>implements</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>,</span> <span>Cloneable</span> <span>{</span>
    <span>private</span> <span>volatile</span> <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> internalMap<span>;</span>

    <span>public</span> <span>CopyOnWriteMap</span><span>(</span><span>)</span> <span>{</span>
        internalMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>
            <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> newMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span>internalMap<span>)</span><span>;</span>
            <span>V</span> val <span>=</span> newMap<span>.</span><span>put</span><span>(</span>key<span>,</span> value<span>)</span><span>;</span>
            internalMap <span>=</span> newMap<span>;</span>
            <span>return</span> val<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>V</span> <span>get</span><span>(</span><span>Object</span> key<span>)</span> <span>{</span>
        <span>return</span> internalMap<span>.</span><span>get</span><span>(</span>key<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>putAll</span><span>(</span><span>Map</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>K</span><span>,</span> <span>?</span> <span>extends</span> <span>V</span><span>></span></span> newData<span>)</span> <span>{</span>
        <span>synchronized</span> <span>(</span><span>this</span><span>)</span> <span>{</span>
            <span>Map</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span> newMap <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>K</span><span>,</span> <span>V</span><span>></span></span><span>(</span>internalMap<span>)</span><span>;</span>
            newMap<span>.</span><span>putAll</span><span>(</span>newData<span>)</span><span>;</span>
            internalMap <span>=</span> newMap<span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><p>上面就是参考 <code>CopyOnWriteArrayList</code> 实现的 <code>CopyOnWriteMap</code> ，我们可以用这个容器来做什么呢？结合我们之前说的CopyOnWrite的复制思想，它最适用于“读多写少”的并发场景。</p>
<p>**场景：**假如我们有一个搜索的网站需要屏蔽一些 “关键字”，“黑名单” 每晚定时更新，每当用户搜索的时候，“黑名单” 中的关键字不会出现在搜索结果当中，并且提示用户敏感字。</p>
<div><pre><code><span>// 黑名单服务</span>
<span>public</span> <span>class</span> <span>BlackListServiceImpl</span> <span>{</span>
    <span>//　减少扩容开销。根据实际需要，初始化CopyOnWriteMap的大小，避免写时CopyOnWriteMap扩容的开销。</span>
    <span>private</span> <span>static</span> <span>CopyOnWriteMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Boolean</span><span>></span></span> blackListMap <span>=</span> 
        <span>new</span> <span>CopyOnWriteMap</span><span><span>&lt;</span><span>String</span><span>,</span> <span>Boolean</span><span>></span></span><span>(</span><span>1000</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>boolean</span> <span>isBlackList</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>
        <span>return</span> blackListMap<span>.</span><span>get</span><span>(</span>id<span>)</span> <span>==</span> <span>null</span> <span>?</span> <span>false</span> <span>:</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>addBlackList</span><span>(</span><span>String</span> id<span>)</span> <span>{</span>
        blackListMap<span>.</span><span>put</span><span>(</span>id<span>,</span> <span>Boolean</span><span>.</span>TRUE<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 批量添加黑名单
     * (使用批量添加。因为每次添加，容器每次都会进行复制，所以减少添加次数，可以减少容器的复制次数。
     * 如使用上面代码里的addBlackList方法)
     * @param ids
     */</span>
    <span>public</span> <span>static</span> <span>void</span> <span>addBlackList</span><span>(</span><span>Map</span><span><span>&lt;</span><span>String</span><span>,</span><span>Boolean</span><span>></span></span> ids<span>)</span> <span>{</span>
        blackListMap<span>.</span><span>putAll</span><span>(</span>ids<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p>这里需要各位小伙伴特别特别注意一个问题，此处的场景是每晚凌晨 “黑名单” 定时更新，原因是 <code>CopyOnWrite</code> 容器有 <strong>数据一致性</strong> 的问题，它只能保证 <strong>最终数据一致性</strong>。</p>
<p><mark>所以如果我们希望写入的数据马上能准确地读取，请不要使用 <code>CopyOnWrite</code> 容器</mark></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T08:02:56.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十八章、Fork/Join框架</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/18/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/18/"/>
    <updated>2022-03-19T11:12:10.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/18.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十八章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、什么是fork-join"> 一、什么是Fork/Join</h2>
<p><code>Fork/Join</code> 框架是一个实现了 <code>ExecutorService</code> 接口的多线程处理器，它专为那些可以通过递归分解成更细小的任务而设计，最大化的利用多核处理器来提高应用程序的性能。</p>
<p>与其他 <code>ExecutorService</code> 相关的实现相同的是，<code>Fork/Join</code> 框架会将任务分配给线程池中的线程。而与之不同的是，<code>Fork/Join</code> 框架在执行任务时使用了 <strong>工作窃取算法</strong>。</p>
<p><strong>fork</strong> 在英文里有分叉的意思，<strong>join</strong> 在英文里连接、结合的意思。顾名思义，fork 就是要使一个大任务分解成若干个小任务，而 join 就是最后将各个小任务的结果结合起来得到大任务的结果。</p>
<p>Fork/Join 的运行流程大致如下所示：</p>
<p><img src="./README.assets/fork_join流程图-16476869316743.png" alt="fork_join流程图" loading="lazy"></p>
<p>需要注意的是，图里的次级子任务可以一直分下去，一直分到子任务足够小为止。用伪代码来表示如下：</p>
<div><pre><code>solve(任务):
    if(任务已经划分到足够小):
        顺序执行任务
    else:
    	for(划分任务得到子任务)
    		solve(子任务)
    	结合所有子任务的结果到上一层循环
    	return 最终结合的结果
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>通过上面伪代码可以看出，我们通过递归嵌套的计算得到最终结果，这里有体现 <strong>分而治之(divide and conquer)</strong> 的算法思想。</p>
<h2 id="二、工作窃取算法"> 二、工作窃取算法</h2>
<div><p>工作窃取算法</p>
<p>指的是在多线程执行不同任务队列的过程中，某个线程执行完自己队列的任务后从其他线程的任务队列里窃取任务来执行。</p>
</div>
<p>工作窃取流程如下图所示：</p>
<p><img src="./README.assets/工作窃取算法运行流程图-16476869525444.png" alt="工作窃取算法运行流程图" loading="lazy"></p>
<p>值得注意的是，当一个线程窃取另一个线程的时候，为了减少两个任务线程之间的竞争，我们通常使用 <strong>双端队列</strong> 来存储任务。被窃取的任务线程都从双端队列的 <strong>头部</strong> 拿任务执行，而窃取其他任务的线程从双端队列的 <strong>尾部</strong> 执行任务。</p>
<p>另外，当一个线程在窃取任务时要是没有其他可用的任务了，这个线程会进入 <strong>阻塞状态</strong> 以等待再次“工作”。</p>
<h2 id="三、fork-join的具体实现"> 三、Fork/Join的具体实现</h2>
<p>前面我们说 <code>Fork/Join</code> 框架简单来讲就是对任务的分割与子任务的合并，所以要实现这个框架，先得有 <strong>任务</strong>。在 <code>Fork/Join</code> 框架里提供了抽象类 <code>ForkJoinTask</code> 来实现任务。</p>
<h3 id="_3-1-forkjointask"> 3.1 ForkJoinTask</h3>
<p>ForkJoinTask是一个类似普通线程的实体，但是比普通线程轻量得多。</p>
<p><strong>fork()方法</strong> ：使用线程池中的空闲线程异步提交任务</p>
<div><pre><code><span>// 本文所有代码都引自Java 8</span>
<span>public</span> <span>final</span> <span>ForkJoinTask</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>fork</span><span>(</span><span>)</span> <span>{</span>
    <span>Thread</span> t<span>;</span>
    <span>// ForkJoinWorkerThread是执行ForkJoinTask的专有线程，由ForkJoinPool管理</span>
    <span>// 先判断当前线程是否是ForkJoin专有线程，如果是，则将任务push到当前线程所负责的队列里去</span>
    <span>if</span> <span>(</span><span>(</span>t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span> <span>instanceof</span> <span>ForkJoinWorkerThread</span><span>)</span>
        <span>(</span><span>(</span><span>ForkJoinWorkerThread</span><span>)</span>t<span>)</span><span>.</span>workQueue<span>.</span><span>push</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>else</span>
     	<span>// 如果不是则将线程加入队列</span>
        <span>// 没有显式创建ForkJoinPool的时候走这里，提交任务到默认的common线程池中</span>
        <span>ForkJoinPool</span><span>.</span>common<span>.</span><span>externalPush</span><span>(</span><span>this</span><span>)</span><span>;</span>
    <span>return</span> <span>this</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>其实 fork() 只做了一件事，那就是 <strong>把任务推入当前工作线程的工作队列里</strong>。</p>
<p><strong>join()方法</strong> ：等待处理任务的线程处理完毕，获得返回值。</p>
<p>来看下join()的源码：</p>
<div><pre><code><span>public</span> <span>final</span> <span>V</span> <span>join</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> s<span>;</span>
    <span>// doJoin()方法来获取当前任务的执行状态</span>
    <span>if</span> <span>(</span><span>(</span>s <span>=</span> <span>doJoin</span><span>(</span><span>)</span> <span>&amp;</span> DONE_MASK<span>)</span> <span>!=</span> NORMAL<span>)</span>
        <span>// 任务异常，抛出异常</span>
        <span>reportException</span><span>(</span>s<span>)</span><span>;</span>
    <span>// 任务正常完成，获取返回值</span>
    <span>return</span> <span>getRawResult</span><span>(</span><span>)</span><span>;</span>
<span>}</span>

<span>/**
 * doJoin()方法用来返回当前任务的执行状态
 **/</span>
<span>private</span> <span>int</span> <span>doJoin</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> s<span>;</span> <span>Thread</span> t<span>;</span> <span>ForkJoinWorkerThread</span> wt<span>;</span> <span>ForkJoinPool<span>.</span>WorkQueue</span> w<span>;</span>
    <span>// 先判断任务是否执行完毕，执行完毕直接返回结果（执行状态）</span>
    <span>return</span> <span>(</span>s <span>=</span> status<span>)</span> <span>&lt;</span> <span>0</span> <span>?</span> s <span>:</span>
    <span>// 如果没有执行完毕，先判断是否是ForkJoinWorkThread线程</span>
    <span>(</span><span>(</span>t <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>)</span> <span>instanceof</span> <span>ForkJoinWorkerThread</span><span>)</span> <span>?</span>
        <span>// 如果是，先判断任务是否处于工作队列顶端（意味着下一个就执行它）</span>
        <span>// tryUnpush()方法判断任务是否处于当前工作队列顶端，是返回true</span>
        <span>// doExec()方法执行任务</span>
        <span>(</span>w <span>=</span> <span>(</span>wt <span>=</span> <span>(</span><span>ForkJoinWorkerThread</span><span>)</span>t<span>)</span><span>.</span>workQueue<span>)</span><span>.</span>
        <span>// 如果是处于顶端并且任务执行完毕，返回结果</span>
        <span>tryUnpush</span><span>(</span><span>this</span><span>)</span> <span>&amp;&amp;</span> <span>(</span>s <span>=</span> <span>doExec</span><span>(</span><span>)</span><span>)</span> <span>&lt;</span> <span>0</span> <span>?</span> s <span>:</span>
        <span>// 如果不在顶端或者在顶端却没未执行完毕，那就调用awitJoin()执行任务</span>
        <span>// awaitJoin()：使用自旋使任务执行完成，返回结果</span>
        wt<span>.</span>pool<span>.</span><span>awaitJoin</span><span>(</span>w<span>,</span> <span>this</span><span>,</span> <span>0L</span><span>)</span> <span>:</span>
    <span>// 如果不是ForkJoinWorkThread线程，执行externalAwaitDone()返回任务结果</span>
    <span>externalAwaitDone</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>我们在之前介绍过说 <code>Thread.join()</code> 会使线程阻塞，而 <code>ForkJoinPool.join()</code> 会使线程免于阻塞，下面是<code>ForkJoinPool.join()</code> 的流程图：</p>
<p><img src="./README.assets/join流程图-16476869995945.png" alt="join流程图" loading="lazy"></p>
<h4 id="recursiveaction和recursivetask"> <strong>RecursiveAction和RecursiveTask</strong></h4>
<p>通常情况下，在创建任务的时候我们一般不直接继承 <code>ForkJoinTask</code> ，而是继承它的子类 <code>RecursiveAction</code> 和 <code>RecursiveTask</code> 。</p>
<p>两个都是 <code>ForkJoinTask</code> 的子类，<strong>RecursiveAction可以看做是无返回值的ForkJoinTask，RecursiveTask是有返回值的ForkJoinTask</strong>。</p>
<p>此外，两个子类都有执行主要计算的方法 <code>compute()</code> ，当然，<code>RecursiveAction</code> 的 <code>compute()</code> 返回 void，<code>RecursiveTask</code> 的 <code>compute()</code> 有具体的返回值。</p>
<h3 id="_3-2-forkjoinpool"> 3.2 ForkJoinPool</h3>
<p><code>ForkJoinPool</code> 是用于执行 <code>ForkJoinTask</code> 任务的执行（线程）池。</p>
<p><code>ForkJoinPool</code> 管理着执行池中的线程和任务队列，此外，执行池是否还接受任务，显示线程的运行状态也是在这里处理。</p>
<p>我们来大致看下 <code>ForkJoinPool</code> 的源码：</p>
<div><pre><code><span>@sun.misc.Contended</span>
<span>public</span> <span>class</span> <span>ForkJoinPool</span> <span>extends</span> <span>AbstractExecutorService</span> <span>{</span>
    <span>// 任务队列</span>
    <span>volatile</span> <span>WorkQueue</span><span>[</span><span>]</span> workQueues<span>;</span>   
    
    <span>// 线程的运行状态</span>
    <span>volatile</span> <span>int</span> runState<span>;</span>  
    
    <span>// 创建ForkJoinWorkerThread的默认工厂，可以通过构造函数重写</span>
    <span>public</span> <span>static</span> <span>final</span> <span>ForkJoinWorkerThreadFactory</span> defaultForkJoinWorkerThreadFactory<span>;</span>
	
	<span>// 公用的线程池，其运行状态不受shutdown()和shutdownNow()的影响</span>
    <span>static</span> <span>final</span> <span>ForkJoinPool</span> common<span>;</span>
    
    <span>// 私有构造方法，没有任何安全检查和参数校验，由makeCommonPool直接调用</span>
    <span>// 其他构造方法都是源自于此方法</span>
    <span>// parallelism: 并行度，</span>
    <span>// 默认调用java.lang.Runtime.availableProcessors() 方法返回可用处理器的数量</span>
    <span>private</span> <span>ForkJoinPool</span><span>(</span><span>int</span> parallelism<span>,</span>
                         <span>ForkJoinWorkerThreadFactory</span> factory<span>,</span> <span>// 工作线程工厂</span>
                         <span>UncaughtExceptionHandler</span> handler<span>,</span> <span>// 拒绝任务的handler</span>
                         <span>int</span> mode<span>,</span> <span>// 同步模式</span>
                         <span>String</span> workerNamePrefix<span>)</span> <span>{</span> <span>// 线程名prefix</span>
        <span>this</span><span>.</span>workerNamePrefix <span>=</span> workerNamePrefix<span>;</span>
        <span>this</span><span>.</span>factory <span>=</span> factory<span>;</span>
        <span>this</span><span>.</span>ueh <span>=</span> handler<span>;</span>
        <span>this</span><span>.</span>config <span>=</span> <span>(</span>parallelism <span>&amp;</span> SMASK<span>)</span> <span>|</span> mode<span>;</span>
        <span>long</span> np <span>=</span> <span>(</span><span>long</span><span>)</span><span>(</span><span>-</span>parallelism<span>)</span><span>;</span> <span>// offset ctl counts</span>
        <span>this</span><span>.</span>ctl <span>=</span> <span>(</span><span>(</span>np <span>&lt;&lt;</span> AC_SHIFT<span>)</span> <span>&amp;</span> AC_MASK<span>)</span> <span>|</span> <span>(</span><span>(</span>np <span>&lt;&lt;</span> TC_SHIFT<span>)</span> <span>&amp;</span> TC_MASK<span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h4 id="workqueue"> WorkQueue</h4>
<p>双端队列，<code>ForkJoinTask</code> 存放在这里。</p>
<p>当工作线程在处理自己的工作队列时，会从队列首取任务来执行（FIFO）；如果是窃取其他队列的任务时，窃取的任务位于所属任务队列的队尾（LIFO）。</p>
<p><code>ForkJoinPool</code> 与传统线程池最显著的区别就是它维护了一个 <strong>工作队列数组</strong>（<code>volatile WorkQueue[] workQueues</code> ，<code>ForkJoinPool</code> 中的 <strong>每个工作线程都维护着一个工作队列</strong>）。</p>
<h4 id="runstate"> runState</h4>
<p><code>ForkJoinPool</code> 的运行状态。<strong>SHUTDOWN</strong>状态用负数表示，其他用2的幂次表示。</p>
<h2 id="四、fork-join的使用"> 四、Fork/Join的使用</h2>
<p>上面我们说 <code>ForkJoinPool</code> 负责管理线程和任务，<code>ForkJoinTask</code> 实现 fork 和 join 操作，所以要使用 <code>Fork/Join</code> 框架就离不开这两个类了，只是在实际开发中我们常用 <code>ForkJoinTask</code> 的子类 <code>RecursiveTask</code> 和 <code>RecursiveAction</code> 来替代 <code>ForkJoinTask</code>。</p>
<p>下面我们用一个计算斐波那契数列第n项的例子来看一下 <code>Fork/Join</code> 的使用：</p>
<blockquote>
<p>斐波那契数列数列是一个线性递推数列，从第三项开始，每一项的值都等于前两项之和：</p>
<p>1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89······</p>
<p>如果设f(n）为该数列的第n项（n∈N*），那么有：f(n) = f(n-1) + f(n-2)。</p>
</blockquote>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>FibonacciTest</span> <span>{</span>

    <span>class</span> <span>Fibonacci</span> <span>extends</span> <span>RecursiveTask</span><span><span>&lt;</span><span>Integer</span><span>></span></span> <span>{</span>

        <span>int</span> n<span>;</span>

        <span>public</span> <span>Fibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
            <span>this</span><span>.</span>n <span>=</span> n<span>;</span>
        <span>}</span>

        <span>// 主要的实现逻辑都在compute()里</span>
        <span>@Override</span>
        <span>protected</span> <span>Integer</span> <span>compute</span><span>(</span><span>)</span> <span>{</span>
            <span>// 这里先假设 n >= 0</span>
            <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
                <span>return</span> n<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// f(n-1)</span>
                <span>Fibonacci</span> f1 <span>=</span> <span>new</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>1</span><span>)</span><span>;</span>
                f1<span>.</span><span>fork</span><span>(</span><span>)</span><span>;</span>
                <span>// f(n-2)</span>
                <span>Fibonacci</span> f2 <span>=</span> <span>new</span> <span>Fibonacci</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
                f2<span>.</span><span>fork</span><span>(</span><span>)</span><span>;</span>
                <span>// f(n) = f(n-1) + f(n-2)</span>
                <span>return</span> f1<span>.</span><span>join</span><span>(</span><span>)</span> <span>+</span> f2<span>.</span><span>join</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>@Test</span>
    <span>public</span> <span>void</span> <span>testFib</span><span>(</span><span>)</span> <span>throws</span> <span>ExecutionException</span><span>,</span> <span>InterruptedException</span> <span>{</span>
        <span>ForkJoinPool</span> forkJoinPool <span>=</span> <span>new</span> <span>ForkJoinPool</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"CPU核数："</span> <span>+</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>Fibonacci</span> fibonacci <span>=</span> <span>new</span> <span>Fibonacci</span><span>(</span><span>40</span><span>)</span><span>;</span>
        <span>Future</span><span><span>&lt;</span><span>Integer</span><span>></span></span> future <span>=</span> forkJoinPool<span>.</span><span>submit</span><span>(</span>fibonacci<span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>future<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"耗时：%d millis"</span><span>,</span> end <span>-</span> start<span>)</span><span>)</span><span>;</span>
    <span>}</span>


<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p>上面例子在本机的输出：</p>
<div><pre><code>CPU核数：4
计算结果：102334155
耗时：9490 millis
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>需要注意的是，上述计算时间复杂度为 <code>O(2^n)</code>，随着n的增长计算效率会越来越低，这也是上面的例子中n不敢取太大的原因。</p>
<p>此外，也并不是所有的任务都适合 <code>Fork/Join</code> 框架，比如上面的例子任务划分过于细小反而体现不出效率，下面我们试试用普通的递归来求f(n)的值，看看是不是要比使用 <code>Fork/Join</code> 快：</p>
<div><pre><code><span>// 普通递归，复杂度为O(2^n)</span>
<span>public</span> <span>int</span> <span>plainRecursion</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>n <span>==</span> <span>1</span> <span>||</span> n <span>==</span> <span>2</span><span>)</span> <span>{</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>return</span> <span>plainRecursion</span><span>(</span>n <span>-</span><span>1</span><span>)</span> <span>+</span> <span>plainRecursion</span><span>(</span>n <span>-</span> <span>2</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>

<span>@Test</span>
<span>public</span> <span>void</span> <span>testPlain</span><span>(</span><span>)</span> <span>{</span>
    <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> result <span>=</span> <span>plainRecursion</span><span>(</span><span>40</span><span>)</span><span>;</span>
    <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"计算结果:"</span> <span>+</span> result<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"耗时：%d millis"</span><span>,</span>  end <span>-</span>start<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>普通递归的例子输出：</p>
<div><pre><code>计算结果:102334155
耗时：436 millis
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>通过输出可以很明显的看出来，使用普通递归的效率都要比使用 <code>Fork/Join</code> 框架要高很多。</p>
<p>这里我们再用另一种思路来计算：</p>
<div><pre><code><span>// 通过循环来计算，复杂度为O(n)</span>
<span>private</span> <span>int</span> <span>computeFibonacci</span><span>(</span><span>int</span> n<span>)</span> <span>{</span>
    <span>// 假设n >= 0</span>
    <span>if</span> <span>(</span>n <span>&lt;=</span> <span>1</span><span>)</span> <span>{</span>
        <span>return</span> n<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>int</span> first <span>=</span> <span>1</span><span>;</span>
        <span>int</span> second <span>=</span> <span>1</span><span>;</span>
        <span>int</span> third <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>3</span><span>;</span> i <span>&lt;=</span> n<span>;</span> i <span>++</span><span>)</span> <span>{</span>
            <span>// 第三个数是前两个数之和</span>
            third <span>=</span> first <span>+</span> second<span>;</span>
            <span>// 前两个数右移</span>
            first <span>=</span> second<span>;</span>
            second <span>=</span> third<span>;</span>
        <span>}</span>
        <span>return</span> third<span>;</span>
    <span>}</span>
<span>}</span>

<span>@Test</span>
<span>public</span> <span>void</span> <span>testComputeFibonacci</span><span>(</span><span>)</span> <span>{</span>
    <span>long</span> start <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> result <span>=</span> <span>computeFibonacci</span><span>(</span><span>40</span><span>)</span><span>;</span>
    <span>long</span> end <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"计算结果:"</span> <span>+</span> result<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"耗时：%d millis"</span><span>,</span>  end <span>-</span>start<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p>上面例子在笔者所用电脑的输出为：</p>
<div><pre><code>计算结果:102334155
耗时：0 millis
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>这里耗时为0不代表没有耗时，是表明这里计算的耗时几乎可以忽略不计，大家可以在自己的电脑试试，即使是n取大很多量级的数据（注意int溢出的问题）耗时也是很短的，或者可以用 <code>System.nanoTime()</code> 统计纳秒的时间。</p>
<p>为什么在这里普通的递归或循环效率更快呢？因为 <code>Fork/Join</code> 是使用多个线程协作来计算的，所以会有线程通信和线程切换的开销。</p>
<p>如果要计算的任务比较简单（比如我们案例中的斐波那契数列），那当然是直接使用单线程会更快一些。但如果要计算的东西比较复杂，计算机又是多核的情况下，就可以充分利用多核CPU来提高计算速度。</p>
<p>另外，Java 8 Stream的并行操作底层就是用到了Fork/Join框架，下一章我们将从源码及案例两方面介绍Java 8 Stream的并行操作。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T11:12:10.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十九章、Stream并行计算原理（不懂）</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/19/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/19/"/>
    <updated>2022-03-19T13:17:08.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/19.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十九章 - GitHub</a></li>
</ul>
</div>
<h2 id="一、java-8-stream简介"> 一、Java 8 Stream简介</h2>
<p>从Java 8 开始，我们可以使用 <code>Stream</code> 接口以及 <strong>lambda表达式</strong> 进行 “流式计算” 。它可以让我们对集合的操作更加简洁、更加可读、更加高效。</p>
<p>Stream接口有非常多用于集合计算的方法，比如判空操作empty、过滤操作filter、求最max值、查找操作findFirst和findAny等等。</p>
<h2 id="二、stream单线程串行计算"> 二、Stream单线程串行计算</h2>
<p>Stream接口默认是使用串行的方式，也就是说在一个线程里执行。下面举一个例子：</p>
<div><pre><code><span>public</span> <span>class</span> <span>StreamDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Stream</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>
                <span>String</span><span>.</span><span>format</span><span>(</span><span>"%s: %d + %d = %d"</span><span>,</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> a<span>,</span> b<span>,</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>
            <span>return</span> a <span>+</span> b<span>;</span>
        <span>}</span><span>)</span><span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>我们来理解一下这个方法。首先我们用整数1~9创建了一个 <code>Stream</code> 。这里的 <code>Stream.of(T... values)</code> 方法是 Stream 接口的一个静态方法，其底层调用的是 <code>Arrays.stream(T[] array)</code> 方法。</p>
<p>然后我们使用了 <code>reduce</code> 方法来计算这个集合的累加和。<code>reduce</code>方法这里做的是：从前两个元素开始，进行某种操作（我这里进行的是加法操作）后，返回一个结果，然后再拿这个结果跟第三个元素执行同样的操作，以此类推，直到最后的一个元素。</p>
<p>我们来打印一下当前这个reduce操作的线程以及它们被操作的元素和返回的结果以及最后所有reduce方法的结果，也就代表的是数字1到9的累加和。</p>
<blockquote>
<p>main: 1 + 2 = 3</p>
<p>main: 3 + 3 = 6</p>
<p>main: 6 + 4 = 10</p>
<p>main: 10 + 5 = 15</p>
<p>main: 15 + 6 = 21</p>
<p>main: 21 + 7 = 28</p>
<p>main: 28 + 8 = 36</p>
<p>main: 36 + 9 = 45</p>
<p>45</p>
</blockquote>
<p>可以看到，默认情况下，它是在一个单线程运行的，也就是 <strong>main</strong> 线程。然后每次reduce操作都是串行起来的，首先计算前两个数字的和，然后再往后依次计算。</p>
<h2 id="三、stream多线程并行计算"> 三、Stream多线程并行计算</h2>
<p>我们思考上面一个例子，是不是一定要在单线程里进行串行地计算呢？假如我的计算机是一个多核计算机，我们在理论上能否利用多核来进行并行计算，提高计算效率呢？</p>
<p>当然可以，比如我们在计算前两个元素1 + 2 = 3的时候，其实我们也可以同时在另一个核计算 3 + 4 = 7。然后等它们都计算完成之后，再计算 3 + 7 = 10的操作。</p>
<p>是不是很熟悉这样的操作手法？没错，它就是ForkJoin框架的思想。下面小小地修改一下上面的代码，增加一行代码，使Stream使用多线程来并行计算：</p>
<div><pre><code><span>public</span> <span>class</span> <span>StreamParallelDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Stream</span><span>.</span><span>of</span><span>(</span><span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span><span>,</span> <span>6</span><span>,</span> <span>7</span><span>,</span> <span>8</span><span>,</span> <span>9</span><span>)</span>
            <span>.</span><span>parallel</span><span>(</span><span>)</span>
            <span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>
                    <span>String</span><span>.</span><span>format</span><span>(</span><span>"%s: %d + %d = %d"</span><span>,</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>.</span><span>getName</span><span>(</span><span>)</span><span>,</span> a<span>,</span> b<span>,</span> a <span>+</span> b<span>)</span><span>)</span><span>;</span>
                <span>return</span> a <span>+</span> b<span>;</span>
            <span>}</span><span>)</span>
            <span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>可以看到，与上一个案例的代码只有一点点区别，就是在reduce方法被调用之前，调用了 <code>parallel()</code> 方法。下面来看看这个方法的输出：</p>
<blockquote>
<p>ForkJoinPool.commonPool-worker-1: 3 + 4 = 7</p>
<p>ForkJoinPool.commonPool-worker-4: 8 + 9 = 17</p>
<p>ForkJoinPool.commonPool-worker-2: 5 + 6 = 11</p>
<p>ForkJoinPool.commonPool-worker-3: 1 + 2 = 3</p>
<p>ForkJoinPool.commonPool-worker-4: 7 + 17 = 24</p>
<p>ForkJoinPool.commonPool-worker-4: 11 + 24 = 35</p>
<p>ForkJoinPool.commonPool-worker-3: 3 + 7 = 10</p>
<p>ForkJoinPool.commonPool-worker-3: 10 + 35 = 45</p>
<p>45</p>
</blockquote>
<p>可以很明显地看到，它使用的线程是 <code>ForkJoinPool</code> 里面的 <code>commonPool</code> 里面的 <strong>worker</strong> 线程。并且它们是并行计算的，并不是串行计算的。但由于Fork/Join框架的作用，它最终能很好的协调计算结果，使得计算结果完全正确。</p>
<p>如果我们用 <code>Fork/Join</code> 代码去实现这样一个功能，那无疑是非常复杂的。但Java8提供了并行式的流式计算，大大简化了我们的代码量，使得我们只需要写很少很简单的代码就可以利用计算机底层的多核资源。</p>
<h2 id="四、从源码看stream并行计算原理"> 四、从源码看Stream并行计算原理</h2>
<p>上面我们通过在控制台输出线程的名字，看到了Stream的并行计算底层其实是使用的 <code>Fork/Join</code> 框架。那它到底是在哪使用 <code>Fork/Join</code> 的呢？我们从源码上来解析一下上述案例。</p>
<p><code>Stream.of</code> 方法就不说了，它只是生成一个简单的 Stream。先来看看 <code>parallel()</code> 方法的源码。这里由于我的数据是 <code>int</code> 类型的，所以它其实是使用的 <code>BaseStream</code> 接口的 <code>parallel()</code> 方法。而 <code>BaseStream</code> 接口的JDK唯一实现类是一个叫 <code>AbstractPipeline</code> 的类。下面我们来看看这个类的<code>parallel()</code> 方法的代码：</p>
<div><pre><code><span>public</span> <span>final</span> <span>S</span> <span>parallel</span><span>(</span><span>)</span> <span>{</span>
    sourceStage<span>.</span>parallel <span>=</span> <span>true</span><span>;</span>
    <span>return</span> <span>(</span><span>S</span><span>)</span> <span>this</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>这个方法很简单，就是把一个标识 <code>sourceStage.parallel</code> 设置为 <code>true</code>。然后返回实例本身。</p>
<p>接着我们再来看 <code>reduce</code> 这个方法的内部实现。</p>
<p><code>Stream.reduce()</code> 方法的具体实现是交给了 <code>ReferencePipeline</code> 这个抽象类，它是继承了 <code>AbstractPipeline</code> 这个类的:</p>
<div><pre><code><span>// ReferencePipeline抽象类的reduce方法</span>
<span>@Override</span>
<span>public</span> <span>final</span> <span>Optional</span><span><span>&lt;</span>P_OUT<span>></span></span> <span>reduce</span><span>(</span><span>BinaryOperator</span><span><span>&lt;</span>P_OUT<span>></span></span> accumulator<span>)</span> <span>{</span>
    <span>// 调用evaluate方法</span>
    <span>return</span> <span>evaluate</span><span>(</span><span>ReduceOps</span><span>.</span><span>makeRef</span><span>(</span>accumulator<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>final</span> <span><span>&lt;</span><span>R</span><span>></span></span> <span>R</span> <span>evaluate</span><span>(</span><span>TerminalOp</span><span><span>&lt;</span>E_OUT<span>,</span> <span>R</span><span>></span></span> terminalOp<span>)</span> <span>{</span>
    <span>assert</span> <span>getOutputShape</span><span>(</span><span>)</span> <span>==</span> terminalOp<span>.</span><span>inputShape</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>linkedOrConsumed<span>)</span>
        <span>throw</span> <span>new</span> <span>IllegalStateException</span><span>(</span>MSG_STREAM_LINKED<span>)</span><span>;</span>
    linkedOrConsumed <span>=</span> <span>true</span><span>;</span>

    <span>return</span> <span>isParallel</span><span>(</span><span>)</span> <span>// 调用isParallel()判断是否使用并行模式</span>
        <span>?</span> terminalOp<span>.</span><span>evaluateParallel</span><span>(</span><span>this</span><span>,</span> <span>sourceSpliterator</span><span>(</span>terminalOp<span>.</span><span>getOpFlags</span><span>(</span><span>)</span><span>)</span><span>)</span>
        <span>:</span> terminalOp<span>.</span><span>evaluateSequential</span><span>(</span><span>this</span><span>,</span> <span>sourceSpliterator</span><span>(</span>terminalOp<span>.</span><span>getOpFlags</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>@Override</span>
<span>public</span> <span>final</span> <span>boolean</span> <span>isParallel</span><span>(</span><span>)</span> <span>{</span>
    <span>// 根据之前在parallel()方法设置的那个flag来判断。</span>
    <span>return</span> sourceStage<span>.</span>parallel<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br></div></div><p>从它的源码可以知道，reduce方法调用了 <code>evaluate</code> 方法，而 <code>evaluate</code> 方法会先去检查当前的flag，是否使用并行模式，如果是则会调用 <code>evaluateParallel</code> 方法执行并行计算，否则，会调用 <code>evaluateSequential</code> 方法执行串行计算。</p>
<p>这里我们再看看 <code>TerminalOp</code>（注意这里是字母l O，而不是数字1 0）接口的 <code>evaluateParallel</code> 方法。<code>TerminalOp</code> 接口的实现类有这样几个内部类：</p>
<ul>
<li>java.util.stream.FindOps.FindOp</li>
<li>java.util.stream.ForEachOps.ForEachOp</li>
<li>java.util.stream.MatchOps.MatchOp</li>
<li>java.util.stream.ReduceOps.ReduceOp</li>
</ul>
<p>可以看到，对应的是Stream的几种主要的计算操作。我们这里的示例代码使用的是reduce计算，那我们就看看ReduceOp类的这个方法的源码：</p>
<div><pre><code><span>// java.util.stream.ReduceOps.ReduceOp.evaluateParallel</span>
<span>@Override</span>
<span>public</span> <span><span>&lt;</span>P_IN<span>></span></span> <span>R</span> <span>evaluateParallel</span><span>(</span><span>PipelineHelper</span><span><span>&lt;</span><span>T</span><span>></span></span> helper<span>,</span>
                                 <span>Spliterator</span><span><span>&lt;</span>P_IN<span>></span></span> spliterator<span>)</span> <span>{</span>
    <span>return</span> <span>new</span> <span>ReduceTask</span><span><span>&lt;</span><span>></span></span><span>(</span><span>this</span><span>,</span> helper<span>,</span> spliterator<span>)</span><span>.</span><span>invoke</span><span>(</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>evaluateParallel方法创建了一个新的ReduceTask实例，并且调用了invoke()方法后再调用get()方法，然后返回这个结果。那这个ReduceTask是什么呢？它的invoke方法内部又是什么呢？</p>
<p>追溯源码我们可以发现，ReduceTask类是ReduceOps类的一个内部类，它继承了AbstractTask类，而AbstractTask类又继承了CountedCompleter类，而CountedCompleter类又继承了ForkJoinTask类！</p>
<p>它们的继承关系如下：</p>
<blockquote>
<p>ReduceTask -&gt; AbstractTask -&gt; CountedCompleter -&gt; ForkJoinTask</p>
</blockquote>
<p>这里的ReduceTask的invoke方法，其实是调用的ForkJoinTask的invoke方法，中间三层继承并没有覆盖这个方法的实现。</p>
<p>所以这就从源码层面解释了Stream并行的底层原理是使用了Fork/Join框架。</p>
<p>需要注意的是，一个Java进程的Stream并行计算任务默认共享同一个线程池，如果随意的使用并行特性可能会导致方法的吞吐量下降。我们可以通过下面这种方式来让你的某个并行Stream使用自定义的ForkJoin线程池：</p>
<div><pre><code><span>ForkJoinPool</span> customThreadPool <span>=</span> <span>new</span> <span>ForkJoinPool</span><span>(</span><span>4</span><span>)</span><span>;</span>
<span>long</span> actualTotal <span>=</span> customThreadPool
  <span>.</span><span>submit</span><span>(</span><span>(</span><span>)</span> <span>-></span> roster<span>.</span><span>parallelStream</span><span>(</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>0</span><span>,</span> <span>Integer</span><span>::</span><span>sum</span><span>)</span><span>)</span><span>.</span><span>get</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="五、stream并行计算的性能提升"> 五、Stream并行计算的性能提升</h2>
<p>我们可以在本地测试一下如果在多核情况下，Stream并行计算会给我们的程序带来多大的效率上的提升。用以下示例代码来计算一千万个随机数的和：</p>
<div><pre><code><span>public</span> <span>class</span> <span>StreamParallelDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"本计算机的核数：%d"</span><span>,</span> <span>Runtime</span><span>.</span><span>getRuntime</span><span>(</span><span>)</span><span>.</span><span>availableProcessors</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>

        <span>// 产生100w个随机数(1 ~ 100)，组成列表</span>
        <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
        <span>List</span><span><span>&lt;</span><span>Integer</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>></span></span><span>(</span><span>1000_0000</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>1000_0000</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>100</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>

        <span>long</span> prevTime <span>=</span> <span>getCurrentTime</span><span>(</span><span>)</span><span>;</span>
        list<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> a <span>+</span> b<span>)</span><span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"单线程计算耗时：%d"</span><span>,</span> <span>getCurrentTime</span><span>(</span><span>)</span> <span>-</span> prevTime<span>)</span><span>)</span><span>;</span>

        prevTime <span>=</span> <span>getCurrentTime</span><span>(</span><span>)</span><span>;</span>
        list<span>.</span><span>stream</span><span>(</span><span>)</span><span>.</span><span>parallel</span><span>(</span><span>)</span><span>.</span><span>reduce</span><span>(</span><span>(</span>a<span>,</span> b<span>)</span> <span>-></span> a <span>+</span> b<span>)</span><span>.</span><span>ifPresent</span><span>(</span><span>System</span><span>.</span>out<span>::</span><span>println</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"多线程计算耗时：%d"</span><span>,</span> <span>getCurrentTime</span><span>(</span><span>)</span> <span>-</span> prevTime<span>)</span><span>)</span><span>;</span>

    <span>}</span>

    <span>private</span> <span>static</span> <span>long</span> <span>getCurrentTime</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>输出：</p>
<blockquote>
<p>本计算机的核数：8<br>
495156156<br>
单线程计算耗时：223<br>
495156156<br>
多线程计算耗时：95</p>
</blockquote>
<p>所以在多核的情况下，使用Stream的并行计算确实比串行计算能带来很大效率上的提升，并且也能保证结果计算完全准确。</p>
<p>本文一直在强调的“多核”的情况。其实可以看到，我的本地电脑有8核，但并行计算耗时并不是单线程计算耗时除以8，因为线程的创建、销毁以及维护线程上下文的切换等等都有一定的开销。所以如果你的服务器并不是多核服务器，那也没必要用Stream的并行计算。因为在单核的情况下，往往Stream的串行计算比并行计算更快，因为它不需要线程切换的开销。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T13:17:08.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第二十章、计划任务</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/20/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/20/"/>
    <updated>2022-03-19T14:11:26.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/20.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第二十章 - GitHub</a></li>
</ul>
</div>
<p>自JDK 1.5 开始，JDK提供了 <code>ScheduledThreadPoolExecutor</code> 类用于计划任务（又称定时任务），</p>
<div><p>用途</p>
<ul>
<li>在给定的延迟之后运行任务</li>
<li>周期性重复执行任务</li>
</ul>
</div>
<p>在这之前，是使用<code>Timer</code>类来完成定时任务的</p>
<div><p>Timer 的缺陷：</p>
<ul>
<li>Timer是<strong>单线程</strong>模式；</li>
<li>如果在执行任务期间某个 <code>TimerTask</code> 耗时较久，那么就会影响其它任务的调度；</li>
<li>Timer的任务调度是基于绝对时间的，对<strong>系统时间</strong>敏感；</li>
<li>Timer不会捕获执行 <code>TimerTask</code> 时所抛出的<strong>异常</strong>，由于Timer是单线程，所以一旦出现异常，则线程就会终止，其他任务也得不到执行。</li>
</ul>
</div>
<h2 id="一、使用案例"> 一、使用案例</h2>
<p>假设我有一个需求，指定时间给大家发送消息。那么我们会将消息（包含发送时间）存储在数据库中，然后想用一个定时任务，每隔1秒检查数据库在当前时间有没有需要发送的消息，那这个计划任务怎么写？下面是一个Demo:</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>ThreadPool</span> <span>{</span>
    
    <span>private</span> <span>static</span> <span>final</span> <span>ScheduledExecutorService</span> executor <span>=</span> <span>new</span>
        <span>ScheduledThreadPoolExecutor</span><span>(</span><span>1</span><span>,</span> <span>Executors</span><span>.</span><span>defaultThreadFactory</span><span>(</span><span>)</span><span>)</span><span>;</span>
    
    <span>private</span> <span>static</span> <span>SimpleDateFormat</span> df <span>=</span> <span>new</span> <span>SimpleDateFormat</span><span>(</span><span>"yyyy-MM-dd HH:mm:ss"</span><span>)</span><span>;</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span><span>{</span>
        <span>// 新建一个固定延迟时间的计划任务</span>
        executor<span>.</span><span>scheduleWithFixedDelay</span><span>(</span><span>new</span> <span>Runnable</span><span>(</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
                <span>if</span> <span>(</span><span>haveMsgAtCurrentTime</span><span>(</span><span>)</span><span>)</span> <span>{</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>df<span>.</span><span>format</span><span>(</span><span>new</span> <span>Date</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"大家注意了，我要发消息了"</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span><span>,</span> <span>1</span><span>,</span> <span>1</span><span>,</span> <span>TimeUnit</span><span>.</span>SECONDS<span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>boolean</span> <span>haveMsgAtCurrentTime</span><span>(</span><span>)</span><span>{</span>
        <span>//查询数据库，有没有当前时间需要发送的消息</span>
        <span>//这里省略实现，直接返回true</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>

</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p>下面截取前面的输出（这个demo会一直运行下去）：</p>
<div><pre><code><span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>48</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>49</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>50</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>51</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>52</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>53</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>54</span>
大家注意了，我要发消息了
<span>2019</span><span>-</span><span>01</span><span>-</span><span>23</span> <span>16</span><span>:</span><span>16</span><span>:</span><span>55</span>
大家注意了，我要发消息了
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p>这就是 <code>ScheduledThreadPoolExecutor</code> 的一个简单运用，想要知道奥秘，接下来的东西需要仔细的看哦。</p>
<h2 id="二、类结构"> 二、类结构</h2>
<div><pre><code><span>public</span> <span>class</span> <span>ScheduledThreadPoolExecutor</span> <span>extends</span> <span>ThreadPoolExecutor</span>
	<span>implements</span> <span>ScheduledExecutorService</span> <span>{</span>
    
    <span>public</span> <span>ScheduledThreadPoolExecutor</span><span>(</span><span>int</span> corePoolSize<span>,</span><span>ThreadFactory</span> threadFactory<span>)</span> <span>{</span>
         <span>super</span><span>(</span>corePoolSize<span>,</span> <span>Integer</span><span>.</span>MAX_VALUE<span>,</span> <span>0</span><span>,</span> NANOSECONDS<span>,</span>
              <span>new</span> <span>DelayedWorkQueue</span><span>(</span><span>)</span><span>,</span> threadFactory<span>)</span><span>;</span>
    <span>}</span>
    <span>//……</span>
<span>}</span>       
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>ScheduledThreadPoolExecutor</code> 继承了 <code>ThreadPoolExecutor</code>，实现了 <code>ScheduledExecutorService</code>。 线程池在之前的章节介绍过了，我们先看看 <code>ScheduledExecutorService</code>。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>ScheduledExecutorService</span> <span>extends</span> <span>ExecutorService</span> <span>{</span>
    
    <span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>schedule</span><span>(</span><span>Runnable</span> command<span>,</span><span>long</span> delay<span>,</span> <span>TimeUnit</span> unit<span>)</span><span>;</span>
    
    <span>public</span> <span><span>&lt;</span><span>V</span><span>></span></span> <span>ScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>schedule</span><span>(</span><span>Callable</span><span><span>&lt;</span><span>V</span><span>></span></span> callable<span>,</span><span>long</span> delay<span>,</span> <span>TimeUnit</span> unit<span>)</span><span>;</span>
    
    <span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>scheduleAtFixedRate</span><span>(</span><span>Runnable</span> command<span>,</span>
                                                  <span>long</span> initialDelay<span>,</span>
                                                  <span>long</span> period<span>,</span>
                                                  <span>TimeUnit</span> unit<span>)</span><span>;</span>
    
    <span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>scheduleWithFixedDelay</span><span>(</span><span>Runnable</span> command<span>,</span>
                                                     <span>long</span> initialDelay<span>,</span>
                                                     <span>long</span> delay<span>,</span>
                                                     <span>TimeUnit</span> unit<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><code>ScheduledExecutorService</code> 实现了 <code>ExecutorService</code> ，并增加若干定时相关的接口。 前两个方法用于单次调度执行任务，区别是有没有返回值。</p>
<p>重点理解一下后面两个方法：</p>
<ul>
<li>
<p><code>scheduleAtFixedRate</code></p>
<p>该方法在 <code>initialDelay</code> 时长后第一次执行任务，以后每隔 <code>period</code> 时长，再次执行任务。注意，period是从<strong>任务开始执行算起</strong>的。开始执行任务后，定时器每隔period时长<strong>检查该任务是否完成</strong>，如果完成则再次启动任务，否则等该任务结束后才再次启动任务。</p>
</li>
<li>
<p><code>scheduleWithFixDelay</code></p>
<p>该方法在 <code>initialDelay</code> 时长后第一次执行任务，以后每当任务执行<strong>完成后</strong>，等待<code>delay</code>时长，再次执行任务。</p>
</li>
</ul>
<h2 id="三、主要方法介绍"> 三、主要方法介绍</h2>
<h3 id="_3-1-schedule"> 3.1 schedule</h3>
<div><pre><code><span>// delay时长后执行任务command，该任务只执行一次</span>
<span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>schedule</span><span>(</span><span>Runnable</span> command<span>,</span> <span>long</span> delay<span>,</span> <span>TimeUnit</span> unit<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>command <span>==</span> <span>null</span> <span>||</span> unit <span>==</span> <span>null</span><span>)</span>
        <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    
    <span>// 这里的decorateTask方法仅仅返回第二个参数</span>
    <span>RunnableScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> t <span>=</span> 
        <span>decorateTask</span><span>(</span>command<span>,</span> <span>new</span> <span>ScheduledFutureTask</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span>command<span>,</span> <span>null</span><span>,</span> <span>triggerTime</span><span>(</span>delay<span>,</span>unit<span>)</span><span>)</span><span>)</span><span>;</span>
    
    <span>// 延时或者周期执行任务的主要方法,稍后统一说明</span>
    <span>delayedExecute</span><span>(</span>t<span>)</span><span>;</span>
    <span>return</span> t<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>我们先看看里面涉及到的几个类和接口 <code>ScheduledFuture</code>、 <code>RunnableScheduledFuture</code>、 <code>ScheduledFutureTask</code>的关系：</p>
<p><img src="./README.assets/类图-16476960710061.jpg" alt="类图" loading="lazy"></p>
<p>我们先看看这几个接口和类：</p>
<h4 id="delayed接口"> Delayed接口</h4>
<div><pre><code><span>// 继承Comparable接口，表示该类对象支持排序</span>
<span>public</span> <span>interface</span> <span>Delayed</span> <span>extends</span> <span>Comparable</span><span><span>&lt;</span><span>Delayed</span><span>></span></span> <span>{</span>
    <span>// 返回该对象剩余时延</span>
    <span>long</span> <span>getDelay</span><span>(</span><span>TimeUnit</span> unit<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><code>Delayed</code>接口很简单，继承了 <code>Comparable</code> 接口，表示对象是可以比较排序的。</p>
<hr>
<h4 id="scheduledfuture接口"> ScheduledFuture接口</h4>
<div><pre><code><span>// 仅仅继承了Delayed和Future接口，自己没有任何代码</span>
<span>public</span> <span>interface</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>extends</span> <span>Delayed</span><span>,</span> <span>Future</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><hr>
<h4 id="runnablescheduledfuture接口"> RunnableScheduledFuture接口</h4>
<div><pre><code><span>public</span> <span>interface</span> <span>RunnableScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>extends</span> <span>RunnableFuture</span><span><span>&lt;</span><span>V</span><span>></span></span><span>,</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>V</span><span>></span></span> <span>{</span>      
    <span>// 是否是周期任务，周期任务可被调度运行多次，非周期任务只被运行一次   </span>
    <span>boolean</span> <span>isPeriodic</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><hr>
<h4 id="scheduledfuturetask类"> ScheduledFutureTask类</h4>
<p>回到 <code>schecule</code> 方法中，它创建了一个 <code>ScheduledFutureTask</code> 的对象，由上面的关系图可知，<code>ScheduledFutureTask</code> 直接或者间接实现了很多接口，一起看看 <code>ScheduledFutureTask</code> 里面的实现方法吧。</p>
<p><strong>构造方法</strong></p>
<div><pre><code><span>ScheduledFutureTask</span><span>(</span><span>Runnable</span> r<span>,</span> <span>V</span> result<span>,</span> <span>long</span> ns<span>,</span> <span>long</span> period<span>)</span> <span>{</span>
    <span>// 调用父类FutureTask的构造方法</span>
    <span>super</span><span>(</span>r<span>,</span> result<span>)</span><span>;</span>
    <span>// time表示任务下次执行的时间</span>
    <span>this</span><span>.</span>time <span>=</span> ns<span>;</span>
    <span>// 周期任务，正数表示按照固定速率，负数表示按照固定时延,0表示不是周期任务</span>
    <span>this</span><span>.</span>period <span>=</span> period<span>;</span>
    <span>// 任务的编号</span>
    <span>this</span><span>.</span>sequenceNumber <span>=</span> sequencer<span>.</span><span>getAndIncrement</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p><strong>Delayed接口的实现</strong></p>
<div><pre><code><span>// 实现Delayed接口的getDelay方法，返回任务开始执行的剩余时间</span>
<span>public</span> <span>long</span> <span>getDelay</span><span>(</span><span>TimeUnit</span> unit<span>)</span> <span>{</span>
    <span>return</span> unit<span>.</span><span>convert</span><span>(</span>time <span>-</span> <span>now</span><span>(</span><span>)</span><span>,</span> <span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p><strong>Comparable接口的实现</strong></p>
<div><pre><code><span>// Comparable接口的compareTo方法，比较两个任务的”大小”。</span>
<span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Delayed</span> other<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>other <span>==</span> <span>this</span><span>)</span>
      <span>return</span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>other <span>instanceof</span> <span>ScheduledFutureTask</span><span>)</span> <span>{</span>
      <span>ScheduledFutureTask</span><span><span>&lt;</span><span>?</span><span>></span></span> x <span>=</span> <span>(</span><span>ScheduledFutureTask</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span>other<span>;</span>
      <span>long</span> diff <span>=</span> time <span>-</span> x<span>.</span>time<span>;</span>
      <span>// 小于0，说明当前任务的执行时间点早于other，要排在延时队列other的前面</span>
      <span>if</span> <span>(</span>diff <span>&lt;</span> <span>0</span><span>)</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
      <span>// 大于0，说明当前任务的执行时间点晚于other，要排在延时队列other的后面</span>
      <span>else</span> <span>if</span> <span>(</span>diff <span>></span> <span>0</span><span>)</span>
        <span>return</span> <span>1</span><span>;</span>
      <span>// 如果两个任务的执行时间点一样，比较两个任务的编号，编号小的排在队列前面，编号大的排在队列后面</span>
      <span>else</span> <span>if</span> <span>(</span>sequenceNumber <span>&lt;</span> x<span>.</span>sequenceNumber<span>)</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
      <span>else</span>
        <span>return</span> <span>1</span><span>;</span>
    <span>}</span>
    <span>// 如果任务类型不是ScheduledFutureTask，通过getDelay方法比较</span>
    <span>long</span> d <span>=</span> <span>(</span><span>getDelay</span><span>(</span><span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span> <span>-</span>
              other<span>.</span><span>getDelay</span><span>(</span><span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span>d <span>==</span> <span>0</span><span>)</span> <span>?</span> <span>0</span> <span>:</span> <span>(</span><span>(</span>d <span>&lt;</span> <span>0</span><span>)</span> <span>?</span> <span>-</span><span>1</span> <span>:</span> <span>1</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><p><strong>setNextRunTime</strong></p>
<div><pre><code><span>// 任务执行完后，设置下次执行的时间</span>
<span>private</span> <span>void</span> <span>setNextRunTime</span><span>(</span><span>)</span> <span>{</span>
    <span>long</span> p <span>=</span> period<span>;</span>
    <span>// p > 0，说明是固定速率运行的任务</span>
    <span>// 在原来任务开始执行时间的基础上加上p即可</span>
    <span>if</span> <span>(</span>p <span>></span> <span>0</span><span>)</span>
      time <span>+=</span> p<span>;</span>
    <span>// p &lt; 0，说明是固定时延运行的任务，</span>
    <span>// 下次执行时间在当前时间(任务执行完成的时间)的基础上加上-p的时间</span>
    <span>else</span>
      time <span>=</span> <span>triggerTime</span><span>(</span><span>-</span>p<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p><strong>Runnable接口实现</strong></p>
<div><pre><code><span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
    <span>boolean</span> periodic <span>=</span> <span>isPeriodic</span><span>(</span><span>)</span><span>;</span>
    <span>// 如果当前状态下不能执行任务，则取消任务</span>
    <span>if</span> <span>(</span><span>!</span><span>canRunInCurrentRunState</span><span>(</span>periodic<span>)</span><span>)</span>
      <span>cancel</span><span>(</span><span>false</span><span>)</span><span>;</span>
    <span>// 不是周期性任务，执行一次任务即可，调用父类的run方法</span>
    <span>else</span> <span>if</span> <span>(</span><span>!</span>periodic<span>)</span>
      <span>ScheduledFutureTask</span><span>.</span><span>super</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
    <span>// 是周期性任务，调用FutureTask的runAndReset方法，方法执行完成后</span>
    <span>// 重新设置任务下一次执行的时间，并将该任务重新入队，等待再次被调度</span>
    <span>else</span> <span>if</span> <span>(</span><span>ScheduledFutureTask</span><span>.</span><span>super</span><span>.</span><span>runAndReset</span><span>(</span><span>)</span><span>)</span> <span>{</span>
      <span>setNextRunTime</span><span>(</span><span>)</span><span>;</span>
      <span>reExecutePeriodic</span><span>(</span>outerTask<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><div><p>执行过程</p>
<ol>
<li>如果当前线程池运行状态不可以执行任务，取消该任务，然后直接返回，否则执行步骤2；</li>
<li>如果不是周期性任务，调用 <code>FutureTask</code> 中的 <code>run</code> 方法执行，会设置执行结果，然后直接返回，否则执行步骤3；</li>
<li>如果是周期性任务，调用 <code>FutureTask中</code> 的 <code>runAndReset</code> 方法执行，不会设置执行结果，然后直接返回，否则执行步骤4和步骤5；</li>
<li>计算下次执行该任务的具体时间；</li>
<li>重复执行任务。</li>
</ol>
</div>
<p><code>runAndReset</code> 方法是为任务多次执行而设计的。<code>runAndReset</code>方法执行完任务后不会设置任务的执行结果，也不会去更新任务的状态，维持任务的状态为初始状态（<strong>NEW</strong>状态），这也是该方法和 <code>FutureTask</code> 的 <code>run</code> 方法的区别。</p>
<h3 id="_3-2-scheduleatfixedrate"> 3.2 scheduleAtFixedRate</h3>
<p>我们看一下代码：</p>
<div><pre><code><span>// 注意，固定速率和固定时延，传入的参数都是Runnable，也就是说这种定时任务是没有返回值的</span>
<span>public</span> <span>ScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>scheduleAtFixedRate</span><span>(</span><span>Runnable</span> command<span>,</span>
                                                  <span>long</span> initialDelay<span>,</span>
                                                  <span>long</span> period<span>,</span>
                                                  <span>TimeUnit</span> unit<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>command <span>==</span> <span>null</span> <span>||</span> unit <span>==</span> <span>null</span><span>)</span>
      <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>period <span>&lt;=</span> <span>0</span><span>)</span>
      <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>)</span><span>;</span>
    
    <span>// 创建一个有初始延时和固定周期的任务</span>
    <span>ScheduledFutureTask</span><span><span>&lt;</span><span>Void</span><span>></span></span> sft <span>=</span>
      <span>new</span> <span>ScheduledFutureTask</span><span><span>&lt;</span><span>Void</span><span>></span></span><span>(</span>command<span>,</span>
                                    <span>null</span><span>,</span>
                                    <span>triggerTime</span><span>(</span>initialDelay<span>,</span> unit<span>)</span><span>,</span>
                                    unit<span>.</span><span>toNanos</span><span>(</span>period<span>)</span><span>)</span><span>;</span>
    
    <span>RunnableScheduledFuture</span><span><span>&lt;</span><span>Void</span><span>></span></span> t <span>=</span> <span>decorateTask</span><span>(</span>command<span>,</span> sft<span>)</span><span>;</span>
    <span>// outerTask表示将会重新入队的任务</span>
    sft<span>.</span>outerTask <span>=</span> t<span>;</span>
    <span>// 稍后说明</span>
    <span>delayedExecute</span><span>(</span>t<span>)</span><span>;</span>
    <span>return</span> t<span>;</span>
<span>}</span>

</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><p><code>scheduleAtFixedRate</code> 这个方法和 <code>schedule</code> 类似，不同点是 <code>scheduleAtFixedRate</code> 方法内部创建的是 <code>ScheduledFutureTask</code>，带有初始延时和固定周期的任务 。</p>
<h3 id="_3-3-schedulewithfixeddelay"> 3.3 scheduleWithFixedDelay</h3>
<p><code>FixedDelay</code> 也是通过 <code>ScheduledFutureTask</code> 体现的，唯一不同的地方在于创建的<code>ScheduledFutureTask</code>不同 。这里不再展示源码。</p>
<h3 id="_3-4-delayedexecute"> 3.4 delayedExecute</h3>
<p>前面讲到的<code>schedule</code>、<code>scheduleAtFixedRate</code>和<code>scheduleWithFixedDelay</code>最后都调用了<code>delayedExecute</code>方法，该方法是定时任务执行的主要方法。 一起来看看源码：</p>
<div><pre><code><span>private</span> <span>void</span> <span>delayedExecute</span><span>(</span><span>RunnableScheduledFuture</span><span><span>&lt;</span><span>?</span><span>></span></span> task<span>)</span> <span>{</span>
    <span>// 线程池已经关闭，调用拒绝执行处理器处理</span>
    <span>if</span> <span>(</span><span>isShutdown</span><span>(</span><span>)</span><span>)</span>
      <span>reject</span><span>(</span>task<span>)</span><span>;</span>
    <span>else</span> <span>{</span>
      <span>// 将任务加入到等待队列</span>
      <span>super</span><span>.</span><span>getQueue</span><span>(</span><span>)</span><span>.</span><span>add</span><span>(</span>task<span>)</span><span>;</span>
      <span>// 线程池已经关闭，且当前状态不能运行该任务，将该任务从等待队列移除并取消该任务</span>
      <span>if</span> <span>(</span><span>isShutdown</span><span>(</span><span>)</span> <span>&amp;&amp;</span>
          <span>!</span><span>canRunInCurrentRunState</span><span>(</span>task<span>.</span><span>isPeriodic</span><span>(</span><span>)</span><span>)</span> <span>&amp;&amp;</span>
          <span>remove</span><span>(</span>task<span>)</span><span>)</span>
        task<span>.</span><span>cancel</span><span>(</span><span>false</span><span>)</span><span>;</span>
      <span>else</span>
        <span>// 增加一个worker，就算corePoolSize=0也要增加一个worker</span>
        <span>ensurePrestart</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><code>delayedExecute</code>方法的逻辑也很简单，主要就是将任务添加到等待队列，然后调用<code>ensurePrestart</code>方法。</p>
<div><pre><code><span>void</span> <span>ensurePrestart</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> wc <span>=</span> <span>workerCountOf</span><span>(</span>ctl<span>.</span><span>get</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span>wc <span>&lt;</span> corePoolSize<span>)</span>
        <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>else</span> <span>if</span> <span>(</span>wc <span>==</span> <span>0</span><span>)</span>
        <span>addWorker</span><span>(</span><span>null</span><span>,</span> <span>false</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ensurePrestart</code>方法主要是调用了<code>addWorker</code>，线程池中的工作线程是通过该方法来启动并执行任务的。 具体可以查看前面讲的线程池章节。</p>
<p>对于<code>ScheduledThreadPoolExecutor</code>，<code>worker</code>添加到线程池后会在等待队列上等待获取任务，这点是和<code>ThreadPoolExecutor</code>一致的。<strong>但是worker是怎么从等待队列取定时任务的？</strong></p>
<p>因为<code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务，该等待队列队首应该保存的是最近将要执行的任务，如果队首任务的开始执行时间还未到，<code>worker</code>也应该继续等待。</p>
<h2 id="四、delayedworkqueue"> 四、DelayedWorkQueue</h2>
<p><code>ScheduledThreadPoolExecutor</code>使用了<code>DelayedWorkQueue</code>保存等待的任务。</p>
<p>该等待队列队首应该保存的是<strong>最近将要执行的任务</strong>，所以<code>worker</code>只关心队首任务即可，如果队首任务的开始执行时间还未到，worker也应该继续等待。</p>
<p>DelayedWorkQueue是一个无界优先队列，使用数组存储，底层是使用堆结构来实现优先队列的功能。我们先看看DelayedWorkQueue的声明和成员变量：</p>
<div><pre><code><span>static</span> <span>class</span> <span>DelayedWorkQueue</span> <span>extends</span> <span>AbstractQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span>
<span>implements</span> <span>BlockingQueue</span><span><span>&lt;</span><span>Runnable</span><span>></span></span> <span>{</span>
	<span>// 队列初始容量</span>
	<span>private</span> <span>static</span> <span>final</span> <span>int</span> INITIAL_CAPACITY <span>=</span> <span>16</span><span>;</span>
	<span>// 数组用来存储定时任务，通过数组实现堆排序</span>
	<span>private</span> <span>RunnableScheduledFuture</span><span>[</span><span>]</span> queue <span>=</span> <span>new</span> <span>RunnableScheduledFuture</span><span>[</span>INITIAL_CAPACITY<span>]</span><span>;</span>
	<span>// 当前在队首等待的线程</span>
	<span>private</span> <span>Thread</span> leader <span>=</span> <span>null</span><span>;</span>
	<span>// 锁和监视器，用于leader线程</span>
	<span>private</span> <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>new</span> <span>ReentrantLock</span><span>(</span><span>)</span><span>;</span>
	<span>private</span> <span>final</span> <span>Condition</span> available <span>=</span> lock<span>.</span><span>newCondition</span><span>(</span><span>)</span><span>;</span>
	<span>// 其他代码，略</span>
<span>}</span>	
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>当一个线程成为leader，它只要等待队首任务的delay时间即可，其他线程会无条件等待。leader取到任务返回前要通知其他线程，直到有线程成为新的leader。每当队首的定时任务被其他更早需要执行的任务替换时，leader设置为null，其他等待的线程（被当前leader通知）和当前的leader重新竞争成为leader。</p>
<p>同时，定义了锁lock和监视器available用于线程竞争成为leader。</p>
<p>当一个新的任务成为队首，或者需要有新的线程成为leader时，available监视器上的线程将会被通知，然后竞争成为leader线程。 有些类似于生产者-消费者模式。</p>
<p>接下来看看<code>DelayedWorkQueue</code>中几个比较重要的方法</p>
<h3 id="_4-1-take"> 4.1 take</h3>
<div><pre><code><span>public</span> <span>RunnableScheduledFuture</span> <span>take</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    lock<span>.</span><span>lockInterruptibly</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
      <span>for</span> <span>(</span><span>;</span><span>;</span><span>)</span> <span>{</span>
        <span>// 取堆顶的任务，堆顶是最近要执行的任务</span>
        <span>RunnableScheduledFuture</span> first <span>=</span> queue<span>[</span><span>0</span><span>]</span><span>;</span>
        <span>// 堆顶为空，线程要在条件available上等待</span>
        <span>if</span> <span>(</span>first <span>==</span> <span>null</span><span>)</span>
          available<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
        <span>else</span> <span>{</span>
          <span>// 堆顶任务还要多长时间才能执行</span>
          <span>long</span> delay <span>=</span> first<span>.</span><span>getDelay</span><span>(</span><span>TimeUnit</span><span>.</span>NANOSECONDS<span>)</span><span>;</span>
          <span>// 堆顶任务已经可以执行了，finishPoll会重新调整堆，使其满足最小堆特性，该方法设置任务在</span>
          <span>// 堆中的index为-1并返回该任务</span>
          <span>if</span> <span>(</span>delay <span>&lt;=</span> <span>0</span><span>)</span>
            <span>return</span> <span>finishPoll</span><span>(</span>first<span>)</span><span>;</span>
          <span>// 如果leader不为空，说明已经有线程成为leader并等待堆顶任务</span>
          <span>// 到达执行时间，此时，其他线程都需要在available条件上等待</span>
          <span>else</span> <span>if</span> <span>(</span>leader <span>!=</span> <span>null</span><span>)</span>
            available<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
          <span>else</span> <span>{</span>
            <span>// leader为空，当前线程成为新的leader</span>
            <span>Thread</span> thisThread <span>=</span> <span>Thread</span><span>.</span><span>currentThread</span><span>(</span><span>)</span><span>;</span>
            leader <span>=</span> thisThread<span>;</span>
            <span>try</span> <span>{</span>
              <span>// 当前线程已经成为leader了，只需要等待堆顶任务到达执行时间即可</span>
              available<span>.</span><span>awaitNanos</span><span>(</span>delay<span>)</span><span>;</span>
            <span>}</span> <span>finally</span> <span>{</span>
              <span>// 返回堆顶元素之前将leader设置为空</span>
              <span>if</span> <span>(</span>leader <span>==</span> thisThread<span>)</span>
                leader <span>=</span> <span>null</span><span>;</span>
            <span>}</span>
          <span>}</span>
        <span>}</span>
      <span>}</span>
    <span>}</span> <span>finally</span> <span>{</span>
      <span>// 通知其他在available条件等待的线程，这些线程可以去竞争成为新的leader</span>
      <span>if</span> <span>(</span>leader <span>==</span> <span>null</span> <span>&amp;&amp;</span> queue<span>[</span><span>0</span><span>]</span> <span>!=</span> <span>null</span><span>)</span>
        available<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>
      lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><p><code>take</code>方法是什么时候调用的呢？在线程池的章节中，介绍了<code>getTask</code>方法，工作线程会循环地从<code>workQueue</code>中取任务。但计划任务却不同，因为如果一旦<code>getTask</code>方法取出了任务就开始执行了，而这时可能还没有到执行的时间，所以在<code>take</code>方法中，要保证只有在到指定的执行时间的时候任务才可以被取走。</p>
<p>总结一下流程：</p>
<ol>
<li>如果堆顶元素为空，在available条件上等待。</li>
<li>如果堆顶任务的执行时间已到，将堆顶元素替换为堆的最后一个元素并调整堆使其满足<strong>最小堆</strong>特性，同时设置任务在堆中索引为-1，返回该任务。</li>
<li>如果leader不为空，说明已经有线程成为leader了，其他线程都要在available监视器上等待。</li>
<li>如果leader为空，当前线程成为新的leader，并等待直到堆顶任务执行时间到达。</li>
<li>take方法返回之前，将leader设置为空，并通知其他线程。</li>
</ol>
<p>再来说一下leader的作用，这里的leader是<strong>为了减少不必要的定时等待</strong>，当一个线程成为leader时，它只等待下一个节点的时间间隔，但其它线程无限期等待。 leader线程必须在从<code>take()</code>或<code>poll()</code>返回之前signal其它线程，除非其他线程成为了leader。</p>
<p>举例来说，如果没有leader，那么在执行take时，都要执行<code>available.awaitNanos(delay)</code>，假设当前线程执行了该段代码，这时还没有signal，第二个线程也执行了该段代码，则第二个线程也要被阻塞。但只有一个线程返回队首任务，其他的线程在<code>awaitNanos(delay)</code>之后，继续执行for循环，因为队首任务已经被返回了，所以这个时候的for循环拿到的队首任务是新的，又需要重新判断时间，又要继续阻塞。</p>
<p>所以，为了不让多个线程频繁的做无用的定时等待，这里增加了leader，如果leader不为空，则说明队列中第一个节点已经在等待出队，这时其它的线程会一直阻塞，减少了无用的阻塞（注意，在<code>finally</code>中调用了<code>signal()</code>来唤醒一个线程，而不是<code>signalAll()</code>）。</p>
<h3 id="_4-2-offer"> 4.2 offer</h3>
<p>该方法往队列插入一个值，返回是否成功插入 。</p>
<div><pre><code><span>public</span> <span>boolean</span> <span>offer</span><span>(</span><span>Runnable</span> x<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>x <span>==</span> <span>null</span><span>)</span>
      <span>throw</span> <span>new</span> <span>NullPointerException</span><span>(</span><span>)</span><span>;</span>
    <span>RunnableScheduledFuture</span> e <span>=</span> <span>(</span><span>RunnableScheduledFuture</span><span>)</span>x<span>;</span>
    <span>final</span> <span>ReentrantLock</span> lock <span>=</span> <span>this</span><span>.</span>lock<span>;</span>
    lock<span>.</span><span>lock</span><span>(</span><span>)</span><span>;</span>
    <span>try</span> <span>{</span>
      <span>int</span> i <span>=</span> size<span>;</span>
      <span>// 队列元素已经大于等于数组的长度，需要扩容，新堆的容量是原来堆容量的1.5倍</span>
      <span>if</span> <span>(</span>i <span>>=</span> queue<span>.</span>length<span>)</span>
        <span>grow</span><span>(</span><span>)</span><span>;</span>
      <span>// 堆中元素增加1</span>
      size <span>=</span> i <span>+</span> <span>1</span><span>;</span>
      <span>// 调整堆</span>
      <span>if</span> <span>(</span>i <span>==</span> <span>0</span><span>)</span> <span>{</span>
        queue<span>[</span><span>0</span><span>]</span> <span>=</span> e<span>;</span>
        <span>setIndex</span><span>(</span>e<span>,</span> <span>0</span><span>)</span><span>;</span>
      <span>}</span> <span>else</span> <span>{</span>
          <span>// 调整堆，使的满足最小堆，比较大小的方式就是上文提到的compareTo方法</span>
        <span>siftUp</span><span>(</span>i<span>,</span> e<span>)</span><span>;</span>
      <span>}</span>
      <span>if</span> <span>(</span>queue<span>[</span><span>0</span><span>]</span> <span>==</span> e<span>)</span> <span>{</span>
        leader <span>=</span> <span>null</span><span>;</span>
        <span>// 通知其他在available条件上等待的线程，这些线程可以竞争成为新的leader</span>
        available<span>.</span><span>signal</span><span>(</span><span>)</span><span>;</span>
      <span>}</span>
    <span>}</span> <span>finally</span> <span>{</span>
      lock<span>.</span><span>unlock</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br></div></div><p>在堆中插入了一个节点，这个时候堆有可能不满足最小堆的定义，<code>siftUp</code>用于将堆调整为最小堆，这属于数据结构的基本内容，本文不做介绍。</p>
<h2 id="五、总结"> 五、总结</h2>
<p>内部使用优化的DelayQueue来实现，由于使用队列来实现定时器，有出入队调整堆等操作，所以定时并不是非常非常精确。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T14:11:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">顺序一致性</title>
    <id>https://notes.lllllan.cn/java/concurrent/def/sequential-consistency/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/def/sequential-consistency/"/>
    <updated>2022-03-18T10:41:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://lotabout.me/2019/QQA-What-is-Sequential-Consistency/" target="_blank" rel="noopener noreferrer">什么是顺序一致性(Sequential Consistency) | 三点水 (lotabout.me)</a></li>
</ul>
</div>
<h2 id="什么是顺序一致性"> 什么是顺序一致性</h2>
<p>顺序一致性内存模型是一个<strong>理想化的理论参考模型</strong>，它为程序员提供了极强的内存可见性保证。</p>
<div><p>顺序一致性模型 两大特性</p>
<ul>
<li><mark>一个线程中</mark> 的所有操作必须按照程序的顺序（即Java代码的顺序）来执行。</li>
<li>不管程序是否同步，所有线程都只能看到一个单一的操作执行顺序。即在顺序一致性模型中，每个操作必须是<strong>原子性的，且立刻对所有线程可见</strong>。</li>
</ul>
</div>
<p>如果可以找到一个所有 CPU 执行指令的排序，该排序中 <strong>每个 CPU 要执行指令的顺序得以保持</strong> [1]，且 <strong>实际的 CPU 执行结果</strong> [2] <strong>与该指令排序的执行结果一致</strong> [3]，则称该次执行达到了顺序一致性。栗如：</p>
<p><img src="./README.assets/Sequential-Consistency.svg" alt="img" loading="lazy"></p>
<blockquote>
<p>图中 <code>W(X, 1)</code> 代表将 1 写入变量 X；<code>R(X, 1)</code> 代表读取变量 X，值为 1</p>
</blockquote>
<hr>
<p><strong>[1] 每个CPU要执行指令的顺序保持不变：</strong></p>
<p>每个CPU执行一个线程任务。单个线程任务中，指令的顺序不得改变；多个线程之间，指令顺序无相关性。</p>
<p>图中上面四条线指每个CPU执行指令的顺序，最下方一条指令序列是某一种符合顺序一致性的排序。观察可知该排序中没有破坏每条线程中的指令顺序。</p>
<blockquote>
<p>即C线程中 <code>R(X, 1)</code> 指令保持出现在 <code>R(X, 2)</code> 之前</p>
</blockquote>
<hr>
<p><strong>[2]实际的CPU执行结果：</strong></p>
<ul>
<li>A线程：写操作，令 X = 1；</li>
<li>B线程：写操作，令 X = 2；</li>
<li>C线程：读操作，得到 X = 1；读操作，得到 X = 2</li>
<li>D线程：读操作，得到 X = 1；读操作，得到 X = 2</li>
</ul>
<blockquote>
<p>图中不要纠结个线程之间指令的先后，只管线程内部的顺序即可。</p>
</blockquote>
<hr>
<p><strong>[3]与该指令排序的执行结果一致</strong></p>
<p>最下方的指令序列获得的结果：</p>
<p>A线程写操作，令 X = 1；C线程读操作，得到 X = 1；D线程读操作，得到 X = 1；</p>
<p>B线程写操作，令 X = 2；C线程读操作，得到 X = 2；D线程读操作，得到 X = 2；</p>
<p>与上面实际的CPU执行结果一致</p>
<hr>
<p><strong>因此我们认为这条指令序列，达到了顺序一致性</strong></p>
<h2 id="更多正反栗"> 更多正反栗</h2>
<h3 id="正栗2"> 正栗2</h3>
<p><img src="./README.assets/Sequential-Consistency-swap-1.svg" alt="img" loading="lazy"></p>
<p>上方四条是实际的CPU执行，最下方是能够找到的符合顺序一致性的指令序列。</p>
<h3 id="反栗1"> 反栗1</h3>
<p><img src="./README.assets/Sequential-Consistency-swap-2.svg" alt="img" loading="lazy"></p>
<p>C线程的指令：两次读操作，先得到X = 1，后续再得到 X = 2</p>
<p>D线程的指令：两次读操作，先得到X = 2，后续再得到 X = 1</p>
<p>但这里对 X 一共只有两次写操作，根据 <mark>不破坏线程中的指令顺序的原则</mark> ，这个栗子中找不到一个指令序列能够满足顺序一致性。</p>
<h3 id="反栗2"> 反栗2</h3>
<p><img src="./README.assets/Sequential-Consistency-swap-3.svg" alt="img" loading="lazy"></p>
<p>A线程的指令：两次写操作，先令 X = 2，后续再令 X = 1</p>
<p>C线程的指令：两次读操作，先得到 X = 1，后续再得到 X = 2</p>
<p>此处没有别的写操作，显然C线程不应该得到这样的结果，我们任务这里依然找不到一个指令序列能够满足顺序一致性</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-18T10:41:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第十七章、通信工具类</title>
    <id>https://notes.lllllan.cn/java/concurrent/3/17/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/3/17/"/>
    <updated>2022-03-19T10:46:42.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://github.com/RedSpider1/concurrent/tree/develop/article/03/17.md" target="_blank" rel="noopener noreferrer">深入浅出多线程 - 第十七章 - GitHub</a></li>
</ul>
</div>
<p>JDK中提供了一些工具类以供开发者使用。这样的话我们在遇到一些常见的应用场景时就可以使用这些工具类，而不用自己再重复造轮子了。</p>
<p>它们都在 <code>java.util.concurrent</code> 包下。先总体概括一下都有哪些工具类，它们有什么作用，然后再分别介绍它们的主要使用方法和原理。</p>
<table>
<thead>
<tr>
<th style="text-align:center">类</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Semaphore</td>
<td style="text-align:center">限制线程的数量</td>
</tr>
<tr>
<td style="text-align:center">Exchanger</td>
<td style="text-align:center">两个线程交换数据</td>
</tr>
<tr>
<td style="text-align:center">CountDownLatch</td>
<td style="text-align:center">线程等待直到计数器减为0时开始工作</td>
</tr>
<tr>
<td style="text-align:center">CyclicBarrier</td>
<td style="text-align:center">作用跟CountDownLatch类似，但是可以重复使用</td>
</tr>
<tr>
<td style="text-align:center">Phaser</td>
<td style="text-align:center">增强的CyclicBarrier</td>
</tr>
</tbody>
</table>
<h2 id="一、semaphore"> 一、Semaphore</h2>
<h3 id="_1-1-semaphore-介绍"> 1.1 Semaphore 介绍</h3>
<p>Semaphore翻译过来是信号的意思。顾名思义，这个工具类提供的功能就是多个线程彼此 “打信号”。而这个 “信号” 是一个 <code>int</code> 类型的数据，也可以看成是一种 “资源”。</p>
<p>可以在构造函数中传入初始资源总数，以及是否使用 “公平” 的同步器。 <mark>默认情况下是非公平的</mark>。</p>
<div><pre><code><span>// 默认情况下使用非公平</span>
<span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>)</span> <span>{</span>
    sync <span>=</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>Semaphore</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>boolean</span> fair<span>)</span> <span>{</span>
    sync <span>=</span> fair <span>?</span> <span>new</span> <span>FairSync</span><span>(</span><span>permits</span><span>)</span> <span>:</span> <span>new</span> <span>NonfairSync</span><span>(</span><span>permits</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p>最主要的方法是 <code>acquire</code> 方法和 <code>release</code> 方法。<code>acquire()</code> 方法会申请一个 <code>permit</code> ，而 <code>release</code> 方法会释放一个 <code>permit</code> 。当然，你也可以申请多个 <code>acquire(int permits)</code> 或者释放多个 <code>release(int permits)</code> 。</p>
<p>每次 <code>acquire</code> ， <code>permits</code> 就会减少一个或者多个。如果减少到了0，再有其他线程来 <code>acquire</code> ，那就要阻塞这个线程直到有其它线程 <code>release permit</code> 为止。</p>
<h3 id="_1-2-semaphore-案例"> 1.2 Semaphore 案例</h3>
<p>Semaphore往往用于资源有限的场景中，去限制线程的数量。举个例子，我想限制同时只能有3个线程在工作：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>SemaphoreDemo</span> <span>{</span>
    <span>static</span> <span>class</span> <span>MyThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>

        <span>private</span> <span>int</span> value<span>;</span>
        <span>private</span> <span>Semaphore</span> semaphore<span>;</span>

        <span>public</span> <span>MyThread</span><span>(</span><span>int</span> value<span>,</span> <span>Semaphore</span> semaphore<span>)</span> <span>{</span>
            <span>this</span><span>.</span>value <span>=</span> value<span>;</span>
            <span>this</span><span>.</span>semaphore <span>=</span> semaphore<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                semaphore<span>.</span><span>acquire</span><span>(</span><span>)</span><span>;</span> <span>// 获取permit</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"当前线程是%d, 还剩%d个资源，还有%d个线程在等待"</span><span>,</span>
                        value<span>,</span> semaphore<span>.</span><span>availablePermits</span><span>(</span><span>)</span><span>,</span> semaphore<span>.</span><span>getQueueLength</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
                <span>// 睡眠随机时间，打乱释放顺序</span>
                <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"线程%d释放了资源"</span><span>,</span> value<span>)</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span> <span>finally</span><span>{</span>
                semaphore<span>.</span><span>release</span><span>(</span><span>)</span><span>;</span> <span>// 释放permit</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Semaphore</span> semaphore <span>=</span> <span>new</span> <span>Semaphore</span><span>(</span><span>3</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>10</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>MyThread</span><span>(</span>i<span>,</span> semaphore<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>输出：</p>
<blockquote>
<p>当前线程是1, 还剩2个资源，还有0个线程在等待</p>
<p>当前线程是0, 还剩1个资源，还有0个线程在等待</p>
<p>当前线程是6, 还剩0个资源，还有0个线程在等待</p>
<p>线程6释放了资源</p>
<p>当前线程是2, 还剩0个资源，还有6个线程在等待</p>
<p>线程2释放了资源</p>
<p>当前线程是4, 还剩0个资源，还有5个线程在等待</p>
<p>线程0释放了资源</p>
<p>当前线程是7, 还剩0个资源，还有4个线程在等待</p>
<p>线程1释放了资源</p>
<p>当前线程是8, 还剩0个资源，还有3个线程在等待</p>
<p>线程7释放了资源</p>
<p>当前线程是5, 还剩0个资源，还有2个线程在等待</p>
<p>线程4释放了资源</p>
<p>当前线程是3, 还剩0个资源，还有1个线程在等待</p>
<p>线程8释放了资源</p>
<p>当前线程是9, 还剩0个资源，还有0个线程在等待</p>
<p>线程9释放了资源</p>
<p>线程5释放了资源</p>
<p>线程3释放了资源</p>
</blockquote>
<p>可以看到，在这次运行中，最开始是1, 0, 6这三个线程获得了资源，而其它线程进入了等待队列。然后当某个线程释放资源后，就会有等待队列中的线程获得资源。</p>
<p>当然， <mark><code>Semaphore</code> 默认的 <code>acquire</code> 方法是会让线程进入等待队列，且会抛出中断异常</mark> 。但它还有一些方法可以忽略中断或不进入阻塞队列：</p>
<div><pre><code><span>// 忽略中断</span>
<span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>)</span>
<span>public</span> <span>void</span> <span>acquireUninterruptibly</span><span>(</span><span>int</span> <span>permits</span><span>)</span>

<span>// 不进入等待队列，底层使用CAS</span>
<span>public</span> <span>boolean</span> tryAcquire
<span>public</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> <span>permits</span><span>)</span>
<span>public</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>int</span> <span>permits</span><span>,</span> <span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>
        <span>throws</span> <span>InterruptedException</span>
<span>public</span> <span>boolean</span> <span>tryAcquire</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><h3 id="_1-3-semaphore-原理"> 1.3 Semaphore 原理</h3>
<p>Semaphore内部有一个继承了AQS的同步器Sync，重写了<code>tryAcquireShared</code>方法。在这个方法里，会去尝试获取资源。</p>
<p>如果获取失败（想要的资源数量小于目前已有的资源数量），就会返回一个负数（代表尝试获取资源失败）。然后当前线程就会进入AQS的等待队列。</p>
<div><p>AQS</p>
<p>还没懂 AQS</p>
</div>
<h2 id="二、exchanger"> 二、Exchanger</h2>
<p><mark>Exchanger类用于两个线程交换数据</mark> 。<strong>它支持泛型</strong>，也就是说你可以在两个线程之间传送任何数据。先来一个案例看看如何使用，比如两个线程之间想要传送字符串：</p>
<div><pre><code><span>public</span> <span>class</span> <span>ExchangerDemo</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>Exchanger</span><span><span>&lt;</span><span>String</span><span>></span></span> exchanger <span>=</span> <span>new</span> <span>Exchanger</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"这是线程A，得到了另一个线程的数据："</span>
                        <span>+</span> exchanger<span>.</span><span>exchange</span><span>(</span><span>"这是来自线程A的数据"</span><span>)</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"这个时候线程A是阻塞的，在等待线程B的数据"</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"这是线程B，得到了另一个线程的数据："</span>
                        <span>+</span> exchanger<span>.</span><span>exchange</span><span>(</span><span>"这是来自线程B的数据"</span><span>)</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><p>输出：</p>
<blockquote>
<p>这个时候线程A是阻塞的，在等待线程B的数据</p>
<p>这是线程B，得到了另一个线程的数据：这是来自线程A的数据</p>
<p>这是线程A，得到了另一个线程的数据：这是来自线程B的数据</p>
</blockquote>
<p>可以看到，当一个线程调用exchange方法后，<strong>它是处于阻塞状态的</strong>，只有当另一个线程也调用了exchange方法，它才会继续向下执行。看源码可以发现它是使用 <code>park/unpark</code> 来实现等待状态的切换的，但是在使用 <code>park/unpark</code> 方法之前，使用了CAS检查，估计是为了提高性能。</p>
<p>Exchanger 一般用于两个线程之间更方便地在内存中交换数据，因为其支持泛型，所以我们可以传输任何的数据，比如IO流或者IO缓存。</p>
<div><p>Exchanger 特性</p>
<ul>
<li>此类提供对外的操作是同步的；</li>
<li>用于成对出现的线程之间交换数据；</li>
<li>可以视作双向的同步队列；</li>
<li>可应用于基因算法、流水线设计等场景。</li>
</ul>
</div>
<p><code>Exchanger</code> 类还有一个有超时参数的方法，如果在指定时间内没有另一个线程调用exchange，就会抛出一个超时异常。</p>
<div><pre><code><span>public</span> <span>V</span> <span>exchange</span><span>(</span><span>V</span> x<span>,</span> <span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p>那么问题来了，<code>Exchanger</code> 只能是两个线程交换数据吗？那三个调用同一个实例的 <code>exchange</code> 方法会发生什么呢？<strong>答案是只有前两个线程会交换数据</strong>，第三个线程会进入阻塞状态。</p>
<p>需要注意的是，<code>exchange</code> 是可以重复使用的。也就是说。<strong>两个线程可以使用 <code>Exchanger</code> 在内存中不断地再交换数据。</strong></p>
<h2 id="三、countdownlatch"> 三、CountDownLatch</h2>
<h3 id="_3-1-countdownlatch-介绍"> 3.1 CountDownLatch 介绍</h3>
<p>先来解读一下 <code>CountDownLatch</code> 这个类名字的意义。<code>CountDown</code> 代表计数递减，<code>Latch</code> 是 “门闩” 的意思。也有人把它称为“ 屏障”。而 <code>CountDownLatch</code> 这个类的作用也很贴合这个名字的意义，假设某个线程在执行任务之前，需要等待其它线程完成一些前置任务，必须等所有的前置任务都完成，才能开始执行本线程的任务。</p>
<p><code>CountDownLatch</code> 的方法也很简单，如下：</p>
<div><pre><code><span>// 构造方法：</span>
<span>public</span> <span>CountDownLatch</span><span>(</span><span>int</span> count<span>)</span>
    
<span>public</span> <span>void</span> <span>await</span><span>(</span><span>)</span> <span>// 等待</span>
<span>public</span> <span>boolean</span> <span>await</span><span>(</span><span>long</span> timeout<span>,</span> <span>TimeUnit</span> unit<span>)</span> <span>// 超时等待</span>
<span>public</span> <span>void</span> <span>countDown</span><span>(</span><span>)</span> <span>// count - 1</span>
<span>public</span> <span>long</span> <span>getCount</span><span>(</span><span>)</span> <span>// 获取当前还有多少count</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_3-2-countdownlatch-案例"> 3.2  CountDownLatch 案例</h3>
<p>我们知道，玩游戏的时候，在游戏真正开始之前，一般会等待一些前置任务完成，比如 “加载地图数据”，“加载人物模型”，“加载背景音乐” 等等。只有当所有的东西都加载完成后，玩家才能真正进入游戏。下面我们就来模拟一下这个demo。</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>CountDownLatchDemo</span> <span>{</span>
    <span>// 定义前置任务线程</span>
    <span>static</span> <span>class</span> <span>PreTaskThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>

        <span>private</span> <span>String</span> task<span>;</span>
        <span>private</span> <span>CountDownLatch</span> countDownLatch<span>;</span>

        <span>public</span> <span>PreTaskThread</span><span>(</span><span>String</span> task<span>,</span> <span>CountDownLatch</span> countDownLatch<span>)</span> <span>{</span>
            <span>this</span><span>.</span>task <span>=</span> task<span>;</span>
            <span>this</span><span>.</span>countDownLatch <span>=</span> countDownLatch<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>task <span>+</span> <span>" - 任务完成"</span><span>)</span><span>;</span>
                countDownLatch<span>.</span><span>countDown</span><span>(</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>// 假设有三个模块需要加载</span>
        <span>CountDownLatch</span> countDownLatch <span>=</span> <span>new</span> <span>CountDownLatch</span><span>(</span><span>3</span><span>)</span><span>;</span>

        <span>// 主任务</span>
        <span>new</span> <span>Thread</span><span>(</span><span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>try</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"等待数据加载..."</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"还有%d个前置任务"</span><span>,</span> countDownLatch<span>.</span><span>getCount</span><span>(</span><span>)</span><span>)</span><span>)</span><span>;</span>
                countDownLatch<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"数据加载完成，正式开始游戏！"</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>

        <span>// 前置任务</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载地图数据"</span><span>,</span> countDownLatch<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载人物模型"</span><span>,</span> countDownLatch<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载背景音乐"</span><span>,</span> countDownLatch<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br></div></div><p>输出：</p>
<blockquote>
<p>等待数据加载...<br>
还有3个前置任务<br>
加载人物模型 - 任务完成<br>
加载背景音乐 - 任务完成<br>
加载地图数据 - 任务完成<br>
数据加载完成，正式开始游戏！</p>
</blockquote>
<h3 id="_3-3-countdownlatch-原理"> 3.3 CountDownLatch 原理</h3>
<p>其实CountDownLatch类的原理挺简单的，内部同样是一个继承了AQS的实现类Sync，且实现起来还很简单，可能是JDK里面AQS的子类中最简单的实现了，有兴趣的读者可以去看看这个内部类的源码。</p>
<p>需要注意的是构造器中的<strong>计数值（count）实际上就是闭锁需要等待的线程数量</strong>。这个值只能被设置一次，而且CountDownLatch<strong>没有提供任何机制去重新设置这个计数值</strong>。</p>
<h2 id="四、cyclicbarrier"> 四、CyclicBarrier</h2>
<h3 id="_4-1-cyclicbarrier-介绍"> 4.1 CyclicBarrier 介绍</h3>
<p>CyclicBarrirer从名字上来理解是 “循环的屏障” 的意思。前面提到了 <code>CountDownLatch</code> 一旦计数值 <code>count</code> 被降为 0 后，就不能再重新设置了，它只能起一次 “屏障” 的作用。而 <code>CyclicBarrier</code> 拥有 <code>CountDownLatch</code> 的所有功能，还可以使用 <code>reset()</code> 方法重置屏障。</p>
<h3 id="_4-2-cyclicbarrier-barrier-被破坏"> 4.2 CyclicBarrier Barrier 被破坏</h3>
<p>如果参与者（线程）在等待的过程中，<code>Barrier</code> 被破坏，就会抛出 <code>BrokenBarrierException</code> 。可以用 <code>isBroken()</code> 方法检测Barrier是否被破坏。</p>
<ol>
<li>如果有线程已经处于等待状态，调用 <code>reset</code> 方法会导致已经在等待的线程出现 <code>BrokenBarrierException</code> 异常。并且由于出现了 <code>BrokenBarrierException</code> ，将会导致始终无法等待。</li>
<li>如果在等待的过程中，线程被中断，会抛出 <code>InterruptedException</code> 异常，并且这个异常会传播到其他所有的线程。</li>
<li>如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，其他线程会抛出 <code>BrokenBarrierException</code>，屏障被损坏。</li>
<li>如果超出指定的等待时间，当前线程会抛出 <code>TimeoutException</code> 异常，其他线程会抛出 <code>BrokenBarrierException</code> 异常。</li>
</ol>
<h3 id="_4-3-cyclicbarrier-案例"> 4.3 CyclicBarrier 案例</h3>
<p>我们同样用玩游戏的例子。如果玩一个游戏有多个 “关卡”，那使用 <code>CountDownLatch</code> 显然不太合适，那需要为每个关卡都创建一个实例。那我们可以使用 <code>CyclicBarrier</code> 来实现每个关卡的数据加载等待功能。</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>CyclicBarrierDemo</span> <span>{</span>
    <span>static</span> <span>class</span> <span>PreTaskThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>

        <span>private</span> <span>String</span> task<span>;</span>
        <span>private</span> <span>CyclicBarrier</span> cyclicBarrier<span>;</span>

        <span>public</span> <span>PreTaskThread</span><span>(</span><span>String</span> task<span>,</span> <span>CyclicBarrier</span> cyclicBarrier<span>)</span> <span>{</span>
            <span>this</span><span>.</span>task <span>=</span> task<span>;</span>
            <span>this</span><span>.</span>cyclicBarrier <span>=</span> cyclicBarrier<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>// 假设总共三个关卡</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"关卡%d的任务%s完成"</span><span>,</span> i<span>,</span> task<span>)</span><span>)</span><span>;</span>
                    cyclicBarrier<span>.</span><span>await</span><span>(</span><span>)</span><span>;</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> <span>|</span> <span>BrokenBarrierException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>CyclicBarrier</span> cyclicBarrier <span>=</span> <span>new</span> <span>CyclicBarrier</span><span>(</span><span>3</span><span>,</span> <span>(</span><span>)</span> <span>-></span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"本关卡所有前置任务完成，开始游戏..."</span><span>)</span><span>;</span>
        <span>}</span><span>)</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载地图数据"</span><span>,</span> cyclicBarrier<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载人物模型"</span><span>,</span> cyclicBarrier<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载背景音乐"</span><span>,</span> cyclicBarrier<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p>输出：</p>
<blockquote>
<p>关卡1的任务加载地图数据完成<br>
关卡1的任务加载背景音乐完成<br>
关卡1的任务加载人物模型完成<br>
本关卡所有前置任务完成，开始游戏...<br>
关卡2的任务加载地图数据完成<br>
关卡2的任务加载背景音乐完成<br>
关卡2的任务加载人物模型完成<br>
本关卡所有前置任务完成，开始游戏...<br>
关卡3的任务加载人物模型完成<br>
关卡3的任务加载地图数据完成<br>
关卡3的任务加载背景音乐完成<br>
本关卡所有前置任务完成，开始游戏...</p>
</blockquote>
<p>注意这里跟 <code>CountDownLatch</code> 的代码有一些不同。<code>CyclicBarrier</code> 没有分为 <code>await()</code> 和 <code>countDown()</code>，而是只有单独的一个 <code>await()</code> 方法。</p>
<p>一旦调用 <code>await()</code> 方法的线程数量等于构造方法中传入的任务总量（这里是3），就代表达到屏障了。 <code>CyclicBarrier</code> 允许我们 <mark>在达到屏障的时候可以执行一个任务</mark> ，可以在构造方法传入一个 <code>Runnable</code> 类型的对象。上述案例就是在达到屏障时，输出 “本关卡所有前置任务完成，开始游戏...” 。</p>
<div><p>区别</p>
<ul>
<li><code>CountDownLatch</code> 需要 <code>countDown</code> 至零，才能执行主任务</li>
<li><code>CyclicBarrier</code> 需要 <code>await</code> 至设定值，才能执行主任务</li>
</ul>
</div>
<div><pre><code><span>// 构造方法</span>
<span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>)</span> <span>{</span>
    <span>this</span><span>(</span>parties<span>,</span> <span>null</span><span>)</span><span>;</span>
<span>}</span>
<span>public</span> <span>CyclicBarrier</span><span>(</span><span>int</span> parties<span>,</span> <span>Runnable</span> barrierAction<span>)</span> <span>{</span>
    <span>// 具体实现</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_4-4-cyclicbarrier-原理"> 4.4 CyclicBarrier 原理</h3>
<p><code>CyclicBarrier</code> 虽说功能与 <code>CountDownLatch</code> 类似，但是实现原理却完全不同，CyclicBarrier内部使用的是 <code>Lock + Condition</code> 实现的等待/通知模式。详情可以查看这个方法的源码：</p>
<div><pre><code><span>private</span> <span>int</span> <span>dowait</span><span>(</span><span>boolean</span> timed<span>,</span> <span>long</span> nanos<span>)</span>
</code></pre>
<div><span>1</span><br></div></div><h2 id="五、phaser"> 五、Phaser</h2>
<h3 id="_5-1-phaser-介绍"> 5.1 Phaser 介绍</h3>
<p><code>Phaser</code> 这个单词是 “移相器，相位器” 的意思。这个类是从JDK 1.7 中出现的。</p>
<blockquote>
<p>移相器（Phaser）能够对波的相位进行调整的一种装置。任何传输介质对在其中传导的波动都会引入相移，这是早期模拟移相器的原理；现代电子技术发展后利用A/D、D/A转换实现了数字移相，顾名思义，它是一种不连续的移相技术，但特点是移相精度高。
移相器在雷达、导弹姿态控制、加速器、通信、仪器仪表甚至于音乐等领域都有着广泛的应用</p>
</blockquote>
<p><code>Phaser</code> 类有点复杂，这里只介绍一些基本的用法和知识点。详情可以查看JDK文档，文档里有这个类非常详尽的介绍。</p>
<p>前面我们介绍了 <code>CyclicBarrier</code> ，可以发现它在构造方法里传入“任务总量” <code>parties</code> 之后，就不能修改这个值了，并且每次调用 <code>await()</code> 方法也只能消耗一个 <code>parties</code> 计数。但 <code>Phaser</code> 可以动态地调整任务总量！</p>
<p>名词解释：</p>
<ul>
<li>
<p>party：对应一个线程，数量可以通过 <code>register</code> 或者构造参数传入;</p>
</li>
<li>
<p>arrive：对应一个 party 的状态，初始时是 unarrived，当调用 <code>arriveAndAwaitAdvance()</code> 或者 <code>arriveAndDeregister()</code> 进入 arrive 状态，可以通过 <code>getUnarrivedParties()</code> 获取当前未到达的数量;</p>
</li>
<li>
<p>register：注册一个party，每一阶段必须所有注册的party都到达才能进入下一阶段;</p>
</li>
<li>
<p>deRegister：减少一个party。</p>
</li>
<li>
<p>phase：阶段，当所有注册的 party 都 arrive 之后，将会调用 Phaser 的 <code>onAdvance()</code> 方法来判断是否要进入下一阶段。</p>
</li>
</ul>
<p>Phaser 终止的两种途径，Phaser 维护的线程执行完毕或者 <code>onAdvance()</code> 返回 <code>true</code>
此外 Phaser 还能维护一个树状的层级关系，构造的时候 <code>new Phaser(parentPhaser)</code> ，对于 Task 执行时间短的场景（竞争激烈），也就是说有大量的 <strong>party</strong>, 那可以把每个 Phaser 的任务量设置较小，多个 Phaser 共同继承一个父Phaser。</p>
<blockquote>
<p>Phasers with large numbers of parties that would otherwise experience heavy synchronization contention costs may instead be set up so that groups of sub-phasers share a common parent. This may greatly increase throughput even though it incurs greater per-operation overhead.</p>
<p>翻译：如果有大量的party，那许多线程可能同步的竞争成本比较高。所以可以拆分成多个子Phaser共享一个共同的父Phaser。这可能会大大增加吞吐量，即使它会带来更多的每次操作开销。</p>
</blockquote>
<h3 id="_5-2-phaser-案例"> 5.2 Phaser 案例</h3>
<p>还是游戏的案例。假设我们游戏有三个关卡，但只有第一个关卡有新手教程，需要加载新手教程模块。但后面的第二个关卡和第三个关卡都不需要。我们可以用Phaser来做这个需求。</p>
<p>代码：</p>
<div><div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><div>&nbsp;</div><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>class</span> <span>PhaserDemo</span> <span>{</span>
    <span>static</span> <span>class</span> <span>PreTaskThread</span> <span>implements</span> <span>Runnable</span> <span>{</span>

        <span>private</span> <span>String</span> task<span>;</span>
        <span>private</span> <span>Phaser</span> phaser<span>;</span>

        <span>public</span> <span>PreTaskThread</span><span>(</span><span>String</span> task<span>,</span> <span>Phaser</span> phaser<span>)</span> <span>{</span>
            <span>this</span><span>.</span>task <span>=</span> task<span>;</span>
            <span>this</span><span>.</span>phaser <span>=</span> phaser<span>;</span>
        <span>}</span>

        <span>@Override</span>
        <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>;</span> i <span>&lt;</span> <span>4</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
                <span>try</span> <span>{</span>
                    <span>// 第二次关卡起不加载NPC，跳过</span>
                    <span>if</span> <span>(</span>i <span>>=</span> <span>2</span> <span>&amp;&amp;</span> <span>"加载新手教程"</span><span>.</span><span>equals</span><span>(</span>task<span>)</span><span>)</span> <span>{</span>
                        <span>continue</span><span>;</span>
                    <span>}</span>
                    <span>Random</span> random <span>=</span> <span>new</span> <span>Random</span><span>(</span><span>)</span><span>;</span>
                    <span>Thread</span><span>.</span><span>sleep</span><span>(</span>random<span>.</span><span>nextInt</span><span>(</span><span>1000</span><span>)</span><span>)</span><span>;</span>
                    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"关卡%d，需要加载%d个模块，当前模块【%s】"</span><span>,</span>
                            i<span>,</span> phaser<span>.</span><span>getRegisteredParties</span><span>(</span><span>)</span><span>,</span> task<span>)</span><span>)</span><span>;</span>

                    <span>// 从第二个关卡起，不加载NPC</span>
                    <span>if</span> <span>(</span>i <span>==</span> <span>1</span> <span>&amp;&amp;</span> <span>"加载新手教程"</span><span>.</span><span>equals</span><span>(</span>task<span>)</span><span>)</span> <span>{</span>
                        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"下次关卡移除加载【新手教程】模块"</span><span>)</span><span>;</span>
                        phaser<span>.</span><span>arriveAndDeregister</span><span>(</span><span>)</span><span>;</span> <span>// 移除一个模块</span>
                    <span>}</span> <span>else</span> <span>{</span>
                        phaser<span>.</span><span>arriveAndAwaitAdvance</span><span>(</span><span>)</span><span>;</span>
                    <span>}</span>
                <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                    e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Phaser</span> phaser <span>=</span> <span>new</span> <span>Phaser</span><span>(</span><span>4</span><span>)</span> <span>{</span>
            <span>@Override</span>
            <span>protected</span> <span>boolean</span> <span>onAdvance</span><span>(</span><span>int</span> phase<span>,</span> <span>int</span> registeredParties<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>String</span><span>.</span><span>format</span><span>(</span><span>"第%d次关卡准备完成"</span><span>,</span> phase <span>+</span> <span>1</span><span>)</span><span>)</span><span>;</span>
                <span>return</span> phase <span>==</span> <span>3</span> <span>||</span> registeredParties <span>==</span> <span>0</span><span>;</span>
            <span>}</span>
        <span>}</span><span>;</span>

        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载地图数据"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载人物模型"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载背景音乐"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>new</span> <span>Thread</span><span>(</span><span>new</span> <span>PreTaskThread</span><span>(</span><span>"加载新手教程"</span><span>,</span> phaser<span>)</span><span>)</span><span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br></div></div><p>输出：</p>
<blockquote>
<p>关卡1，需要加载4个模块，当前模块【加载背景音乐】</p>
<p>关卡1，需要加载4个模块，当前模块【加载新手教程】</p>
<p>下次关卡移除加载【新手教程】模块</p>
<p>关卡1，需要加载3个模块，当前模块【加载地图数据】</p>
<p>关卡1，需要加载3个模块，当前模块【加载人物模型】</p>
<p>第1次关卡准备完成</p>
<p>关卡2，需要加载3个模块，当前模块【加载地图数据】</p>
<p>关卡2，需要加载3个模块，当前模块【加载背景音乐】</p>
<p>关卡2，需要加载3个模块，当前模块【加载人物模型】</p>
<p>第2次关卡准备完成</p>
<p>关卡3，需要加载3个模块，当前模块【加载人物模型】</p>
<p>关卡3，需要加载3个模块，当前模块【加载地图数据】</p>
<p>关卡3，需要加载3个模块，当前模块【加载背景音乐】</p>
<p>第3次关卡准备完成</p>
</blockquote>
<p>这里要注意关卡1的输出，在“加载新手教程”线程中调用了 <code>arriveAndDeregister()</code> 减少一个 party 之后，后面的线程使用 <code>getRegisteredParties()</code> 得到的是已经被修改后的 parties 了。但是当前这个阶段(phase)，仍然是需要 4 个 partie s都 arrive 才触发屏障的。从下一个阶段开始，才需要 3 个 parties 都 arrive 就触发屏障。</p>
<p>另外 Phaser 类用来控制某个阶段的线程数量很有用，但它并在意这个阶段具体有哪些线程 arrive，只要达到它当前阶段的 parties 值，就触发屏障。所以我这里的案例虽然制定了特定的线程（加载新手教程）来更直观地表述 Phaser 的功能，但是其实Phaser是没有分辨具体是哪个线程的功能的，它在意的只是数量，这一点需要读者注意。</p>
<h3 id="_5-3-phaser-原理"> 5.3 Phaser 原理</h3>
<p>Phaser类的原理相比起来要复杂得多。它内部使用了两个基于Fork-Join框架的原子类辅助：</p>
<div><pre><code><span>private</span> <span>final</span> <span>AtomicReference</span><span><span>&lt;</span><span>QNode</span><span>></span></span> evenQ<span>;</span>
<span>private</span> <span>final</span> <span>AtomicReference</span><span><span>&lt;</span><span>QNode</span><span>></span></span> oddQ<span>;</span>

<span>static</span> <span>final</span> <span>class</span> <span>QNode</span> <span>implements</span> <span>ForkJoinPool<span>.</span>ManagedBlocker</span> <span>{</span>
	<span>// 实现代码</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>有兴趣的读者可以去看看JDK源代码，这里不做过多叙述。</p>
<p>总的来说，CountDownLatch，CyclicBarrier，Phaser是一个比一个强大，但也一个比一个复杂。根据自己的业务需求合理选择即可。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-19T08:34:44.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">ArrayList 源码解读</title>
    <id>https://notes.lllllan.cn/java/container/source-code/arraylist/</id>
    <link href="https://notes.lllllan.cn/java/container/source-code/arraylist/"/>
    <updated>2022-03-22T12:02:50.000Z</updated>
    <content type="html"><![CDATA[<h2 id="基本属性"> 基本属性</h2>
<div><pre><code><span>// 默认的初始容量 10</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>

<span>// 空数组，容量为零</span>
<span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

<span>// 无参构造的空数组，容量为10</span>
<span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

<span>// 数据存放的数组</span>
<span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>

<span>// 当前大小，即数组内元素个数</span>
<span>private</span> <span>int</span> size<span>;</span>

<span>// 数组的最大大小</span>
<span>// 尝试分配更大的数组可能导致 OutOfMemoryError：请求的数组大小超过虚拟机限制</span>
<span>private</span> <span>static</span> <span>final</span> <span>int</span> MAX_ARRAY_SIZE <span>=</span> <span>Integer</span><span>.</span>MAX_VALUE <span>-</span> <span>8</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><h3 id="为什么有两个空数组"> 为什么有两个空数组</h3>
<div><p>EMPTY_ELEMENTDATA</p>
<p>根据指定的容量不同而选择</p>
<ul>
<li>如果是无参构造，即人为没有选择初始容量。那么默认的初始容量是10，则使用 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，在第一次添加元素的时候，会进行扩容到10</li>
<li>如果使用的构造方法中，明确指定了容量为零，则使用 <code>EMPTY_ELEMENTDATA</code></li>
</ul>
<p>只有无参构造函数中使用到了 <code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code>，这么做是因为 ArrayList 的默认初始容量是 10，如果遇到这个静态实例第一次添加元素，则会将其容量扩容到10，方便进行判断。</p>
</div>
<h2 id="构造方法"> 构造方法</h2>
<h3 id="无参构造"> 无参构造</h3>
<div><pre><code><span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
    <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><p>默认的初始容量为10，那为什么指向一个空数组？</p>
<ol>
<li>为什么指向一个空数组：（个人推测）等真正使用的时候再来请求空间，不急着消耗资源</li>
<li>为什么初始容量为10：数组的扩容是每次增加50%（扩容机制后面会讲）
<ol>
<li>设为10而不是0，是为了防止一开始的反复扩容而导致效率降低</li>
<li>设为10而不是更大，真的需要那么大容量再说，容量变大以后，每次扩容50%也不少了</li>
</ol>
</li>
</ol>
</div>
<h3 id="指定容量"> 指定容量</h3>
<ul>
<li>这个构造方法中并没有限定容量的上限，可能是否能创建成功要看虚拟机能获得的内存了</li>
<li>如果指定容量为零，存放数据的数组指向 <code>EMPTY_ELEMENTDATA</code></li>
<li>如果指定容量是负数，则会抛出异常 <code>IllegalArgumentException</code></li>
</ul>
<div><pre><code><span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
    <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span> initialCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="指定集合"> 指定集合</h3>
<p>将某个集合里的所有元素都复制到一个新的 ArrayList 中。</p>
<div><pre><code><span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
    <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
    <span>if</span> <span>(</span><span>(</span>size <span>=</span> a<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
        <span>if</span> <span>(</span>c<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> <span>ArrayList</span><span>.</span><span>class</span><span>)</span> <span>{</span>
            elementData <span>=</span> a<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>// replace with empty array.</span>
        elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h2 id="添加元素"> 添加元素</h2>
<p>四个添加方法中全都用到一个方法 ，主要作用就是根据添加元素的个数，计算数组至少需要的容量，从而判断是否需要扩容。</p>
<p>四个方法的返回类型都是 <code>boolean</code>，返回是否成功添加元素。</p>
<h3 id="添加单个元素"> 添加单个元素</h3>
<div><div><br><div>&nbsp;</div><br><br><br><br><br></div><pre><code><span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span> 
    <span>// 在数组末尾添加元素</span>
    elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
    <span>return</span> <span>true</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="添加单个元素到指定位置"> 添加单个元素到指定位置</h3>
<p></p>
<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
    <span>// 检查索引的合法性</span>
    <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span> 
    
    <span>// 索引后的所有元素整体后移</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>
    
    <span>// 在索引处添加指定元素</span>
    elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
    size<span>++</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="添加指定集合内所有元素"> 添加指定集合内所有元素</h3>
<div><div><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
    <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
    
    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span> 
    
    <span>// 将集合内的所有元素都复制到数组末尾</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>
    size <span>+=</span> numNew<span>;</span>
    <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><h3 id="添加指定集合内所有元素到指定位置"> 添加指定集合内所有元素到指定位置</h3>
<ul>
<li></li>
</ul>
<div><div><br><br><br><br><br><br><br><div>&nbsp;</div><br><br><br><br><br><br><br><br><br><br><br><br><br><br></div><pre><code><span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>int</span> index<span>,</span> <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
    <span>// 检查索引的合法性</span>
    <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

    <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
    <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
    
    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>

    <span>// 计算需要移动的元素个数</span>
    <span>int</span> numMoved <span>=</span> size <span>-</span> index<span>;</span>
    <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
        <span>// 索引后的所有元素整体后移</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> numNew<span>,</span> numMoved<span>)</span><span>;</span>

    <span>// 将集合内的所有元素都复制到索引处</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> index<span>,</span> numNew<span>)</span><span>;</span>
    
    size <span>+=</span> numNew<span>;</span>
    <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
<span>}</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="扩容机制"> 扩容机制</h2>
<h3 id="扩容发起"> 扩容发起</h3>
<p><code>minCapacity</code> 是在添加元素时候确定的容量，可以理解为需要存放这些数据的最小容量。</p>
<ul>
<li></li>
<li></li>
</ul>
<div><pre><code><span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>ensureExplicitCapacity</span><span>(</span><span>calculateCapacity</span><span>(</span>elementData<span>,</span> minCapacity<span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>// private void ensureCapacityInternal(int minCapacity) {</span>
<span>// 	   int capacity = calculateCapacity(elementData, minCapacity);</span>
<span>//     ensureExplicitCapacity(capacity);</span>
<span>// }</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="比较初始容量"> 比较初始容量</h3>
<p>一般情况下都是直接返回 <code>minCapacity</code></p>
<p>只有当数组还指向默认的空数组实例的时候，才会指定10的初始容量，将两个值取较大值返回</p>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>calculateCapacity</span><span>(</span><span>Object</span><span>[</span><span>]</span> elementData<span>,</span> <span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>// minCapacity 指定了需要的容量</span>
    <span>// 如果数组指向了默认的空数组实例，在指定容量和默认初始容量10中选较大值</span>
    <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
        <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> minCapacity<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h3 id="扩容检查"> 扩容检查</h3>
<p>当需要存放数据的最小容量正式超过当前数组的大小时候，就要开始扩容了。</p>
<ul>
<li></li>
</ul>
<div><pre><code><span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    modCount<span>++</span><span>;</span>

    <span>// overflow-conscious code</span>
    <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
        <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="扩容方法"> 扩容方法</h3>
<p>默认每次扩容50%，除非是一次性添加了太多的元素，扩容50%都不够，就会按照计算得到的最小容量来进行扩容。</p>
<p>并且规定有数组大小的上限，当超过上限时，还允许申请 <code>Integer.MAX_VALUE</code> 以内的大小，再大就要抛出异常了</p>
<ul>
<li></li>
</ul>
<div><pre><code><span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
    
    <span>// 在原来的容量基础上，扩容50%</span>
    <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
    
    <span>// 如果这个容量还不够，就按照指定的容量大小</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
        newCapacity <span>=</span> minCapacity<span>;</span>
    
    <span>// 如果扩容容量超过了最大值，就要判断是否造成内存溢出</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
        newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    
    elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="超大容量"> 超大容量</h3>
<p>当扩容到一定大小时，就要时刻注意这个值了。</p>
<p>源码中设置的最大数组大小是 <code>Integer.MAX_VALUE - 8</code>，当申请的容量超过这个值，就会返回 <code>Integer.MAX_VALUE</code>，再大呢就会变成负数了，这个时候将抛出异常 <code>OutOfMemoryError()</code></p>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
        <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
    <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span> MAX_ARRAY_SIZE<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><h2 id="删除元素"> 删除元素</h2>
<p>删除部分就不重点解读了，先略过</p>
<h3 id="删除指定元素"> 删除指定元素</h3>
<div><pre><code><span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
            <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
    <span>}</span> <span>else</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
            <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>
                <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span>
    <span>}</span>
    <span>return</span> <span>false</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="删除指定索引处元素"> 删除指定索引处元素</h3>
<div><pre><code><span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

    modCount<span>++</span><span>;</span>
    <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>

    <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
    <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span>
                         numMoved<span>)</span><span>;</span>
    elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>

    <span>return</span> oldValue<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="删除指定集合内所有元素"> 删除指定集合内所有元素</h3>
<div><pre><code><span>public</span> <span>boolean</span> <span>removeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
    <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>false</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="删除指定范围内所有元素"> 删除指定范围内所有元素</h3>
<div><pre><code><span>public</span> <span>boolean</span> <span>removeIf</span><span>(</span><span>Predicate</span><span><span>&lt;</span><span>?</span> <span>super</span> <span>E</span><span>></span></span> filter<span>)</span> <span>{</span>
    <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>filter<span>)</span><span>;</span>
    <span>// figure out which elements are to be removed</span>
    <span>// any exception thrown from the filter predicate at this stage</span>
    <span>// will leave the collection unmodified</span>
    <span>int</span> removeCount <span>=</span> <span>0</span><span>;</span>
    <span>final</span> <span>BitSet</span> removeSet <span>=</span> <span>new</span> <span>BitSet</span><span>(</span>size<span>)</span><span>;</span>
    <span>final</span> <span>int</span> expectedModCount <span>=</span> modCount<span>;</span>
    <span>final</span> <span>int</span> size <span>=</span> <span>this</span><span>.</span>size<span>;</span>
    <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>;</span> modCount <span>==</span> expectedModCount <span>&amp;&amp;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
        <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
        <span>final</span> <span>E</span> element <span>=</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>i<span>]</span><span>;</span>
        <span>if</span> <span>(</span>filter<span>.</span><span>test</span><span>(</span>element<span>)</span><span>)</span> <span>{</span>
            removeSet<span>.</span><span>set</span><span>(</span>i<span>)</span><span>;</span>
            removeCount<span>++</span><span>;</span>
        <span>}</span>
    <span>}</span>
    <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>
        <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

    <span>// shift surviving elements left over the spaces left by removed elements</span>
    <span>final</span> <span>boolean</span> anyToRemove <span>=</span> removeCount <span>></span> <span>0</span><span>;</span>
    <span>if</span> <span>(</span>anyToRemove<span>)</span> <span>{</span>
        <span>final</span> <span>int</span> newSize <span>=</span> size <span>-</span> removeCount<span>;</span>
        <span>for</span> <span>(</span><span>int</span> i<span>=</span><span>0</span><span>,</span> j<span>=</span><span>0</span><span>;</span> <span>(</span>i <span>&lt;</span> size<span>)</span> <span>&amp;&amp;</span> <span>(</span>j <span>&lt;</span> newSize<span>)</span><span>;</span> i<span>++</span><span>,</span> j<span>++</span><span>)</span> <span>{</span>
            i <span>=</span> removeSet<span>.</span><span>nextClearBit</span><span>(</span>i<span>)</span><span>;</span>
            elementData<span>[</span>j<span>]</span> <span>=</span> elementData<span>[</span>i<span>]</span><span>;</span>
        <span>}</span>
        <span>for</span> <span>(</span><span>int</span> k<span>=</span>newSize<span>;</span> k <span>&lt;</span> size<span>;</span> k<span>++</span><span>)</span> <span>{</span>
            elementData<span>[</span>k<span>]</span> <span>=</span> <span>null</span><span>;</span>  <span>// Let gc do its work</span>
        <span>}</span>
        <span>this</span><span>.</span>size <span>=</span> newSize<span>;</span>
        <span>if</span> <span>(</span>modCount <span>!=</span> expectedModCount<span>)</span> <span>{</span>
            <span>throw</span> <span>new</span> <span>ConcurrentModificationException</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        modCount<span>++</span><span>;</span>
    <span>}</span>

    <span>return</span> anyToRemove<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h2 id="其他方法"> 其他方法</h2>
<h3 id="检查索引合法性"> 检查索引合法性</h3>
<div><pre><code><span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>
        <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">ConcurrentHashMap 源码解读</title>
    <id>https://notes.lllllan.cn/java/container/source-code/concurrent-hashmap/</id>
    <link href="https://notes.lllllan.cn/java/container/source-code/concurrent-hashmap/"/>
    <updated>2022-04-19T02:17:11.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.itqiankun.com/article/concurrenthashmap-principle" target="_blank" rel="noopener noreferrer">一文彻底搞懂ConcurrentHashMap原理-IT乾坤技术博客 (itqiankun.com)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1461980" target="_blank" rel="noopener noreferrer">Java 经典面试题：为什么 ConcurrentHashMap 的读操作不需要加锁？ - 云+社区 - 腾讯云 (tencent.com)</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1873182" target="_blank" rel="noopener noreferrer">ConcurrentHashMap（JDK8） - 云+社区 - 腾讯云 (tencent.com)</a></li>
</ul>
</div>
<h2 id="hashmap"> HashMap</h2>
<p>HashMap 的问题在于不是线程安全的，ConcurrentHashMap 是 HashMap 的升级版，大体的实现原理和 HashMap 都是类似的，只是加了一下手段保证了线程安全。</p>
<h2 id="hashtable"> Hashtable</h2>
<p>Hashtable 是线程安全的，但是执行 <code>get/put/remove</code> 操作都需要锁住整个结构，效率很低。</p>
<p>Hashtable 是快速失败的，遍历时改变结构会报错 <code>ConcurrentModificationException</code></p>
<h2 id="concurrenthashmap"> ConcurrentHashMap</h2>
<h3 id="jdk-1-7"> JDK 1.7</h3>
<div><p>分段锁</p>
<ul>
<li>将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。</li>
<li>ConcurrentHashMap定位一个元素的过程需要进行两次Hash操作，第一次Hash定位到Segment，第二次Hash定位到元素所在的链表的头部。</li>
<li>JDK7中使用了 ReentrantLock</li>
<li>JDK7中的扩容是 <mark>每个Segment内部进行扩容，不会影响其他Segment</mark></li>
</ul>
</div>
<div><p>头插法</p>
<p>JDK 1.7 中，在链表中插入一个节点的时候，是在加在链表的头部。</p>
<p>据说，这种方法在扩容的时候会出现死循环，JDK 1.8 就改成了尾插法</p>
</div>
<p><img src="./README.assets/1587000999.png" alt="concurrenthashmap-principle" loading="lazy"></p>
<h3 id="jdk-1-8"> JDK 1.8</h3>
<div><p>Synchronized</p>
<p>JDK 1.8 中取消了分段锁，选择了和 HashMap 类似的操作方法，在一个 Entry 节点上进行同步，支持多线程的操作。</p>
</div>
<p><img src="./README.assets/1620.png" alt="img" loading="lazy"></p>
<h2 id="为什么-concurrenthashmap-的读操作不需要加锁"> 为什么 ConcurrentHashMap 的读操作不需要加锁？</h2>
<p><a href="https://cloud.tencent.com/developer/article/1461980" target="_blank" rel="noopener noreferrer">Java 经典面试题：为什么 ConcurrentHashMap 的读操作不需要加锁？ - 云+社区 - 腾讯云 (tencent.com)</a></p>
<ol>
<li>使用 synchronized 对 Entry 进行同步</li>
<li>get 过程中如果遇到扩容的时候，会调用标志正在扩容节点ForwardingNode的find方法，查找该节点，匹配就返回</li>
<li>使用 volatile 关键字保证共享遍历的可见性</li>
</ol>
<h2 id="jdk1-8-concurrenthashmap-扩容"> JDK1.8 ConcurrentHashMap 扩容</h2>
<p>首先，JDK8中是支持多线程扩容的，JDK8中的ConcurrentHashMap不再是分段，或者可以理解为每个桶为一段，在需要扩容时，首先会生成一个双倍大小的数组，生成完数组后，线程就会开始转移元素，在扩容的过程中，如果有其他线程在put，那么这个put线程会帮助去进行元素的转移，虽然叫转移，但是其实是基于原数组上的Node信息去生成一个新的Node的，也就是原数组上的Node不会消失，因为在扩容的过程中，如果有其他线程在get也是可以的。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-19T02:17:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HashMap 源码解读</title>
    <id>https://notes.lllllan.cn/java/container/source-code/hashmap/</id>
    <link href="https://notes.lllllan.cn/java/container/source-code/hashmap/"/>
    <updated>2022-04-13T12:00:52.000Z</updated>
    <content type="html"><![CDATA[<p>为了控制篇幅，只简单概括一下扩容机制，至于源码就不搬上来了，<s>写写真的很费劲</s></p>
<h2 id="构成"> 构成</h2>
<p>Map 使用 <code>Entry&lt;K,V&gt;</code> 来记录一个键值对，HashMap中的链表节点 <code>Node&lt;K, V&gt;</code> 正是继承了这个类。其中包含了key、value、hash和对下一个节点的引用next。几个节点链接在一起形成了一条链表。</p>
<p>另外还有一种树上节点 <code>TreeNode&lt;K, V&gt;</code> 则是继承了 <code>Node&lt;K, V&gt;</code> 。</p>
<p>HashMap 底层维护了一个数组，数组中的元素则是由以上的链表或者红黑树构成。简单理解就是节点较少时使用链表，节点较多时使用红黑树以提高查询效率。</p>
<h2 id="扩容"> 扩容</h2>
<p>存放数据的数组不是固定不变的，默认的初始大小是16。</p>
<p>HashMap 中有一个默认的加载因子 0.75，通过当前的数组大小 * 加载因子能够得到一个【扩容阈值】。当键值对数量到达该阈值，HashMap 会对它的数组进行两倍扩容。</p>
<h2 id="添加"> 添加</h2>
<p>往 HashMap 中添加一对映射关系，即往数组中添加一个节点。如果数组中已经存在 key，可以选择对已有的 value 进行替换或者保留；如果不存在，将创建一个新的节点加入到数组中。</p>
<div><p>替换或保留</p>
<p>此次添加的映射关系，可能在数组中已经存在了相同的key。可以根据需要，用新的value替换/覆盖原来的value；或是选择保留原来的value都行。</p>
<div><pre><code><span>// 如果存在key，选择替换原来的value</span>
<span>public</span> <span>V</span> <span>put</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>false</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span>

<span>// 如果存在key，选择保留原来的value</span>
<span>public</span> <span>V</span> <span>putIfAbsent</span><span>(</span><span>K</span> key<span>,</span> <span>V</span> value<span>)</span> <span>{</span>
    <span>return</span> <span>putVal</span><span>(</span><span>hash</span><span>(</span>key<span>)</span><span>,</span> key<span>,</span> value<span>,</span> <span>true</span><span>,</span> <span>true</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div></div>
<h3 id="节点"> 节点</h3>
<p>一对映射关系就是一个节点，创建之初的节点只是一个普通的链表节点。当有需要时才会转换成红黑树的节点、或者从红黑树的节点退化成链表节点。</p>
<h3 id="位置"> 位置</h3>
<p>添加一对映射关系，会根据 key 计算得到一个 hash，再通过数组的大小计算一个索引表示这个节点应该存放的位置：</p>
<div><pre><code>index <span>=</span> hash <span>&amp;</span> <span>(</span>table<span>.</span>length <span>-</span> <span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><div><p>hash & (table.length - 1)</p>
<p>为什么是这么个算法，根据规律，当这个 length 是2的幂次的时候满足如下等式</p>
<div><pre><code>hash <span>%</span> table<span>.</span>length <span>=</span> hash <span>&amp;</span> <span>(</span>table<span>.</span>length <span>-</span> <span>1</span><span>)</span>
</code></pre>
<div><span>1</span><br></div></div><p><code>hash % table.length</code> 其实很好理解，就是根据hash，将各种节点在数组中依次排放。但是上面的位运算在计算速度上更具优势，因此会可以保证数组的大小是2的幂次，以此来加快每个节点存放位置的计算。</p>
</div>
<h2 id="删除"> 删除</h2>
<p>可以从数组中删除一个节点，即删除了这对映射关系。可以选择含有 key 的映射关系，也可以选择严格相等的 key-value 键值对。</p>
<h2 id="链表的树化"> 链表的树化</h2>
<ol>
<li>
<p>节点的添加通常添加到对应链表的末尾。当满足以下两个条件时，则会将该链表，升级成红黑树：</p>
<ul>
<li>
<p>数组的大小不小于64</p>
</li>
<li>
<p>链表中节点个数不小于8</p>
</li>
</ul>
</li>
<li>
<p>当链表需要树化的时候，但碍于数组大小太小，会暂不树化，先对数组进行扩容。</p>
</li>
</ol>
<h2 id="红黑树的退化"> 红黑树的退化</h2>
<ol>
<li>
<p>在数组扩容的时候，会对原先的所有链表和红黑树，将其中所有的节点进行重新分布。</p>
<p>因为数组大小的改变，每个 key 在数组中的索引位置也会发生变化。有些红黑树在重新分布之后，节点数量会减少，当这个数量减少到6的时候，则会将该红黑树退化成链表。</p>
</li>
<li>
<p>在删除红黑树中的节点的时候，当节点数量少到一定程度，也会将该红黑树退化成链表</p>
</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-03T15:58:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HashTable 源码解读</title>
    <id>https://notes.lllllan.cn/java/container/source-code/hashtable/</id>
    <link href="https://notes.lllllan.cn/java/container/source-code/hashtable/"/>
    <updated>2022-04-13T13:20:21.000Z</updated>
    <content type="html"><![CDATA[<h2 id="构成"> 构成</h2>
<p>一对映射关系保存在一个 <code>Entry&lt;K, V&gt;</code> 中，继承自 <code>Map.Entry&lt;K, V&gt;</code>。</p>
<p>HashTable 底层维护一个数组，数组中的元素就是由节点组成的链表。</p>
<h2 id="索引"> 索引</h2>
<blockquote>
<p>这里的索引指一个节点在数组中存放的下标</p>
</blockquote>
<p>HashTable 的索引计算方式和 HashMap 有所不同。</p>
<div><pre><code>index <span>=</span> <span>(</span>hash <span>&amp;</span> <span>0x7FFFFFFF</span><span>)</span> <span>%</span> tab<span>.</span>length
</code></pre>
<div><span>1</span><br></div></div><h2 id="扩容"> 扩容</h2>
<p>HashTable 也采取了双倍扩容的策略，在每次扩容之后，会将原来数组中节点重新分布到新的数组中。</p>
<p>扩容时机：当总的节点数量不小于扩容阈值时 。</p>
<h2 id="添加"> 添加</h2>
<p>因为只有链表的存在，HashTable 的节点添加会更加简单。</p>
<p>另外一个区别在于 HashTable 的节点时添加在链表头，而 HashMap 的节点添加在链表末尾。</p>
<h2 id="线程安全"> 线程安全</h2>
<p>HashTable 的线程安全是由 synchronized 保证的。</p>
<p>大部分的方法都由 synchronized 修饰，当某个线程在操作时，需要获取并占有该对象，其他线程想要操作只能等待。代价就是效率会低很多。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-13T13:20:21.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java 集合框架基础知识</title>
    <id>https://notes.lllllan.cn/java/container/collection-basic/</id>
    <link href="https://notes.lllllan.cn/java/container/collection-basic/"/>
    <updated>2022-03-16T10:37:26.000Z</updated>
    <content type="html"><![CDATA[<div><p>本文转载自一下文章，略有改动</p>
<ul>
<li><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">主页 | JavaGuide</a></li>
</ul>
</div>
<h2 id="一、集合概述"> 一、集合概述</h2>
<h3 id="_1-0-java集合概览"> 1.0 Java集合概览</h3>
<p><img src="./README.assets/java-collection-hierarchy.71519bdb.png" alt="img" loading="lazy"></p>
<h3 id="_1-1-集合框架底层数据结构"> 1.1 集合框架底层数据结构</h3>
<ul>
<li><code>Collection</code>
<ul>
<li><code>List</code>
<ul>
<li><code>ArrayList</code>: Object[] 数组</li>
<li><code>Vector</code>: Object[] 数组</li>
<li><code>LinkedList</code>: 双向链表</li>
</ul>
</li>
<li><code>Set</code>
<ul>
<li><code>HashSet</code>（无序）: 基于 <code>HashMap</code> 实现</li>
<li><code>LinkedHashSet</code>: <code>HashSet</code> 的子类，基于 <code>LinkedHashMap</code> 实现</li>
<li><code>TreeSet</code>（有序）: 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
<li><code>Queue</code>
<ul>
<li><code>PriorityQueue</code> : Object[] 数组实现二叉堆</li>
<li><code>ArrayQueue</code> : Object[] 数组 + 双指针</li>
</ul>
</li>
</ul>
</li>
<li><code>Map</code>
<ul>
<li><code>HashMap</code> : 数组 + 链表 + 红黑树（链表根据大小和阈值进行扩容，扩容到一定大小转换为红黑树）</li>
<li><code>LinkedMap</code> : 继承自 <code>HashMap</code>，增加一条双向链表以保持插入顺序</li>
<li><code>Hashtable</code> : 数组 + 链表</li>
<li><code>TreeMap</code> : 红黑树</li>
</ul>
</li>
</ul>
<h3 id="_1-2-集合的选择"> 1.2 集合的选择</h3>
<p><img src="./README.assets/image-20220118101609300.png" alt="image-20220118101609300" loading="lazy"></p>
<h3 id="_1-3-collection-和-collections"> 1.3 Collection 和 Collections</h3>
<ul>
<li>Collection是集合类的上级接口，子接口有 Set、List、LinkedList、ArrayList、Vector、Stack、 Set；</li>
<li>Collections是集合类的一个帮助类， 它包含有各种有关集合操作的静态多态方法，用于实现对各种 集合的搜索、排序、线程安全化等操作。此类不能实例化，就像一个工具类，服务于Java的 Collection框架。</li>
</ul>
<h3 id="_1-3-fail-fast"> 1.3 fail-fast</h3>
<p>fail-fast 机制是 Java 集合（Collection）中的一种错误机制。当多个线程对同一个集合的内容进行 操作时，就可能会产生 fail-fast 事件。</p>
<p>例如：当某一个线程 A 通过 iterator 去遍历某集合的过程中，若该集合的内容被其他线程所改变 了，那么线程 A 访问集合时，就会抛出 ConcurrentModificationException 异常，产生 fail-fast 事 件。这里的操作主要是指 add、remove 和 clear，对集合元素个数进行修改。</p>
<p>解决办法：建议使用“java.util.concurrent 包下的类”去取代“java.util 包下的类”。</p>
<p>可以这么理解：在遍历之前，把 modCount 记下来 expectModCount，后面 expectModCount 去 和 modCount 进行比较，如果不相等了，证明已并发了，被修改了，于是抛出 <code>ConcurrentModificationException</code> 异常。</p>
<h2 id="二、list"> 二、List</h2>
<h3 id="_2-1-arraylist-和-vector-的区别"> 2.1 ArrayList 和 Vector 的区别</h3>
<p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全的（代价就是效率差一些）。</p>
<h3 id="_2-2-arraylist-和-linkedlist-的区别"> 2.2 ArrayList  和 LinkedList 的区别</h3>
<p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="_2-3-randomaccess-接口"> 2.3 RandomAccess 接口</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>RandomAccess</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch()</code>方法中，它要判断传入的 list 是否 <code>RamdomAccess</code>的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>
    <span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>
        <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h3 id="_2-4-arraylist-扩容机制"> 2.4 ArrayList 扩容机制</h3>
<p>详见另一篇 <a href="../2-source-code/1-arraylist">ArrayList 源码解读</a></p>
<h2 id="三、set"> 三、Set</h2>
<h3 id="_3-1-comparable-和-comparator-的区别"> 3.1 comparable 和 Comparator 的区别</h3>
<ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<h4 id="_3-1-1-comparator-定制排序"> 3.1.1 Comparator 定制排序</h4>
<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"原始数组:"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>// void reverse(List list)：反转</span>
<span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.reverse(arrayList):"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>

<span>// void sort(List list),按自然排序的升序排序</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.sort(arrayList):"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>// 定制排序的用法</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>
        <span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"定制排序后："</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>Output:</p>
<div><pre><code>原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_3-1-2-重写-compareto-方法"> 3.1.2 重写 compareTo 方法</h4>
<div><pre><code><span>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>
<span>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>
<span>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>
<span>public</span>  <span>class</span> <span>Person</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Person</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>></span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>&lt;</span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> pdata <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"张三"</span><span>,</span> <span>30</span><span>)</span><span>,</span> <span>"zhangsan"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"李四"</span><span>,</span> <span>20</span><span>)</span><span>,</span> <span>"lisi"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"王五"</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>"wangwu"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"小红"</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>"xiaohong"</span><span>)</span><span>;</span>
    <span>// 得到key的值的同时得到key所对应的值</span>
    <span>Set</span><span><span>&lt;</span><span>Person</span><span>></span></span> keys <span>=</span> pdata<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>Person</span> key <span>:</span> keys<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>"-"</span> <span>+</span> key<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Output：</p>
<div><pre><code>5-小红
10-王五
20-李四
30-张三
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h2 id="四、map"> 四、Map</h2>
<h3 id="_4-1-hashmap-和-hashtable-的区别"> 4.1 HashMap 和 HashTable 的区别</h3>
<ol>
<li>两者父类不同
<ol>
<li>HashMap 继承自 AbstractMap，HashTable 继承自 Dictionary</li>
<li>他们都实现了 map、Cloneable（可复制）、Serializable（可序列化）三个接口</li>
</ol>
</li>
<li>对外提供接口不同
<ol>
<li>HashTable 中提供方法 elements()：返回 value 的枚举</li>
<li>HashTable 中提供方法 contains()：实际上就是 containsValue()</li>
</ol>
</li>
<li>对 null 的支持不同
<ol>
<li>HashTable：key 和 value 都不能为 null</li>
<li>HashMap：key 和 value 都可以为 null</li>
</ol>
</li>
<li>安全性不同
<ol>
<li>HashMap 是线程不安全的，但是效率更高</li>
<li>HashTable 是线程安全的</li>
<li>ConcurrentHashMap 是线程安全的，效率比 HashTable 高，比 HashMap 低</li>
</ol>
</li>
<li>初始容量大小、扩充容量大小不同</li>
<li>计算 hash 值的方法不同</li>
</ol>
<h3 id="_4-2-hashmap-的容量为什么是2的n次方"> 4.2 HashMap 的容量为什么是2的n次方</h3>
<p>在 HashMap 中，键值对的插入，需要先获得 key 的hash，然后根据当前的容量计算应该存放的位置，也就是 <code>hash % n</code></p>
<blockquote>
<p>取余（%）操作中如果除数是 2 的幂次，则等价于与其除数减一的与（&amp;）操作（也就是说 hash % length == hash &amp;(length - 1) 的前提是 length 是 2 的 n 次方）。并且，采用二进 制位操作 &amp; ，相对于 % 能够提高运算效率。</p>
</blockquote>
<p>所以只要控制容量的大小，就能从这里提高效率</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">常见面试题</title>
    <id>https://notes.lllllan.cn/java/concurrent/</id>
    <link href="https://notes.lllllan.cn/java/concurrent/"/>
    <updated>2022-04-14T08:09:13.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://www.cnblogs.com/greta/p/5624839.html" target="_blank" rel="noopener noreferrer">如何正确地停止一个线程？ - 王晓符 - 博客园 (cnblogs.com)</a></li>
<li><a href="https://blog.csdn.net/meism5/article/details/90238268" target="_blank" rel="noopener noreferrer">notify() 和 notifyAll() 有什么区别？_ConstXiong的博客-CSDN博客_notifyall</a></li>
<li><a href="https://blog.csdn.net/zhu_fangyuan/article/details/110455386" target="_blank" rel="noopener noreferrer">65. SynchronizedMap 和 ConcurrentHashMap 有什么区别？_江湖@小小白的博客-CSDN博客</a></li>
<li><a href="https://www.cnblogs.com/cxuanBlog/p/11679883.html" target="_blank" rel="noopener noreferrer">看完你就明白的锁系列之自旋锁 - 程序员cxuan - 博客园 (cnblogs.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/138689342" target="_blank" rel="noopener noreferrer">拜托，线程间的通信真的很简单。 - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/qq_41359051/article/details/89673188" target="_blank" rel="noopener noreferrer">什么是上下文切换_有关心情的博客-CSDN博客_上下文切换</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/258956479" target="_blank" rel="noopener noreferrer">送命题：进程切换与线程切换的区别 - 知乎 (zhihu.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/107649830" target="_blank" rel="noopener noreferrer">Java 什么是守护线程 - 知乎 (zhihu.com)</a></li>
</ul>
</div>
<h2 id="上下文切换-▲"> 上下文切换 ▲</h2>
<p><a href="https://blog.csdn.net/qq_41359051/article/details/89673188" target="_blank" rel="noopener noreferrer">什么是上下文切换_有关心情的博客-CSDN博客_上下文切换</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/258956479" target="_blank" rel="noopener noreferrer">送命题：进程切换与线程切换的区别 - 知乎 (zhihu.com)</a></p>
<p>还是有点模糊，稍后再看。</p>
<h2 id="如何停止一个线程"> 如何停止一个线程</h2>
<h3 id="stop"> stop</h3>
<p>stop()方法以及作废，因为如果强制让线程停止有可能使一些清理性的工作得不到完成。另外一个情况就是对锁定的对象进行了解锁，导致数据得不到同步的处理，出现数据不一致的问题。</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>private</span> <span>int</span> i <span>=</span> <span>0</span><span>;</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>super</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>
        <span>try</span> <span>{</span>
            <span>while</span> <span>(</span><span>true</span><span>)</span><span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"i="</span> <span>+</span> i<span>)</span><span>;</span>
                i<span>++</span><span>;</span>
                <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>200</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
            e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Run</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>Thread</span> thread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>
        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>
        thread<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="interrupt"> interrupt</h3>
<p>interrupt()方法的使用效果并不像for+break语句那样，马上就停止循环。调用interrupt方法是在当前线程中打了一个停止标志，并不是真的停止线程。</p>
<p>因此可以使用interrupt配合条件判断或者异常捕捉使用，当检查到线程被interrupt，即可退出循环，让线程结束。</p>
<div><pre><code><span>public</span> <span>class</span> <span>MyThread</span> <span>extends</span> <span>Thread</span> <span>{</span>
    <span>public</span> <span>void</span> <span>run</span><span>(</span><span>)</span><span>{</span>
        <span>super</span><span>.</span><span>run</span><span>(</span><span>)</span><span>;</span>

        <span>while</span><span>(</span><span>true</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>getName</span><span>(</span><span>)</span> <span>+</span> <span>" is running"</span><span>)</span><span>;</span>
            
            tru <span>{</span>
                <span>sleep</span><span>(</span><span>1000</span><span>)</span><span>;</span>
            <span>}</span> <span>catch</span><span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
                <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"被停止"</span><span>)</span><span>;</span>
                <span>break</span><span>;</span>
            <span>}</span>
        <span>}</span>

    <span>}</span>
<span>}</span>

<span>public</span> <span>class</span> <span>Run</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span> args<span>[</span><span>]</span><span>)</span> <span>throws</span> <span>InterruptedException</span> <span>{</span>
        <span>Thread</span> thread <span>=</span> <span>new</span> <span>MyThread</span><span>(</span><span>)</span><span>;</span>
        thread<span>.</span><span>start</span><span>(</span><span>)</span><span>;</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>2000</span><span>)</span><span>;</span>
        thread<span>.</span><span>stop</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br></div></div><h2 id="线程通信"> 线程通信</h2>
<p><a href="./1/5/">线程通信方式</a></p>
<p><a href="https://zhuanlan.zhihu.com/p/138689342" target="_blank" rel="noopener noreferrer">拜托，线程间的通信真的很简单。 - 知乎 (zhihu.com)</a></p>
<p>通信大体可以分为【共享内存】、【消息传递】和【管道流】</p>
<ul>
<li>
<p>共享内存：</p>
<ul>
<li>volatile修饰的变量</li>
<li>临界区</li>
</ul>
</li>
<li>
<p>消息传递：</p>
<ul>
<li>等待/通知机制：使用锁的 <code>wait()</code> 和 <code>notify()</code> 来阻塞和唤醒线程。</li>
<li>join：阻塞当前线程去执行另一线程x，直到x的执行结束之后才会接触当前线程的阻塞。</li>
</ul>
</li>
<li>
<p>管道输入输出：</p>
</li>
</ul>
<h2 id="线程安全"> 线程安全</h2>
<p>如果你的代码在多线程下执行和在单线程下执行永远都能获得一样的结果，那么这个代码就是线程安全的。</p>
<ol>
<li>不可变。像String、Integer、Long这些，都是final类型的类，任何一个线程都改变不了它们的值，要改变除非新创建一个，因此这些不可变对象不需要任何同步手段就可以直接在多线程环境下使用</li>
<li>绝对线程安全。不管运行时环境如何，调用者都不需要额外的同步措施。要做到这一点通常需要付出许多额外的代价，Java中标注自己是线程安全的类，实际上绝大多数都不是线程安全的，不过绝对线程安全的类，Java中也有，比方说CopyOnWriteArrayList、CopyOnWriteArraySet</li>
<li>相对线程安全。相对线程安全也就是我们通常意义上所说的线程安全，像 Vector 这种，add、remove方法都是原子操作，不会被打断，但也仅限于此，如果有个线程在遍历某个Vector、有个线程同时在add这个Vector，99% 的情况下都会出现 <code>ConcurrentModificationException</code>，也就是 fail-fast 机制。</li>
<li>非线程安全。这个就没什么好说的了，ArrayList、LinkedList、HashMap等都是线程非安全的类</li>
</ol>
<h3 id="线程安全需要保证的特性"> 线程安全需要保证的特性</h3>
<ul>
<li>原子性。线程的操作中途不会被其他线程干扰，需要通过同步机制实现。</li>
<li>可见性。某个线程修改了共享变量，需要立即通知到其他线程。</li>
<li>有序性。保证线程内串行语义，避免指令重排序。</li>
</ul>
<h2 id="线程方法"> 线程方法</h2>
<h3 id="notify-和-notifyall"> notify 和 notifyAll</h3>
<p><a href="https://blog.csdn.net/meism5/article/details/90238268" target="_blank" rel="noopener noreferrer">notify() 和 notifyAll() 有什么区别？_ConstXiong的博客-CSDN博客_notifyall</a></p>
<p>先解释两个概念。</p>
<ul>
<li>锁池：获得锁的线程能够执行，没有获得锁的线程则在锁池中争夺这个锁。</li>
<li>等待池：某个线程获得锁之后，调用了 wait() 方法，则会进入等待池。进入等待池的线程不会去争夺锁。</li>
</ul>
<p>区别：notify() 方法随机唤醒对象的等待池中的一个线程，进入锁池；notifyAll() 唤醒对象的等待池中的所有线程，进入锁池。</p>
<p>只是调入锁池，但是一定只有一个线程能够获得锁并执行。</p>
<h3 id="sleep-和-wait"> sleep 和 wait</h3>
<p><a href="./1/5/#_5-2-sleep方法">sleep和wait的区别</a></p>
<p>sleep是Thread的方法，可以在任意位置使用，让线程睡眠。</p>
<p>wait是Object的方法，必须在同步块/同步方法中使用。wait方法是让当前获得锁的线程释放锁，因此必须在同步块/同步方法中使用，确保该线程获得了锁。</p>
<div><pre><code><span>synchronized</span> <span>(</span>lock<span>)</span> <span>{</span>
    <span>try</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before wait"</span><span>)</span><span>;</span>
        
        lock<span>.</span><span>wait</span><span>(</span><span>)</span><span>;</span>

        <span>// 进入等待被唤醒之后，会从这里重新执行</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after wait"</span><span>)</span><span>;</span>
    <span>}</span> <span>catch</span> <span>(</span><span>InterruptedException</span> e<span>)</span> <span>{</span>
        e<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="yield"> yield</h3>
<p>Yield方法可以暂停当前正在执行的线程对象，让其它有相同优先级的线程执行。它是一个静态方法而且只保证当前线程放弃CPU占用而不能保证使其它线程一定能占用CPU，执行yield()的线程有可能在进入到暂停状态后马上又被执行。</p>
<h3 id="wait-和-notify-必须要在同步块中调用"> wait 和 notify 必须要在同步块中调用</h3>
<ol>
<li>这些方法都是对象级别的，时从锁出发去执行的方法。因此只有获得了独占锁的线程，才能够去调用该对象的方法</li>
<li>如果不这么做，就会抛出 <code>IllegalMonitorStateException</code></li>
<li>为了避免 wait 和 notify 之间产生竞态条件</li>
</ol>
<h3 id="interrupted-和-isinterrupted-★"> interrupted 和 isInterrupted ★</h3>
<div><pre><code><span>public</span> <span>static</span> <span>boolean</span> <span>interrupted</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>currentThread</span><span>(</span><span>)</span><span>.</span><span>isInterrupted</span><span>(</span><span>true</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>boolean</span> <span>isInterrupted</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>isInterrupted</span><span>(</span><span>false</span><span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>native</span> <span>boolean</span> <span>isInterrupted</span><span>(</span><span>boolean</span> <span>ClearInterrupted</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>看源代码，两个方法都会调用同一个方法 <code>isInterrupted(boolean ClearInterrupted)</code>，返回值是该线程的中断标识。</p>
<p>区别在于，调用 <code>interrupted()</code> 方法会清楚中断状态，而 <code>isInterrupted()</code> 方法并不会。</p>
<h2 id="synchronized-和锁-★"> synchronized 和锁 ★</h2>
<p>synchronized 关键字解决的是多个线程之间访问资源的同步性，synchronized 关键字可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p>
<p><a href="./2/9/">synchronized和锁</a></p>
<p>Java 早期版本 synchronized 属于重量级锁，效率底下。Java 6 为了减少获得锁和释放锁带来的性能消耗，引入了【偏向锁】和【轻量级锁】。</p>
<div><p>自旋锁</p>
<p>当一个线程尝试去获取某一把锁的时候，如果这个锁此时已经被别人获取（占用），那么此线程就无法获取到这把锁，该线程将会等待，间隔一段时间后会再次尝试获取。这种采用循环加锁 -&gt; 等待的机制被称为【自旋锁(spinlock)】</p>
<p>自旋锁尽可能的减少线程的阻塞，这对于锁的竞争不激烈，且占用锁时间非常短的代码块来说性能能大幅度的提升，因为自旋的消耗会小于线程阻塞挂起再唤醒的操作的消耗，这些操作会导致线程发生两次上下文切换！</p>
<p>但是如果锁的竞争激烈，或者持有锁的线程需要长时间占用锁执行同步块，这时候就不适合使用自旋锁了，因为自旋锁在获取锁前一直都是占用 cpu 做无用功，占着 XX 不 XX，同时有大量线程在竞争一个锁，会导致获取锁的时间很长，线程自旋的消耗大于线程阻塞挂起操作的消耗，其它需要 cpu 的线程又不能获取到 cpu，造成 cpu 的浪费。所以这种情况下我们要关闭自旋锁。</p>
</div>
<div><p>自适应锁</p>
<p>自适应锁就是自适应的自旋锁，自旋的时间不是固定时间，而是由前一次在同一个锁上的自旋时间和锁的持有者状态来决定。</p>
<p>简单来说就是线程如果自旋成功了，则下次自旋的次数会更多，如果自旋失败了，则自旋的次数就会减少。</p>
</div>
<div><p>偏向锁</p>
<blockquote>
<p>当第一个线程获取锁，或者在没有其他线程占用锁的时候，此时的锁是偏向锁。</p>
</blockquote>
<p>偏向锁在资源无竞争情况下消除了同步语句，连CAS操作都不做了，提高了程序的运行性能</p>
</div>
<div><p>轻量级锁</p>
<blockquote>
<p>当多个线程竞争同一把锁的时候，偏向锁会升级为轻量级锁。</p>
</blockquote>
<p>线程通过自旋来获取锁。消耗cpu，但是减少了线程阻塞挂起再唤醒的消耗。</p>
</div>
<div><p>重量级锁</p>
<blockquote>
<p>线程长时间的自旋依然不能得到锁就会导致锁升级为重量级锁。</p>
</blockquote>
<p>获取不到锁的线程会被阻塞挂起，等待占有锁的线程执行完之后来唤醒他们。</p>
</div>
<h3 id="synchronized-和-reentrantlock-★"> synchronized 和 ReentrantLock ★</h3>
<p>不太懂。<a href="./3/14/">Java锁</a></p>
<p>他们都是加锁方式同步，而且都是阻塞式的同步。当一个线程获得了对象锁，进入了同步块，其他访问该同步块的线程都必须阻塞在同步块外面等待。</p>
<p>ReentrantLock提供了一些功能：</p>
<ol>
<li>等待可中断。持有锁的线程长期不释放的时候，正在等待的线程可以选择放弃等待，相对于synchronized来说可以避免出现死锁的情况</li>
<li>公平锁。ReentrantLock默认是非公平锁，可以通过参数设为公平锁（多个线程等待同一个锁时必须按照申请锁的时间顺序来获得锁），但是性能不是很好。</li>
<li>锁绑定多个条件。一个ReentrantLock对象可以同时绑定多个对象</li>
</ol>
<h3 id="synchronizedmap-和-concurrentmap-▲"> SynchronizedMap 和 ConcurrentMap ▲</h3>
<p>（还有点小问题）</p>
<p><a href="https://blog.csdn.net/zhu_fangyuan/article/details/110455386" target="_blank" rel="noopener noreferrer">65. SynchronizedMap 和 ConcurrentHashMap 有什么区别？_江湖@小小白的博客-CSDN博客</a></p>
<ol>
<li>SynchronizedMap 一次锁住整张表来保证线程安全，所以每次只能有一个线程来访问Map.</li>
<li>ConcurrentHashMap 中则是一次锁住一个桶。ConcurrentHashMap 默认将 hash 表分为 16 个桶，诸如get、put、remove 等常用操作只锁当前需要用到的桶。这样，原来只能一个线程进入，现在却能同时有 16 个写线程执行，并发性能的提升是显而易见的。</li>
<li>另外 ConcurrrentHashMap 使用一种不同的迭代方式。在这种迭代方式中，当 iterator 被创建后集合再发生改变就不再是抛出 ConcurrentModificationException，取而代之的是在改变 new 新的数据从而不影响原有的数据，iterator 完成后再将头指针替换为新的数据，这样 iterator 线程可以使用原来老的数据，而写线程也可以并发的完成改变。</li>
</ol>
<h2 id="悲观锁和乐观锁"> 悲观锁和乐观锁</h2>
<p><a href="./2/10/">乐观锁 &amp; 悲观锁 &amp; CAS</a></p>
<h2 id="cas-★"> CAS ★</h2>
<p><a href="./2/10/">CompareAndSwap</a></p>
<h2 id="volatile-★"> volatile ★</h2>
<p><a href="./2/8/">volatile</a></p>
<h3 id="内存可见性"> 内存可见性</h3>
<p>因为每个线程在自己私有的工作内存中对共享变量有一份拷贝（类的（静态）成员变量），所以当一个线程试图修改一个成员变量的时候，其实只修改了自己工作内存中的拷贝，其他线程不能知道这次修改。这就是不可见性</p>
<p>使用 volatile 修饰以后，当一个线程试图修改一个成员变量，会同时修改主内存中的值；当其他线程试图获取这个成员变量，也会到主内存中重新读取。这就是保证可见性</p>
<h3 id="禁止重排序"> 禁止重排序</h3>
<p>计算机在执行程序时，为了提高性能，编译器和处理器常常会对指令做重排。</p>
<p>但是在多线程下，这个重排序可能会导致一些问题，见 <a href="./2/8/#_2-2-禁止重排序">禁止重排序 | 多线程下重排序的危害</a></p>
<p>使用 volatile 修饰以后，会对重排序做一定的限制。</p>
<h2 id="线程池-★"> 线程池 ★</h2>
<p>线程池原理、执行流程、拒绝策略，<a href="./3/12/">线程池</a></p>
<p>线程池如何使用 —— 线程池的好处 —— 线程池的启动策略</p>
<h3 id="线程池的优点"> 线程池的优点</h3>
<ol>
<li>降低资源的消耗。线程本身是一种资源，创建和销毁线程会有CPU开销，线程池可以<strong>复用已创建的线程</strong>。</li>
<li>提高任务执行的响应速度。任务执行时，可以不必等到线程创建完之后再执行。</li>
<li>方便线程并发数的管控。线程若是无限制的创建，不仅会额外消耗大量系统资源，更是占用过多资源而阻塞系统或oom等状况，从而降低系统的稳定性。线程池能有效管控线程，统一分配、调优，提供资源使用率</li>
<li>更强大的功能，线程池提供了定时、定期以及可控线程数等功能的线程池，使用方便简单。</li>
</ol>
<h3 id="常用线程池"> 常用线程池</h3>
<ul>
<li>newSingleThreadExecutor：创建一个单线程的线程池，此线程池保证所有任务的执行顺序按照任务的提交顺序执行。</li>
<li>newFixedThreadPool：创建固定大小的线程池，每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。</li>
<li>newCachedThreadPool：创建一个可缓存的线程池，此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。</li>
<li>newScheduledThreadPool：创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。</li>
</ul>
<h3 id="线程池方法-submit-和-execute"> 线程池方法 submit() 和 execute()</h3>
<ul>
<li>两个方法都可以向线程池提交任务。</li>
<li>execute() 方法的返回类型是 void，它定义在 Executor 接口中。而 submit() 方法可以返回持有计算结果的 Future 对象，它定义在 ExecutorService 接口中，它扩展了 Executor 接口</li>
<li>其它线程池类像 ThreadPoolExecutor 和 ScheduledThreadPoolExecutor 都有这些方法。</li>
</ul>
<h3 id="常用队列"> 常用队列</h3>
<p><a href="./3/13/">阻塞队列</a></p>
<ul>
<li><code>ArrayBlockingQueue</code>，基于数组结构的有界阻塞队列，按先进先出原则进行排序</li>
<li><code>LinkedBlockingQueue</code>，基于链表的阻塞队列，按照先进先出排序元素，吞吐量高于 ArrayBlocklingQueue</li>
<li><code>SynchronousQueue</code>，不存储元素的阻塞队列</li>
<li><code>PriorityBlockingQueue</code>，具有优先级的无限阻塞队列</li>
<li><code>DelayQueue</code>，队列中的元素只有当其指定的延迟时间到了，才能够从队列中获取到该元素；没有大小限制的队列，因此往队列中插入数据的操作（生产者）永远不会被阻塞，而只有获取数据的操作（消费者）才会被阻塞。</li>
</ul>
<h2 id="threadlocal-原理"> ThreadLocal 原理</h2>
<p>没太看懂，先放一下。</p>
<h2 id="jmm-★"> JMM ★</h2>
<p><a href="./2/6/">Java内存模型</a></p>
<h2 id="aqs-★"> AQS ★</h2>
<p><a href="./2/11/">抽象队列同步器</a></p>
<h2 id="守护线程"> 守护线程</h2>
<p><a href="https://zhuanlan.zhihu.com/p/107649830" target="_blank" rel="noopener noreferrer">Java 什么是守护线程 - 知乎 (zhihu.com)</a></p>
<p>守护线程可以理解是一种服务线程。和用户线程的区别在于，当所有的用户线程都执行结束了，即时守护线程还在执行，但也没有执行的必要了，此时就可以结束程序了。</p>
<p>比如垃圾回收线程就是典型的守护线程。所有的用户线程都执行完了，也没有再回收垃圾的必要了，直接结束程序即可。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-10T04:37:20.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Vector 源码解读</title>
    <id>https://notes.lllllan.cn/java/container/source-code/vector/</id>
    <link href="https://notes.lllllan.cn/java/container/source-code/vector/"/>
    <updated>2022-04-18T15:41:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://blog.csdn.net/yt_19940616/article/details/90183781" target="_blank" rel="noopener noreferrer">Java集合 Vector的底层详解_Dre丿的博客-CSDN博客_java vector底层</a></li>
</ul>
</div>
<p>类似 ArrayList，底层都是维护一个数组，只是大部分方法前用 synchronized 修饰，实现线程安全。</p>
<p>扩容机制上，vector 可以指定增长系数 increment，每次扩容容量增加一个 increment；若不指定则每次双倍扩容</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-18T15:41:07.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">垃圾收集算法</title>
    <id>https://notes.lllllan.cn/java/jvm/3/3/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/3/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<h2 id="一、分代收集理论"> 一、分代收集理论</h2>
<h3 id="分代假说"> 分代假说</h3>
<ol>
<li>弱分代假说：绝大多数对象都是朝生夕灭的</li>
<li>强分代假说：熬过越多次垃圾收集过程的对象就越难以消亡</li>
</ol>
<p>这两个分代假说共同奠定了多款常用的垃圾收集器的一致的设计原则：<strong>收集器应该将 Java 堆划分出不同的区域，然后将回收对象依据其年龄（年龄即对象熬过垃圾收集过程的次数）分配到不同的区域之中存储。</strong></p>
<h3 id="跨代引用假说"> 跨代引用假说</h3>
<ol start="3">
<li>跨代引用假说：跨代引用对于同代应用来说仅占极少数</li>
</ol>
<p>依据这条假说，我们就不应再为了少量的跨代引用去扫描整个老年代，也不必浪费空间专门记录 每一个对象是否存在及存在哪些跨代引用，只需 <strong>在新生代上建立一个全局的数据结构</strong>（该结构被称 为 <mark>“记忆集”</mark> ，Remembered Set），这个结构把老年代划分成若干小块，<strong>标识出老年代的哪一块内存会存在跨代引用</strong>。此后当发生Minor GC时，只有包含了跨代引用的小块内存里的对象才会被加入到GC Roots进行扫描。虽然这种方法需要在对象改变引用关系（如将自己或者某个属性赋值）时维护记录数据的正确性，会增加一些运行时的开销，但比起收集时扫描整个老年代来说仍然是划算的。</p>
<div><p>收集</p>
<ul>
<li>部分收集 <code>Partial GC</code>：指目标不是完整收集整个 Java 堆的垃圾收集
<ul>
<li>新生代收集 <code>Minor GC/Young GC</code>：新生代的垃圾收集</li>
<li>老年代收集 <code>Major GC/Old GC</code>：老年代的垃圾收集，目前只有 <strong>CMS收集器</strong> 会有单独收集老年代</li>
<li>混合收集 <code>Mixed GC</code>：收集整个新生代和部分老年代，目前只有 <strong>G1收集器</strong> 会这么做</li>
</ul>
</li>
<li>整堆收集 <code>Full GC</code>：整个 Java堆和方法区的收集</li>
</ul>
</div>
<h2 id="二、标记-清除算法"> 二、标记-清除算法</h2>
<p>算法分为【<strong>标记</strong>】和【<strong>清除</strong>】两个阶段：首先标记出所有需要回收的对象，在标记完成后，统一回收掉所有被标记的对象，也可以反过来，标记存活的对象，统一回收所有未被标记的对象。</p>
<p><img src="./README.assets/image-20220317090851255.png" alt="image-20220317090851255" loading="lazy"></p>
<div><p>缺点：</p>
<ol>
<li><strong>执行效率不稳定：</strong> 如果Java堆中包含大量对象，而且其中大部分是需要被回收的，这时必须进行大量标记和清除的动作，导致标记和清除两个过程的执行效率都随对象数量增长而降低</li>
<li><strong>空间的碎片化问题：</strong> 标记、清除之后会产生大量不连续的内存碎片，空间碎片太多可能会导致当以后在程序运行过程中需要分配较大对象时无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作</li>
</ol>
</div>
<h2 id="三、标记-复制算法"> 三、标记-复制算法</h2>
<p>它将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉。</p>
<p><img src="./README.assets/image-20220317090904423.png" alt="image-20220317090904423" loading="lazy"></p>
<p>每次都是针对整个半区进行内存回收，分配内存时也就不用考虑有空间碎片的复杂情况，只要移动堆顶指针，按顺序分配即可。这样实现简单，运行高效</p>
<div><p>缺点</p>
<ol>
<li><strong>执行效率不稳定：</strong> 如果内存中多数对象都是存活的，这种算法将会产生大量的内存间复制的开销，但对于多数对象都是可回收的情况，算法需要复制的就是占少数的存活对象</li>
<li><strong>空间浪费：</strong> 这种复制回收算法的代价是将可用内存缩小为了原来的一半</li>
</ol>
</div>
<div><p>朝生夕灭</p>
<p>IBM公司曾有一项专门研究对新生代【朝生夕灭】的特点做了更量化的诠释——新生代中的对象有 98% 熬不过第一轮收集。因此也不必担心在垃圾回收时存在大量存活的对象需要去复制转移，甚至都不需要按照 <code>1:1</code> 的比例来划分新生代的空间。</p>
</div>
<div><p>Appel 式回收</p>
<p>HotSpot虚拟机的 Serial、ParNew 等新生代收集器均采用了这种策略来设计新生代的内存布局</p>
<p>Appel 式回收的具体做法是把新生代分为一块较大的 <code>Eden</code> 空间和两块较小的 <code>Survivor</code> 空间，每次分配内存只使用 Eden 和其中一块 Survivor。发生垃圾搜集时，将 Eden 和 Survivor 中仍 然存活的对象一次性复制到另外一块 Survivor 空间上，然后直接清理掉 Eden 和已用过的那块 Survivor 空间</p>
<p>HotSpot 虚拟机默认 Eden 和 Survivor 的大小比例是 8∶1，也即每次新生代中可用内存空间为整个新生代容量的 90%（Eden 的 80% 加上一个 Survivor 的 10%），只有一个 Survivor 空间，即 10% 的新生代是会被【浪费】的。</p>
<p>当然，98% 的对象可被回收仅仅是【普通场景】下测得的数据，任何人都没有办法百分百保证每次回收都只有不多于 10% 的对象存活，因此 Appel 式回收还有一个充当罕见情况的【逃生门】的安全设计，当 Survivor 空间不足以容纳一次 Minor GC 之后存活的对象时，就需要 <mark>依赖其他内存区域（实际上大多就是老年代）进行分配担保（Handle Promotion）</mark></p>
</div>
<h2 id="四、标记-整理算法"> 四、标记-整理算法</h2>
<p>标记-清除算法与标记-整理算法的本质差异在于前者是一种非移动式的回收算法，而后者是移动式的。</p>
<p><img src="./README.assets/image-20220317090917823.png" alt="image-20220317090917823" loading="lazy"></p>
<div><p>缺点</p>
<ol>
<li>在老年代这种每次回收都有大量对象存活区域，移动存活对象并更新 所有引用这些对象的地方将会是一种极为负重的操作，而且这种对象移动操作必须全程暂停用户应用程序才能进行</li>
<li>但如果跟标记-清除算法那样完全不考虑移动和整理存活对象的话，弥散于堆中的存活对象导致的空间碎片化问题就只能依赖更为复杂的内存分配器和内存访问器来解决。</li>
</ol>
<p>基于以上两点，是否移动对象都存在弊端，移动则内存回收时会更复杂，不移动则内存分配时会更复杂</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:20:00.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">运行时数据区域</title>
    <id>https://notes.lllllan.cn/java/jvm/2/1/</id>
    <link href="https://notes.lllllan.cn/java/jvm/2/1/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<blockquote>
<p>Java 与 C++ 之间有一堵由内存动态分配和垃圾收集技术所围成的高墙，墙外面的人想进去，墙里面的人却想出来。</p>
</blockquote>
<p><img src="./README.assets/image-20220317085056977.png" alt="image-20220317085056977" loading="lazy"></p>
<h2 id="一、程序计数器"> 一、程序计数器</h2>
<p>程序计数器（Program Counter Register）是一块较小的内存空间，是 <mark>线程私有</mark> 的，它可以看作是 <mark>当前线程所执行的字节码的行号指示器。此内存区域是唯一一个在《Java虚拟机规范》中没有规定任何 <code>OutOfMemoryError</code> 情况的区域</mark></p>
<h2 id="二、java-虚拟机栈"> 二、Java 虚拟机栈</h2>
<p>与程序计数器一样，Java 虚拟机栈（Java Virtual Machine Stack）也是 <mark>线程私有</mark> 的，它的生命周期与线程相同。虚拟机栈描述的是 Java 方法执行的线程内存模型：每个方法被执行的时候，Java 虚拟机都会同步创建一个 <mark>栈帧，用于存储局部变量表、操作数栈、动态连接、方法出口等信息</mark> 。每一个方法被调用直至执行完毕的过程，就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p>
<div><p>局部变量表</p>
<p>存放了编译期可知的各种 Java 虚拟机基本数据类型、对象引用、returnAddress 类型（指向了一条字节码指令的地址）</p>
</div>
<div><p>异常状况</p>
<ul>
<li>如果线程请求的栈深度大于虚拟机所允许的深度，将抛出 <code>StackOverflowError</code> 异常</li>
<li>如果 Java 虚拟机栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 <code>OutOfMemoryError</code> 异常</li>
</ul>
</div>
<h2 id="三、本地方法栈"> 三、本地方法栈</h2>
<p>本地方法栈（Native Method Stacks）与虚拟机栈所发挥的作用是非常相似的，都是 <mark>线程私有</mark> ，其区别只是虚拟机栈为虚拟机执行 Java 方法（也就是字节码）服务，而本地方法栈则是 <mark>为虚拟机使用到的本地（Native） 方法服务</mark></p>
<div><p>异常状况</p>
<ul>
<li>如果线程请求的栈深度大于本地方法栈所允许的深度，将抛出 <code>StackOverflowError</code> 异常</li>
<li>如果本地方法栈容量可以动态扩展，当栈扩展时无法申请到足够的内存会抛出 <code>OutOfMemoryError</code> 异常</li>
</ul>
</div>
<h2 id="四、java-堆"> 四、Java 堆</h2>
<p>Java堆是被 <mark>所有线程共享</mark> 的一块内存区域，在 <mark>虚拟机启动时创建</mark> 。此内存区域的唯一目的就是 <mark>存放对象实例</mark> ，Java 世界里 <mark>“几乎”</mark> 所有的对象实例都在这里分配内存。</p>
<div><p>几乎</p>
<p>由于 <strong>即时编译技术</strong> 的进步，尤其是 <strong>逃逸分析技术</strong> 的日渐强大，<strong>栈上分配</strong> 、 <strong>标量替换优化手段</strong> 已经导致一些微妙的变化悄然发生，所以说 Java 对象实例都分配在堆上也渐渐变得不是那么绝对了</p>
</div>
<div><p>异常状况</p>
<p>如果在 Java 堆中没有内存完成实例分配，并且堆也无法再 扩展时，Java 虚拟机将会抛出 <code>OutOfMemoryError</code> 异常</p>
</div>
<h2 id="五、方法区"> 五、方法区</h2>
<p>方法区（Method Area）与 Java 堆一样，是各个 <mark>线程共享</mark> 的内存区域，它用于 <mark>存储已被虚拟机加载的类型信息、常量、静态变量、即时编译器编译后的代码缓存等数据</mark></p>
<p>方法区中的内存挥手目标主要是针对常量池的挥手和类型的卸载，但是因为回收条件苛刻、回收效果不佳。</p>
<div><p>异常状况</p>
<p>如果方法区无法满足新的内存分配需求时，将抛出 <code>OutOfMemoryError</code> 异常。</p>
</div>
<h2 id="六、运行时常量池"> 六、运行时常量池</h2>
<p>运行时常量池（Runtime Constant Pool）是 <mark>方法区的一部分</mark></p>
<p>Class文件中除了有类的版本、字 段、方法、接口等描述信息外，还有一项信息是 <strong>常量池表</strong> （Constant Pool Table），用于 <mark>存放编译期生成的各种字面量与符号引用</mark> ，这部分内容将在类加载后存放到方法区的运行时常量池中。</p>
<p>运行时常量池相对于 Class 文件常量池的另外一个重要特征是具备 <strong>动态性</strong> ，Java 语言并不要求常量 一定只有编译期才能产生，也就是说，并非预置入 Class 文件中常量池的内容才能进入方法区运行时常量池，运行期间也可以将新的常量放入池中，这种特性被开发人员利用得比较多的便是 String 类的 intern() 方法。</p>
<blockquote>
<p>参考 <a href="https://cloud.tencent.com/developer/article/1690589" target="_blank" rel="noopener noreferrer">面试题系列第5篇：JDK的运行时常量池、字符串常量池、静态常量池，还傻傻分不清？</a></p>
</blockquote>
<div><p>异常状况</p>
<p>当常量池无法再申请到内存 时会抛出 <code>OutOfMemoryError</code> 异常</p>
</div>
<h2 id="七、直接内存"> 七、直接内存</h2>
<p>直接内存（Direct Memory） <mark>并不是虚拟机运行时数据区的一部分</mark> ，也不是《Java虚拟机规范》中 定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 <code>OutOfMemoryError</code> 异常出现，</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:03:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HotSpot 虚拟机中的对象</title>
    <id>https://notes.lllllan.cn/java/jvm/2/2/</id>
    <link href="https://notes.lllllan.cn/java/jvm/2/2/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<h2 id="一、对象的创建过程"> 一、对象的创建过程</h2>
<ol>
<li>
<p><strong>类加载检查</strong></p>
<blockquote>
<p>首先类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程</p>
</blockquote>
</li>
<li>
<p><strong>分配内存</strong></p>
<blockquote>
<p>为对象分配空间的任务实际上便等同于把一块确定大小的内存块从 Java 堆中划分出来</p>
<ul>
<li><mark>指针碰撞</mark> ： 假设 Java 堆中内存是绝对规整的，所有被使用过的内存都被放在一边，空闲的内存被放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针向空闲空间方向挪动一段与对象大小相等的距离</li>
<li><mark>空闲列表</mark> ： 但如果 Java 堆中的内存并不是规整的，已被使用的内存和空闲的内存相互交错在一起，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录</li>
</ul>
<p>选择哪种分配方式由Java堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有 <mark>空间压缩整理（Compact）</mark> 的能力决定</p>
</blockquote>
<div><p>非线程安全</p>
<p>在并发情况下也并 <mark>不是线程安全的</mark> ，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：</p>
<ol>
<li>
<p>对分配内存空间的动作进行同步处理——实际上虚拟机是采用 <mark>CAS配上失败重试</mark> 的方式保证更新操作的原子性</p>
</li>
<li>
<p>另外一种是把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程在Java堆中预先分配一小块内存，称为 <mark>本地线程分配缓冲</mark> （Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定。</p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>对象字段初始化为零值</strong></p>
<blockquote>
<p>将分配到的内存空间（但不包括对象头）都初始化为零值，这步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，使程序能访问到这些字段的数据类型所对应的零值。</p>
</blockquote>
</li>
<li>
<p><strong>设置对象头</strong></p>
<blockquote>
<p>设置这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码（实际上对象的哈希码会延后到真正调用 <code>Object::hashCode()</code> 方法时才计算）、对象的 GC 分代年龄等信息</p>
</blockquote>
</li>
<li>
<p><strong>执行构造函数</strong></p>
</li>
</ol>
<h2 id="二、对象的内存布局"> 二、对象的内存布局</h2>
<p>对象在堆内存中的存储布局可以划分为三个部分：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）</p>
<h3 id="_2-1-对象头"> 2.1 对象头</h3>
<p>HotSpot虚拟机对象的对象头部分包括两类信息</p>
<ol>
<li>
<p><strong>对象自身的运行数据：</strong> 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等</p>
<blockquote>
<p><img src="./README.assets/image-20220317085203714.png" alt="image-20220317085203714" loading="lazy"></p>
</blockquote>
</li>
<li>
<p><strong>类型指针：</strong> 对象指向它的类型元数据的指针，Java虚拟机通过这个指针来确定该对象是哪个类的实例。</p>
<blockquote>
<p>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据信息并不一定要经过对象本身</p>
</blockquote>
</li>
</ol>
<h3 id="_2-2-实例数据"> 2.2 实例数据</h3>
<p>来实例数据部分是对象真正存储的有效信息，即我们在程序代码里面所定义的各种类型的字段内容，无论是从父类继承下来的，还是在子类中定义的字段都必须记录起来</p>
<p><img src="./README.assets/image-20220317085219807.png" alt="image-20220317085219807" loading="lazy"></p>
<h3 id="_2-3-对齐填充"> 2.3 对齐填充</h3>
<p>这并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。</p>
<p>由于 HotSpot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是任何对象的大小都必须是 <strong>8字节的整数倍</strong>。</p>
<h2 id="三、对象的访问定位"> 三、对象的访问定位</h2>
<p>对象访问方式也是由虚拟机实现而定的，主流的访问方式主要有使用句柄和直接指针两种：</p>
<h3 id="_3-1-句柄访问"> 3.1 句柄访问</h3>
<p>Java堆中将可能会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自具体的地址信息</p>
<p><img src="./README.assets/image-20220317085231743.png" alt="image-20220317085231743" loading="lazy"></p>
<div><p>句柄的优势</p>
<p>是 reference 中存储的是稳定句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要被修改。</p>
</div>
<h3 id="_3-2-直接指针访问"> 3.2 直接指针访问</h3>
<p>Java 堆中对象的内存布局就必须考虑如何放置访问类型数据的相关信息，reference 中存储的直接就是对象地址，如果只是访问对象本身的话，就不需要多一次间接访问的开销</p>
<p><img src="./README.assets/image-20220317085241030.png" alt="image-20220317085241030" loading="lazy"></p>
<div><p>指针的优势</p>
<p>是速度更快，它节省了一次指针定位的时间开销，由于对象访问在 Java 中非常频繁，因此这类开销积少成多也是一项极为可观的执行成本。</p>
<p>对于 HotSpot 而言，它主要使用第二种方式进行对象访问。</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:03:11.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">概述</title>
    <id>https://notes.lllllan.cn/java/jvm/3/1/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/1/"/>
    <updated>2022-04-12T10:53:45.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<h2 id="概述"> 概述</h2>
<p>垃圾收集需要完成的三件事情：</p>
<ul>
<li>哪些内存需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ul>
<p>当需要排查各种内存溢出、内存泄漏问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就必须对这些【自动化】的技术实施必要的监控和调节。</p>
<p>Java堆和方法区这两个区域则有着很显著的不确定性：一个接口的多个实现类需要的内存可能会不一样，一个方法所执行的不同条件分支所需要的内存也可能不一样，只有处于运行期间，我们才能知道程序究竟会创建哪些对象，创建多少个对象，这部分内存的分配和回收是动态的。垃圾收集器所关注的正是这部分内存该如何管理，本文后续讨论中的【内存】分配与回收也仅仅特指这一部分内存。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:20:00.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">HotSpot 的算法实现细节</title>
    <id>https://notes.lllllan.cn/java/jvm/3/4/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/4/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://blog.csdn.net/weixin_42090746/article/details/103942247" target="_blank" rel="noopener noreferrer">HotSpot VM中的准确式GC、OopMap、Safepoint、抢先式中断、主动式中断、Safe Region和RememberedSet</a></li>
<li><a href="https://blog.csdn.net/nazeniwaresakini/article/details/105947623" target="_blank" rel="noopener noreferrer">再谈HotSpot JVM GC机制中的写屏障</a></li>
<li><a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener noreferrer">伪共享（false sharing），并发编程无声的性能杀手 - cyfonly - 博客园 (cnblogs.com)</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/286110609" target="_blank" rel="noopener noreferrer">jvm大局观之内存管理篇: 理解jvm安全点,写出更高效的代码 - 知乎 (zhihu.com)</a></li>
</ul>
</div>
<h2 id="一、根节点枚举"> 一、根节点枚举</h2>
<p>迄今为止， <mark>所有收集器在根节点枚举这一步骤时都是必须暂停用户线程的</mark> 。在枚举根节点的期间，根节点集合的对象引用关系应该保持不变，这是枚举根节点应该保证的 <strong>一致性</strong> 。如果这点都不能满足，分析结果也就无法保证，因此垃圾手机过程必须停顿所有用户线程。</p>
<div><p>一致性</p>
<p>整个枚举期间执行子系统看起来就像被冻结在某个时间点上，不会出现分析过程中，根节点集合的对象引用关系还在不断变化的情况。如果这个都不能满足的花，分析结果的准确性也就无法保证。</p>
</div>
<div><p>准确式 GC 和 OopMap</p>
<blockquote>
<p>保守式GC，不知道每个位置上的数据时什么类型，只能扫描整个新生代。</p>
</blockquote>
<p>目前主流Java虚拟机都是使用 <mark>准确式垃圾收集</mark> ，即虚拟机知道内存中某个位置存储的数据是什么类型，在GC时，只需遍历引用类型即可，而不需要一个不漏地检查完所有执行上下文和全局的引用位置。</p>
<p>其用来维护哪些地方存有引用的数据结构就叫做 <mark>OopMap</mark>。在 HotSpot 中一旦类记载完成的时候，HotSpot 会将对象内什么偏移量上是什么类型的数据计算出来，在即时编译过程中，在特定位置记录下栈里和寄存器里哪些位置是引用。这样收集器在扫描时就可以直接获取这些信息了。</p>
</div>
<h2 id="二、安全点"> 二、安全点</h2>
<p><a href="https://zhuanlan.zhihu.com/p/286110609" target="_blank" rel="noopener noreferrer">jvm大局观之内存管理篇: 理解jvm安全点,写出更高效的代码 - 知乎 (zhihu.com)</a></p>
<p>在OopMap的协助下，HotSpot可以快速准确地完成GC Roots枚举，但一个很现实的问题随之而来：可能导致引用关系变化，或者说导致OopMap内容变化的指令非常多，如果为每一条指令都生成 对应的OopMap，那将会需要大量的额外存储空间，这样垃圾收集伴随而来的空间成本就会变得无法忍受的高昂。</p>
<div><p>安全点</p>
<p>实际上HotSpot也的确没有为每条指令都生成OopMap，前面已经提到，只是在“特定的位置”记录 了这些信息，这些位置被称为<strong>安全点（Safepoint）</strong>。</p>
</div>
<p>安全点位置选取的原则：</p>
<ul>
<li><strong>是否具有让程序长时间执行的特征</strong>。【长时间执行】的最明显特征就是指令序列的复用，例如 <mark>方法调用、循环跳转、异常跳转</mark> 等都属于指令序列服用，只有具有这些功能的指令才会产生安全点</li>
<li><strong>如何在垃圾收集发生时让所有线程（不包括执行JNI调用的线程）都跑到最近的安全点</strong>。抢先式中断、主动式中断</li>
</ul>
<div><p>两种中断</p>
<p><strong>抢先式中断：</strong> 抢先式中断不需要线程的执行代码主动去配合，在垃圾收集发生时，系统首先把所有用户线程全部中断，如果发现有用户线程中断的地方不在安全点上，就恢复这条线程执行，让它一会再重新中断，直到跑到安全点上。</p>
<p><strong>主动式中断：</strong> 是当垃圾收集需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志位，各个线程执行过程时会不停地主动去轮询这个标志，一旦发现中断标志为真时就自己在最近的安全点上主动中断挂起</p>
</div>
<h2 id="三、安全区域"> 三、安全区域</h2>
<p>安全点机制保证了程序执行时，在不太长的时间内就会遇到可进入垃圾收集过程的安全点</p>
<p>但是，程序【不执行】的时候呢？所谓的程序不执行就是没有分配处理器时间，典型的场景便是用户线程处于 <code>Sleep</code> 状态或者 <code>Blocked</code> 状态，这时候线程无法响应虚拟机的中断请求，不能再走到安全的地方去中断挂起自己，虚拟机也显然不可能持续等待线程重新被激活分配处理器时间。对于这种情况，就必须引入安全区域（Safe Region）来解决。</p>
<div><p>安全区域</p>
<p><mark>安全区域</mark> 是指能够确保在某一段代码片段之中，引用关系不会发生变化，因此，在这个区域中任意地方开始垃圾收集都是安全的。我们也可以把安全区域看作被扩展拉伸了的安全点。</p>
</div>
<p>当用户线程执行到安全区域里面的代码时，<strong>首先会标识自己已经进入了安全区域</strong>，那样当这段时间里虚拟机要发起垃圾收集时就不必去管这些已声明自己在安全区域内的线程了。当线程要 <strong>离开安全区域时，它要检查虚拟机是否已经完成了根节点枚举</strong>（或者垃圾收集过程中其他需要暂停用户线程的 阶段），如果完成了，那线程就当作没事发生过，继续执行；否则它就必须一直等待，直到收到可以离开安全区域的信号为止</p>
<h2 id="四、记忆集和卡表"> 四、记忆集和卡表</h2>
<div><p>记忆集</p>
<p>所有涉及部分区域收集（Partial GC）行为的垃圾收集器，都会面临对象跨代引用的问题。 <mark>记忆集</mark> 是一种用于记录从非收集区域指向收集区域的指针集合的抽象数据结构</p>
</div>
<p>这种记录全部含跨代引用对象的实现方案，无论是空间占用还是维护成本都相当高昂。而在垃圾收集的场景中，收集器只需要通过记忆集判断出某一块非收集区域是否存在有指向了收集区域的指针就可以了，并不需要了解这些跨代指针的全部细节。</p>
<ul>
<li><strong>字长精度</strong>：每个记录精确到一个机器字长（就是处理器的寻址位数，如常见的32位或64位，这个精度决定了机器访问物理内存地址的指针长度），该字包含跨代指针。</li>
<li><strong>对象精度</strong>：每个记录精确到一个对象，该对象里有字段含有跨代指针。</li>
<li><strong>卡精度</strong>：每个记录精确到一块内存区域，该区域内有对象含有跨代指针</li>
</ul>
<div><p>卡表</p>
<p><mark>卡表</mark> 就是记忆集的一种具体实现，它定义了记忆集的记录精度、与堆内存的映射关系等。</p>
</div>
<p>HotSpot 虚拟机中卡表就是一个字节数组，其中每一个元素都对应着其标识的内存区域中一块特定大小的内存块，这个内存块称为 <mark>卡页</mark> 。一个卡页的内存中通常包含不止一个对象，只要卡页内有一个（或更多）对象的字段存在着跨代指针，那就将对应卡表的数组元素的值标识为 1，称为这个元素变脏（Dirty），没有则标识为 0。</p>
<p>在垃圾收集发生时，只要筛选出卡表中变脏的元素，就能轻易得出哪些卡页内存块中包含跨代指针，把它们加入 GC Roots 中一并扫描。</p>
<p><img src="./README.assets/image-20220317091055571.png" alt="image-20220317091055571" loading="lazy"></p>
<h2 id="五、写屏障"> 五、写屏障</h2>
<p>我们已经解决了如何使用记忆集来缩减 GC Roots 扫描范围的问题，但还没有解决卡表元素如何维护的问题，例如它们何时变脏、谁来把它们变脏等。</p>
<ol>
<li><strong>何时变脏：</strong> 有其他分代区域中对象引用了本区域对象时，其对应的卡表元素就应该变脏，变脏时间点原则上应该发生在引用类型字段赋值的那一刻</li>
<li><strong>如何变脏：</strong> 通过写屏障技术维护卡表状态</li>
</ol>
<div><p>写屏障</p>
<p><mark>写屏障</mark> 可以看作在虚拟机层面对【引用类型字段赋值】这个动作的 AOP 切面，在引用对象赋值时会产生一个环形（Around）通知，供程序执行额外的动作，也就是说赋值的前后都在写屏障的覆盖范畴内。</p>
<p>换句话就是 <strong>对一个对象引用进行写操作（即引用赋值）之前或之后附加执行的逻辑</strong>，相当于为引用赋值挂上的一小段钩子代码。</p>
<p>参考 <a href="./../../../concurrent/2/8/#_2-2-禁止重排序">内存屏障</a></p>
</div>
<p>除了写屏障的开销外，卡表在高并发场景下还面临着【伪共享（False Sharing）】问题。伪共享是处理并发底层细节时一种经常需要考虑的问题</p>
<div><p>伪共享问题</p>
<p><a href="https://www.cnblogs.com/cyfonly/p/5800758.html" target="_blank" rel="noopener noreferrer">伪共享（false sharing），并发编程无声的性能杀手 - cyfonly - 博客园 (cnblogs.com)</a></p>
<p><mark>现代中央处理器的缓存系统中是以缓存行（Cache Line）为单位存储的，当多线程修改互相独立的变量时，如果这些变量恰好共享同一个缓存行，就会彼此影响（写回、无效化或者同步）而导致性能降低，这就是伪共享问题</mark></p>
</div>
<p>为了避免 伪共享问题：</p>
<ul>
<li>
<p>一种简单的解决方案是 <strong>不采用无条件的写屏障，而是先检查卡表标记</strong>，只有当该卡表元素未被标记过时才将其标记为变脏。</p>
<blockquote>
<p>个人理解，只有必要将 “未变脏” 的卡页变为 “脏”，而没必要记录 “脏” 了多少，从而减少修改卡表的次数。</p>
</blockquote>
</li>
<li>
<p>在JDK 7之后，HotSpot虚拟机增加了一个新的参数 <code>-XX：+UseCondCardMark</code>，用来决定是否开启卡表更新的条件判断；开启会增加一次额外判断的开销，但能够避免伪共享问。</p>
</li>
</ul>
<h2 id="六、并发的可达性分析"> 六、并发的可达性分析</h2>
<p>可达性分析算法理论上要求全过程都基于一个能保障一致性的快照中才能够进行分析， 这意味着必须全程冻结用户线程的运行。从 GC Roots 再继续往下遍历对象图，这一步骤的停顿时间就必定会与 Java 堆容量直接成正比例关系了：堆越大，存储的对象越多，对象图结构越复杂，要标记更多对象而产生的停顿时间自然就更长。</p>
<blockquote>
<p><img src="./README.assets/image-20220317091104766.png" alt="image-20220317091104766" loading="lazy"></p>
<p><img src="./README.assets/image-20220317091112557.png" alt="image-20220317091112557" loading="lazy"></p>
</blockquote>
<p>因此，我们要解决并发扫描时的对象消失问题，只需破坏这两个条件的任意一个即可。由此分别 产生了两种解决方案：<mark>增量更新</mark>（Incremental Update）和 <mark>原始快照</mark>（Snapshot At The Beginning， SATB）。</p>
<div><p>增量更新</p>
<p>黑色对象一旦新插入了指向白色对象的引用之后，它就变回灰色对象了。等并发扫描结束之后，再将这些记录过的引用关系中的黑色对象为根，重新扫描一次</p>
</div>
<div><p>原始快照</p>
<p>无论引用关系删除与否，都会按照刚刚开始扫描那一刻的对象图快照来进行搜索</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:20:00.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">对象已死</title>
    <id>https://notes.lllllan.cn/java/jvm/3/2/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/2/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p>垃圾收集器在对堆进行回收前，第一件事情就是要确定这些对象之中哪些还【存活】着，哪些已经【死去】（死去即不可能再被任何途径使用的对象）了</p>
<h2 id="一、引用计数算法"> 一、引用计数算法</h2>
<p>在对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加一；当引用失效时，计数器值就减一；任何时刻计数器为零的对象就是不可 能再被使用的。</p>
<ul>
<li>优点：原理简单，判定效率也很高</li>
<li>缺点：单纯的引用计数 就很难解决对象之间相互循环引用的问题</li>
</ul>
<div><pre><code><span>/**
 * testGC()方法执行后，objA和objB会不会被GC呢？
 * @author zzm
 */</span>
<span>public</span> <span>class</span> <span>ReferenceCountingGC</span> <span>{</span>
    <span>public</span> <span>Object</span> instance <span>=</span> <span>null</span><span>;</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> _1MB <span>=</span> <span>1024</span> <span>*</span> <span>1024</span><span>;</span>
    <span>/**
     * 这个成员属性的唯一意义就是占点内存，以便能在GC日志中看清楚是否有回收过
     */</span>
    <span>private</span> <span>byte</span><span>[</span><span>]</span> bigSize <span>=</span> <span>new</span> <span>byte</span><span>[</span><span>2</span> <span>*</span> _1MB<span>]</span><span>;</span>
    <span>public</span> <span>static</span> <span>void</span> <span>testGC</span><span>(</span><span>)</span> <span>{</span>
        <span>ReferenceCountingGC</span> objA <span>=</span> <span>new</span> <span>ReferenceCountingGC</span><span>(</span><span>)</span><span>;</span>
        <span>ReferenceCountingGC</span> objB <span>=</span> <span>new</span> <span>ReferenceCountingGC</span><span>(</span><span>)</span><span>;</span>
        objA<span>.</span>instance <span>=</span> objB<span>;</span>
        objB<span>.</span>instance <span>=</span> objA<span>;</span>
        objA <span>=</span> <span>null</span><span>;</span>
        objB <span>=</span> <span>null</span><span>;</span>
        <span>// 假设在这行发生GC，objA和objB是否能被回收？</span>
        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><p>实际上虚拟机并没有因为这两个对象互相引用就放弃回收它们，这也从侧面说明了 Java 虚拟机并不是通过引用计数算法来判断对象是否存活的。</p>
<h2 id="二、可达性分析算法"> 二、可达性分析算法</h2>
<p>通过一系列称为 <mark>GC Roots</mark> 的根对象作为起始节点集，从这些节点开始，根据引用关系 <strong>向下搜索</strong> ，搜索过程所走过的路径称为 <mark>引用链</mark> （Reference Chain），如果某个对象到 GC Roots 间没有任何引用链相连， 或者用图论的话来说就是从 GC Roots 到这个对象不可达时，则证明此对象是不可能再被使用的。</p>
<p><img src="./README.assets/image-20220317090714456.png" alt="image-20220317090714456" loading="lazy"></p>
<div><p>GC Roots 包括的对象</p>
<ol>
<li>在虚拟机栈（栈帧中的 <strong>本地变量表）中引用的对象</strong>，譬如各个线程被调用的方法堆栈中使用到的参数、局部变量、临时变量等</li>
<li>在方法区中类 <strong>静态属性引用的对象</strong>，譬如Java类的引用类型静态变量</li>
<li>在方法区中 <strong>常量引用的对象</strong>，譬如字符串常量池（String Table）里的引用</li>
<li>在本地方法栈中JNI（即通常所说的 <strong>Native方法）引用的对象</strong></li>
<li>Java <strong>虚拟机内部的引用</strong>，如基本数据类型对应的Class对象，一些常驻的异常对象（比如 NullPointExcepiton、OutOfMemoryError）等，还有系统类加载器</li>
<li>所有被 <strong>同步锁（synchronized关键字）持有的对象</strong></li>
<li>反映Java虚拟机内部情况的JMXBean、JVMTI中注册的回调、本地代码缓存等。</li>
</ol>
<p>根据用户所选用的垃圾收集器以及当前回收的内存区域不同，还 <strong>可以有其他对象【临时性】地加入</strong>，共同构成完整GC Roots集合。</p>
</div>
<h2 id="三、再谈引用"> 三、再谈引用</h2>
<p>在 JDK 1.2 版之后，Java对引用的概念进行了扩充，将引用分为强引用（Strongly Re-ference）、软引用（Soft Reference）、弱引用（Weak Reference）和虚引用（Phantom Reference）4 种，这 4 种引用强度依次逐渐减弱。</p>
<ul>
<li><strong>强引用</strong> 是最传统的【引用】的定义，是指在程序代码之中普遍存在的引用赋值，即类似 <code>Object obj=new Object()</code> 这种引用关系。无论任何情况下，只要强引用关系还存在，垃圾收集器就永远不会回收掉被引用的对象。</li>
<li><strong>软引用</strong> 是用来描述一些<u>还有用，但非必须</u>的对象。只被软引用关联着的对象， <mark>在系统将要发生内存溢出异常前，会把这些对象列进回收范围之中进行第二次回收，如果这次回收还没有足够的内存，才会抛出内存溢出异常</mark> 。  <code>SoftReference</code></li>
<li><strong>弱引用</strong> 也是用来描述那些非必须对象，但是它的强度比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生为止。 <mark>当垃圾收集器开始工作，无论当前内存是否足够，都会回收掉只被弱引用关联的对象</mark> 。 <code>WeakReference</code></li>
<li><strong>虚引用</strong> 是最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚 引用关联的唯一目的只是为了能在这个对象被收集器回收时收到一个系统通知。 <code>PhantomReference</code></li>
</ul>
<h2 id="四、生存还是死亡"> 四、生存还是死亡</h2>
<p>即使在可达性分析算法中判定为不可达的对象，也不是“非死不可”的，这时候它们暂时还处于“缓刑”阶段。</p>
<p>要真正宣告一个对象死亡，至少要经历两次标记过程：</p>
<ol>
<li>如果对象在进行可达性分析后发现没有与 GC Roots 相连接的引用链，那它将会被第一次标记，随后进行一次筛选</li>
<li>筛选的条件是此对象是否有必要执行 <code>finalize()</code> 方法。假如对象没有覆盖 finalize() 方法，或者 finalize() 方法已经被虚拟机调用过，那么虚拟机将这两种情况都视为“没有必要执行”。</li>
</ol>
<blockquote>
<p>如果这个对象被判定为确有必要执行 finalize 方法，那么该对象将会被放置在一个名为F-Queue的队列之中，并在稍后由一条由虚拟机自动建立的、低调度优先级的 Finalizer 线程去执行它们的 finalize() 方法。这里所说的【执行】是指虚拟机会触发这个方法开始运行，但并不承诺一定会等待它运行结束。</p>
<p>这样做的原因是，如果某个对象的 finalize 方法执行缓慢，或者更极端地发生了死循环，将很可能导致 F-Queue 队列中的其他对象永久处于等待，甚至导致整个内存回收子系统的崩溃。finalize 方法是对象逃脱死亡命运的最后一次机会，稍后收集器将对 F-Queue 中的对象进行第二次小规模的标记，如果对象要在 finalize() 中成功拯救自己——只要重新与引用链上的任何一个对象建立关联即可，譬如把自己（this关键字）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出【即将回收】的集合；如果对象这时候还没有逃脱，那基本上它就真的要被回收了。</p>
</blockquote>
<div><pre><code><span>/**
* 此代码演示了两点：
* 1.对象可以在被GC时自我拯救。
* 2.这种自救的机会只有一次，因为一个对象的finalize()方法最多只会被系统自动调用一次
* @author zzm
*/</span>
<span>public</span> <span>class</span> <span>FinalizeEscapeGC</span> <span>{</span>
    <span>public</span> <span>static</span> <span>FinalizeEscapeGC</span> SAVE_HOOK <span>=</span> <span>null</span><span>;</span>
    <span>public</span> <span>void</span> <span>isAlive</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"yes, i am still alive :)"</span><span>)</span><span>;</span>
    <span>}</span>
    <span>@Override</span>
    <span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
        <span>super</span><span>.</span><span>finalize</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"finalize method executed!"</span><span>)</span><span>;</span>
        <span>FinalizeEscapeGC</span><span>.</span>SAVE_HOOK <span>=</span> <span>this</span><span>;</span>
    <span>}</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
        SAVE_HOOK <span>=</span> <span>new</span> <span>FinalizeEscapeGC</span><span>(</span><span>)</span><span>;</span>
        <span>//对象第一次成功拯救自己</span>
        SAVE_HOOK <span>=</span> <span>null</span><span>;</span>
        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>
        <span>// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>SAVE_HOOK <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            SAVE_HOOK<span>.</span><span>isAlive</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"no, i am dead :("</span><span>)</span><span>;</span>
        <span>}</span>
        <span>// 下面这段代码与上面的完全相同，但是这次自救却失败了</span>
        SAVE_HOOK <span>=</span> <span>null</span><span>;</span>
        <span>System</span><span>.</span><span>gc</span><span>(</span><span>)</span><span>;</span>
        <span>// 因为Finalizer方法优先级很低，暂停0.5秒，以等待它</span>
        <span>Thread</span><span>.</span><span>sleep</span><span>(</span><span>500</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span>SAVE_HOOK <span>!=</span> <span>null</span><span>)</span> <span>{</span>
            SAVE_HOOK<span>.</span><span>isAlive</span><span>(</span><span>)</span><span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"no, i am dead :("</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><div><pre><code>finalize method executed<span>!</span>
yes<span>,</span> i am still alive <span>:</span><span>)</span>
no<span>,</span> i am dead <span>:</span><span>(</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>代码中有两段完全一样的代码片段，执行结果却是一次逃脱成功，一次失败了。这是因为 <strong>任何一个对象的 <code>finalize()</code> 方法都只会被系统自动调用一次</strong>，如果对象面临下一次回收，它的 <code>finalize()</code> 方法不会被再次执行，因此第二段代码的自救行动失败了。</p>
<h2 id="五、回收方法区"> 五、回收方法区</h2>
<p>方法区垃圾收集 的“性价比”通常也是比较低的：在 Java 堆中，尤其是在新生代中，对常规应用进行一次垃圾收集通常 可以回收 70% 至 99% 的内存空间，相比之下，方法区回收囿于苛刻的判定条件，其区域垃圾收集的回收成果往往远低于此。</p>
<p><strong>方法区的垃圾收集主要回收两部分内容：废弃的常量和不再使用的类型。</strong></p>
<p>判定一个常量是否“废弃”还是相对简单，而要判定一个类型是否属于“不再被使用的类”的条件就 比较苛刻了。需要同时满足下面三个条件：</p>
<ol>
<li>该类 <strong>所有的实例都已经被回收</strong>，也就是Java堆中不存在该类及其任何派生子类的实例。</li>
<li>加载该类的 <strong>类加载器已经被回收</strong>，这个条件除非是经过精心设计的可替换类加载器的场景，如 OSGi、JSP的重加载等，否则通常是很难达成的。</li>
<li>该类对应的 <strong><code>java.lang.Class</code> 对象没有在任何地方被引用</strong>，无法在任何地方通过反射访问该类的方 法。</li>
</ol>
<blockquote>
<p>所有实例被回收 &amp;&amp; 类加载器被回收 &amp;&amp; class对象没有被引用</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:20:00.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">选择合适的垃圾收集器</title>
    <id>https://notes.lllllan.cn/java/jvm/3/7/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/7/"/>
    <updated>2022-03-17T02:28:45.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T02:28:45.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">经典垃圾收集器</title>
    <id>https://notes.lllllan.cn/java/jvm/3/5/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/5/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p><img src="./README.assets/image-20220317091154019.png" alt="image-20220317091154019" loading="lazy"></p>
<h2 id="一、serial-收集器"> 一、Serial 收集器</h2>
<p>Serial 收集器是一个 <mark>单线程工作、新生代的收集器</mark> ，要求在进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束。</p>
<p><strong>优点：</strong></p>
<ul>
<li>简单高效</li>
<li>额外的内存消耗最小</li>
<li>最高的单线程收集效率</li>
</ul>
<p><img src="./README.assets/image-20220317091204412.png" alt="image-20220317091204412" loading="lazy"></p>
<h2 id="二、parnew-收集器"> 二、ParNew 收集器</h2>
<p>ParNew 收集器实质上是 Serial 收集器的 <mark>多线程并行版本</mark>。<strong>优势：除了 Serial 收集器外，目前只有它能与 CMS 收集器配合工作</strong></p>
<p><img src="./README.assets/image-20220317152537593.png" alt="image-20220317152537593" loading="lazy"></p>
<div><p>CMS收集器</p>
<p>JDK5 发布的 CMS 收集器是HotSpot虚拟机中第一款真正意义上 <mark>支持并发</mark> 的垃圾收集器，它首次实现了让垃圾收集线程与用户线程（基本上）同时工作。是一个 <mark>老年代的收集器</mark></p>
</div>
<blockquote>
<p>随着垃圾收集器技术的不断改进，更先进的 G1 收集器带着 CMS 继承者和替代者的光环登场。G1 是一个面向全堆的收集器，不再需要其他新生代收集器的配合工作。ParNew 可以说是 HotSpot 虚拟机中第一款退出历史舞台的垃圾收集器。</p>
</blockquote>
<div><p>并行和并发</p>
<ul>
<li><strong>并行：</strong> 描述多条垃圾收集器之间的关系。同一时间可以有多条这样的线程在协同工作，默认此时用户线程处于等待状态。</li>
<li><strong>并发：</strong> 描述垃圾收集器线程和用户线程之间的关系。垃圾收集器线程可以和用户线程同时运行。</li>
</ul>
</div>
<h2 id="三、parallel-scavenge-收集器"> 三、Parallel Scavenge 收集器</h2>
<p>Parallel Scavenge 收集器是一款 <mark>基于标记-复制算法实现的、新生代的、并行收集的多线程收集器</mark> 。该收集器关注的目标是达到一个可控制的吞吐量。</p>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:0.6833em;"></span><span>吞吐量</span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:2.1297em;vertical-align:-0.7693em;"></span><span><span></span><span><span><span><span style="height:1.3603em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span>运行用户代码时间</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>运行垃圾收集时间</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>运行用户代码时间</span></span></span></span><span>​</span></span><span><span style="height:0.7693em;"><span></span></span></span></span></span><span></span></span></span></span></span></span></p>
<p><img src="./README.assets/image-20220317091226262.png" alt="image-20220317091226262" loading="lazy"></p>
<ul>
<li>停顿时间越短就越适合需要与用户交互或需要保证服务响应质量的程序，良好的响应速度能提升用户体验</li>
<li>而高吞吐量则可以最高效率地利用处理器资源，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的分析任务</li>
</ul>
<h2 id="四、serial-old-收集器"> 四、Serial Old 收集器</h2>
<p>Serial Old 收集器是 Serial 收集器的 <mark>老年代版本，是基于标记-整理算法实现的单线程收集器。</mark></p>
<p><img src="./README.assets/image-20220317091235416.png" alt="image-20220317091235416" loading="lazy"></p>
<h2 id="五、parallel-old-收集器"> 五、Parallel Old 收集器</h2>
<p>Parallel Ole 收集器是 Parallel Scavenge 收集器的  <mark>老年代版本，是基于标记-整理算法实现的多线程并发收集器</mark></p>
<p><img src="./README.assets/image-20220317091241402.png" alt="image-20220317091241402" loading="lazy"></p>
<h2 id="六、cms-收集器"> 六、CMS 收集器</h2>
<p>CMS（Concurrent Mark Sweep）收集器是一种 <mark>获取最短回收停顿时间为目标、支持并发的老年代收集器</mark></p>
<ol>
<li><strong>初始标记：</strong> 单线程。标记一下 GC Roots 能直接关联的对象，速度很快。</li>
<li><strong>并发标记：</strong> 和用户线程并发运行。从直接关联对象开始遍历整个对象图，耗时较长。</li>
<li><strong>重新标记：</strong> 暂停用户线程，多条标记线程并行。修正并发期间用户线程运行产生的对象变动，停顿较初始标记稍长。</li>
<li><strong>并发清除：</strong> 和用户线程并发运行。</li>
</ol>
<p><img src="./README.assets/image-20220317091259800.png" alt="image-20220317091259800" loading="lazy"></p>
<p><strong>优点：</strong> 并发收集、低停顿</p>
<div><p>CMS 的缺点</p>
<p><strong>对处理器资源非常敏感。</strong></p>
<p>在并发阶段，它虽然不会导致用户线程停顿，但却会因为占用了一部分线程（或者说处理器的计算能力）而导致应用程序变慢，降低总吞吐量。</p>
<blockquote>
<p>CMS默认启动的回收线程数是（处理器核心数量 + 3）/4，也就是说，如果处理器核心数在四个或以上，并发回收时垃圾收集线程只占用不超过 25% 的处理器运算资源，并且会随着处理器核心数量的增加而下降。但是当处理器核心数量不足四个时， CMS 对用户程序的影响就可能变得很大</p>
</blockquote>
<hr>
<p><strong>无法处理浮动垃圾。</strong></p>
<p>有可能出现【Con-current Mode Failure】失败进而导致另一次完全【Stop The World】的 Full GC 的产生</p>
<p>在 CMS 的并发标记和并发清理阶段，用户线程是还在继续运行的，程序在运行自然就还会伴随有新的垃圾对象不断产生，但这一部分垃圾对象是出现在标记过程结束以后，CMS 无法在当次收集中处理掉它们，只好留待下一次垃圾收集时再清理掉。</p>
<hr>
<p><strong>收集结束会产生大量的垃圾碎片。</strong></p>
<p>空间碎片过多时，将会给大对象分配带来很大麻烦，往往会出现老年代还有很多剩余空间，但就是无法找到足够大的连续空间来分配当前对象，而不得不提前触发一次 Full GC 的情况</p>
</div>
<h2 id="七、garbage-first-收集器"> 七、Garbage First 收集器</h2>
<p>Garbage First（简称G1）收集器是 <mark>面向局部收集、基于Region内存分布形式</mark> 的收集器。</p>
<div><p>G1 的特点</p>
<p>G1 不再坚持固定大小以及固定数量的分代区域划分，而是把连续的 Java 堆划分为多个大小相等的独立区域（Region），每一个 Region 都可以根据需要，扮演新生代的 Eden 空间、Survivor 空间，或者老年代空间。</p>
<p>特殊的 Humongous 区域，专门用来存储大对象。G1 认为只要大小超过了一个 Region 容量一半的对象即可判定为大对象。</p>
<p>新生代和老年代是一系列区域的动态集合。</p>
</div>
<p><img src="./README.assets/image-20220317091316308.png" alt="image-20220317091316308" loading="lazy"></p>
<div><p>G1 需要解决的细节问题</p>
<p><strong>Region 里面存在的跨 Region 引用对象如何解决？</strong></p>
<p>使用记忆集避免全堆作为 GC Roots 扫描，但在 G1 收集器上记忆集的应用其实要复杂很多，它的每个 Region 都维护有自己的记忆集，这些记忆集会记录下别的 Region 指向自己的指针，并标记这些指针分别在哪些卡页的范围之内。</p>
<hr>
<p><strong>并发标记阶段如何保证收集线程与用户线程互不干扰地运行？</strong></p>
<p>G1 收集器则是通过原始快照（SATB）算法来实现的。</p>
<hr>
<p><strong>怎样建立起可靠的停顿预测模型？</strong></p>
<p>看不懂</p>
</div>
<ol>
<li><strong>初始标记：</strong> 单线程。标记一下GC Roots 能直接关联的对象，速度很快。<u>修改TAMS 指针的值，让下一阶段用户线程并发运行时，能正确地在可用的Region中分配新对象。</u></li>
<li><strong>并发标记：</strong> 和用户线程并发运行。从直接关联对象开始遍历整个对象图，耗时较长。<u>当对象图扫描完成以 后，还要重新处理SATB记录下的在并发时有引用变动的对象。</u></li>
<li><strong>最终标记：</strong> 暂停用户线程，多条标记线程并行。用于处理并发阶段结束后仍遗留下来的最后那少量的SATB记录。</li>
<li><strong>筛选回收：</strong> 暂停用户线程，多条筛选线程并行。负责更新Region的统计数据，对各个Region的回收价值和成本进行排序，根据用户所期望的停顿时间来制定回收计划，可以自由选择任意多个 Region 构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，再清理掉整个旧 Region的全部空间。</li>
</ol>
<p><img src="./README.assets/image-20220317091331512.png" alt="image-20220317091331512" loading="lazy"></p>
<div><p>用户指定期望的停顿时间</p>
<p>由用户指定期望的停顿时间是G1收集器很强大的一个功能，设置不同的期望停顿 时间，可使得G1在不同应用场景中取得关注吞吐量和关注延迟之间的最佳平衡。</p>
</div>
<div><p>应付应用的内存分配速率的垃圾收集</p>
<p>从G1开始，最先进的垃圾收集器的设计导向都不约而同地变为追求能够应付应用的内存分配速率 （Allocation Rate），而不追求一次把整个Java堆全部清理干净。这样，应用在分配，同时收集器在收集，只要收集的速度能跟得上对象分配的速度，那一切就能运作得很完美。</p>
</div>
<div><p>CMS 和 G1 的优缺点对比</p>
<p>（看不懂）</p>
<p><img src="./README.assets/image-20220317091337548.png" alt="image-20220317091337548" loading="lazy"></p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T01:20:00.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">内存分配与回收策略</title>
    <id>https://notes.lllllan.cn/java/jvm/3/8/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/8/"/>
    <updated>2022-03-17T02:28:45.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p>Java技术体系的自动内存管理，最根本的目标是自动化地解决两个问题：<mark>自动给对象分配内存</mark> 以及 <mark>自动回收分配给对象的内存</mark></p>
<div><p>对象的内存分配</p>
<p>从概念上讲，应该都是在堆上分配。而实际上也有可能经过即时编译后被拆散成标量类型并间接在栈上分配。</p>
</div>
<p>在经典分代的设计下，新生对象通常会分配在新生代中，少数情况下（例如对象大小超过一定阈值）也可能会直接分配在老年代。</p>
<p>对象分配的规则并不是固定的， 《Java虚拟机规范》并未规定新对象的创建和存储细节，这取决于虚拟机当前使用的是哪一种垃圾收集器，以及虚拟机中与内存相关的参数的设定。</p>
<h2 id="一、对象优先在eden分配"> 一、对象优先在Eden分配</h2>
<p>大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC。</p>
<h2 id="二、大对象直接进入老年代"> 二、大对象直接进入老年代</h2>
<p>在Java虚拟机中要避免大对象的原因是，在分配空间时，它容易导致内存明明还有不少空间时就提前触发垃圾收集，以获取足够的连续空间才能安置好它们，而当复制对象时，大对象就意味着高额的内存复制开销。</p>
<p>HotSpot虚拟机提供了 <code>-XX：PretenureSizeThreshold</code> 参数，指定大于该设置值的对象直接在老年代分配，这样做的目的就是避免在Eden区及两个Survivor区之间来回复制，产生大量的内存复制操作。</p>
<h2 id="三、长期存活的对象将进入老年代"> 三、长期存活的对象将进入老年代</h2>
<p>HotSpot虚拟机中多数收集器都采用了分代收集来管理堆内存，那内存回收时就必须能决策哪些存活对象应当放在新生代，哪些存活对象放在老年代中。虚拟机给每个对象定义了一个对象年龄（Age）计数器，存储在对象头中</p>
<p>对象通常在Eden区里诞生，如果经过第一次 Minor GC后仍然存活，并且能被Survivor容纳的话，该对象会被移动到Survivor空间中，并且将其对象 年龄设为1岁。对象在Survivor区中每熬过一次Minor GC，年龄就增加1岁，当它的年龄增加到一定程 度（默认为15），就会被晋升到老年代中。对象晋升老年代的年龄阈值，可以通过参数 <code>-XX： MaxTenuringThreshold</code> 设置。</p>
<h2 id="四、动态对象年龄判定"> 四、动态对象年龄判定</h2>
<p>为了能更好地适应不同程序的内存状况，HotSpot虚拟机并不是永远要求对象的年龄必须达到 <code>-XX：MaxTenuringThreshold</code> 才能晋升老年代，如果在Survivor空间中相同年龄所有对象大小的总和大于 Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代，无须等到 <code>-XX： MaxTenuringThreshold</code> 中要求的年龄。</p>
<h2 id="五、空间分配担保"> 五、空间分配担保</h2>
<p>在发生Minor GC之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次Minor GC可以确保是安全的。</p>
<p>如果不成立，则虚拟机会先查看 <code>-XX：HandlePromotionFailure</code> 参数的设置值是否允许担保失败（Handle Promotion Failure）；如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次Minor GC，尽管这次Minor GC是有风险的；如果小于，或者 <code>-XX： HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次Full GC。</p>
<div><p>冒险</p>
<p>前面提到过，新生代使用复制收集算法，但为了内存利用率， 只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况 ——最极端的情况就是内存回收后新生代中所有对象都存活，需要老年代进行分配担保，把Survivor无 法容纳的对象直接送入老年代，这与生活中贷款担保类似。老年代要进行这样的担保，前提是老年代本身还有容纳这些对象的剩余空间，但一共有多少对象会在这次回收中活下来在实际完成内存回收之 前是无法明确知道的，所以只能取之前每一次回收晋升到老年代对象容量的平均大小作为经验值，与老年代的剩余空间进行比较，决定是否进行Full GC来让老年代腾出更多空间。</p>
<p>取历史平均值来比较其实仍然是一种赌概率的解决办法，也就是说假如某次Minor GC存活后的对 象突增，远远高于历史平均值的话，依然会导致担保失败。如果出现了担保失败，那就只好老老实实地重新发起一次Full GC，这样停顿时间就很长了。虽然担保失败时绕的圈子是最大的，但通常情况下 都还是会将 <code>-XX：HandlePromotionFailure</code>开关打开，避免Full GC过于频繁。</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T02:28:45.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">低延迟垃圾收集器</title>
    <id>https://notes.lllllan.cn/java/jvm/3/6/</id>
    <link href="https://notes.lllllan.cn/java/jvm/3/6/"/>
    <updated>2022-03-17T02:04:25.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p>衡量垃圾收集器的三项最重要的指标是：<mark>内存占用（Footprint）、吞吐量（Throughput）和延迟 （Latency）</mark> ，三者共同构成了一个“不可能三角”</p>
<p>图3-14中浅色阶段表示必须挂起用户线程，深色表示收集器线程与用户线程是并发工作的。</p>
<p><img src="./README.assets/image-20220317093803558.png" alt="image-20220317093803558" loading="lazy"></p>
<h2 id="一、shenandoah-收集器"> 一、Shenandoah 收集器</h2>
<p>Shenandoah 更像是 G1 的下一代继承者，它们两者有着相似的堆内存布局，在初始标记、并发标记等许多阶段的处理思路上都高度一致，甚至还直接共享了一部分实现代码</p>
<h3 id="_1-1-shenandoah-和-g1-的不同"> 1.1 Shenandoah 和 G1 的不同</h3>
<ol>
<li>支持并发的整理算法：G1 的回收阶段是可以多线程并行的，但不能与用户线程并发</li>
<li>默认不使用分代收集：</li>
<li>摒弃记忆集，改用连接矩阵：连接矩阵记录跨Region的引用关系，降低了处理跨代指针时的记忆集维护消耗，也降低了伪共享问题的发生概率</li>
</ol>
<p><img src="./README.assets/image-20220317095213696.png" alt="image-20220317095213696" loading="lazy"></p>
<div><p>连接矩阵</p>
<p>不太懂，以后再补</p>
</div>
<h3 id="_1-2-工作阶段"> 1.2 工作阶段</h3>
<ol>
<li>初始标记：首先标记与GC Roots直接关联的对象，仍然是 <mark>Stop The World</mark></li>
<li>并发标记：遍历对象图，标记出全部可达的对象， <mark>与用户线程并发</mark></li>
<li>最终标记：处理剩余的SATB扫描，并在这个阶段统计出回收价值最高的Region，将这些Region构成一组回收集。 <mark>有停顿</mark></li>
<li>并发清理：清理那些整个区域内连一个存活对象都没有找到的Region</li>
<li>并发回收：把回收集里面的存活对象先复制一份到其他未被使用的Region之中。（涉及读屏障、转发指针）</li>
<li>初始引用更新：建立一个线程集合点，确保所有并发回收阶段中进行的收集器线程都已完成分配给它们的对象移动任务。 <mark>短暂停顿</mark></li>
<li>并发引用更新：把堆中所有指向旧对象的引用修正到复制后的新地。 <mark>与用户线程并发</mark></li>
<li>最终引用更新：修正存在于GC Roots 中的引用。 <mark>最后一次停顿</mark></li>
<li>并发清理：回收内存空间</li>
</ol>
<p><img src="./README.assets/image-20220317100109273.png" alt="image-20220317100109273" loading="lazy"></p>
<div><p>插眼</p>
<p>文档中后半部分看不懂，没再记录，之后再补</p>
</div>
<h2 id="二、zgc-收集器"> 二、ZGC 收集器</h2>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-17T02:04:25.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">无关性的基石</title>
    <id>https://notes.lllllan.cn/java/jvm/6/2/</id>
    <link href="https://notes.lllllan.cn/java/jvm/6/2/"/>
    <updated>2022-03-21T05:07:48.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p><strong>平台无关性</strong></p>
<p>各种不同平台的Java虚拟机，以及所有平台都统一支持的程序存储格式 —— 字节码是构成平台无关性的基石。</p>
<p><strong>语言无关性</strong></p>
<p>GraalVM 能够支持不同语言的运行</p>
<p><img src="./README.assets/image-20220321130633830.png" alt="image-20220321130633830" loading="lazy"></p>
<p><img src="./README.assets/image-20220321130742524.png" alt="image-20220321130742524" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-21T05:07:08.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节码指令简介</title>
    <id>https://notes.lllllan.cn/java/jvm/6/4/</id>
    <link href="https://notes.lllllan.cn/java/jvm/6/4/"/>
    <updated>2022-03-23T02:35:51.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p>Java 虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（操作码，Opcode）以及跟随其后的零至多个代表此操作所需的参数（操作数，Operand）构成。</p>
<p><strong>优点：</strong></p>
<ol>
<li>放弃了操作数长度对齐，就意味着可以省略掉大量的填充和间隔字符</li>
<li>用一个字节来代表操作码，也是为了尽可能获得短小精干的编译代码</li>
</ol>
<p><strong>缺点：</strong></p>
<ol>
<li>操作码的长度为一个字节，意味着指令集的操作码总数不能超过256</li>
<li>由于 Class 文件格式放弃了编译后代码的操作数长度对齐，意味着虚拟机在处理超过一个字节的数据时，不得不在运行时从字节中重建出具体数据的结构</li>
</ol>
<div><p>字节码和数据类型</p>
<p>因为Java虚拟机的操作码长度只有一字节，所以包含了数据类型的操作码就为指令集的设计带来了很大的压力：如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那么指令的数量恐怕就会超出一字节所能表示的数量范围了。因此，<strong>Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它，换句话说，指令集将会被故意设计成非完全独立的。</strong></p>
</div>
<ol>
<li>
<p>加载和存储指令</p>
<blockquote>
<p>加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输</p>
</blockquote>
</li>
<li>
<p>运算指令</p>
<blockquote>
<p>算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。</p>
</blockquote>
</li>
<li>
<p>类型转换指令</p>
<blockquote>
<p>类型转换指令可以将两种不同的数值类型相互转换。</p>
<ul>
<li>
<p>Java 虚拟机直接支持（即转换时无须显式的转换指令）数值类型的宽化类型转换（即小范围类型转向大范围类型的安全转换）</p>
</li>
<li>
<p>处理窄化类型转换时就必须显式地使用转换指令来完成</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>对象创建与访问指令</p>
<blockquote>
<p>虽然类实例和数组都是对象，但Java虚拟机对类实例和数组的创建与操作使用了不同的字节码指令。对象创建后，就可以通过对象访问指令获取对象实例或者数组实例中的字段或者数组元素</p>
</blockquote>
</li>
<li>
<p>操作数栈管理指令</p>
<blockquote>
<p>如同操作一个普通数据结构中的堆栈那样，Java虚拟机提供了一些用于直接操作操作数栈的指令</p>
</blockquote>
</li>
<li>
<p>控制转移指令</p>
<blockquote>
<p>控制转移指令可以让Java虚拟机有条件或无条件地从指定位置指令（而不是控制转移指令）的下一条指令继续执行程序，从概念模型上理解，可以认为控制指令就是在有条件或无条件地修改PC寄存器的值。</p>
</blockquote>
</li>
<li>
<p>方法调用和返回指令</p>
<blockquote>
<p>方法调用指令与数据类型无关，而方法返回指令是根据返回值的类型区分的</p>
</blockquote>
</li>
<li>
<p>异常处理指令</p>
<blockquote>
<p>而在Java虚拟机中，处理异常（catch语句）不是由字节码指令来实现的（很久之前曾经使用jsr和 ret指令来实现，现在已经不用了），而是采用异常表来完成</p>
</blockquote>
</li>
<li>
<p>同步指令</p>
<blockquote>
<p>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用 <mark>管程</mark> （Monitor，更常见的是直接将它称为“锁”）来实现的</p>
</blockquote>
</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-21T06:28:43.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">类加载的过程</title>
    <id>https://notes.lllllan.cn/java/jvm/7/3/</id>
    <link href="https://notes.lllllan.cn/java/jvm/7/3/"/>
    <updated>2022-03-23T08:27:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<h2 id="一、加载"> 一、加载</h2>
<blockquote>
<p>加载阶段，是整个类加载过程中的其中一个阶段</p>
</blockquote>
<ol>
<li>通过一个类的全限定名来获取此类的二进制字节流</li>
<li>将这个字节流的静态存储结构转化为方法区的运行时数据结构</li>
<li>在内存中生成一个代表这个类的 <code>java.lang.Class</code> 对象，作为方法区这个类的各种数据的访问入口</li>
</ol>
<h3 id="灵活度大"> 灵活度大</h3>
<p>《Java虚拟机规范》对这三点要求其实并不是特别具体，留给虚拟机实现与Java应用的灵活度都是相当大的</p>
<p>例如【通过一个类的全限定名来获取定义此类的二进制字节流】这条规则，它并没有指明二进制字节流必须得从某个Class文件中获取，确切地说是根本没有指明要从哪里获取、如何获取。</p>
<ul>
<li>从ZIP压缩包中读取，这很常见，最终成为日后JAR、EAR、WAR格式的基础。</li>
<li>从网络中获取，这种场景最典型的应用就是Web Applet。</li>
<li>由其他文件生成，典型场景是JSP应用，由JSP文件生成对应的Class文件。</li>
<li>...</li>
</ul>
<h3 id="非数组类型的加载"> 非数组类型的加载</h3>
<p>非数组类型的加载阶段（准确地说，是加载阶段中获取类的二进制字节流的动作）是开发人员可控性最强的阶段。加载阶段既可以使用Java虚拟机里内置的引导类加载器来完成，也可以由用户自定义的类加载器去完成，开发人员通过定义自己的类加载器去控制字节流的获取方式（重写一个类加载器的 <code>findClass()</code> 或 <code>loadClass()</code> 方法），实现根据自己的想法来赋予应用程序获取运行代码的动态性。</p>
<h3 id="数组类型的加载"> 数组类型的加载</h3>
<p>数组类本身不通过类加载器创建，它是由Java虚拟机直接在内存中动态构造出来的。</p>
<p>但数组类与类加载器仍然有很密切的关系，因为数组类的元素类型（Element Type，指的是数组去掉所有维度的类型）最终还是要靠类加载器来完成加载，一个数组类（下面简称为C）创建过程遵循以下规则：</p>
<ul>
<li>如果数组的组件类型（Component Type，指的是数组去掉一个维度的类型，注意和前面的元素类型区分开来）是引用类型，那就递归采用本节中定义的加载过程去加载这个组件类型，数组C将被标识在加载该组件类型的类加载器的类名称空间上</li>
<li>如果数组的组件类型不是引用类型（例如int[]数组的组件类型为int），Java虚拟机将会把数组C标记为与引导类加载器关联。</li>
<li>数组类的可访问性与它的组件类型的可访问性一致，如果组件类型不是引用类型，它的数组类的可访问性将默认为public，可被所有的类和接口访问到。</li>
</ul>
<h2 id="二、验证"> 二、验证</h2>
<p>验证是连接阶段的第一步，这一阶段的目的是 <mark>确保Class文件的字节流中包含的信息符合《Java虚拟机规范》的全部约束要求，保证这些信息被当作代码运行后不会危害虚拟机自身的安全</mark></p>
<h3 id="_2-1-文件格式验证"> 2.1 文件格式验证</h3>
<p>第一阶段要验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理。</p>
<ul>
<li>是否以魔数 <code>0xCAFEBABE</code> 开头</li>
<li>主、次版本号是否在当前Java虚拟机接受范围之内</li>
<li>常量池的常量中是否有不被支持的常量类型（检查常量tag标志）</li>
<li>...</li>
</ul>
<p>这阶段的验证是基于二进制字节流进行的，只有通过了这个阶段的验证之后，这段字节流才被允许进入Java虚拟机内存的方法区中进行存储</p>
<hr>
<h3 id="_2-2-元数据验证"> 2.2 元数据验证</h3>
<p>第二阶段是对字节码描述的信息进行语义分析</p>
<ul>
<li>这个类是否有父类（除了java.lang.Object之外，所有的类都应当有父类）</li>
<li>这个类的父类是否继承了不允许被继承的类（被final修饰的类）</li>
<li>如果这个类不是抽象类，是否实现了其父类或接口之中要求实现的所有方法</li>
<li>...</li>
</ul>
<p>第二阶段的主要目的是 <strong>对类的元数据信息进行语义校验</strong>，保证不存在与《Java语言规范》定义相悖的元数据信息。</p>
<hr>
<h3 id="_2-3-字节码验证"> 2.3 字节码验证</h3>
<p>第三阶段是整个验证过程中最复杂的一个阶段，主要目的是 <strong>通过数据流分析和控制流分析，确定程序语义是合法的、符合逻辑的</strong>。在第二阶段对元数据信息中的数据类型校验完毕以后，这阶段就要对类的方法体（Class文件中的Code属性）进行校验分析，<strong>保证被校验类的方法在运行时不会做出危害虚拟机安全的行为</strong></p>
<ul>
<li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作，例如不会出现类似于“在操作栈放置了一个int类型的数据，使用时却按long类型来加载入本地变量表中”这样的情况</li>
<li>保证任何跳转指令都不会跳转到方法体以外的字节码指令上</li>
<li>...</li>
</ul>
<p>如果一个类型中有方法体的字节码没有通过字节码验证，那它肯定是有问题的；但如果一个方法体通过了字节码验证，也仍然不能保证它一定就是安全的。即使字节码验证阶段中进行了再大量、再严密的检查，也依然不能保证这一点。</p>
<hr>
<h3 id="_2-4-符号引用验证"> 2.4 符号引用验证</h3>
<p>最后一个阶段的校验行为发生在虚拟机将符号引用转化为直接引用的时候，这个转化动作将在连接的第三阶段——解析阶段中发生。符号引用验证可以看作是对类自身以外（常量池中的各种符号引用）的各类信息进行匹配性校验，通俗来说就是，该类是否缺少或者被禁止访问它依赖的某些外部类、方法、字段等资源</p>
<ul>
<li>符号引用中通过字符串描述的全限定名是否能找到对应的类。</li>
<li>在指定类中是否存在符合方法的字段描述符及简单名称所描述的方法和字段。</li>
<li>...</li>
</ul>
<p>符号引用验证的主要目的是 <strong>确保解析行为能正常执行</strong>，如果无法通过符号引用验证，Java虚拟机 将会抛出一个 <code>java.lang.IncompatibleClassChangeError</code> 的子类异常</p>
<h2 id="三、准备"> 三、准备</h2>
<p>准备阶段是正式为类中定义的变量（即静态变量，被static修饰的变量） <mark>分配内存并设置类变量初始值的阶段</mark></p>
<div><p>误区</p>
<p>这时候进行内存分配的仅包括类变量，而不包括实例变量；实例变量会在对象实例化时随着对象一起分配在 Java 堆中</p>
<p>设置初始值通常情况下是数据类型的零值。</p>
</div>
<p><img src="./README.assets/image-20220323155214025.png" alt="image-20220323155214025" loading="lazy"></p>
<h2 id="四、解析"> 四、解析</h2>
<p>解析阶段是Java虚拟机 <mark>将常量池内的符号引用替换为直接引用的过程</mark></p>
<div><p>符号引用</p>
<p>符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。</p>
<p>符号引用与虚拟机实现的内存布局无关，引用的目标并不一定是已经加载到虚拟机内存当中的内容。</p>
</div>
<div><p>直接引用</p>
<p>直接引用是可以直接指向目标的指针、相对偏移量或者是一个能间接定位到目标的句柄。</p>
<p>直接引用是和虚拟机实现的内存布局直接相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那引用的目标必定已经在虚拟机的内存中存在。</p>
</div>
<h3 id="_4-1-类或接口的解析"> 4.1 类或接口的解析</h3>
<p>假设当前代码所处的类为D，如果要把一个从未解析过的符号引用N解析为一个类或接口C的直接引用，那虚拟机完成整个解析的过程需要包括以下3个步骤：</p>
<ol>
<li>如果C不是一个数组类型，那虚拟机将会把代表N的全限定名传递给D的类加载器去加载这个类C。在加载过程中，由于元数据验证、字节码验证的需要，又可能触发其他相关类的加载动作，例如加载这个类的父类或实现的接口。一旦这个加载过程出现了任何异常，解析过程就将宣告失败。</li>
<li>如果C是一个数组类型，并且数组的元素类型为对象，也就是N的描述符会是类似 <code>[Ljava/lang/Integer</code> 的形式，那将会按照第一点的规则加载数组元素类型。如果N的描述符如前面所假设的形式，需要加载的元素类型就是 <code>java.lang.Integer</code> ，接着由虚拟机生成一个代表该数组维度和元素的数组对象。</li>
<li>如果上面两步没有出现任何异常，那么C在虚拟机中实际上已经成为一个有效的类或接口了，但在解析完成前还要进行符号引用验证，确认D是否具备对C的访问权限。如果发现不具备访问权限，将抛出 <code>java.lang.IllegalAccessError</code> 异常。</li>
</ol>
<h3 id="_4-2-字段解析"> 4.2 字段解析</h3>
<ol>
<li>如果C本身就包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果在C中实现了接口，将会按照继承关系从下往上递归搜索各个接口和它的父接口，如果接口中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，如果C不是 <code>java.lang.Object</code> 的话，将会按照继承关系从下往上递归搜索其父类，如果在父类中包含了简单名称和字段描述符都与目标相匹配的字段，则返回这个字段的直接引用，查找结束。</li>
<li>否则，查找失败，抛出 <code>java.lang.NoSuchFieldError</code> 异常。</li>
</ol>
<p>如果查找过程成功返回了引用，将会对这个字段进行权限验证，如果发现不具备对字段的访问权限，将抛出 <code>java.lang.IllegalAccessError</code> 异常。</p>
<h3 id="_4-3-方法解析"> 4.3 方法解析</h3>
<ol>
<li>与类的方法解析相反，如果在接口方法表中发现 <code>class_index</code> 中的索引C是个类而不是接口，那么就直接抛出 <code>java.lang.IncompatibleClassChangeError</code> 异常</li>
<li>否则，在接口C中查找是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束。</li>
<li>否则，在接口C的父接口中递归查找，直到 <code>java.lang.Object</code> 类（接口方法的查找范围也会包括 <code>Object</code> 类中的方法）为止，看是否有简单名称和描述符都与目标相匹配的方法，如果有则返回这个方法的直接引用，查找结束</li>
<li>对于规则3，由于Java的接口允许多重继承，如果C的不同父接口中存有多个简单名称和描述符都与目标相匹配的方法，那将会从这多个方法中返回其中一个并结束查找，《Java虚拟机规范》中并没有进一步规则约束应该返回哪一个接口方法。但与之前字段查找类似地，不同发行商实现的Javac编译器有可能会按照更严格的约束拒绝编译这种代码来避免不确定性。</li>
<li>否则，宣告方法查找失败，抛出 <code>java.lang.NoSuchMethodError</code> 异常</li>
</ol>
<h2 id="五、初始化"> 五、初始化</h2>
<p>进行准备阶段时，变量已经赋过一次系统要求的初始零值，而在初始化阶段，则会根据程序员通过程序编码制定的主观计划去初始化类变量和其他资源。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-23T06:16:13.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Class 类文件的结构</title>
    <id>https://notes.lllllan.cn/java/jvm/6/3/</id>
    <link href="https://notes.lllllan.cn/java/jvm/6/3/"/>
    <updated>2022-03-23T02:35:51.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://blog.csdn.net/BraveLoser/article/details/82500474" target="_blank" rel="noopener noreferrer">基础储备----字面量, 符号引用与直接引用</a></li>
</ul>
</div>
<p><strong>Class 文件是一组以 8 个字节为基础单位的二进制流。</strong></p>
<p>各个数据项目严格按照顺序紧凑地排列在文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8个字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8个字节进行存储。</p>
<div><p>【class文件】 和 【类或接口】</p>
<p>任何一个 Class 文件都对应着唯一的一个类或接口的定义信息。</p>
<p>但是反过来，类或接口不一定都得定义在文件里（譬如类或接口也可以动态生成，直接送入类加载器中）</p>
</div>
<p>根据《Java虚拟机规范》的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：【无符号数】和【表】。</p>
<ul>
<li>无符号数属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，<u>无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值</u>。</li>
<li>表是由多个无符号数或者其他表作为数据项构成的复合数据类型，为了便于区分，所有表的命名都习惯性地以【_info】结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上也可以视作是一张表</li>
</ul>
<h2 id="一、魔数与class文件的版本"> 一、魔数与Class文件的版本</h2>
<div><p>魔数</p>
<p>每个 Class 文件的头4个字节被称为魔数，<strong>它唯一的作用是确定这个文件是否为一个能被虚拟机接收的 Class 文件。</strong></p>
<p>Class 文件的魔数取值为 <code>0xCAFEBABE</code> （咖啡宝贝？）</p>
</div>
<div><p>版本号</p>
<p>紧接着魔数的4个字节存储的 Class 文件的版本号，56两个字节是次版本号，78两个字节是主版本号。</p>
</div>
<h2 id="二、常量池"> 二、常量池</h2>
<div><p>常量池</p>
<p>版本号之后的是常量池入口，可以比喻为 Class 文件里的资源仓库。</p>
<p>常量池中主要存放两大类常量：【字面量】、【符号引用】。</p>
<ul>
<li>字面量比较接近于 Java 语言层面的常量概念，如文本字符串、被声明 final 的常量值</li>
<li>符号引用则属于编译原理方面的概念：被模块导出或者开放的包、类和接口的全限定名、字段的名称和描述符、方法的名称和描述符、方法句柄和方法类型、动态调用和动态常量</li>
</ul>
</div>
<blockquote>
<p>Class 文件结构中只有常量池的容量计数是从1开始的。</p>
<p><img src="./README.assets/image-20220321134555529.png" alt="image-20220321134555529" loading="lazy"></p>
</blockquote>
<div><p>字面量 & 符号引用 & 直接引用</p>
<ul>
<li>
<p>字面量：字面量(literal)是用于表达源代码中一个固定值的表示法(notation)。</p>
<blockquote>
<p>int i = 1; 把整数1赋值给int型变量i，整数1就是Java字面量。</p>
<p>String s = &quot;abc&quot;; 中的abc也是字面量。</p>
</blockquote>
</li>
<li>
<p>符号引用：以一组符号来描述所引用的目标。</p>
<blockquote>
<p>比如 <code>org.simple.People</code> 类引用了 <code>org.simple.Language</code> 类, 在编译时 <code>People</code> 类并不知道 <code>Language</code> 类的实际内存地址, 因此只能使用符号 <code>org.simple.Language</code> 来表示 <code>Language</code> 类的地址</p>
</blockquote>
</li>
<li>
<p>直接引用：程序运行时可以定位到引用的东西（类, 对象, 变量或者方法等）的地址</p>
</li>
</ul>
</div>
<h2 id="三、访问标志"> 三、访问标志</h2>
<div><p>访问标志</p>
<p>常量池之后两个字节标识访问标志，这个标志用于识别一些类或者接口层次的访问信息。</p>
</div>
<p><img src="./README.assets/image-20220321135723035.png" alt="image-20220321135723035" loading="lazy"></p>
<h2 id="四、类索引、父类索引、接口索引集合"> 四、类索引、父类索引、接口索引集合</h2>
<p>类索引和父类索引都是一个 u2 类型的数据，而接口索引集合是一组 u2 类型的数据的集合，Class 文件中由着三项数据来确定该类型的继承关系。</p>
<ul>
<li>类型索引用于确定这个类的全限定名</li>
<li>父类索引用于确定这个类的父类的全限定名</li>
<li>接口索引集合用来描述实现了哪些接口</li>
</ul>
<h2 id="五、字段表集合"> 五、字段表集合</h2>
<p>字段表用于描述接口或类中声明的变量。</p>
<blockquote>
<p>Java语言中的“字段”（Field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量</p>
</blockquote>
<p><img src="./README.assets/image-20220321141759349.png" alt="image-20220321141759349" loading="lazy"></p>
<ol>
<li>
<p>字段修饰符 access_flags</p>
<blockquote>
<p><img src="./README.assets/image-20220321141841952.png" alt="image-20220321141841952" loading="lazy"></p>
</blockquote>
</li>
<li>
<p>简单名称 name_index，方法名或字段名</p>
</li>
<li>
<p>修饰符 descriptor_index，描述字段的数据类型、方法的参数列表和返回值</p>
</li>
<li>
<p>属性表集合，用于存储一些额外的信息</p>
</li>
</ol>
<h2 id="六、方法表集合"> 六、方法表集合</h2>
<p>Class文件存储 格式中对方法的描述与对字段的描述采用了几乎完全一致的方式，方法表的结构如同字段表一样，依次包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项</p>
<p><img src="./README.assets/image-20220321142237514.png" alt="image-20220321142237514" loading="lazy"></p>
<p><img src="./README.assets/image-20220321142247105.png" alt="image-20220321142247105" loading="lazy"></p>
<h2 id="七、属性表集合"> 七、属性表集合</h2>
<p>Class文件、字段表、方法表都可以携带自己的属性表集合，以描述某些场景专有的信息。</p>
<p><img src="./README.assets/image-20220321142538079.png" alt="image-20220321142538079" loading="lazy"></p>
<div><p>属性表集合</p>
<p>《》P321，内容太多暂且跳过。</p>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-21T05:07:08.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">类加载器</title>
    <id>https://notes.lllllan.cn/java/jvm/7/4/</id>
    <link href="https://notes.lllllan.cn/java/jvm/7/4/"/>
    <updated>2022-03-25T07:39:52.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://blog.csdn.net/u010312474/article/details/91046318" target="_blank" rel="noopener noreferrer">双亲委派模式的优点</a></li>
</ul>
</div>
<p>Java虚拟机设计团队有意把类加载阶段中的【通过一个类的全限定名来获取描述该类的二进制字节流】这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需的类。实现这个动作的代码被称为【类加载器】（Class Loader）。</p>
<h2 id="一、类与类加载器"> 一、类与类加载器</h2>
<p>类加载器用于实现类的加载动作。</p>
<div><p>Note</p>
<p>对于任意一个类，都必须由加载它的类加载器和这个类本身一起共同确立其在 Java虚拟机中的唯一性，每一个类加载器都拥有一个独立的类命名空间。</p>
<p>即：比较两个类是否【相等】，只有在这两个类是由同一个类加载器加载的前提下才有意义。否则，即使这两个类来源于同一个 Class 文件、被同一个 Java 虚拟机加载，只要加载他们的类加载器不同，那么这两个类就必定不相等。</p>
<blockquote>
<p>这里所指的【相等】，包括代表类的 Class 对象的 <code>equals(), isAssignableFrom(), isInstance()</code> 的返回结果，也包括了使用 <code>instanceof</code> 关键字做对象所属关系判定等各种情况。</p>
</blockquote>
</div>
<h2 id="二、双亲委派模型"> 二、双亲委派模型</h2>
<p>站在 Java 虚拟机的角度来看，只有两种不同的类加载器：</p>
<ol>
<li>启动类加载器，使用 C++ 语言实现，是虚拟机自身的一部分</li>
<li>其他所有类加载器，由 Java 语言实现，独立存在于虚拟机外部，并且全部继承自抽象类 <code>java.lang.ClassLoader</code></li>
</ol>
<p>站在 Java 开发人员的角度来看，Java 一直保持着三层类加载器、双亲委派的类加载架构</p>
<h3 id="三层类加载器"> 三层类加载器</h3>
<ol>
<li><strong>启动类加载器</strong>：这个加载器负责加载放在 <code>&lt;JAVA_HOME&gt;\lib</code> 目录，或者被 <code>-Xbootclasspath</code> 参数指定的路径中存放的、而且是Java虚拟机能够识别的类库加载到虚拟机的内存中。</li>
<li><strong>扩展类加载器</strong>：负责加载 <code>&lt;JAVA_HOME&gt;\lib\ext</code> 目录中，或者被 <code>java.ext.dirs</code> 系统变量所指定的路径中的所有类库。允许用户将具有通用性的类库放置在ext目录里以扩展Java SE的功能</li>
<li><strong>应用程序类加载器</strong>：负责加载用户类路径上的所有类库，开发者同样可以直接在代码中使用这个类加载器。</li>
</ol>
<p><img src="./README.assets/image-20220325151231771.png" alt="image-20220325151231771" loading="lazy"></p>
<p>JDK 9 之前的 Java 应用都是由这三种类加载器互相配合来完成加载的，如果用户认为有必要，还可以加入自定义的类加载器来进行扩展。</p>
<h3 id="双亲委派模型"> 双亲委派模型</h3>
<p>上图各种类加载器之间的层次关系被称为类加载器的【双亲委派模型】。</p>
<p>双亲委派模型要求出了顶层的启动类加载器外，其余的类加载器都应有自己的父类加载器。不过这里的父子关系一般不是以继承的关系来实现，而是通常使用组合关系来复用父加载器的代码。</p>
<div><p>双亲委派模型的工作过程：</p>
<p>如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这请求委派给父类加载器去完成，每一个层次的类加载器都是如此。因此所有的加载请求最终都应该传送到最顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个类加载请求时（它的搜索范围中没有找到所需要的类）时，子加载器才会尝试自己去完成加载。</p>
</div>
<div><p>双亲委派模型的好处</p>
<p><strong>避免重复加载 + 避免核心类篡改</strong></p>
<p>采用双亲委派模式的是好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系，通过这种层级关可以避免类的重复加载，当父亲已经加载了该类时，就没有必要子ClassLoader再加载一次。</p>
<p>其次是考虑到安全因素，java核心api中定义类型不会被随意替换，假设通过网络传递一个名为 <code>java.lang.Integer</code> 的类，通过双亲委托模式传递到启动类加载器，而启动类加载器在核心Java API发现这个名字的类，发现该类已被加载，并不会重新加载网络传递的过来的 <code>java.lang.Integer</code> ，而直接返回已加载过的 <code>Integer.class</code> ，这样便可以防止核心API库被随意篡改。</p>
</div>
<h2 id="三、破坏双亲委派模型"> 三、破坏双亲委派模型</h2>
<p>双亲委派模型并不是一个具有强制性约束的模型，而是Java设计者推荐给开发者们的类加载器实现方式。</p>
<blockquote>
<p><img src="./README.assets/image-20220325153606566.png" alt="image-20220325153606566" loading="lazy"></p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-23T06:16:13.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">类加载的时机</title>
    <id>https://notes.lllllan.cn/java/jvm/7/2/</id>
    <link href="https://notes.lllllan.cn/java/jvm/7/2/"/>
    <updated>2022-03-23T08:27:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p>个类型从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期将会经历加载 （Loading）、验证（Verification）、准备（Preparation）、解析（Resolution）、初始化 （Initialization）、使用（Using）和卸载（Unloading）七个阶段，其中验证、准备、解析三个部分统称为连接（Linking）</p>
<p><img src="./README.assets/image-20220323142422667.png" alt="image-20220323142422667" loading="lazy"></p>
<p><u>加载、验证、准备、初始化和卸载</u> 这五个阶段的顺序是确定的，类型的加载过程必须按照这种顺序按部就班地开始，而 <strong>解析阶段则不一定：它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定特性（也称为动态绑定或晚期绑定）</strong></p>
<h2 id="加载"> 加载</h2>
<p>关于在什么情况下需要开始类加载过程的第一个阶段“加载”，《Java虚拟机规范》中并没有进行强制约束，这点可以交给虚拟机的具体实现来自由把握。</p>
<h2 id="初始化"> 初始化</h2>
<p>但对于初始化阶段有且只有六种情况必须立即对类进行初始化：</p>
<ol>
<li>遇到 <code>new、getstatic、putstatic、invokestatic</code> 这四条字节码指令时，如果类型没有进行过初始化，则需要先触发其初始化阶段。
<ul>
<li>使用new关键字实例化对象</li>
<li>读取或设置一个类型的静态字段（被final修饰、已在编译期把结果放入常量池的静态字段除外）</li>
<li>调用一个类型的静态方法</li>
</ul>
</li>
<li>使用 <code>java.lang.reflect</code> 包的方法对类型进行反射调用的时候，如果类型没有进行过初始化，则需要先触发其初始化。</li>
<li>当初始化类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化。</li>
<li>当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类。</li>
<li>当使用JDK 7新加入的动态语言支持时，如果一个 <code>java.lang.invoke.MethodHandle</code> 实例最后的解析结果为 <code>REF_getStatic、REF_putStatic、REF_invokeStatic、REF_newInvokeSpecial</code> 四种类型的方法句柄，并且这个方法句柄对应的类没有进行过初始化，则需要先触发其初始化</li>
<li>当一个接口中定义了JDK 8新加入的默认方法（被default关键字修饰的接口方法）时，如果有这个接口的实现类发生了初始化，那该接口要在其之前被初始化。</li>
</ol>
<p>对于这六种会触发类型进行初始化的场景，《Java虚拟机规范》中使用了一个非常强烈的限定语 ——“有且只有”，这六种场景中的行为称为对一个类型进行主动引用。除此之外，所有引用类型的方式都不会触发初始化，称为被动引用。（书上有栗子，看不懂记不住就没有抄）</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-23T06:16:13.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">运行时栈帧结构</title>
    <id>https://notes.lllllan.cn/java/jvm/8/2/</id>
    <link href="https://notes.lllllan.cn/java/jvm/8/2/"/>
    <updated>2022-03-25T13:52:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
<li><a href="https://zhuanlan.zhihu.com/p/45354152" target="_blank" rel="noopener noreferrer">Java虚拟机—栈帧、操作数栈和局部变量表</a></li>
</ul>
</div>
<p><mark>Java虚拟机以方法作为最基本的执行单元</mark></p>
<p>【栈帧（Stack Frame）】则是用于支持虚拟机进行方法调用和方法执行背后的数据结构，它也是虚拟机运行时数据区中的虚拟机栈（Virtual Machine Stack）的栈元素</p>
<p>每一个栈帧都包括了局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。</p>
<p>一个线程中的方法调用链可能会很长，以Java程序的角度来看，同一时刻、同一条线程里面，在调用堆栈的所有方法都同时处于执行状态。而对于执行引擎来讲，在活动线程中，只有位于栈顶的方法才是在运行的，只有位于栈顶的栈帧才是生效的，其被称为【当前栈帧】（Current Stack Frame），与这个栈帧所关联的方法被称为【当前方法】（Current Method）</p>
<p><img src="./README.assets/image-20220325210043905.png" alt="image-20220325210043905" loading="lazy"></p>
<h2 id="一、局部变量表"> 一、局部变量表</h2>
<p>局部变量表（Local Variables Table）是一组变量值的存储空间，用于存放方法参数和方法内部定义的局部变量。</p>
<p>局部变量表的容量以【变量槽】（Variable Slot）为最小单位。一个变量槽可以存放一个 32位以内的数据类型，Java中占用不超过32位存储空间的数据类型有 <code>boolean, byte, char, short, int, float, reference, returnAddress</code> 这8种类型。对于64位的数据类型 <code>long, double</code>，Java虚拟机会以高位对齐的方式为其分配两个连续的变量槽空间。</p>
<blockquote>
<p>由于局部变量表是建立在线程堆栈中的，属于线程私有的数据，无论读写两个连续的变量槽是否为原子操作，都不会引起数据竞 争和线程安全问题。</p>
</blockquote>
<p>Java虚拟机 <strong>通过索引定位的方式使用局部变量表</strong>，索引值的范围是从0开始至局部变量表最大的变量槽数量</p>
<p>当一个方法被调用时，Java虚拟机会使用局部变量表来完成参数值到参数变量列表的传递过程，即实参到形参的传递。如果执行的是实例方法（没有被static修饰的方法），那局部变量表中第0位索引的变量槽默认是用于传递方法所属对象实例的引用，在方法中可以通过关键字“this”来访问到这个隐含的参数</p>
<p>为了尽可能节省栈帧耗用的内存空间，局部变量表中的 <strong>变量槽是可以重用的</strong>，方法体中定义的变量，其作用域并不一定会覆盖整个方法体，如果当前字节码PC计数器的值已经超出了某个变量的作用域，那这个变量对应的变量槽就可以交给其他变量来重用。不过，这样的设计除了节省栈帧空间以外，还会伴随有少量额外的副作用，例如在某些情况下变量槽的 <strong>复用会直接影响到系统的垃圾收集行为</strong></p>
<h2 id="二、操作数栈"> 二、操作数栈</h2>
<p>操作数栈（Operand Stack）也常被称为操作栈，方法执行的过程中需要往操作数栈中写入和提取内容。</p>
<blockquote>
<p>例如整数加法的字节码指令iadd，这条指令在运行的时候要求操作数栈中最接近栈顶的两个元素已经存入了两个int型的数值，当执行这个指令时，会把这两个int 值出栈并相加，然后将相加的结果重新入栈。</p>
</blockquote>
<p>当一个方法刚刚开始执行时，其操作数栈是空的，随着方法执行和字节码指令的执行，会从局部变量表或对象实例的字段中复制常量或变量写入到操作数栈，再随着计算的进行将栈中元素出栈到局部变量表或者返回给方法调用者，也就是出栈/入栈操作。一个完整的方法执行期间往往包含多个这样出栈/入栈的过程。</p>
<p>在概念模型中，两个不同栈帧作为不同方法的虚拟机栈的元素，是完全相互独立的。但是在大多虚拟机的实现里都会进行一些优化处理，令两个栈帧出现一部分重叠。让下面栈帧的部分操作数栈与上面栈帧的部分局部变量表重叠在一起，这样做不仅节约了一些空间，更重要的是在进行方法调用时就可以直接共用一部分数据，无须进行额外的参数复制传递了</p>
<p><img src="./README.assets/image-20220325214054033.png" alt="image-20220325214054033" loading="lazy"></p>
<h2 id="三、动态连接"> 三、动态连接</h2>
<p>在一个class文件中，一个方法要调用其他方法，需要将这些方法的符号引用转化为其在内存地址中的直接引用，而符号引用存在于方法区中的运行时常量池。</p>
<p>Java虚拟机栈中，每个栈帧都包含一个指向运行时常量池中该栈所属方法的符号引用，持有这个引用的目的是为了支持方法调用过程中的<strong>动态连接(Dynamic Linking)</strong>。</p>
<div><p>动态连接</p>
<p>这些符号引用一部分会在类加载阶段或者第一次使用时就直接转化为直接引用，这类转化称为<strong>静态解析</strong>。另一部分将在每次运行期间转化为直接引用，这类转化称为 <strong>动态连接</strong>。</p>
</div>
<h2 id="四、方法返回地址"> 四、方法返回地址</h2>
<p>当一个方法开始执行后，只有两种方式退出这个方法。</p>
<ul>
<li>正常调用完成：执行引擎遇到任意一个方法返回的字节码指令，这时候可能会有返回值传递给上层的方法调用者</li>
<li>异常调用完成：方法执行的过程中遇到了异常，并且这个异常没有在方法体内得到妥善处理</li>
</ul>
<p>方法返回时可能需要在栈帧中保存一些信息，用来帮助恢复它的上层主调方法的执行状态。一般来说，方法正常退出时，主调方法的PC计数器的值就可以作为返回地址，栈帧中很可能会保存这个计数器值。而方法异常退出时，返回地址是要通过异常处理器表来确定的，栈帧中就一般不会保存这部分信息。</p>
<p>方法退出的过程实际上等同于把当前栈帧出栈，因此退出时可能执行的操作有：恢复上层方法的局部变量表和操作数栈，把返回值（如果有的话）压入调用者栈帧的操作数栈中，调整PC计数器的值以指向方法调用指令后面的一条指令等。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-25T12:18:53.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">方法调用</title>
    <id>https://notes.lllllan.cn/java/jvm/8/3/</id>
    <link href="https://notes.lllllan.cn/java/jvm/8/3/"/>
    <updated>2022-03-26T06:17:44.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<p>方法调用并不等同于方法中的代码被执行，方法调用阶段唯一的任务就是确定被调用方法的版本（即调用哪一个方法），暂时还未涉及方法内部的具体运行过程。</p>
<blockquote>
<p>Class文件的编译过程中不包含传统程序语言编译的连接步骤，一切方法调用在Class文件里面存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（也就是之前说的直接引用）。</p>
<p>这个特性给Java带来了更强大的动态扩展能力，但也使得Java方法调用过程变得相对复杂，某些调用需要在类加载期间，甚至到运行期间才能确定目标方法的直接引用</p>
</blockquote>
<h2 id="一、解析"> 一、解析</h2>
<p>所有方法调用的目标方法在Class文件里面都是一个常量池中的符号引用，在类加载的解析阶段，会将其中的一部分符号引用转化为直接引用，这种解析能够成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。 <mark>调用目标在程序代码写好、编译器进行编译那一刻就已经确定下来。</mark> 这类方法的调用被称为解析。</p>
<h3 id="_1-1-编译期可知-运行期不可变"> 1.1 编译期可知，运行期不可变</h3>
<p>主要有静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问，这两种方法各自的特点决定了它们都不可能通过继承或别的方式重写出其他版本，因此它们都适合在类加载阶段进行解析</p>
<h3 id="_1-2-字节码指令"> 1.2 字节码指令</h3>
<p>在Java虚拟机支持以下5条方法调用字 节码指令</p>
<ul>
<li>invokestatic。用于调用静态方法。</li>
<li>invokespecial。用于调用实例构造器()方法、私有方法和父类中的方法。</li>
<li>invokevirtual。用于调用所有的虚方法。</li>
<li>invokeinterface。用于调用接口方法，会在运行时再确定一个实现该接口的对象。</li>
<li>invokedynamic。先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。前面4条调用指令，分派逻辑都固化在Java虚拟机内部，而invokedynamic指令的分派逻辑是由用户设定的引导方法来决定的。</li>
</ul>
<div><p>虚方法</p>
<p>只要能被 <code>invokestatic</code> 和 <code>invokespecial</code> 指令调用的方法，都可以在解析阶段中确定唯一的调用版本， Java语言里符合这个条件的方法共有静态方法、私有方法、实例构造器、父类方法4种，再加上被final 修饰的方法（尽管它使用 <code>invokevirtual</code> 指令调用），这5种方法调用会在类加载的时候就可以把符号引用解析为该方法的直接引用。这些方法统称为【非虚方法】（Non-Virtual Method）。</p>
<p>与之相反，其他方 法就被称为【虚方法】（Virtual Method）。</p>
</div>
<blockquote>
<p>Java中的非虚方法除了使用 <code>invokestatic</code> 、<code>invokespecial</code> 调用的方法之外还有一种，就是被 <code>final</code> 修饰的实例方法。虽然由于历史设计的原因，final 方法是使用 <code>invokevirtual</code> 指令来调用的，但是因为它也无法被覆盖，没有其他版本的可能，所以也无须对方法接收者进行多态选择，又或者说多态选择的结果肯定是唯一的。在《Java语言规范》中明确定义了被 final 修饰的方法是一种非虚方法。</p>
</blockquote>
<h3 id="_1-3-解析调用"> 1.3 解析调用</h3>
<p><mark>解析调用一定是个静态的过程，在编译期间就完全确定</mark> ，在类加载的解析阶段就会把涉及的符号引用全部转变为明确的直接引用，不必延迟到运行期再去完成。</p>
<h2 id="二、分派"> 二、分派</h2>
<p>分派是区别于解析的另一种方法调用形式。它要更加复杂，可能是静态的也可能是动态的。</p>
<h3 id="_2-1-静态分派"> 2.1 静态分派</h3>
<p>重载代码示例：</p>
<div><pre><code><span>package</span> <span>org<span>.</span>fenixsoft<span>.</span>polymorphic</span><span>;</span>
<span>/**
* 方法静态分派演示
* @author zzm
*/</span>
<span>public</span> <span>class</span> <span>StaticDispatch</span> <span>{</span>
    <span>static</span> <span>abstract</span> <span>class</span> <span>Human</span> <span>{</span>
    <span>}</span>
    
    <span>static</span> <span>class</span> <span>Man</span> <span>extends</span> <span>Human</span> <span>{</span>
    <span>}</span>
    
    <span>static</span> <span>class</span> <span>Woman</span> <span>extends</span> <span>Human</span> <span>{</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>Human</span> guy<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello,guy!"</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>Man</span> guy<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello,gentleman!"</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>sayHello</span><span>(</span><span>Woman</span> guy<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello,lady!"</span><span>)</span><span>;</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Human</span> man <span>=</span> <span>new</span> <span>Man</span><span>(</span><span>)</span><span>;</span>
        <span>Human</span> woman <span>=</span> <span>new</span> <span>Woman</span><span>(</span><span>)</span><span>;</span>
        <span>StaticDispatch</span> sr <span>=</span> <span>new</span> <span>StaticDispatch</span><span>(</span><span>)</span><span>;</span>
        sr<span>.</span><span>sayHello</span><span>(</span>man<span>)</span><span>;</span>
        sr<span>.</span><span>sayHello</span><span>(</span>woman<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br></div></div><p>运行结果：</p>
<div><pre><code>hello<span>,</span>guy<span>!</span>
hello<span>,</span>guy<span>!</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>我们把上面代码中的【Human】称为变量的 <mark>静态类型</mark>（Static Type），或者叫 【外观类 型】（Apparent Type），后面的【Man】则被称为变量的 <mark>实际类型</mark>（Actual Type）或者叫【运行时类型】（Runtime Type）。</p>
<p>静态类型和实际类型在程序中都可能会发生变化，区别是静态类型的变化仅仅在使用时发生，变量本身的静态类型不会被改变，并且最终的静态类型是在编译期可知的；而实际类型变化的结果在运行期才可确定，编译器在编译程序的时候并不知道一个对象的实际类型是什么</p>
<p><mark>重载是在编译时确定的</mark>，由于静态类型在编译期可知，所以在编译阶段，Javac编译器就根据参数的静态类型决定了会使用哪个重载版本，因此选择了 <code>sayHello(Human)</code> 作为调用目标</p>
<h3 id="_2-2-动态分派"> 2.2 动态分派</h3>
<p>重写代码示例：</p>
<div><pre><code><span>package</span> <span>org<span>.</span>fenixsoft<span>.</span>polymorphic</span><span>;</span>
<span>/**
* 方法动态分派演示
* @author zzm
*/</span>
<span>public</span> <span>class</span> <span>DynamicDispatch</span> <span>{</span>
    <span>static</span> <span>abstract</span> <span>class</span> <span>Human</span> <span>{</span>
        <span>protected</span> <span>abstract</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
   
    <span>static</span> <span>class</span> <span>Man</span> <span>extends</span> <span>Human</span> <span>{</span>
        <span>@Override</span>
        <span>protected</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"man say hello"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>static</span> <span>class</span> <span>Woman</span> <span>extends</span> <span>Human</span> <span>{</span>
        <span>@Override</span>
        <span>protected</span> <span>void</span> <span>sayHello</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"woman say hello"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Human</span> man <span>=</span> <span>new</span> <span>Man</span><span>(</span><span>)</span><span>;</span>
        <span>Human</span> woman <span>=</span> <span>new</span> <span>Woman</span><span>(</span><span>)</span><span>;</span>
        man<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
        woman<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
        man <span>=</span> <span>new</span> <span>Woman</span><span>(</span><span>)</span><span>;</span>
        man<span>.</span><span>sayHello</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br></div></div><p>运行结果：</p>
<div><pre><code>man say hello
woman say hello
woman say hello
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><mark>重写是在运行时确定的</mark>，在确定了实际类型之后，才会选择对应的重写方法。</p>
<h3 id="_2-3-字段没有多态性"> 2.3 字段没有多态性</h3>
<div><pre><code><span>package</span> <span>org<span>.</span>fenixsoft<span>.</span>polymorphic</span><span>;</span>
<span>/**
* 字段不参与多态
* @author zzm
*/</span>
<span>public</span> <span>class</span> <span>FieldHasNoPolymorphic</span> <span>{</span>
    <span>static</span> <span>class</span> <span>Father</span> <span>{</span>
        <span>public</span> <span>int</span> money <span>=</span> <span>1</span><span>;</span>
        
        <span>public</span> <span>Father</span><span>(</span><span>)</span> <span>{</span>
            money <span>=</span> <span>2</span><span>;</span>
            <span>showMeTheMoney</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        
        <span>public</span> <span>void</span> <span>showMeTheMoney</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I am Father, i have $"</span> <span>+</span> money<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>static</span> <span>class</span> <span>Son</span> <span>extends</span> <span>Father</span> <span>{</span>
        <span>public</span> <span>int</span> money <span>=</span> <span>3</span><span>;</span>
        
        <span>public</span> <span>Son</span><span>(</span><span>)</span> <span>{</span>
            money <span>=</span> <span>4</span><span>;</span>
            <span>showMeTheMoney</span><span>(</span><span>)</span><span>;</span>
        <span>}</span>
        
        <span>public</span> <span>void</span> <span>showMeTheMoney</span><span>(</span><span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I am Son, i have $"</span> <span>+</span> money<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Father</span> gay <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"This gay has $"</span> <span>+</span> gay<span>.</span>money<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><div><pre><code><span>I</span> am <span>Son</span><span>,</span> i have $<span>0</span>
<span>I</span> am <span>Son</span><span>,</span> i have $<span>4</span>
<span>This</span> gay has $<span>2</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol>
<li>创建 Son 类的时候，首先隐式调用了父类 Father 的构造函数。而父类中存在对 <code>showMeTheMoney()</code> 的虚方法调用，实际执行的版本是 <code>Son::showMeTheMoney()</code>，但此时 Son 还没有进行初始化，因而使出了0</li>
<li>之后 Son 在进行初始化的时候，才对自己的 money 赋值，调用 <code>showMeTheMoney()</code> 时输出了4</li>
<li><mark>字段没有多态性</mark>，因此直接或缺类中的字段，其实时通过静态类型访问到了父类中的 money，因此输出了2</li>
</ol>
<h3 id="_2-4-单分派与多分派"> 2.4 单分派与多分派</h3>
<p>方法的接收者与方法的参数统称为方法的宗量，根据分派基于多少种宗量，可以将分派划分为单分派和多分派两种。单分派是根据一个宗量对目标方法进行选择，多分派则是根据多于一个宗量对目标方法进行选择。</p>
<div><pre><code><span>/**
* 单分派、多分派演示
* @author zzm
*/</span>
<span>public</span> <span>class</span> <span>Dispatch</span> <span>{</span>
    <span>static</span> <span>class</span> <span>QQ</span> <span>{</span><span>}</span>
    
    <span>static</span> <span>class</span> _360 <span>{</span><span>}</span>
    
    <span>public</span> <span>static</span> <span>class</span> <span>Father</span> <span>{</span>
        <span>public</span> <span>void</span> <span>hardChoice</span><span>(</span><span>QQ</span> arg<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"father choose qq"</span><span>)</span><span>;</span>
        <span>}</span>
    
        <span>public</span> <span>void</span> <span>hardChoice</span><span>(</span>_360 arg<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"father choose 360"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>class</span> <span>Son</span> <span>extends</span> <span>Father</span> <span>{</span>
        <span>public</span> <span>void</span> <span>hardChoice</span><span>(</span><span>QQ</span> arg<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"son choose qq"</span><span>)</span><span>;</span>
        <span>}</span>
    
        <span>public</span> <span>void</span> <span>hardChoice</span><span>(</span>_360 arg<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"son choose 360"</span><span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>
    
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Father</span> father <span>=</span> <span>new</span> <span>Father</span><span>(</span><span>)</span><span>;</span>
        <span>Father</span> son <span>=</span> <span>new</span> <span>Son</span><span>(</span><span>)</span><span>;</span>
        father<span>.</span><span>hardChoice</span><span>(</span><span>new</span> <span>_360</span><span>(</span><span>)</span><span>)</span><span>;</span>
        son<span>.</span><span>hardChoice</span><span>(</span><span>new</span> <span>QQ</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br></div></div><p>运行结果：</p>
<div><pre><code>father choose <span>360</span>
son choose qq
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><blockquote>
<p>在 <code>main()</code> 里调用了两次 <code>hardChoice()</code> 方法，这两次 <code>hardChoice()</code> 方法的选择结果在程序输出中已经显示得很清楚了。我们关注的首先是编译阶段中编译器的选择过程，也就是静态分派的过程。这时候选择目标方法的依据有两点：一是静态类型是【Father】还是【Son】，二是方法参数是【QQ】还是【360】。这次选择结 果的最终产物是产生了两条 <code>invokevirtual</code> 指令，两条指令的参数分别为常量池中指向 <code>Father::hardChoice(360)</code> 及 <code>Father::hardChoice(QQ)</code> 方法的符号引用。因为是根据两个宗量进行选择，所以 <mark>Java语言的静态分派属于多分派类型</mark>。</p>
<p>再看看运行阶段中虚拟机的选择，也就是动态分派的过程。在执行 <code>son.hardChoice(new QQ())</code> 这 行代码时，更准确地说，是在执行这行代码所对应的 <code>invokevirtual</code> 指令时，由于编译期已经决定目标方 法的签名必须为 <code>hardChoice(QQ)</code> ，虚拟机此时不会关心传递过来的参数【QQ】到底是“腾讯QQ”还是“奇瑞QQ”，因为这时候参数的静态类型、实际类型都对方法的选择不会构成任何影响，唯一可以影响虚 拟机选择的因素只有该方法的接受者的实际类型是【Father】还是【Son】。因为只有一个宗量作为选择依据， 所以 <mark>Java语言的动态分派属于单分派类型</mark></p>
</blockquote>
<h3 id="_2-5-虚拟机动态分派的实现"> 2.5 虚拟机动态分派的实现</h3>
<p>动态分派的方法版本选择过程需要运行时在接收者类型的方法元数据中搜索合适的目标方法，因此，Java虚拟机实现基于执行性能的考虑，真正运行时一般不会如此频繁地去反复搜索类型元数据。</p>
<p>面对这种情况，一种基础而且常见的优化手段是为类型在方法区中建立一个【虚方法表】（Virtual Method Table，也称为vtable，与此对应的，在invokeinterface执行时也 会用到【接口方法表】——Interface Method Table，简称itable）</p>
<p><img src="./README.assets/image-20220326141403679.png" alt="image-20220326141403679" loading="lazy"></p>
<p>虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那子类的虚方法表中的地址入口和父类相同方法的地址入口是一致的，都指向父类的实现入口。如果子类中重写了这个方法，子类虚方法表中的地址也会被替换为指向子类实现版本的入口地址。</p>
<p>为了程序实现方便，具有相同签名的方法，在父类、子类的虚方法表中都应当具有一样的索引序号，这样当类型变换时，仅需要变更查找的虚方法表，就可以从不同的虚方法表中按索引转换出所需的入口地址。虚方法表一般在类加载的连接阶段进行初始化，准备了类的变量初始值后，虚拟机会把 该类的虚方法表也一同初始化完毕。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-26T06:17:44.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">JVM 常见问题</title>
    <id>https://notes.lllllan.cn/java/jvm/</id>
    <link href="https://notes.lllllan.cn/java/jvm/"/>
    <updated>2022-04-27T07:55:07.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/111809384" target="_blank" rel="noopener noreferrer">面试官 | JVM 为什么使用元空间替换了永久代？ - 知乎 (zhihu.com)</a></li>
<li><a href="https://blog.csdn.net/renjingjingya0429/article/details/88525915" target="_blank" rel="noopener noreferrer">【JVM】JVM加载class文件的原理机制_FAIRY哦的博客-CSDN博客_jvm加载类文件原理机制</a></li>
<li><a href="https://blog.csdn.net/fly_rice/article/details/82354188" target="_blank" rel="noopener noreferrer">java对象的创建过程_你别过来的博客-CSDN博客_对象的创建过程</a></li>
<li><a href="https://www.hollischuang.com/archives/2398" target="_blank" rel="noopener noreferrer">对象和数组并不是都在堆上分配内存的。-HollisChuang's Blog</a></li>
<li><a href="https://www.cnblogs.com/strinkbug/p/6376525.html" target="_blank" rel="noopener noreferrer">Java系列：JVM中的OopMap（zz） - 拿走不谢 - 博客园 (cnblogs.com)</a></li>
</ul>
</div>
<h2 id="永久代和元空间"> 永久代和元空间</h2>
<p><a href="https://zhuanlan.zhihu.com/p/111809384" target="_blank" rel="noopener noreferrer">面试官 | JVM 为什么使用元空间替换了永久代？ - 知乎 (zhihu.com)</a></p>
<p><a href="https://www.cnblogs.com/jichi/p/12580906.html" target="_blank" rel="noopener noreferrer">JVM年轻代，老年代，永久代详解 - 经典鸡翅 - 博客园 (cnblogs.com)</a></p>
<p>方法区是一种规范，永久代和元空间都是对方法区的一种实现。</p>
<p>JDK1.8 以前，采用的是永久代。当时的堆和方法区在逻辑上是两个概念，但是物理地址是连续的。</p>
<p>JDK1.8 之后，取消了永久代，改用元空间。元空间不再和堆连续，而是 <mark>存在于本地内存</mark> 。这么做的好处是，只要本地内存足够，他就不会像永久代一样出现OOM：<code>java.lang.OutOfMemoryError: PermGen space</code></p>
<h2 id="什么时候触发-full-gc"> 什么时候触发 Full GC</h2>
<ol>
<li>老年代空间不足。老年代只有在新生代对象转入及创建大对象、大数组时才会出现不足的现象；当执行 Full GC 之后空间仍然得不到满足，则抛出 <code>java.lang.OutOfMemoryError: Java heap space</code></li>
<li>方法区空间不足。当系统中要加载、反射的类和调用的方法较多时，方法区可能会被占满；当执行 Full GC 之后空间仍然得不到满足，则抛出 <code>java.lang.OutOfMemoryError: PermGen space</code></li>
<li>对于采用 CMS 进行老年代 GC 的程序而言，尤其要注意 GC 日志中是否有 promotion failed 和 concurrent mode failure 两种状况，当这两种状况出现时可能会触发 Full GC。</li>
<li>统计得到的 Minor GC 晋升到旧生代的平均大小大于旧生代的剩余空间。<a href="./3/8/#五、空间分配担保">空间担保机制</a></li>
</ol>
<h2 id="jvm-加载-class-文件的原理机制"> JVM 加载 class 文件的原理机制</h2>
<p>JVM 中类的装在是由类加载器和它的子类来实现的，Java 中的类加载器是一个重要的 Java 运行时系统组件，它负责在运行时查找和装入类文件中的类。</p>
<blockquote>
<p>由于 Java 的跨平台性，经过编译的 Java 源程序并不是一个可执行程序，而是一个或多个类文件。</p>
</blockquote>
<p>当 Java 程序需要使用某个类时，JVM 会确保这个类已经被加载、连接（验证、准备、解析）和初始化。</p>
<ol>
<li>
<p>类的加载是把类的 class 文件中的数据读入到内存中，通常是创建一个字节数组读入 class 文件，然后产生于所加载类对应的 Class 对象。加载完成之后，Class 对象还不完整，所以此时的类还不可用。</p>
</li>
<li>
<p>当类被加载后就进入连接阶段，这一阶段包括验证、准备（为静态变量分配内存并设置默认的初始值）和解析（将符号引用替换为直接引用）。</p>
</li>
<li>
<p>最后 JVM 对类进行初始化，包括：</p>
<ol>
<li>
<p>如果类存在直接的父类并且这个类还没有被初始化，那么就先初始化父类</p>
</li>
<li>
<p>如果类中存在初始化语句，就依次执行这些初始化语句</p>
</li>
</ol>
</li>
</ol>
<h3 id="类加载器"> 类加载器</h3>
<p>类的加载是由加载器完成的，类加载器包括</p>
<ul>
<li>根加载器，BootStap Class Loader</li>
<li>扩展加载器，Extension Class Loader</li>
<li>应用程序类加载器，Application Class Loader</li>
</ul>
<h3 id="类装载方式"> 类装载方式</h3>
<ol>
<li>隐式装载：程序在运行过程中当碰到通过 new 等方式生成类或者子类对象、使用类或者子类的静态域时，隐式调用类加载器加载对应的的类到 JVM 中。</li>
<li>显式装载：通过调用 <code>Class.forName()</code> 或者 <code>ClassLoader.loadClass(className)</code> 等方法，显式加载需要的类。</li>
</ol>
<h3 id="类加载的动态性体现"> 类加载的动态性体现</h3>
<p>一个应用程序总是由 n 多个类组成，Java 程序启动时，并不是一次把所有的类全部加载再运行，他总是把保证程序运行的基础类一次性加载到 JVM 中，其他类等到 JVM 用到的时候再加载，这样是为了节省内存的开销，因为 Java 最早就是为嵌入式系统而设计的，内存宝贵，而用到时再加载这也是 Java 动态性的一种体现。</p>
<h2 id="对象创建的过程-★"> 对象创建的过程 ★</h2>
<p><a href="http://blog.lllllan.cn/java/jvm/2/2/#%E4%B8%80%E3%80%81%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%88%9B%E5%BB%BA%E8%BF%87%E7%A8%8B" target="_blank" rel="noopener noreferrer">HotSpot 虚拟机中的对象 | lllllan</a></p>
<h2 id="逃逸分析"> 逃逸分析</h2>
<p>通过逃逸分析，Java Hotspot 编译器能够分析出一个新的对象的引用的使用范围，从而决定是否要将这个对象分配到堆上。逃逸分析(Escape Analysis)，是一种可以有效减少Java 程序中同步负载和内存堆分配压力的跨函数全局数据流分析算法。</p>
<p><a href="https://www.hollischuang.com/archives/2398" target="_blank" rel="noopener noreferrer">对象和数组并不是都在堆上分配内存的。-HollisChuang's Blog</a></p>
<p>什么是逃逸：</p>
<p>当变量（或者对象）在方法中分配后，其指针有可能被返回或者被全局引用，这样就会被其他方法或者线程所引用，这种现象称作指针（或者引用）的逃逸(Escape)。通俗点讲，如果一个对象的指针被多个方法或者线程引用时，那么我们就称这个对象的指针发生了逃逸。</p>
<ul>
<li>当一个对象在方法中被定义后，它可能被外部方法所引用，例如作为调用参数传递到其他地方中，称为方法逃逸</li>
<li>甚至还有可能被外部线程访问到，譬如赋值给类变量或可以在其他线程中访问的实例变量，称为线程逃逸</li>
</ul>
<div><p>逃逸分析的好处</p>
<ul>
<li>同步消除。如果一个对象被发现只能从一个线程被访问到，那么对于这个对象的操作可以不考虑同步。</li>
<li>栈上分配。可以降低垃圾收集器运行的频率</li>
<li>标量替换。把对象分解成一个个基本类型，并且内存分配不再是分配在堆上，而是分配在栈上。这样的好处有，一、减少内存使用，因为不用生成对象头。二、程序内存回收效率高，并且GC频率也会减少</li>
</ul>
</div>
<h2 id="保守式-准确式gc-▲"> 保守式/准确式GC ▲</h2>
<p><a href="https://www.cnblogs.com/strinkbug/p/6376525.html" target="_blank" rel="noopener noreferrer">Java系列：JVM中的OopMap（zz） - 拿走不谢 - 博客园 (cnblogs.com)</a></p>
<p>调用栈里的引用类型数据是 GC 的根集合（root set）的重要组成部分；找出栈上的引用是 GC 的根枚举（root enumeration）中不可或缺的一环。</p>
<h3 id="保守式-gc"> 保守式 GC</h3>
<p>因为栈中没有对某块数据记录类型，虚拟机甚至无法区分指针和非指针，</p>
<p><mark>保守式 GC，会把所有看上去像是引用的的数据，都看作是引用</mark></p>
<p>保守式 GC 的好处是相对来说实现简单些，而且可以方便的用在对 GC 没有特别支持的编程语言里提供自动内存管理功能。</p>
<div><p>保守式 GC 的缺点</p>
<ol>
<li>会有部分对象本来应该已经死了，但有疑似指针指向它们，使它们逃过 GC 的收集。这对程序语义来说是安全的，因为所有应该活着的对象都会是活的；但对内存占用量来说就不是件好事，总会有一些已经不需要的数据还占用着 GC 堆空间。</li>
<li>由于不知道疑似指针是否真的是指针，所以它们的值都不能改写；移动对象就意味着要修正指针。换言之，对象就不可移动了。</li>
</ol>
</div>
<h3 id="半保守式-gc"> 半保守式 GC</h3>
<p>JVM 可以选择在栈上不记录类型信息，而在对象上记录类型信息。这样的话，扫描栈的时候仍然会跟上面说的过程一样，但扫描到 GC 堆内的对象时因为对象带有足够类型信息了，JVM 就能够判断出在该对象内什么位置的数据是引用类型了。这种是“半保守式GC”，也称为“根上保守（conservative with respect to the roots）”。</p>
<p>半保守式 GC 对 JNI 方法调用的支持会比较容易：管它是不是 JNI 方法调用，是栈都扫过去…完事了。不需要对引用做任何额外的处理。当然代价跟完全保守式一样，会有“疑似指针”的问题。</p>
<h3 id="准确式-gc"> 准确式 GC</h3>
<p>就是说给定某个位置上的某块数据，要能知道它的准确类型是什么，这样才可以合理地解读数据的含义；GC 所关心的含义就是“这块数据是不是指针”。
要实现这样的 GC，JVM 就要能够判断出所有位置上的数据是不是指向 GC 堆里的引用，包括活动记录（栈 + 寄存器）里的数据。</p>
<h2 id="oopmap和安全点-▲"> OopMap和安全点 ▲</h2>
<p><a href="./3/4/">oop和安全点</a></p>
<h3 id="oopmap"> OopMap</h3>
<p><mark>在 HotSpot 中，对象的类型信息里有记录自己的 OopMap，记录了在该类型的对象内什么偏移量上是什么类型的数据</mark>。所以从对象开始向外的扫描可以是准确的；这些数据是在类加载过程中计算得到的。</p>
<p>可以把 oopMap 简单理解成是调试信息。 在源代码里面每个变量都是有类型的，但是编译之后的代码就只有变量在栈上的位置了。oopMap 就是一个附加的信息，告诉你栈上哪个位置本来是个什么东西。 这个信息是在 JIT 编译时跟机器码一起产生的。因为只有编译器知道源代码跟产生的代码的对应关系。 每个方法可能会有好几个 oopMap，就是根据 safepoint 把一个方法的代码分成几段，每一段代码一个 oopMap，作用域自然也仅限于这一段代码。 循环中引用多个对象，肯定会有多个变量，编译后占据栈上的多个位置。那这段代码的 oopMap 就会包含多条记录。</p>
<p>每个被JIT编译过后的方法也会在一些特定的位置记录下 OopMap，记录了执行到该方法的某条指令的时候，栈上和寄存器里哪些位置是引用。这样 GC 在扫描栈的时候就会查询这些 OopMap 就知道哪里是引用了。</p>
<div><p>特定的位置主要在：</p>
<ol>
<li>循环的末尾</li>
<li>方法临返回前 / 调用方法的 call 指令后</li>
<li>可能抛异常的位置</li>
</ol>
</div>
<h3 id="安全点"> 安全点</h3>
<p>这种位置被称为“安全点”（safepoint）。之所以要选择一些特定的位置来记录 OopMap，是因为如果对每条指令（的位置）都记录 OopMap 的话，这些记录就会比较大，那么空间开销会显得不值得。选用一些比较关键的点来记录就能有效的缩小需要记录的数据量，但仍然能达到区分引用的目的。 <mark>因为这样，HotSpot 中 GC 不是在任意位置都可以进入，而只能在 safepoint 处进入。</mark></p>
<h2 id="jvm组成部分"> JVM组成部分</h2>
<ul>
<li>Class Loader，类装载器。根据给定的全限定名来装在 class 文件到运行时数据区的方法区中。</li>
<li>Execution engine，执行引擎。执行 class 的指令。</li>
<li>Native Interface，本地接口。于 native lib 交互，式其他编程语言交互的接口。</li>
<li>Runtime data area，运行时数据区域。即 JVM 内存。</li>
</ul>
<p>首先通过编译器把 Java 源代码转换成字节码，Class loader（类装载）再把字节码加载到内存中，将其放在运行时数据区的方法区内，而字节码文件只是 JVM 的一套指令集规范，并不能直接交给底层操作系统去执行，因此需要特定的命令解析器执行引擎（Execution Engine），将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的本地库接口（Native Interface）来实现整个程序的功能</p>
<h2 id="碰撞指针和空闲列表-★"> 碰撞指针和空闲列表 ★</h2>
<p><a href="./2/2/#一、对象的创建过程">分配内存 | 指针碰撞和空闲列表</a></p>
<h2 id="tlab-本地线程分配缓存"> TLAB 本地线程分配缓存</h2>
<p><a href="./2/2/#一、对象的创建过程">分配内存 | TLAB</a></p>
<p>内存分配在并发情况下也并 <mark>不是线程安全的</mark>，可能出现正在给对象 A 分配内存，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种可选方案：</p>
<ol>
<li>对分配内存空间的动作进行同步处理——实际上虚拟机是采用 <mark>CAS配上失败重试</mark> 的方式保证更新操作的原子性</li>
<li>另外一种是把内存分配的动作按照线程划分在不同的空间之中进 行，即每个线程在 Java 堆中预先分配一小块内存，称为 <mark>本地线程分配缓冲</mark> （Thread Local Allocation Buffer，TLAB），哪个线程要分配内存，就在哪个线程的本地缓冲区中分配，只有本地缓冲区用完 了，分配新的缓存区时才需要同步锁定</li>
</ol>
<h2 id="垃圾回收器-▲"> 垃圾回收器 ▲</h2>
<p><a href="./3/5/">垃圾回收器</a></p>
<ul>
<li>如果你的堆大小不是很大，选择串行收集器一般是效率最高的。SerialGC</li>
<li>如果你的应用运行在单核的机器上，或者你的虚拟机核数只有单核，选怎并行收集器没有任何收益。SerialGC</li>
<li>如果你的应用是【吞吐量】优先的，并且堆较长时间的停顿没有什么特别的要求，选择并行收集器更好。ParallelGC</li>
<li>如果你的应用对响应时间要求较高，想要较少的停顿。选择 G1、ZGC、CMS，但是吞吐量会低一些。</li>
</ul>
<h2 id="双亲委派机制"> 双亲委派机制</h2>
<p>JVM 并不是在启动时就把所有的 <code>.class</code> 文件都加载一遍，而是程序在运行过程中用到了这个类才去加载。</p>
<p>首先检查这个类是不是已经被加载过了，如果加载过了直接返回，否则委派给父加载器加载，这是一个递归调用，<strong>一层一层向上委派，最顶层的类加载器（启动类加载器）无法加载该类时，再一层一层向下委派给子类加载器加载</strong>。</p>
<p><img src="./README.assets/007.png" alt="双亲委派模型" loading="lazy"></p>
<div><p>为什么要有双亲委派机制</p>
<ol>
<li>避免一个类的重复加载</li>
<li>保护框架需要加载的类不被应用程序覆盖</li>
</ol>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-16T10:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">动态类型语言支持</title>
    <id>https://notes.lllllan.cn/java/jvm/8/4/</id>
    <link href="https://notes.lllllan.cn/java/jvm/8/4/"/>
    <updated>2022-03-26T07:14:47.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<h2 id="一、动态类型语言"> 一、动态类型语言</h2>
<p>动态类型语言的关键特征是 <mark>它的类型检查主体过程在运行期而不是编译期进行的</mark>，包括有 JavaScript、PHP、Python等。相对的在编译期就进行类型检查过程的语言就是静态类型语言，比如C、C++。</p>
<p>静态语言和动态语言各自的优势：</p>
<ul>
<li>静态语言的编译器可以提供全面严谨的类型检查，这样与数据类型相关的潜在问题就能在编码时被及时发现，利于稳定性及让项目容易达到更大的规模。</li>
<li>动态语言可以为开发人员提供极大的灵活性，做某些功能可能会更加清晰简洁，提高开发效率</li>
</ul>
<h2 id="二、看不懂-以后再说"> 二、看不懂，以后再说</h2>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-26T07:14:47.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节码解释执行引擎</title>
    <id>https://notes.lllllan.cn/java/jvm/8/5/</id>
    <link href="https://notes.lllllan.cn/java/jvm/8/5/"/>
    <updated>2022-03-26T07:58:16.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li>《深入理解Java虚拟机》</li>
</ul>
</div>
<h2 id="一、解释执行"> 一、解释执行</h2>
<blockquote>
<p>Java语言经常被人们定位为【解释执行】的语言，在Java初生的JDK 1.0时代，这种定义还算是比较准确的，但当主流的虚拟机中都包含了【即时编译器】后，Class文件中的代码到底会被解释执行还是编译执行，就成了只有虚拟机自己才能准确判断的事。</p>
</blockquote>
<p>大部分的程序代码转换成物理机的目标代码或虚拟机能执行的指令集 之前，都需要经过图8-4中的各个步骤</p>
<p><img src="./README.assets/image-20220326151852398.png" alt="image-20220326151852398" loading="lazy"></p>
<p>在Java语言中，Javac 编译器完成了程序代码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程。因为这一部分动作是在Java虚拟机之外进行的，而解释器在虚拟机的内部，所以Java程序的编译就是半独立的实现。</p>
<h2 id="二、基于栈的指令集和基于寄存器的指令集"> 二、基于栈的指令集和基于寄存器的指令集</h2>
<p>Javac编译器输出的字节码指令流，基本上是一种【基于栈的指令集架构】（Instruction Set Architecture，ISA），字节码指令流里面的指令大部分都是零地址指令，它们依赖操作数栈进行工作。</p>
<p>与之相对的另外一套常用的指令集架构是【基于寄存器的指令集】，最典型的就是x86的二地址指令集，如果说得更通俗一些就是现在我们主流PC机中物理硬件直接支持的指令集架构，这些指令依赖寄 存器进行工作</p>
<p>举个最简单的例子，分别使用这两种指令集去计算【1+1】的结果：</p>
<CodeGroup>
<CodeGroupItem title="基于栈的指令集">
<div><pre><code>iconst_1
iconst_1
iadd
istore_0
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>两条 <code>iconst_1</code> 指令连续把两个常量1压入栈后，iadd指令把栈顶的两个值出栈、相加，然后把结果放回栈顶，最后 <code>istore_0</code> 把栈顶的值放到局部变量表的第0个变量槽中。这种指令流中的指令通常都是不带参数的，使用操作数栈中的数据作为指令的运算输入，指令的运算结果也存储在操作数栈之中。</p>
</CodeGroupItem>
<CodeGroupItem title="基于寄存器的指令集">
<div><pre><code>mov eax, <span>1</span>
<span>add</span> eax, <span>1</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>mov指令把EAX寄存器的值设为1，然后add指令再把这个值加1，结果就保存在EAX寄存器里面。 这种二地址指令是x86指令集中的主流，每个指令都包含两个单独的输入参数，依赖于寄存器来访问和存储数据。</p>
</CodeGroupItem>
</CodeGroup>
<div><p>两种指令集各自的优缺</p>
<p><strong>基于栈的指令集：</strong></p>
<ul>
<li>可以自由地把访问最频繁的数据放到寄存去中获取尽量好的性能</li>
<li>代码相对更加紧凑、编译器实现更加简单</li>
<li>由于指令数量和内存访问的原因，执行速度略慢</li>
</ul>
<hr>
<p><strong>基于寄存器的指令集：</strong></p>
<ul>
<li>不可能避免地要受到硬件的约束</li>
<li>直接依赖寄存及，理论上执行速度更快</li>
</ul>
</div>
<h2 id="三、基于栈的解释器执行过程"> 三、基于栈的解释器执行过程</h2>
<div><pre><code><span>public</span> <span>int</span> <span>calc</span><span>(</span><span>)</span> <span>{</span>
    <span>int</span> a <span>=</span> <span>100</span><span>;</span>
    <span>int</span> b <span>=</span> <span>200</span><span>;</span>
    <span>int</span> c <span>=</span> <span>300</span><span>;</span>
    <span>return</span> <span>(</span>a <span>+</span> b<span>)</span> <span>*</span> c<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><div><pre><code>public int calc();
	Code:
		Stack=2, Locals=4, Args_size=1
        0: bipush 100
		2: istore_1
		3: sipush 200
		6: istore_2
		7: sipush 300
		10: istore_3
		11: iload_1
		12: iload_2
		13: iadd
		14: iload_3
		15: imul
		16: ireturn
}
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_0"> 0</h3>
<p>首先，执行偏移地址为0的指令，Bipush指令的作用是将单字节的整型常量值（-128～127）推入操作数栈顶，跟随有一个参数，指明推送的常量值，这里是100</p>
<p><img src="./README.assets/image-20220326155149877.png" alt="image-20220326155149877" loading="lazy"></p>
<h3 id="_1"> 1</h3>
<p>执行偏移地址为2的指令，<code>istore_1</code> 指令的作用是将操作数栈顶的整型值出栈并存放到第1个局部变量槽中。后续4条指令（直到偏移为11的指令为止）都是做一样的事情，也就是在对应代码中把变量 a、b、c赋值为100、200、300。这4条指令的图示略过。</p>
<p><img src="./README.assets/image-20220326155221300.png" alt="image-20220326155221300" loading="lazy"></p>
<h3 id="_2"> 2</h3>
<p>执行偏移地址为11的指令，iload_1指令的作用是将局部变量表第1个变量槽中的整型值复制到操作数栈顶。</p>
<p><img src="./README.assets/image-20220326155315623.png" alt="image-20220326155315623" loading="lazy"></p>
<h3 id="_3"> 3</h3>
<p>执行偏移地址为12的指令，iload_2指令的执行过程与iload_1类似，把第2个变量槽的整型值入栈。 画出这个指令的图示主要是为了显示下一条iadd指令执行前的堆栈状况。</p>
<p><img src="./README.assets/image-20220326155344243.png" alt="image-20220326155344243" loading="lazy"></p>
<h3 id="_4"> 4</h3>
<p>执行偏移地址为13的指令，<code>iadd</code> 指令的作用是将操作数栈中头两个栈顶元素出栈，做整型加法，然后把结果重新入栈。在iadd指令执行完毕后，栈中原有的100和200被出栈，它们的和300被重新入栈。</p>
<p><img src="./README.assets/image-20220326155414066.png" alt="image-20220326155414066" loading="lazy"></p>
<h3 id="_5"> 5</h3>
<p>执行偏移地址为14的指令，<code>iload_3</code> 指令把存放在第3个局部变量槽中的300入栈到操作数栈中。这时操作数栈为两个整数300。下一条指令imul是将操作数栈中头两个栈顶元素出栈，做整型乘法，然后把结果重新入栈，与iadd完全类似</p>
<p><img src="./README.assets/image-20220326155505863.png" alt="image-20220326155505863" loading="lazy"></p>
<h3 id="_6"> 6</h3>
<p>执行偏移地址为16的指令，ireturn指令是方法返回指令之一，它将结束方法执行并将操作数栈顶的整型值返回给该方法的调用者。到此为止，这段方法执行结束</p>
<p><img src="./README.assets/image-20220326155630648.png" alt="image-20220326155630648" loading="lazy"></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-26T07:58:16.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节|飞书后端|春招</title>
    <id>https://notes.lllllan.cn/mianjing/2/</id>
    <link href="https://notes.lllllan.cn/mianjing/2/"/>
    <updated>2022-04-18T15:41:07.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/868973?type=0&amp;order=7&amp;pos=7&amp;page=1&amp;source_id=discuss_center_0_nctrack&amp;channel=1009&amp;ncTraceId=d0a73883bdb740f3968ec2e23effb273.353.16493833740621503&amp;gio_id=C91C10B51FF30120EDE03275F6698FF2-1649383374967" target="_blank" rel="noopener noreferrer">春招 已oc 字节 成都 飞书后端 人力套件 一二三面经_笔经面经_牛客网 (nowcoder.com)</a></p>
<h2 id="_2022-03-19-1面"> 2022.03.19   1面</h2>
<ol>
<li>项目介绍</li>
<li><a href="./../../cs-basic/network/interview-questions/#_3-1-四次挥手流程">发送方发送fin之后进入什么状态，接收方进入什么状态? </a></li>
<li><a href="./../../cs-basic/os/def/process-communication/">进程通信的方式? </a></li>
<li>什么时候会用到管道</li>
<li>管道的底层原理是什么?</li>
<li>socket有使用过吗?</li>
<li>Java对http1.1 keep-alive的实现，<a href="./../../cs-basic/network/keep-alive/">http的keep-alive和tcp的keepalive</a>、<a href="./../../cs-basic/network/http-and-https/#http不同版本之间的区别">http各版本区别</a></li>
<li>底层如何通过socket传输数据? 如何知道是那个请求的数据?</li>
<li>讲讲<a href="./../../cs-basic/os/def/multiplexing/">多路复用</a></li>
<li>mybatis源码?不会</li>
<li>说一下你对<a href="./../../mysql/#三、索引">索引</a>的理解，聚集索引 和 非聚集索引</li>
<li>为什么索引会采用<a href="./../../mysql/index/">B+树?</a></li>
<li>B+树如何分裂?</li>
<li>算法题: 找出数据中,满足 prefix 的所有字符串</li>
</ol>
<hr>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-0"><label for="task-item-0"> TCP挥手</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-1"><label for="task-item-1"> 每个包发送之后的状态</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-2"><label for="task-item-2"> 进程通信方式</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-3"><label for="task-item-3"> 管道的底层原理 - 看不懂</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-4"><label for="task-item-4"> socket</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-5"><label for="task-item-5"> 底层、怎么知道哪个请求的数据</label></li>
</ul>
</li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-6"><label for="task-item-6"> http1.1</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-7"><label for="task-item-7"> http各版本区别</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-8"><label for="task-item-8"> keep-alive</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-9"><label for="task-item-9"> 多路复用</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-10"><label for="task-item-10"> IO多路复用</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-11"><label for="task-item-11"> 时分复用</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-12"><label for="task-item-12"> 索引理解</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-13"><label for="task-item-13"> 聚簇索引、非聚簇索引</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-14"><label for="task-item-14"> B+树</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-15"><label for="task-item-15"> 为什么是B+ 树</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-16"><label for="task-item-16"> 底层实现</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-17"><label for="task-item-17"> 题：满足prefis的所有字符串</label></li>
</ul>
<h2 id="_2面"> 2面</h2>
<ol>
<li>
<p>自我介绍</p>
</li>
<li>
<p>了解linux 嘛</p>
</li>
<li>
<p>Linux 中 怎么排查对应的程序 占用内存 或者 使用cpu? top</p>
</li>
<li>
<p><a href="./../../cs-basic/network/url-to-page/">一个请求从输入网址到返回</a></p>
</li>
<li>
<p><a href="./../../cs-basic/network/http-and-https/#https工作流程">HTTPS加密流程 </a></p>
</li>
<li>
<p>spring 的设计模式</p>
</li>
<li>
<p>IOC 和 <a href="../../framework">AOP</a></p>
<ul>
<li><a href="https://blog.csdn.net/ivan820819/article/details/79744797" target="_blank" rel="noopener noreferrer">浅谈IOC--说清楚IOC是什么_ivan820819的博客-CSDN博客_ioc</a></li>
<li><a href="https://blog.csdn.net/q982151756/article/details/80513340" target="_blank" rel="noopener noreferrer">细说Spring——AOP详解（AOP概览）_Jivan2233的博客-CSDN博客_aop</a></li>
</ul>
</li>
<li>
<p><a href="./../../cs-basic/network/interview-questions/">JWT</a>加密如何实现?如何预防攻击?</p>
</li>
<li>
<p>数据库的索引怎么理解?</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/#%E7%B4%A2%E5%BC%95" target="_blank" rel="noopener noreferrer">MySQL 面试题合集 | lllllan</a></li>
<li><a href="http://blog.lllllan.cn/mysql/index/" target="_blank" rel="noopener noreferrer">索引 | lllllan</a></li>
</ol>
</li>
<li>
<p>数据库的隔离级别有哪些?</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/transaction/#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" target="_blank" rel="noopener noreferrer">事务 | lllllan</a></li>
</ol>
</li>
<li>
<p>什么情况下该采用那个级别?</p>
</li>
<li>
<p>Java中的锁有哪些? - <a href="http://blog.lllllan.cn/java/concurrent/2/9/" target="_blank" rel="noopener noreferrer">第九章、synchronized与锁 | lllllan</a></p>
</li>
<li>
<p>synchronize锁的升级 和 降级?</p>
</li>
<li>
<p>hashmap的实现 <a href="http://blog.lllllan.cn/java/container/source-code/hashmap/" target="_blank" rel="noopener noreferrer">HashMap 源码解读 | lllllan</a></p>
</li>
<li>
<p>hashmap安全嘛? concurrenthashmap</p>
</li>
<li>
<p>算法题: 括号匹配</p>
</li>
</ol>
<hr>
<ul>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-18"><label for="task-item-18"> linux</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-19"><label for="task-item-19"> 排查对应程序 占用内存、使用CPU情况</label></li>
</ul>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-20"><label for="task-item-20"> url到页面显示</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-21"><label for="task-item-21"> https加密流程</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-22"><label for="task-item-22"> spring设计模式</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-23"><label for="task-item-23"> ioc、aop</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-24"><label for="task-item-24"> IOC</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-25"><label for="task-item-25"> AOP</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-26"><label for="task-item-26"> JWT加密</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-27"><label for="task-item-27"> 如何实现</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-28"><label for="task-item-28"> 如何预防攻击</label></li>
</ul>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-29"><label for="task-item-29"> 索引理解</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-30"><label for="task-item-30"> 数据库隔离级别</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-31"><label for="task-item-31"> 怎么选择</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-32"><label for="task-item-32"> Java 锁</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-33"><label for="task-item-33"> synchronize锁的升级和降级</label></li>
</ul>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-34"><label for="task-item-34"> hashmap实现</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-35"><label for="task-item-35"> 是否安全</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-36"><label for="task-item-36"> concurrentHashMap</label></li>
</ul>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-37"><label for="task-item-37"> 题：括号匹配</label></p>
</li>
</ul>
<h2 id="_3面"> 3面</h2>
<ol>
<li>自我介绍</li>
<li>了解redis嘛?</li>
<li>手写sql 给两张成绩表 一张数学表 一张英语表(course_score,stu_id) 求每个同学的数学和英语的总成绩</li>
<li>数据库的隔离级别有哪些?</li>
<li>RR 和 串行读取有什么区别?</li>
<li>什么场景下该使用什么样的数据库隔离级别?</li>
<li>算法: https://leetcode-cn.com/problems/search-a-2d-matrix-ii/</li>
</ol>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-38"><label for="task-item-38"> redis</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-39"><label for="task-item-39"> 手写sql</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-40"><label for="task-item-40"> 数据库隔离级别</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-41"><label for="task-item-41"> RR和串行读区别</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-42"><label for="task-item-42"> 选择</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-43"><label for="task-item-43"> 题：搜索二维矩阵 II</label></li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="面经"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-08T02:19:10.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节|抖音直播支付|日常实习</title>
    <id>https://notes.lllllan.cn/mianjing/1/</id>
    <link href="https://notes.lllllan.cn/mianjing/1/"/>
    <updated>2022-04-17T07:25:28.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/816404?type=2&amp;order=3&amp;pos=1&amp;page=2&amp;source_id=discuss_tag_nctrack&amp;channel=-1&amp;ncTraceId=54dc7a9f0e894e9eba08bb844d43d679.4532.16487083812994999&amp;gio_id=C04414E246388416475DED5620E560A6-1648708382329" target="_blank" rel="noopener noreferrer">字节跳动 抖音直播支付 日常实习面经 (已oc)_笔经面经_牛客网 (nowcoder.com)</a></p>
<p>学历双非本科，大一打过算法比赛，后来学的java方向，学长帮我推的抖音直播。三轮面试官和hr都非常nice，因为才第二次面试，三轮都非常紧张，面试官会引导我说，直到我了解的最深的地方。</p>
<h2 id="一面"> 一面:</h2>
<ol>
<li>自我介绍 x 1</li>
<li>项目深挖(整体架构，技术对比和选择原因，负载均衡策略，几种io模型，这块比较熟悉说了很多，面试官也没有打断，还追问了epoll具体实现，触发方式等)</li>
<li><a href="./../../java/container/source-code/hashmap/">hashmap原理</a>,扩容,问了我hashmap怎么缩容(这里应该说红黑树退化链表的，hashmap没有缩容，我还以为自己记错了😭)</li>
<li>hashtable hashmap synchronizedmap concurrentmap(细说，这里我紧张，面试官开始引导我，爱了！！！)</li>
<li><a href="./../../framework/design-pattern/agent/">代理模式</a> （静态动态，动态的两种方式及区别，cglib缺点我说了final和首次字节码生成的效率）</li>
<li>快排归并，区别，手撕时间复杂度推导</li>
<li>思维题：两个人轮流扔硬币，谁先扔正面谁赢，求先抛的人赢得概率(淦，这里理解错题意了，就是简单的等比数列求和加极限就能做)</li>
<li>算法题：排列组合</li>
</ol>
<hr>
<ul>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-0"><label for="task-item-0"> HashMap 扩容、退化</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-1"><label for="task-item-1"> 基本的put和get</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-2"><label for="task-item-2"> 红黑树相关的操作</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-3"><label for="task-item-3"> Java各类Map对比</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-4"><label for="task-item-4"> HashMap</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-5"><label for="task-item-5"> HashTable</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-6"><label for="task-item-6"> TreeMap</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-7"><label for="task-item-7"> ConcurrentHashMap</label></li>
</ul>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-8"><label for="task-item-8"> 代理模式</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-9"><label for="task-item-9">  代理模式概念，静态代理、动态代理（JDK动态代理、CGlib动态代理）</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-10"><label for="task-item-10">  两种代理的区别</label></li>
</ul>
</li>
</ul>
<h2 id="二面"> 二面:</h2>
<ol>
<li>自我介绍x2</li>
<li>看你第一个项目聊了很多，这次说说第二个项目(麻了，第二个项目是一个落地的crud,只问了5分钟不太感兴趣就没再问)</li>
<li>经典题~<a href="./../../cs-basic/network/url-to-page/">从输入url到显示页面的过程</a>(这里提了dns,tcp连接,http协议，然后开始追问，把这几个玩意都细讲了)</li>
<li>[dns解析出错，怎么排查错误](<a href="https://hsk.oray.com/news/7898.html" target="_blank" rel="noopener noreferrer">dns错误怎么解决？怎么排查及解决dns解析故障？-贝锐花生壳官网 (oray.com)</a>)</li>
<li>tcp,udp</li>
<li><a href="./../../cs-basic/network/http-and-https/">http,https,https理解，秘钥交换过程</a></li>
<li>口述几个sql语句</li>
<li>mysql索引(这里说了b+树，感觉面试官问的是唯一索引聚集索引那些，理解错意思x2)</li>
<li>创建索引的原则(区分度，是否是查询时使用，插入性能和读取性能权衡，减少回表)</li>
<li>ACID(每个都问了细节)</li>
<li><a href="./../../mysql/mvcc/">MVCC</a></li>
<li>用过的<a href="./../../framework/design-pattern/">设计模式</a>(提了项目里的代理模式，aqs的模板方法模式)</li>
<li>spring,springmvc中代理模式用在哪些地方</li>
<li><a href="../../framework">aop</a></li>
<li>思维题 ： <a href="./../../ds-and-algorithms/algorithms/sort/unstable-quick-sort/">如何实现稳定的快速排序</a>、 对一个省上百万考生的考试成绩排序 要求o(n)  交叉链表找交叉节点</li>
<li>算法题：数组峰值元素</li>
</ol>
<hr>
<ul>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-11"><label for="task-item-11"> 从输入url到页面显示的详细过程</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-12"><label for="task-item-12"> dns解析出错（查不到太具体的答案）</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-13"><label for="task-item-13"> http、https，密钥</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-14"><label for="task-item-14"> http、https的区别</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-15"><label for="task-item-15"> https请求过程</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-16"><label for="task-item-16"> HTTPS的握手</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-17"><label for="task-item-17"> SSL、TLS</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-18"><label for="task-item-18"> sql语句</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-19"><label for="task-item-19"> mysql索引</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-20"><label for="task-item-20"> 创建索引的原则</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-21"><label for="task-item-21"> ACID</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-22"><label for="task-item-22"> MVCC</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-23"><label for="task-item-23"> 设计模式</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-24"><label for="task-item-24"> spring中的代理模式</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-25"><label for="task-item-25"> aop</label></p>
</li>
<li>
<p><input type="checkbox" checked="checked" disabled="disabled" id="task-item-26"><label for="task-item-26"> 稳定快排</label></p>
</li>
</ul>
<h2 id="三面"> 三面:</h2>
<ol>
<li>自我介绍x3</li>
<li>介绍项目</li>
<li>netty作用，自己的理解，组件(我明明记了很多！没说出来，我不李姐)</li>
<li>项目整体流程(三面项目问的很短，直接开始做题了还以为被挂了，慌得一b)</li>
<li>算法题：[两个有序数组找第k小元素要求时间复杂度o(logn)](<a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays/" target="_blank" rel="noopener noreferrer">4. 寻找两个正序数组的中位数 - 力扣（LeetCode） (leetcode-cn.com)</a>) 、 二叉树从根节点到叶子结点和为k的所有路径</li>
</ol>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-27"><label for="task-item-27"> netty</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-28"><label for="task-item-28"> 两个有序数组第k小元素</label></li>
</ul>
<p>唠嗑，聊学习方式，顺便问基础知识，三面后面还问了很多基础知识，挺广的，从csrf,xss到sql注入一大堆。三面当时没记面经，靠回忆8太记得了
三面主要是知识的深度广度还有场景题，ld面确实很顶</p>
<h2 id="hr面"> hr面:</h2>
<p>自我介绍x4
略😂😂😂</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="面经"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T12:27:53.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节|番茄后端|实习</title>
    <id>https://notes.lllllan.cn/mianjing/3/</id>
    <link href="https://notes.lllllan.cn/mianjing/3/"/>
    <updated>2022-04-19T05:17:15.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/924126" target="_blank" rel="noopener noreferrer">字节跳动 后端暑期实习 一二三面凉经_笔经面经_牛客网 (nowcoder.com)</a></p>
<h2 id="字节一面3-28"> 字节一面3.28</h2>
<ol>
<li>
<p>自我介绍</p>
</li>
<li>
<p>new/delete和malloc/free的区别</p>
</li>
<li>
<p>new操作符可以被重载吗</p>
</li>
<li>
<p>static关键字的作用</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/basic/2-grammar/#_3-3-static-%E7%9A%84%E4%BD%9C%E7%94%A8" target="_blank" rel="noopener noreferrer">Java - 基础语法 | lllllan</a></li>
</ol>
</li>
<li>
<p>C++的多态了解吗</p>
</li>
<li>
<p>构造函数和析构函数可以是虚函数吗</p>
</li>
<li>
<p>vector底层实现机制</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/container/source-code/vector/" target="_blank" rel="noopener noreferrer">Vector 源码解读 | lllllan</a></li>
</ol>
</li>
<li>
<p>map和unordered_map的区别</p>
</li>
<li>
<p>哈希冲突的解决方法</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/basic/#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" target="_blank" rel="noopener noreferrer">常见面试题 | lllllan</a></li>
</ol>
</li>
<li>
<p>进程和线程的区别</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/os/#%E4%BA%8C%E3%80%81%E8%BF%9B%E7%A8%8B%E5%92%8C%E7%BA%BF%E7%A8%8B" target="_blank" rel="noopener noreferrer">操作系统 | lllllan</a></li>
</ol>
</li>
<li>
<p>进程中的一个线程有问题，会有什么影响</p>
</li>
<li>
<p>实现一个服务，可以多进程，单进程，多线程，会怎么选择实现的方式，考虑是什么</p>
</li>
<li>
<p>高并发线程不够用怎么办</p>
</li>
<li>
<p>epoll的两种模式</p>
</li>
<li>
<p>常见的进程间的通信方式，哪个最快</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/os/def/process-communication/" target="_blank" rel="noopener noreferrer">进程间通信 | lllllan</a></li>
</ol>
</li>
<li>
<p>为什么共享内存最快</p>
</li>
<li>
<p>介绍一下虚拟地址和物理地址，虚拟地址怎么映射到物理地址</p>
</li>
<li>
<p>TCP和UDP的区别</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/interview-questions/#%E5%9B%9B%E3%80%81tcp%E3%80%81udp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ol>
</li>
<li>
<p>TCP粘包是什么</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/interview-questions/#tcp%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85-%E2%98%85" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ol>
</li>
<li>
<p>描述一下TCP的四次挥手</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/4-wave/" target="_blank" rel="noopener noreferrer">四次挥手 | lllllan</a></li>
</ol>
</li>
<li>
<p>TIME_WAIT状态的作用</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/4-wave/#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener noreferrer">四次挥手 | lllllan</a></li>
</ol>
</li>
<li>
<p>MySQL索引底层什么实现的</p>
</li>
<li>
<p>为什么采用B+树</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/index/" target="_blank" rel="noopener noreferrer">索引 | lllllan</a></li>
</ol>
</li>
<li>
<p>聚簇索引和非聚簇索引的区别</p>
</li>
<li>
<p>聚簇索引一个表可以有多个吗</p>
</li>
</ol>
<p>做题：n*m的格子，1表示小岛，求最大小岛面积。</p>
<p>反问</p>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-0"><label for="task-item-0"> new/delete、malloc/free</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-1"><label for="task-item-1"> new可以被重载吗</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-2"><label for="task-item-2"> static 关键字作用</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-3"><label for="task-item-3"> 各种关键字</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-4"><label for="task-item-4"> vector底层实现</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-5"><label for="task-item-5"> 哈希冲突的解决办法</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-6"><label for="task-item-6"> 进程和线程的区别</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-7"><label for="task-item-7"> 进程中的一个线程出现问题，会有什么影响</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-8"><label for="task-item-8"> 实现一个服务，怎么考虑进程和线程的使用</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-9"><label for="task-item-9"> 高并发线程不够用</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-10"><label for="task-item-10"> epoll两种模式</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-11"><label for="task-item-11"> 进程通信方式，哪个最快</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-12"><label for="task-item-12"> 为什么共享内存最快 - 直接在内存存取</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-13"><label for="task-item-13"> 虚拟地址怎么映射到物理地址</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-14"><label for="task-item-14"> TCP和UDP的区别</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-15"><label for="task-item-15"> TCP粘包是什么</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-16"><label for="task-item-16"> TCP四次挥手</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-17"><label for="task-item-17"> TIME_WAIT状态的作用</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-18"><label for="task-item-18"> mysql索引底层实现</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-19"><label for="task-item-19"> 为什么采用B+树</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-20"><label for="task-item-20"> 聚簇索引和非聚簇索引</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-21"><label for="task-item-21"> 一个表中可以有多个聚簇索引吗</label></li>
</ul>
</li>
</ul>
<h2 id="字节二面3-30"> 字节二面3.30</h2>
<ol>
<li>
<p>自我介绍</p>
</li>
<li>
<p>在校期间有做过什么实习的东西吗</p>
</li>
<li>
<p>引用和指针的区别</p>
</li>
<li>
<p>引用可以为空吗</p>
</li>
<li>
<p>const修饰一个引用表示什么意思</p>
</li>
<li>
<p>set的底层是怎么实现的</p>
</li>
<li>
<p>为什么采用红黑树，为什么不用哈希</p>
<ol>
<li><a href="https://blog.csdn.net/it_qingfengzhuimeng/article/details/103308308" target="_blank" rel="noopener noreferrer">在Java8中为什么要使用红黑树来实现的HashMap？_清风追梦enjoy的博客-CSDN博客_hashmap为什么要用红黑树</a></li>
</ol>
</li>
<li>
<p>http协议和https协议的区别</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/http-and-https/#http-%E4%B8%8E-https-%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">HTTP和HTTPS | lllllan</a></li>
</ol>
</li>
<li>
<p>https的建连，有几次握手</p>
</li>
<li>
<p>http协议工作在哪一层</p>
<ol>
<li>应用层</li>
</ol>
</li>
<li>
<p>传输层协议有哪些</p>
<ol>
<li>tcp、udp</li>
</ol>
</li>
<li>
<p>http的长连接和短连接</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/keep-alive/" target="_blank" rel="noopener noreferrer">keep-alive | lllllan</a></li>
</ol>
</li>
<li>
<p>tcp的长连接和短连接</p>
<ol>
<li>HTTP的长连接和短连接本质上是TCP长连接和短连接</li>
</ol>
</li>
<li>
<p>常用的IO模型</p>
</li>
<li>
<p>什么是IO复用</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/os/#_5-3-unix%E5%B8%B8%E8%A7%81%E7%9A%84io%E6%A8%A1%E5%9E%8B-%E2%98%85" target="_blank" rel="noopener noreferrer">操作系统 | lllllan</a></li>
</ol>
</li>
<li>
<p>IO多路复用模型的区别</p>
</li>
<li>
<p>select、poll、epoll分别适用于什么场景</p>
</li>
<li>
<p>了解什么是局部性原理吗</p>
<ol>
<li>空间局部性、时间局部性</li>
</ol>
</li>
<li>
<p>什么情况会使用局部性原理</p>
</li>
<li>
<p>使用索引的优点和缺点</p>
<ol>
<li>检索快、维护难占空间</li>
</ol>
</li>
<li>
<p>b+树索引和哈希索引了解吗</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/index/" target="_blank" rel="noopener noreferrer">索引 | lllllan</a></li>
</ol>
</li>
<li>
<p>实际场景，有一个查询语句select * from table where a&gt;1 and b=1，怎么给a，b建一个联合索引性能比较好</p>
<ol>
<li>当遇到范围查询(&gt;、&lt;、between、like)就会停止匹配</li>
<li>联合索引（b，a）</li>
</ol>
</li>
<li>
<p>什么是事务</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/transaction/" target="_blank" rel="noopener noreferrer">事务 | lllllan</a></li>
</ol>
</li>
<li>
<p>事务有哪些特性</p>
</li>
<li>
<p>Innodb支持哪些隔离级别</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/transaction/#%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB" target="_blank" rel="noopener noreferrer">事务 | lllllan</a></li>
</ol>
</li>
<li>
<p>幻读可以举个例子吗</p>
</li>
<li>
<p>MySQL怎么解决幻读问题</p>
</li>
<li>
<p>什么是间隙锁</p>
<ol>
<li><a href="https://www.jianshu.com/p/32904ee07e56" target="_blank" rel="noopener noreferrer">MYSQL（04）-间隙锁详解 - 简书 (jianshu.com)</a></li>
</ol>
</li>
<li>
<p>间隙锁只有RR级别下才有的吗</p>
</li>
</ol>
<p>做题：大数相乘，字符串模拟</p>
<p>反问</p>
<hr>
<ul>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-22"><label for="task-item-22"> 引用和指针</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-23"><label for="task-item-23"> 引用可以为空吗</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-24"><label for="task-item-24"> const</label></p>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-25"><label for="task-item-25"> set底层实现</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-26"><label for="task-item-26"> 为什么采用红黑树，而不是哈希</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-27"><label for="task-item-27"> http和https</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-28"><label for="task-item-28"> https的握手</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-29"><label for="task-item-29"> http在哪一层工作</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-30"><label for="task-item-30"> http长连接和短连接</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-31"><label for="task-item-31"> tcp长连接和短连接</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-32"><label for="task-item-32"> 传输层协议有哪些</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-33"><label for="task-item-33"> 常用的IO模型</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-34"><label for="task-item-34"> IO多路复用</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-35"><label for="task-item-35"> IO多路复用模型的区别</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-36"><label for="task-item-36"> select、poll、epoll适用场景</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-37"><label for="task-item-37"> 局部性原理</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-38"><label for="task-item-38"> 什么情况下使用局部性原理</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-39"><label for="task-item-39"> 索引的优点和缺点</label></p>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-40"><label for="task-item-40"> b+树索引和哈希索引</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-41"> <code>select * from table where a&gt;1 and b=1</code><label for="task-item-41"> `select * from table where a>1 and b=1` 怎么简历联合索引性能好</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-42"><label for="task-item-42"> 最左匹配原则</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-43"><label for="task-item-43"> 事务</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-44"><label for="task-item-44"> 事务特性</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-45"><label for="task-item-45"> innodb隔离级别</label></p>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-46"><label for="task-item-46"> 幻读例子</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-47"><label for="task-item-47"> mysql怎么解决幻读</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-48"><label for="task-item-48"> 间隙锁</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-49"><label for="task-item-49"> 间隙锁只有在RR级别下才有吗</label></li>
</ul>
</li>
<li>
<p><input type="checkbox"  disabled="disabled" id="task-item-50"><label for="task-item-50"> 大数相乘</label></p>
</li>
</ul>
<h2 id="字节三面4-2"> 字节三面4.2</h2>
<ol>
<li>
<p>map和unordered_map的实现</p>
</li>
<li>
<p>怎么处理哈希冲突</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/basic/#%E5%93%88%E5%B8%8C%E5%86%B2%E7%AA%81%E7%9A%84%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95" target="_blank" rel="noopener noreferrer">常见面试题 | lllllan</a></li>
</ol>
</li>
<li>
<p>了解哪些程序语言的锁</p>
</li>
<li>
<p>阻塞到唤醒为什么还会有开销</p>
</li>
<li>
<p>了解cas吗</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/concurrent/2/10/" target="_blank" rel="noopener noreferrer">第十章、CAS与原子操作 | lllllan</a></li>
</ol>
</li>
<li>
<p>怎么实现一个优先级队列</p>
</li>
<li>
<p>对2000万高考考生的分数进行排序</p>
</li>
</ol>
<p>做题：给m个不重复字符和一个长度为n的字符串，能否在这个字符串中找到一个长度为m的连续子串，使得子串都由上面的m个字符组成。</p>
<p>反问</p>
<p>今天看官网，挂了。。。</p>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-51"><label for="task-item-51"> map实现</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-52"><label for="task-item-52"> 怎么处理哈希冲突</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-53"><label for="task-item-53"> java锁</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-54"><label for="task-item-54"> 阻塞到唤醒为什么有开销</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-55"><label for="task-item-55"> cas</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-56"><label for="task-item-56"> 怎么实现优先队列</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-57"><label for="task-item-57"> 给m个不重复字符和一个长度为n的字符串，能否在这个字符串中找到一个长度为m的连续子串，使得子串都由上面的m个字符组成。</label></li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="面经"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-09T03:13:56.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节|后端|实习</title>
    <id>https://notes.lllllan.cn/mianjing/4/</id>
    <link href="https://notes.lllllan.cn/mianjing/4/"/>
    <updated>2022-04-19T05:17:15.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/870251" target="_blank" rel="noopener noreferrer">已发offer | 字节跳动 后端 实习一二三面_笔经面经_牛客网 (nowcoder.com)</a></p>
<p>3.8投简历，3.9约面试，3.16下午连着走完了三面所有流程，3.21下午HR沟通，半小时后发offer，不得不感叹字节效率是真的高。</p>
<p>本人所在部门目前hc还有很多，如果有想实习的同学，欢迎联系我进行内推投递，反馈很快</p>
<p>面试体验极佳，面试官都很有耐心和礼貌，遇到问题时会不断地引导。</p>
<p>下面记录一下面试内容：</p>
<h1 id="一面"> <strong>一面:</strong></h1>
<ol>
<li>
<p>HashMap和ConcurrentHashMap，说一下扩容过程，有什么区别。</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/container/source-code/hashmap/" target="_blank" rel="noopener noreferrer">HashMap 源码解读 | lllllan</a></li>
<li><a href="http://blog.lllllan.cn/java/container/source-code/concurrent-hashmap/" target="_blank" rel="noopener noreferrer">ConcurrentHashMap 源码解读 | lllllan</a></li>
</ol>
</li>
<li>
<p>Java的泛型如何实现？泛型擦除是什么</p>
<ol>
<li><a href="https://cloud.tencent.com/developer/article/1649866" target="_blank" rel="noopener noreferrer">面试官问我：“泛型擦除是什么，会带来什么问题？” - 云+社区 - 腾讯云 (tencent.com)</a></li>
</ol>
</li>
<li>
<p>java的类加载为什么要使用双亲委派机制</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/jvm/#%E5%8F%8C%E4%BA%B2%E5%A7%94%E6%B4%BE%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener noreferrer">JVM 常见问题 | lllllan</a></li>
<li>避免一个类的重复加载</li>
<li>保护框架需要加载的类不会被应用程序覆盖</li>
</ol>
</li>
<li>
<p>挖项目，问数据库表和字段的设计（有点紧张，说得很磕巴）</p>
</li>
<li>
<p>说一下MySQL事务隔离级别，默认的级别是什么？是否解决了幻读？如何解决？MVCC如何实现？</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/transaction/" target="_blank" rel="noopener noreferrer">事务 | lllllan</a></li>
<li><a href="http://blog.lllllan.cn/mysql/mvcc/" target="_blank" rel="noopener noreferrer">MVCC | lllllan</a></li>
</ol>
</li>
<li>
<p>MySQL主从复制了解吗，如果让你设计，你会如何实现？（直说没了解，想了半天也没有想出来如何设计，面试官不断引导，奈何本人不争气）</p>
</li>
<li>
<p>说一下https和http区别，说一下握手过程（这里说得比较详细，从非对称加密开始讲起</p>
</li>
<li>
<p>time_wait是什么？如何解决？（结合项目中实际遇到的问题，也说得很详细）</p>
</li>
<li>
<p>Spring如何解决循环依赖？（没遇到过，没有了解</p>
</li>
<li>
<p>算法题：第一题是lc983，没做出来，表示不擅长动态规划。然后换成了根据前序和中序序列重建二叉树。</p>
</li>
</ol>
<p>以为要凉，结果面试官让我等等，马上二面，我有点懵逼。</p>
<p>一面过程中非常紧张，然而还是给过了。。感谢面试官。</p>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-0"><label for="task-item-0"> 各种map的扩容过程</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-1"><label for="task-item-1"> hashMap</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-2"><label for="task-item-2"> ConcurrentHashMap</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-3"><label for="task-item-3"> Java泛型</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-4"><label for="task-item-4"> 如何实现</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-5"><label for="task-item-5"> 泛型擦除</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-6"><label for="task-item-6"> 双亲委派机制</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-7"><label for="task-item-7"> MySQL事务隔离级别</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-8"><label for="task-item-8"> 默认级别</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-9"><label for="task-item-9"> 怎么解决幻读</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-10"><label for="task-item-10"> mvcc</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-11"><label for="task-item-11"> MySQL主从复制</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-12"><label for="task-item-12"> http和https</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-13"><label for="task-item-13"> 握手过程</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-14"><label for="task-item-14"> time_wait、如何解决</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-15"><label for="task-item-15"> spring循环依赖</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-16"><label for="task-item-16"> 算法</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-17"><label for="task-item-17"> lc983</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-18"><label for="task-item-18"> 重建二叉树</label></li>
</ul>
</li>
</ul>
<h1 id="二面"> <strong>二面:</strong></h1>
<ol>
<li>
<p>了解Flink吗？用过什么算子？（说了一下Flink架构，还有常见的几个算子</p>
</li>
<li>
<p>了解JVM吗？说一说G1GC的过程，和CMS的区别。</p>
</li>
<li>
<p>了解Linux网络模型吗？（ 没答上来，只说了个epoll</p>
</li>
<li>
<p>了解微服务吗？组件有什么？（我说不了解，但他还是追问，我就说了SpringCloud的那些组件</p>
</li>
<li>
<p>了解k8s吗？了解云原生吗？（我说我了解docker，他说docker只是个容器。我说云原生没有很确切的概念，他说没错，看来你看过相关的。。</p>
</li>
<li>
<p>了解AQS吗？（讲了一下AQS的源码，比较满意）</p>
</li>
<li>
<p>了解java内存模型吗？说说volatile底层原理。（讲了一下JMM，内存读写屏障）</p>
<ol>
<li><a href="http://blog.lllllan.cn/java/concurrent/2/6/" target="_blank" rel="noopener noreferrer">第六章、Java内存模型基础知识 | lllllan</a></li>
</ol>
</li>
<li>
<p>项目中遇到什么问题？如何解决？（说了一些技术细节</p>
</li>
<li>
<p>算法题：最长回文子串，求x的算术平方根，验证一个树是否为另一个的子树。</p>
</li>
</ol>
<p>反问环节：有什么建议？（让我别紧张，大家都是这么过来的，多面几次就好了，听到这话我以为凉了，然后让我等通知，后续有面试的话会通知我。洗了把脸准备出门，出门5分钟就被通知马上三面，有点懵逼）</p>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-19"><label for="task-item-19"> Flink</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-20"><label for="task-item-20"> G1和CMS的GC过程、区别</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-21"><label for="task-item-21"> linux网络模型</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-22"><label for="task-item-22"> 微服务、组件</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-23"><label for="task-item-23"> k8s、云原生</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-24"><label for="task-item-24"> AQS</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-25"><label for="task-item-25"> java内存模型</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-26"><label for="task-item-26"> JMM</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-27"><label for="task-item-27"> volatile底层</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-28"><label for="task-item-28"> 内存读写屏障</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-29"><label for="task-item-29"> 算法</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-30"><label for="task-item-30"> 最长回文子串</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-31"><label for="task-item-31"> 算数平方根</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-32"><label for="task-item-32"> 子树</label></li>
</ul>
</li>
</ul>
<h1 id="三面"> <strong>三面：</strong></h1>
<ol>
<li>先介绍项目，然后做了一道SQL索引设计题，没什么难度。</li>
<li>算法题，镜像二叉树</li>
<li>自主命题，把List结构转换成树结构</li>
<li>然后继续问项目中遇到的困难，如何解决</li>
<li>问能否接受更换语言？Go</li>
<li>最后开始聊人生。</li>
</ol>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-33"><label for="task-item-33"> SQL索引设计</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-34"><label for="task-item-34"> 镜像二叉树</label></li>
</ul>
<h1 id="offer"> offer</h1>
<p>3.21下午接到HR电话，介绍了一下福利、地点等，沟通了入职时间，已收到offer。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="面经"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-13T02:53:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节|后端|日常实习</title>
    <id>https://notes.lllllan.cn/mianjing/5/</id>
    <link href="https://notes.lllllan.cn/mianjing/5/"/>
    <updated>2022-04-22T13:10:39.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.nowcoder.com/discuss/927475?type=post&amp;order=create&amp;pos=&amp;page=1&amp;ncTraceId=&amp;channel=-1&amp;source_id=search_post_nctrack" target="_blank" rel="noopener noreferrer">字节后端日常实习一二三面经_笔经面经_牛客网 (nowcoder.com)</a></p>
<p>第一次面字节，总结一下三次面经。
面试的是后端开发日常实习岗，部门是电商商家与运营（上海）。技术栈主要是 Go，所以 Java 问题偏少，集中在操作系统、网络和数据库的问题上，当然算法和项目是必问的。
字节面试官感觉都很忙，面试体验一般，但总体效率很高，一般当天就会给结果。最后三面过了，因为目前在 gap 还没入学，所以 Offer 审核没过。</p>
<h2 id="一面-3月9日-60分钟"> 一面（3月9日，60分钟）</h2>
<ol>
<li>
<p>自我介绍</p>
</li>
<li>
<p>项目讨论</p>
</li>
<li>
<p>MySQL 有哪些索引？（主键，唯一，普通）</p>
<ol>
<li><a href="http://blog.lllllan.cn/mysql/index/" target="_blank" rel="noopener noreferrer">索引 | lllllan</a></li>
</ol>
</li>
<li>
<p>聚类、非聚类索引区别？</p>
</li>
<li>
<p>联合索引 abc，查 a（走索引），查 b （不走），查 b = 1 and a = 1（走），查 a &gt; 0 and b = 1 （走，但 b 列走不了）</p>
<ul>
<li>最后一个情况，为什么 a 走 b 不走？（最左匹配）</li>
<li>你给我详细分析一下 a &gt; 0 and b = 1 查询索引的过程？（我说先匹配 a，再通过叶子节点链表取出数据过滤 b）</li>
<li>如果一定要用索引匹配 b，怎么设计这个算法？（二分？想了一下挺麻烦的）</li>
<li>B+ 树叶子节点是链表怎么二分？（同页上的数据可以二分，页结构中有一个数组）</li>
</ul>
</li>
<li>
<p>怎么知道命中索引了没？（explain）</p>
<ol>
<li><a href="https://blog.csdn.net/ba_qi/article/details/88799093" target="_blank" rel="noopener noreferrer">如何监测MySQL是否命中索引？_空心人(・。・)的博客-CSDN博客_mysql怎么查看索引是否命中</a></li>
</ol>
</li>
<li>
<p>索引失效的情况？（比如条件里带函数，is null 等一些字段，like 左边加了通配符）</p>
<ol>
<li><a href="https://blog.csdn.net/sy_white/article/details/122112440" target="_blank" rel="noopener noreferrer">索引失效的情况及解决(超详细)_zyy_demon的博客-CSDN博客_索引失效的几种情况和解决</a></li>
</ol>
</li>
<li>
<p>like 左边有通配符为什么不匹配？（不知道，感觉和最左匹配差不多）</p>
</li>
<li>
<p>场景题：字符串左右模糊匹配，比如“我爱中国”匹配“爱中”怎么设计索引？（我说存一个反序，通配符都加后面行不行？面试官说有问题，不过也没往下聊了）</p>
<ol>
<li>全文索引</li>
</ol>
</li>
<li>
<p>浏览器输入 URL？（八股）</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/url-to-page/" target="_blank" rel="noopener noreferrer">输入url网址到页面显示 | lllllan</a></li>
</ol>
</li>
<li>
<p>具体到 HTTP 协议？（我说了 TCP 握手， HTTP 协议的报文，面试官感觉我应该懂就直接打断了）</p>
</li>
<li>
<p>算法：岛屿数量（只要求写核心函数）</p>
</li>
<li>
<p>反问</p>
</li>
</ol>
<p>总结：**大部分时间花在 MySQL 的讨论上，需要在八股文的基础之上深入思考。**面试官性格蛮好的，除了提问他也会参与讨论给出他的意见。Java，操作系统，框架，Redis…… 一个没问。</p>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-0"><label for="task-item-0"> MySQL索引</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-1"><label for="task-item-1"> 聚集、非聚集索引区别</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-2"><label for="task-item-2"> 联合索引</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-3"><label for="task-item-3"> 最左匹配</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-4"><label for="task-item-4"> B+树叶子节点怎么二分</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-5"><label for="task-item-5"> 怎么知道索引命中了没有</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-6"><label for="task-item-6"> 索引失效的情况</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-7"><label for="task-item-7"> like左边有通配符为什么不匹配</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-8"><label for="task-item-8"> 字符串左右模糊匹配</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-9"><label for="task-item-9"> url到页面显示</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-10"><label for="task-item-10"> 具体用到什么协议</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-11"><label for="task-item-11"> 算法：岛屿数量</label></li>
</ul>
<h2 id="二面-3月11日-80分钟"> 二面（3月11日，80分钟）</h2>
<ol>
<li>
<p>自我介绍</p>
</li>
<li>
<p>项目讨论（两个项目问了 15 分钟，疯狂轰炸原理、代码细节）</p>
</li>
<li>
<p>HTTP 的 keep-alive 和 TCP 的 keep-alive（项目延伸问题，讨论了 10 分钟）</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/keep-alive/" target="_blank" rel="noopener noreferrer">keep-alive | lllllan</a></li>
<li>HTTP 的 keep-alive 多长？（不了解，提到 Nginx 好像是 60s，但理论上应该没限制？）</li>
</ol>
</li>
<li>
<p>HTTP 怎么拆包的？（CRLF 分隔，同时有一个 Content-Length 字段决定 body 长度）</p>
<ol>
<li><a href="http://blog.lllllan.cn/cs-basic/network/how-is-the-network-connected/2/#_3-2-%E5%AF%B9%E8%BE%83%E5%A4%A7%E6%95%B0%E6%8D%AE%E8%BF%9B%E8%A1%8C%E6%8B%86%E5%88%86" target="_blank" rel="noopener noreferrer">第二章、用电信号传输 TCP/IP 数据 | lllllan</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/77275039" target="_blank" rel="noopener noreferrer">应用层的拆包和粘包 - 知乎 (zhihu.com)</a></li>
</ol>
<blockquote>
<ul>
<li>
<p>请求行的边界是CRLF，如果读取到CRLF，则意味着请求行的信息已经读取完成。</p>
</li>
<li>
<p>Header的边界是CRLF，如果连续读取两个CRLF，则意味着header的信息读取完成。</p>
</li>
<li>
<p>body的长度是有Content-Length 来进行确定。如果没有Content-Length ，则是chunked协议(具体参考前面的trunked协议)。</p>
</li>
</ul>
</blockquote>
</li>
<li>
<p>HTTP 如何传输大文件呢？（分块传输，Transfer-Encoding: chunked）</p>
<ul>
<li>分块传输怎么判断什么时候传输完成呢？（最后一个包是空的）</li>
<li><a href="http://blog.lllllan.cn/cs-basic/network/def/http-big-data/" target="_blank" rel="noopener noreferrer">HTTP 传输大文件 | lllllan</a></li>
</ul>
</li>
<li>
<p>为什么 TCP 会粘包？（TCP 是字节流）</p>
<ul>
<li>怎么解决粘包？（刚才不一直在聊 HTTP 解决粘包吗。。。）</li>
<li><a href="http://blog.lllllan.cn/cs-basic/network/interview-questions/#tcp%E7%B2%98%E5%8C%85%E5%92%8C%E6%8B%86%E5%8C%85-%E2%98%85" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a>m/kex1n/p/6502002.html)</li>
</ul>
</li>
<li>
<p>Java 的 Object 有哪些方法？（记不全会提醒你，然后一个一个问）</p>
<ul>
<li><a href="http://blog.lllllan.cn/java/basic/4-object/#%E5%85%AB%E3%80%81-object-%E7%B1%BB%E7%9A%84%E5%B8%B8%E8%A7%81%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">Java - 面向对象 | lllllan</a></li>
</ul>
<ol>
<li>equals() 和 hashcode() 八股</li>
<li>哈希冲突如何解决？（开放定址，链接法，再哈希）
<ul>
<li>这些办法的优缺点？</li>
<li>负载因子是什么？怎么算？</li>
</ul>
</li>
<li>clone() 怎么用？引用拷贝深拷贝浅拷贝？</li>
</ol>
<ul>
<li><a href="https://blog.csdn.net/qq_33314107/article/details/80271963" target="_blank" rel="noopener noreferrer">java对象clone()方法_客 人的博客-CSDN博客_clone</a></li>
</ul>
<ol>
<li>wait() 和 sleep() 八股</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/java/concurrent/1/5/#_5-2-sleep%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">第五章、Java线程间的通信 | lllllan</a></li>
</ul>
</li>
<li>
<p>场景题：2T 的两个大文件，每一行存储一个字符串，内存只有 1G，找出两个文件中相同的字符串？（哈希，分治）</p>
<ul>
<li>
<p><a href="https://blog.csdn.net/tiankong_/article/details/77234726" target="_blank" rel="noopener noreferrer">算法系列-大数据面试题-两个大文件中找出共同记录_五癫的博客-CSDN博客_两个超大文件找共同出现的单词</a></p>
</li>
<li>
<p>你设计的算法，每一个字符串需要被读几次？</p>
</li>
<li>
<p>复杂度多少？还可以优化吗？</p>
</li>
</ul>
</li>
<li>
<p>算法题：最长有效括号（磨了 20 分钟才写出来，把测试通过就行了）</p>
</li>
<li>
<p>没反问......</p>
</li>
</ol>
<p>总结：**网络问得很细，Java 问得偏八股。**面试官全程面无表情，但没啥反馈。做算法题的时间有点长，可能着急结束，代码跑通了就行，甚至连代码都没细看，面试体验很一般。</p>
<hr>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-12"><label for="task-item-12"> HTTP 的 keep-alive 和 TCP 的 keepalive</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-13"><label for="task-item-13"> 多长时间</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-14"><label for="task-item-14"> HTTP 拆包</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-15"><label for="task-item-15"> HTTP 传输大文件</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-16"><label for="task-item-16"> 分块传输</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-17"><label for="task-item-17"> 怎么判断什么时候传输完成</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-18"><label for="task-item-18"> TCP 为什么会粘包</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-19"><label for="task-item-19"> 怎么解决</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-20"><label for="task-item-20"> Object的方法</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-21"><label for="task-item-21"> equals 和 hashcode</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-22"><label for="task-item-22"> 哈希冲突解决</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-23"><label for="task-item-23"> 各自的优缺点</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-24"><label for="task-item-24"> 负载因子</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-25"><label for="task-item-25"> clone 怎么用，深浅</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-26"><label for="task-item-26"> wait 和 sleep</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-27"><label for="task-item-27"> 2T 的两个大文件，每一行存储一个字符串，内存只有 1G，找出两个文件中相同的字符串</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-28"><label for="task-item-28"> 算法：最长有效括号</label></li>
</ul>
<h2 id="三面-3月18日-60分钟"> 三面（3月18日，60分钟）</h2>
<ol>
<li>自我介绍</li>
<li>epoll 怎么用？（项目相关）</li>
<li>buffer 用来干嘛？（没说两句被打断，面试官指的是项目中的，开始没理解到）</li>
<li>用过哪些 Linux 命令？</li>
<li>路由器和交换机区别？
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/def/router-and-switch/#%E8%B7%AF%E7%94%B1%E5%99%A8" target="_blank" rel="noopener noreferrer">路由器和交换机 | lllllan</a></li>
<li>链路层是干什么的？有哪些协议？</li>
<li>IP 地址和 MAC 地址的区别？</li>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#ip%E5%9C%B0%E5%9D%80%E5%92%8Cmac%E5%9C%B0%E5%9D%80" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ul>
</li>
<li>事务 ACID 知道吧，解释 C 的含义？（说了很久，面试官说基本对，下去再看看）</li>
<li>物理地址和虚拟地址区别？
<ul>
<li>怎么转换？</li>
<li>为什么要多级页表和快表？</li>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/1/#_4-3-%E5%85%B7%E6%9C%89%E5%BF%AB%E8%A1%A8%E7%9A%84%E5%9C%B0%E5%9D%80%E5%8F%98%E6%8D%A2%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener noreferrer">内存管理概念 | lllllan</a></li>
<li>缺页中断处理流程？</li>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/2/#_2-2-%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E6%9C%BA%E6%9E%84" target="_blank" rel="noopener noreferrer">虚拟内存管理 | lllllan</a></li>
<li>页表项的结构？（页地址、页偏移，各种标记位标识 CPU 特权级、读写权限、是否在内存中......）</li>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/2/#_2-1-%E9%A1%B5%E8%A1%A8%E6%9C%BA%E5%88%B6" target="_blank" rel="noopener noreferrer">虚拟内存管理 | lllllan</a></li>
<li>你提到了 CPU 特权级？怎么转换的？（中断）</li>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/1/3/#%E4%B8%89%E3%80%81%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8" target="_blank" rel="noopener noreferrer">操作系统运行环境 | lllllan</a></li>
<li>具体有哪些中断？（外部中断，异常，软中断）</li>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/1/3/#_2-2-%E4%B8%AD%E6%96%AD%E5%92%8C%E5%BC%82%E5%B8%B8%E7%9A%84%E5%88%86%E7%B1%BB" target="_blank" rel="noopener noreferrer">操作系统运行环境 | lllllan</a></li>
</ul>
</li>
<li>数据从网卡到内存的过程描述一下？
<ul>
<li>具体有几次中断？</li>
<li><a href="https://blog.csdn.net/JMW1407/article/details/108636657" target="_blank" rel="noopener noreferrer">计算机网络——数据从网卡到应用的过程_JMW1407的博客-CSDN博客_数据包从网卡到应用层的过程</a></li>
<li><a href="http://blog.lllllan.cn/cs-basic/network/how-is-the-network-connected/2/#_5-10-%E6%8E%A5%E5%8F%97%E8%BF%94%E5%9B%9E%E5%8C%85" target="_blank" rel="noopener noreferrer">第二章、用电信号传输 TCP/IP 数据 | lllllan</a></li>
</ul>
</li>
<li>CPU 4 个核有共享缓存对吧，怎么保证缓存一致性？（总线锁，MESI）
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/os/def/cpu-cache/" target="_blank" rel="noopener noreferrer">CPU 缓存 | lllllan</a></li>
</ul>
</li>
<li>平时怎么学的？</li>
<li>反问</li>
</ol>
<p>总结：可能是之前没问操作系统，<strong>终面的操作系统问得特别详细</strong>。面试官很严肃，哪怕有一点不对就会被追问，中途有一次口误他显得很不高兴。</p>
<hr>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-29"><label for="task-item-29"> epoll 怎么用</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-30"><label for="task-item-30"> buffer 干嘛</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-31"><label for="task-item-31"> linux 命令</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-32"><label for="task-item-32"> 路由器和交换机</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-33"><label for="task-item-33"> 链路层干嘛，协议</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-34"><label for="task-item-34"> IP地址和MAC地址</label></li>
</ul>
</li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-35"><label for="task-item-35"> ACID</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-36"><label for="task-item-36"> 物理地址和虚拟地址</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-37"><label for="task-item-37"> 地址转换</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-38"><label for="task-item-38"> 快表和多级页表</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-39"><label for="task-item-39"> 缺页中断处理流程</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-40"><label for="task-item-40"> 页表项结构</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-41"><label for="task-item-41"> CPU 特权指令，转换</label></li>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-42"><label for="task-item-42"> 中断分类</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-43"><label for="task-item-43"> 数据从网卡到内存的过程</label>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-44"><label for="task-item-44"> 几次中断</label></li>
</ul>
</li>
<li><input type="checkbox"  disabled="disabled" id="task-item-45"><label for="task-item-45"> CPU 共享缓存</label>
<ul>
<li><input type="checkbox" checked="checked" disabled="disabled" id="task-item-46"><label for="task-item-46"> 缓存一致性</label></li>
</ul>
</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="面经"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-14T10:25:29.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">MySQL 面试题合集</title>
    <id>https://notes.lllllan.cn/mysql/</id>
    <link href="https://notes.lllllan.cn/mysql/"/>
    <updated>2022-04-19T07:04:48.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载自一下文章，略有改动</p>
<ul>
<li><a href="https://zhuanlan.zhihu.com/p/91973413" target="_blank" rel="noopener noreferrer">SQL：多表查询</a></li>
<li><a href="https://www.jianshu.com/p/8a70a4af7eac" target="_blank" rel="noopener noreferrer">MySQL中的悲观锁</a></li>
<li><a href="https://www.jianshu.com/p/d2ac26ca6525" target="_blank" rel="noopener noreferrer">什么是乐观锁，什么是悲观锁 - 简书 (jianshu.com)</a></li>
<li><a href="https://blog.csdn.net/jerry11112/article/details/78160771" target="_blank" rel="noopener noreferrer">数据库——彻底明白超键、候选键、主键、外键</a></li>
</ul>
</div>
<h2 id="数据库【常识】"> 数据库【常识】</h2>
<h3 id="数据三范式"> 数据三范式</h3>
<ol>
<li>第一范式：属性不可再分</li>
<li>第二范式：第一范式基础上，消除了非主属性对于码的部分函数依赖</li>
<li>第三范式，第二范式基础上，消除了非主属性对于码的传递函数依赖</li>
</ol>
<h2 id="mysql-存储引擎及使用场景"> MySQL 存储引擎及使用场景</h2>
<h3 id="什么是存储引擎"> 什么是存储引擎</h3>
<p><strong>数据库引擎是数据库 <mark>底层软件组织</mark></strong></p>
<p>MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。</p>
<h3 id="mysql-各种存储引擎"> MySQL 各种存储引擎</h3>
<table>
<thead>
<tr>
<th style="text-align:center">功能</th>
<th style="text-align:center">MyISAM</th>
<th style="text-align:center">MEMORY</th>
<th style="text-align:center">InnoDB</th>
<th style="text-align:center">Archive</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">存储限制</td>
<td style="text-align:center">256TB</td>
<td style="text-align:center">RAM</td>
<td style="text-align:center">64TB</td>
<td style="text-align:center">None</td>
</tr>
<tr>
<td style="text-align:center">支持事务</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center"><mark>Yes</mark></td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">支持全文索引</td>
<td style="text-align:center"><mark>Yes</mark></td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">支持树索引</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">Yes</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">支持哈希索引</td>
<td style="text-align:center">No</td>
<td style="text-align:center"><mark>Yes</mark></td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">支持数据缓存</td>
<td style="text-align:center">No</td>
<td style="text-align:center">N/A</td>
<td style="text-align:center"><mark>Yes</mark></td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">支持外键</td>
<td style="text-align:center">No</td>
<td style="text-align:center">No</td>
<td style="text-align:center"><mark>Yes</mark></td>
<td style="text-align:center">No</td>
</tr>
<tr>
<td style="text-align:center">锁</td>
<td style="text-align:center">全表锁</td>
<td style="text-align:center">全表锁</td>
<td style="text-align:center"><mark>行级锁</mark></td>
<td style="text-align:center"></td>
</tr>
</tbody>
</table>
<h3 id="存储引擎的选择"> 存储引擎的选择</h3>
<ol>
<li>如果需要提供提交、回滚和恢复的 <mark>事务安全</mark> 能力，并要求 <mark>并发控制</mark>  → InnoDB</li>
<li>如果数据表主要用来 <mark>插入和查询</mark> 记录 → MyISAM</li>
<li>如果只是临时存放数据，<mark>数据量不大</mark>，并且<strong>不需要提高数据的安全性</strong> → MEMORY</li>
<li>如果 <mark>只有插入和查询</mark> → Archive，支持高并发的插入，但是非事务安全</li>
</ol>
<h3 id="myisam-和-innodb-的区别"> MyISAM 和 InnoDB 的区别</h3>
<p><strong>区别：</strong></p>
<ol>
<li>InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 编程的 InnoDB 的重要原因之一。</li>
<li>InnoDB 支持外键，MyISAM 不支持。</li>
<li>InnoDB 是聚集索引，MyISAM 是非聚集索引。</li>
<li>InnoDB 不保存表的具体行数，执行 <code>select count(*) from table</code> 需要全表扫描。 而 MyISAM 用一个变量保存了整个表的行数，查询行数时速度更快。</li>
<li>InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。</li>
</ol>
<p><strong>如何选择：</strong></p>
<ol>
<li>需要支持事务，InnoDB</li>
<li>主要是查询工作，MyISAM；如果读写也频繁，InnoDB</li>
<li>MyISAM 系统崩溃后恢复更困难</li>
</ol>
<h2 id="关键字"> 关键字</h2>
<h3 id="drop、delete、truncate"> drop、delete、truncate</h3>
<ul>
<li>drop 丢弃数据：<code>drop table</code>，直接删除表</li>
<li>truncate 清空数据：<code>truncate table</code>，值删除表中的数据，再插入数据时自增id又从1开始</li>
<li>delete 删除数据：<code>delete from table where ?</code>，删除某一列的数据</li>
</ul>
<div><p>执行速度</p>
<p>一般来说：drop &gt; truncate &gt; delete</p>
<ul>
<li><code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li>
<li><code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li>
<li><code>drop</code>命令会把表占用的空间全部释放掉。</li>
</ul>
</div>
<h3 id="varchar-和-char-的区别"> varchar 和 char 的区别</h3>
<ul>
<li>char 固定长度，加入申请了 <code>char(10)</code> ，那么无论实际存储多少内容，该字段都占用了10个字符</li>
<li>varchr 是变长，申请的只是最大长度，占用的控件时实际的字符长度+1</li>
</ul>
<p>从效率角度 <code>char &gt; varchar</code> ，因此使用中如果确定某字段值的长度，可以使用 char，否则应该尽量使用 varchar</p>
<h3 id="varchar-10-和-int-10"> varchar(10) 和 int(10)</h3>
<p>varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.</p>
<h2 id="查询"> 查询</h2>
<p><img src="./README.assets/v2-ab43140ca2435d62d1bf501051cc558a_720w.jpg" alt="img" loading="lazy"></p>
<h2 id="锁"> 锁</h2>
<p><a href="https://www.cnblogs.com/jojop/p/13982679.html" target="_blank" rel="noopener noreferrer">【MySQL】MySQL中的锁机制 - 周二鸭 - 博客园 (cnblogs.com)</a></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T15:49:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">字节|客户端|春招</title>
    <id>https://notes.lllllan.cn/mianjing/ww/</id>
    <link href="https://notes.lllllan.cn/mianjing/ww/"/>
    <updated>2022-04-22T13:12:37.000Z</updated>
    <content type="html"><![CDATA[<h2 id="一面"> 一面</h2>
<ol>
<li>
<p>死锁发生的条件</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/2/4/" target="_blank" rel="noopener noreferrer">死锁 | lllllan</a></li>
</ul>
</li>
<li>
<p>计算机的五层网络结构</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/osi&amp;tcp/" target="_blank" rel="noopener noreferrer">OSI 和 TCP/IP 网络分层模型详解 | lllllan</a></li>
</ul>
</li>
<li>
<p>传输层的协议</p>
<ol>
<li>TCP和UDP的区别</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#tcp%E3%80%81udp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ul>
</li>
<li>
<p>为什么是三次握手，而不是两次或者四次</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/3-handshake/#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B-%E2%AD%90" target="_blank" rel="noopener noreferrer">三次握手 | lllllan</a></li>
</ul>
</li>
<li>
<p>应用层的协议</p>
</li>
<li>
<p>HTTP的常见操作</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/diagram-http/2/#%E4%BA%94%E3%80%81%E5%91%8A%E7%9F%A5%E6%9C%8D%E5%8A%A1%E5%99%A8%E6%84%8F%E5%9B%BE%E7%9A%84-http-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">第二章、简单的HTTP协议 | lllllan</a></li>
</ul>
<ol>
<li>GET和POST的区别</li>
</ol>
</li>
<li>
<p><s>构造函数和拷贝构造函数和虚函数的区别</s></p>
</li>
<li>
<p><s>STL里面比较常见的容器</s></p>
</li>
<li>
<p><s>map和unordered_map的区别</s></p>
</li>
<li>
<p>map是怎么保证有序的</p>
</li>
<li>
<p>散列会出现什么问题</p>
<ol>
<li>哈希冲突怎么解决，除了开链法外还有什么解决方案</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/java/basic/#java%E7%A8%8B%E5%BA%8F%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84" target="_blank" rel="noopener noreferrer">常见面试题 | lllllan</a></li>
</ul>
</li>
<li>
<p><s>指针和引用的区别</s></p>
</li>
<li>
<p>Java的内存回收</p>
<ol>
<li>Java怎么判断需要回收内存（不是引用计数）</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/java/jvm/3/2/" target="_blank" rel="noopener noreferrer">对象已死 | lllllan</a></li>
</ul>
</li>
<li>
<p>你为什么要选客户端开发岗位</p>
</li>
<li>
<p>比赛中的最大挑战</p>
</li>
<li>
<p>算法题（肯定不会出比较麻烦的）</p>
<ol>
<li>最大连续子数组和最小值</li>
</ol>
<ul>
<li><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums/" target="_blank" rel="noopener noreferrer">907. 子数组的最小值之和 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
<ol start="2">
<li>最长回文子串</li>
</ol>
<ul>
<li><a href="https://leetcode-cn.com/problems/longest-palindromic-substring/" target="_blank" rel="noopener noreferrer">5. 最长回文子串 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
</li>
<li>
<p>反问</p>
</li>
</ol>
<h2 id="二面"> 二面</h2>
<ol>
<li>
<p>进程和线程的概念</p>
<ol>
<li>进程的共享资源 - 临界区</li>
<li>线程的共享资源 - 临界区 + 进程资源</li>
<li>线程的私有资源 - 栈 + 程序计数器</li>
</ol>
</li>
<li>
<p>进程之间通信的方式</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/os/def/process-communication/" target="_blank" rel="noopener noreferrer">进程间通信 | lllllan</a></li>
</ul>
</li>
<li>
<p><s>C++共享内存的机制</s></p>
</li>
<li>
<p>mmap了解嘛</p>
<ul>
<li><mark><a href="https://zhuanlan.zhihu.com/p/357820303" target="_blank" rel="noopener noreferrer">阿里二面：什么是mmap？ - 知乎 (zhihu.com)</a></mark></li>
<li><mark><a href="https://www.cnblogs.com/huxiao-tee/p/4660352.html" target="_blank" rel="noopener noreferrer">认真分析mmap：是什么 为什么 怎么用 - 胡潇 - 博客园 (cnblogs.com)</a></mark></li>
<li><mark><a href="https://blog.csdn.net/Holy_666/article/details/86532671" target="_blank" rel="noopener noreferrer">彻底理解mmap()_Holy_666的博客-CSDN博客_mmap</a></mark></li>
</ul>
</li>
<li>
<p>共享内存和管道的通信效率的比较</p>
</li>
<li>
<p>用户态和内核态的数据拷贝</p>
<ul>
<li><mark><a href="https://www.cnblogs.com/koushr/p/5873404.html" target="_blank" rel="noopener noreferrer">用户态、内核态及零拷贝 - koushr - 博客园 (cnblogs.com)</a></mark></li>
</ul>
</li>
<li>
<p>管道大小是不是可以调整，怎么调整</p>
</li>
<li>
<p>CPU调度算法</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/2/2/#%E5%9B%9B%E3%80%81%E5%85%B8%E5%9E%8B%E7%9A%84%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95" target="_blank" rel="noopener noreferrer">处理机调度 | lllllan</a></li>
</ul>
<ol>
<li>时间片轮转的缺点：平均等待时间长、上下文切换浪费时间</li>
</ol>
</li>
<li>
<p>为什么要区分内核态和用户态</p>
<ul>
<li>处于安全考虑</li>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/1/3/#%E4%B8%80%E3%80%81%E5%A4%84%E7%90%86%E5%99%A8%E8%BF%90%E8%A1%8C%E6%A8%A1%E5%BC%8F" target="_blank" rel="noopener noreferrer">操作系统运行环境 | lllllan</a></li>
</ul>
</li>
<li>
<p>虚拟内存有了解嘛</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/os/wangdao/3/2/" target="_blank" rel="noopener noreferrer">虚拟内存管理 | lllllan</a></li>
</ul>
<ol>
<li>虚拟内存的作用</li>
</ol>
</li>
<li>
<p>TCP和UDP的区别</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#tcp%E3%80%81udp%E5%8D%8F%E8%AE%AE%E7%9A%84%E5%8C%BA%E5%88%AB" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ul>
</li>
<li>
<p>TCP的拥塞控制</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/def/tcp-reliable-transmission/#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener noreferrer">TCP可靠传输 | lllllan</a></li>
</ul>
</li>
<li>
<p>应用层协议主要用到TCP、UDP的协议有哪些</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#%E4%BD%BF%E7%94%A8tcp%E3%80%81udp%E7%9A%84%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
<li>FTP协议 SMTP协议</li>
</ul>
</li>
<li>
<p>HTTP请求格式</p>
<ol>
<li>请求头包含了哪些东西</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#%E9%A6%96%E9%83%A8%E5%AD%97%E6%AE%B5" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ul>
<ol start="2">
<li>请求方法有哪些</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#%E8%AF%B7%E6%B1%82%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ul>
<ol start="3">
<li>POST和GET的区别</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/#get%E5%92%8Cpost" target="_blank" rel="noopener noreferrer">计算机网络-常见面试题 | lllllan</a></li>
</ul>
<ol start="4">
<li>HTTP返回码</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/diagram-http/4/" target="_blank" rel="noopener noreferrer">第四章、Http状态码 | lllllan</a></li>
</ul>
</li>
<li>
<p>内存泄漏和内存溢出的区别</p>
<ul>
<li>区别：内存溢出是指程序在申请内存时，没有足够的内存空间供其使用， 系统已经不能再分配出你所需要的空间；内存泄露是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但是内存泄漏次数多了就会导致内存溢出。</li>
</ul>
<ol>
<li>内存泄漏是怎么引起的</li>
</ol>
<ul>
<li><mark><a href="https://blog.csdn.net/baidu_32015283/article/details/87916080" target="_blank" rel="noopener noreferrer">什么是内存泄漏，常见引起引起内存泄漏的原因,及解决办法_Lonely池的博客-CSDN博客_内存泄漏</a></mark></li>
</ul>
<ol start="2">
<li>内存溢出是怎么引起的</li>
</ol>
<ul>
<li><a href="http://blog.lllllan.cn/java/jvm/2/1/" target="_blank" rel="noopener noreferrer">运行时数据区域 | lllllan</a></li>
</ul>
</li>
<li>
<p><s>C++中内存泄露的分类</s></p>
</li>
<li>
<p>堆栈队列的概念</p>
</li>
<li>
<p>二叉树的中序前序后序遍历的概念</p>
</li>
<li>
<p>什么是线程安全，是有什么风险</p>
</li>
<li>
<p><s>C++里是怎么保证线程安全的</s></p>
</li>
<li>
<p>线程池了解过嘛，线程池是什么概念</p>
</li>
<li>
<p><s>什么是多态，C++有什么机制来实现多态，具体有什么关键字</s></p>
</li>
<li>
<p><s>virtual关键字有用过嘛</s></p>
</li>
<li>
<p><s>C++的sizeof的计算，什么样的原理，是怎么用的</s></p>
</li>
<li>
<p><s>什么是虚函数</s></p>
</li>
<li>
<p>之前来面试过字节嘛</p>
</li>
<li>
<p><s>什么是LRU，应用场景是什么，在C++里面</s></p>
</li>
<li>
<p>SQL语句了解嘛</p>
</li>
<li>
<p>HTTPS建立的流程</p>
<ul>
<li><a href="http://blog.lllllan.cn/cs-basic/network/http-and-https/#https%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B" target="_blank" rel="noopener noreferrer">HTTP和HTTPS | lllllan</a></li>
</ul>
</li>
<li>
<p>HTTP1.1/HTTP2.0/HTTP3.0有什么改进嘛</p>
<ul>
<li><mark><a href="https://blog.csdn.net/m0_46171043/article/details/115167824" target="_blank" rel="noopener noreferrer">了解 HTTP3.0 吗？简要说一下 HTTP 的一个发展历程？_CreatorRay的博客-CSDN博客_http3.0</a></mark></li>
</ul>
</li>
<li>
<p>算法题</p>
<ol>
<li>二叉树的中序遍历非递归</li>
</ol>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal/" target="_blank" rel="noopener noreferrer">94. 二叉树的中序遍历 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
<ol start="2">
<li>二叉树最大子路径和</li>
</ol>
<ul>
<li><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum/" target="_blank" rel="noopener noreferrer">124. 二叉树中的最大路径和 - 力扣（LeetCode） (leetcode-cn.com)</a></li>
</ul>
</li>
<li>
<p>你平时是怎么学习的</p>
</li>
<li>
<p>后续的职业发展怎么考虑的</p>
</li>
<li>
<p>后面想做什么方向</p>
</li>
<li>
<p>为什么想做客户端</p>
</li>
<li>
<p>反问</p>
</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="面经"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-21T08:13:15.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">MySQL 基础架构</title>
    <id>https://notes.lllllan.cn/mysql/architecture/</id>
    <link href="https://notes.lllllan.cn/mysql/architecture/"/>
    <updated>2022-04-16T02:23:03.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://funnylog.gitee.io/mysql45/01%E8%AE%B2%E5%9F%BA%E7%A1%80%E6%9E%B6%E6%9E%84%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html" target="_blank" rel="noopener noreferrer">01讲基础架构：一条SQL查询语句是如何执行的</a></li>
</ul>
</div>
<p>大体来说，MySQL可以分为Server层和存储引擎层两部分</p>
<p>Server层包括<u>连接器、查询缓存、分析器、优化器、执行器等</u>，涵盖MySQL的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p>
<p>而存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持InnoDB、MyISAM、Memory等多个存储引擎。现在最常用的存储引擎是InnoDB，它从MySQL 5.5.5版本开始成为了默认存储引擎</p>
<p><img src="./README.assets/0d2070e8f84c4801adbfa03bda1f98d9.png" alt="img" loading="lazy"></p>
<h2 id="连接器"> 连接器</h2>
<p><mark>连接器负责跟客户端建立连接、获取权限、维持和管理连接。</mark></p>
<p>第一步，你会先连接到这个数据库上，这时候接待你的就是连接器。连接命令一般是这么写的</p>
<div><pre><code>mysql -h$ip -P$port -u$user -p
</code></pre>
<div><span>1</span><br></div></div><p>一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</p>
<p>连接完成后，如果你没有后续的动作，这个连接就处于空闲状态。</p>
<p>客户端如果太长时间没动静，连接器就会自动将它断开。这个时间是由参数 <code>wait_timeout</code> 控制的，默认值是8小时。</p>
<h2 id="查询缓存"> 查询缓存</h2>
<p>连接建立完成后，你就可以执行 select 语句了。执行逻辑就会来到第二步：查询缓存。</p>
<p>MySQL 拿到一个查询请求后，会先到查询缓存看看，之前是不是执行过这条语句。之前执行过的语句及其结果可能会以 <code>key-value</code> 对的形式，被直接缓存在内存中。key 是查询的语句，value 是查询的结果。如果你的查询能够直接在这个缓存中找到 key，那么这个 value 就会被直接返回给客户端。</p>
<p>如果语句不在查询缓存中，就会继续后面的执行阶段。执行完成后，执行结果会被存入查询缓存中。你可以看到，如果查询命中缓存，MySQL不需要执行后面的复杂操作，就可以直接返回结果，这个效率会很高。</p>
<div><p>不建议缓存</p>
<p>查询缓存的失效非常频繁，只要有对一个表的更新，这个表上所有的查询缓存都会被清空。因此很可能你费劲地把结果存起来，还没使用呢，就被一个更新全清空了。对于更新压力大的数据库来说，查询缓存的命中率会非常低。除非你的业务就是有一张静态表，很长时间才会更新一次。比如，一个系统配置表，那这张表上的查询才适合使用查询缓存。</p>
<p>你可以将参数 <code>query_cache_type</code> 设置成 <code>DEMAND</code> 来关闭查询缓存。而对于你确定要使用查询缓存的语句，可以用 SQL_CACHE 显式指定，像下面这个语句一样：</p>
<div><pre><code>mysql&gt; select SQL_CACHE * from T where ID=10；
</code></pre>
<div><span>1</span><br></div></div><p>需要注意的是，MySQL 8.0版本直接将查询缓存的整块功能删掉了，也就是说8.0开始彻底没有这个功能了</p>
</div>
<h2 id="分析器"> 分析器</h2>
<p>如果没有命中查询缓存，就要开始真正执行语句了。<strong>首先，MySQL需要知道你要做什么，因此需要对SQL语句做解析。</strong></p>
<ul>
<li><mark>分析器先会做【词法分析】</mark> 。MySQL需要识别出 SQL 语句里面的字符串分别是什么，代表什么。</li>
<li><mark>然后做【语法分析】</mark> 。根据词法分析的结果，语法分析器会根据语法规则，判断你输入的这个 SQL 语句是否满足 MySQL 语法。</li>
</ul>
<p>如果你的语句不对，就会收到 <code>You have an error in your SQL syntax</code> 的错误提醒，比如下面这个语句 select 少打了开头的字母【s】。</p>
<div><pre><code>mysql&gt; elect * from t where ID=1;

ERROR 1064 (42000): You have an error in your SQL syntax; check the manual that corresponds to your MySQL server version for the right syntax to use near &#39;elect * from t where ID=1&#39; at line 1
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>一般语法错误会提示第一个出现错误的位置，所以你要关注的是紧接【use near】的内容。</p>
<h2 id="优化器"> 优化器</h2>
<p>经过了分析器，MySQL就知道你要做什么了。在开始执行之前，还要先经过优化器的处理。</p>
<p><strong>优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。</strong> 比如你执行下面这样的语句，这个语句是执行两个表的join：</p>
<div><pre><code>mysql&gt; select * from t1 join t2 using(ID) where t1.c=10 and t2.d=20;
</code></pre>
<div><span>1</span><br></div></div><ul>
<li>既可以先从表 t1 里面取出 c = 10 的记录的ID值，再根据 ID 值关联到 t2，再判断 t2 里面 d 的值是否等于20。</li>
<li>也可以先从表 t2 里面取出 d = 20 的记录的ID值，再根据 ID 值关联到 t1，再判断 t1 里面 c 的值是否等于10。</li>
</ul>
<p>这两种执行方法的逻辑结果是一样的，但是执行的效率会有不同，而优化器的作用就是决定选择使用哪一个方案。</p>
<div><p>怎么优化的？</p>
</div>
<h2 id="执行器"> 执行器</h2>
<p><strong>要先判断一下你对这个表T有没有执行查询的权限</strong>，如果没有，就会返回没有权限的错误，如下所示（在工程实现上，如果命中查询缓存，会在查询缓存放回结果的时候，做权限验证。查询也会在优化器之前调用precheck验证权限）。</p>
<div><pre><code>mysql&gt; select * from T where ID=10;

ERROR 1142 (42000): SELECT command denied to user &#39;b&#39;@&#39;localhost&#39; for table &#39;T&#39;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>如果有权限，就打开表继续执行。打开表的时候，执行器就会根据表的引擎定义，去使用这个引擎提供的接口。</p>
<p>比如我们这个例子中的表T中，ID 字段没有索引，那么执行器的执行流程是这样的：</p>
<ol>
<li>调用 InnoDB 引擎接口取这个表的第一行，判断 ID 值是不是 10，如果不是则跳过，如果是则将这行存在结果集中；</li>
<li>调用引擎接口取【下一行】，重复相同的判断逻辑，直到取到这个表的最后一行。</li>
<li>执行器将上述遍历过程中所有满足条件的行组成的记录集作为结果集返回给客户端。</li>
</ol>
<p>至此，这个语句就执行完成了。</p>
<hr>
<p>对于有索引的表，执行的逻辑也差不多。第一次调用的是【取满足条件的第一行】这个接口，之后循环取【满足条件的下一行】这个接口，这些接口都是引擎中已经定义好的。</p>
<p>你会在数据库的慢查询日志中看到一个 <code>rows_examined</code> 的字段，表示这个语句执行过程中扫描了多少行。这个值就是在执行器每次调用引擎获取数据行的时候累加的。</p>
<p>在有些场景下，执行器调用一次，在引擎内部则扫描了多行，因此<strong>引擎扫描行数跟rows_examined并不是完全相同的。</strong></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T15:49:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">MySQL 日志系统</title>
    <id>https://notes.lllllan.cn/mysql/log-system/</id>
    <link href="https://notes.lllllan.cn/mysql/log-system/"/>
    <updated>2022-04-16T06:09:10.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://funnylog.gitee.io/mysql45/02%E8%AE%B2%E6%97%A5%E5%BF%97%E7%B3%BB%E7%BB%9F%EF%BC%9A%E4%B8%80%E6%9D%A1SQL%E6%9B%B4%E6%96%B0%E8%AF%AD%E5%8F%A5%E6%98%AF%E5%A6%82%E4%BD%95%E6%89%A7%E8%A1%8C%E7%9A%84.html" target="_blank" rel="noopener noreferrer">02讲日志系统</a></li>
<li><a href="https://www.jianshu.com/p/d13b3c98ce30" target="_blank" rel="noopener noreferrer">MySQL之Redo log - 简书 (jianshu.com)</a></li>
<li><a href="https://www.cnblogs.com/f-ck-need-u/p/9010872.html#!comments" target="_blank" rel="noopener noreferrer">详细分析MySQL事务日志(redo log和undo log) - 骏马金龙 - 博客园 (cnblogs.com)</a> ★</li>
<li><a href="https://zhuanlan.zhihu.com/p/190886874" target="_blank" rel="noopener noreferrer">必须了解的MySQL三大日志：binlog、redo log和undo log - 知乎 (zhihu.com)</a></li>
</ul>
</div>
<p>执行更新语句会涉及到两个重要的日志模块：redo log（重做日志）和 binlog（归档日志）。</p>
<h2 id="redo-log"> redo log</h2>
<div><p>redo log 是提升MySQL效率的同时保证数据持久化的物理日志</p>
</div>
<h3 id="提升效率"> 提升效率</h3>
<p>首先我们先明确一下 InnoDB 的修改数据的基本流程，当我们想要修改 DB 上某一行数据的时候，<mark>InnoDB 是把数据从磁盘读取到内存的缓冲池上进行修改</mark>。</p>
<p>这个时候数据在内存中被修改，与磁盘中相比就存在了差异，我们称这种有差异的数据为<strong>脏页</strong>。<mark>InnoDB 对脏页的处理不是每次生成脏页就将脏页刷新回磁盘，如果每一次的更新都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个的IO成本、查找成本都很高</mark>，严重影响 InnoDB 的处理性能。</p>
<p>既然脏页与磁盘中的数据存在差异，那么如果在这期间 DB 出现故障就会造成数据的丢失。为了解决这个问题，redo log 就应运而生了。每次都修改都将内容写进 redo log，事后有时间再更新到磁盘当中。</p>
<h3 id="数据持久化"> 数据持久化</h3>
<p>写内存要比写磁盘更快，所以 redo log 有一部分在内存当中。每次对数据修改只要写入 redo log 的内存部分，能够提升很多性能。但如果只是存在内存当中，发生故障的时候这个 redo log 照样也会丢失。</p>
<p>实际上，redo log 包括两部分：<mark>重做日志缓冲（redo log buffer）</mark> ，这部分日志是易失性的， <mark>重做日志文件（redo log file）</mark> ，这部分日志是持久的。</p>
<p><mark>想要保证持久化，就需要将数据/日志写到磁盘当中</mark> ，否则一出故障内存中的数据都会一起丢失。也就是说必须以损耗一定性能的代价，去保证数据的持久化。InnoDB 会采取一定的策略，将 buffer 中的日志写入到磁盘文件当中。如果某时刻出现故障，事后只要到 redo log file 中逐一将日志内容更新到数据库当中即可。</p>
<div><p>都是要写入磁盘，那还要 redo log 干嘛</p>
<p>区别就在于，数据库中的修改，你需要找到具体的位置对具体的信息进行修改。</p>
<p>如果是日志，你只要将这次修改的信息写到文件末即可。</p>
</div>
<h3 id="log-file"> log file</h3>
<p><a href="https://www.cnblogs.com/f-ck-need-u/p/9010872.html#auto_id_2" target="_blank" rel="noopener noreferrer">详细分析MySQL事务日志(redo log和undo log) - 骏马金龙 - 博客园 (cnblogs.com)</a></p>
<p>在概念上，innodb 通过 <strong>force log at commit</strong> 机制实现事务的持久性，即在事务提交的时候，必须先将该事务的所有事务日志写入到磁盘上的 redo log file 和 undo log file 中进行持久化。</p>
<p>为了确保每次日志都能写入到事务日志文件中，在每次将 log buffer 中的日志写入日志文件的过程中都会调用一次操作系统的 fsync 操作（即fsync()系统调用）。因为 MariaDB/MySQL 是工作在用户空间的，而 log buffer 处于用户空间的内存中。要写入到磁盘上的 log file 中，中间还要经过操作系统内核空间的 os buffer，调用 fsync() 的作用就是将 OS buffer 中的日志刷到磁盘上的 log file 中。</p>
<p><img src="./README.assets/733013-20180508101949424-938931340.png" alt="img" loading="lazy"></p>
<div><p>log file</p>
<p>在此处需要注意一点，一般所说的 log file 并不是磁盘上的物理日志文件，而是 <mark>操作系统缓存中的 log file</mark>，官方手册上的意思也是如此（例如：With a value of 2, the contents of the <strong>InnoDB log buffer are written to the log file</strong> after each transaction commit and <strong>the log file is flushed to disk approximately once per second</strong>）。但说实话，这不太好理解，既然都称为 file 了，应该已经属于物理文件了。所以在本文后续内容中都以 os buffer 或者 file system buffer 来表示官方手册中所说的 Log file，然后 log file 则表示磁盘上的物理日志文件，即log file on disk。</p>
</div>
<h3 id="刷盘策略"> 刷盘策略</h3>
<p>MySQL支持用户自定义在 commit 时如何将 log buffer 中的日志刷 log file 中。</p>
<p>这种控制通过变量 <code>innodb_flush_log_at_trx_commit</code> 的值来决定。该变量有3种值：0、1、2，默认为1。但注意，这个变量只是控制 commit 动作是否刷新 log buffer 到磁盘。</p>
<ul>
<li>当设置为 1 的时候，<mark>事务每次提交都会将 log buffer 中的日志写入 os buffer 并调用 fsync() 刷到磁盘的 log file 中</mark>。这种方式即使系统崩溃也不会丢失任何数据，但是因为每次提交都写入磁盘，IO 的性能较差。</li>
<li>当设置为 0 的时候，事务提交时不会将 log buffer 中日志写入到 os buffer，而是 <mark>每秒写入 os buffer 并调用 fsync() 写入到磁盘的 log file 中</mark> 。也就是说设置为0时是(大约)每秒刷新写入到磁盘中的，当系统崩溃，会丢失1秒钟的数据。</li>
<li>当设置为 2 的时候，<mark>每次提交都仅写入到 os buffer，然后是每秒调用 fsync() 将 os buffer 中的日志写入到磁盘的 log file 中</mark>。</li>
</ul>
<p><img src="./README.assets/733013-20180508104623183-690986409.png" alt="img" loading="lazy"></p>
<div><p>其实值为2和0的时候，它们的差距并不太大，但2却比0要安全的多。</p>
</div>
<div><p>问自己</p>
<ol>
<li>redo log 中记录什么，修改是以什么形式记录下来的</li>
<li>checkpoint</li>
<li>log sequence number</li>
</ol>
<p>有点复杂，暂时不深究</p>
</div>
<h2 id="binlog"> binlog</h2>
<p>redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。</p>
<p>因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。</p>
<blockquote>
<p>InnoDB就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为<strong>crash-safe</strong></p>
</blockquote>
<div><p>Tips</p>
<ol>
<li>redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。</li>
<li>redo log 是物理日志，记录的是【在某个数据页上做了什么修改】；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如【给 ID = 2 这一行的 c 字段加 1】。</li>
<li>redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。【追加写】是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>
</ol>
</div>
<h2 id="redo-log-和-binlog-的重要性"> redo log 和 binlog 的重要性</h2>
<h3 id="redo-log-实现崩溃恢复"> redo log 实现崩溃恢复</h3>
<p><mark>binlog 不能做崩溃恢复，redo log能，所以 InnoDB 必须要有 redo log。</mark></p>
<p>redo log 中记录的是【做了什么改动但还没更新到数据库磁盘的内容】，InnoDB 在空闲的时候会将 redo log 的内容去更新到数据库磁盘，然后在 redo log 中抹去这一记录。</p>
<p>binlog 记录sql语句或内容，但是没有标志哪些操作已经写入数据库磁盘、哪些没有写入数据库磁盘，所以不能做崩溃恢复。</p>
<blockquote>
<p>binlog 有两种模式，statement 格式的话是记sql语句，row 格式会记录行的内容，记两条，更新前和更新后都有</p>
</blockquote>
<div><p>Note</p>
<p>找到之前某一时刻的数据库备份，然后读取binlog恢复数据库不也能做到恢复吗？</p>
<p>虽然效率来看，会差很多很多，但也不能说是不能做崩溃恢复吧？</p>
</div>
<h3 id="binlog-做归档"> binlog 做归档</h3>
<p><mark>binlog 能够将数据库恢复到任意时刻的状态（只有有记录），而 redo log 不能，所以必须要有 binlog。</mark></p>
<p>因为 binlog 是追加写的，文件写满了就新建文件，所以你只要一直保留文件和某一时刻的数据库备份，你就能恢复从备份时刻起到当前过程中任意时刻的数据库状态。</p>
<p>redo log 是循环写的，会覆盖掉/抹除已经写入数据库磁盘的内容，因此不能持久保存，也就不具备归档的功能。</p>
<h2 id="两阶段提交"> 两阶段提交</h2>
<p>既然 redo log 和 binlog 都要保留，就涉及到了两者一致性的问题。</p>
<p>有点模糊不清，虽然确定了 <mark>binlog只有在事务提交以后才会记录</mark>，但是关于 redo log 是在什么具体时间去记录什么，查不到太好的内容，于是就不太能理清两阶段提交。保留以后再查。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T15:49:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">索引</title>
    <id>https://notes.lllllan.cn/mysql/index/</id>
    <link href="https://notes.lllllan.cn/mysql/index/"/>
    <updated>2022-04-19T07:04:48.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://funnylog.gitee.io/mysql45/iframe/" target="_blank" rel="noopener noreferrer">MySQL实战45讲 (gitee.io)</a></li>
</ul>
</div>
<p>索引的出现其实就是为了提高数据查询的效率，就像书的目录一样。一本500页的书，如果你想快速找到其中的某一个知识点，在不借助目录的情况下，那我估计你可得找一会儿。同样，对于数据库的表而言，索引其实就是它的“目录”。</p>
<h2 id="一、索引的常见模型"> 一、索引的常见模型</h2>
<p>索引的常见模型有：哈希表、有序数组、搜索树。</p>
<h3 id="_1-1-哈希表"> 1.1 哈希表</h3>
<p>哈希表是一种以键-值（key-value）存储数据的结构，我们只要输入待查找的值即key，就可以找到其对应的值即Value。哈希的思路很简单，把值放在数组里，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置。</p>
<p>不可避免地，多个key值经过哈希函数的换算，会出现同一个值的情况。处理这种情况的一种方法是，拉出一个链表。</p>
<p>假设，你现在维护着一个身份证信息和姓名的表，需要根据身份证号查找对应的名字，这时对应的哈希索引的示意图如下所示：</p>
<p><img src="./README.assets/0c62b601afda86fe5d0fe57346ace957.png" alt="img" loading="lazy"></p>
<p>图中，User2和User4根据身份证号算出来的值都是N，但没关系，后面还跟了一个链表。假设，这时候你要查ID_card_n2对应的名字是什么，处理步骤就是：首先，将ID_card_n2通过哈希函数算出N；然后，按顺序遍历，找到User2。</p>
<p>需要注意的是，图中四个ID_card_n的值并不是递增的，这样做的好处是增加新的User时速度会很快，只需要往后追加。但缺点是，因为不是有序的，所以哈希索引做区间查询的速度是很慢的。</p>
<p>你可以设想下，如果你现在要找身份证号在[ID_card_X, ID_card_Y]这个区间的所有用户，就必须全部扫描一遍了。</p>
<p>所以，<strong>哈希表这种结构适用于只有等值查询的场景</strong>，比如Memcached及其他一些NoSQL引擎。</p>
<h3 id="_1-2-有序数组"> 1.2 有序数组</h3>
<p><strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>。还是上面这个根据身份证号查名字的例子，如果我们使用有序数组来实现的话，示意图如下所示：</p>
<p><img src="./README.assets/bfc907a92f99cadf5493cf0afac9ca49.png" alt="img" loading="lazy"></p>
<p>这里我们假设身份证号没有重复，这个数组就是按照身份证号递增的顺序保存的。这时候如果你要查ID_card_n2对应的名字，用二分法就可以快速得到，这个时间复杂度是O(log(N))。</p>
<p>同时很显然，这个索引结构支持范围查询。你要查身份证号在[ID_card_X, ID_card_Y]区间的User，可以先用二分法找到ID_card_X（如果不存在ID_card_X，就找到大于ID_card_X的第一个User），然后向右遍历，直到查到第一个大于ID_card_Y的身份证号，退出循环。</p>
<p>如果仅仅看查询效率，有序数组就是最好的数据结构了。但是，在需要更新数据的时候就麻烦了，你往中间插入一个记录就必须得挪动后面所有的记录，成本太高。</p>
<p>所以，<strong>有序数组索引只适用于静态存储引擎</strong>，比如你要保存的是2017年某个城市的所有人口信息，这类不会再修改的数据。</p>
<h3 id="_1-3-搜索树"> 1.3 搜索树</h3>
<p>二叉搜索树的特点是：每个节点的左儿子小于父节点，父节点又小于右儿子。这样如果你要查ID_card_n2的话，按照图中的搜索顺序就是按照UserA -&gt; UserC -&gt; UserF -&gt; User2这个路径得到。这个时间复杂度是O(log(N))。</p>
<p>当然为了维持O(log(N))的查询复杂度，你就需要保持这棵树是平衡二叉树。为了做这个保证，更新的时间复杂度也是O(log(N))。</p>
<p><img src="./README.assets/04fb9d24065635a6a637c25ba9ddde68.png" alt="img" loading="lazy"></p>
<p>树可以有二叉，也可以有多叉。多叉树就是每个节点有多个儿子，儿子之间的大小保证从左到右递增。二叉树是搜索效率最高的，但是实际上大多数的数据库存储却并不使用二叉树。其原因是，索引不止存在内存中，还要写到磁盘上。</p>
<p>你可以想象一下一棵100万节点的平衡二叉树，树高20。一次查询可能需要访问20个数据块。在机械硬盘时代，从磁盘随机读一个数据块需要10 ms左右的寻址时间。也就是说，对于一个100万行的表，如果使用二叉树来存储，单独访问一个行可能需要20个10 ms的时间，这个查询可真够慢的。</p>
<p>为了让一个查询尽量少地读磁盘，就必须让查询过程访问尽量少的数据块。那么，我们就不应该使用二叉树，而是要使用“N叉”树。这里，“N叉”树中的“N”取决于数据块的大小。</p>
<p>以InnoDB的一个整数字段索引为例，这个N差不多是1200。这棵树高是4的时候，就可以存1200的3次方个值，这已经17亿了。考虑到树根的数据块总是在内存中的，一个10亿行的表上一个整数字段的索引，查找一个值最多只需要访问3次磁盘。其实，树的第二层也有很大概率在内存中，那么访问磁盘的平均次数就更少了。</p>
<p>N叉树由于在读写上的性能优点，以及适配磁盘的访问模式，已经被广泛应用在数据库引擎中了。</p>
<p>不管是哈希还是有序数组，或者N叉树，它们都是不断迭代、不断优化的产物或者解决方案。数据库技术发展到今天，跳表、LSM树等数据结构也被用于引擎设计中，这里我就不再一一展开了。</p>
<h2 id="二、innodb的索引模型"> 二、InnoDB的索引模型</h2>
<p>在InnoDB中，表都是根据主键顺序以索引的形式存放的，这种存储方式的表称为索引组织表。InnoDB使用了B+树索引模型，所以数据都是存储在B+树中的。</p>
<h3 id="_2-1-b-树"> 2.1 B+树</h3>
<p>每一个索引在InnoDB里面对应一棵B+树。</p>
<p>假设，我们有一个主键列为ID的表，表中有字段k，并且在k上有索引。</p>
<p>这个表的建表语句是：</p>
<div><pre><code>create table T(
    id int primary key, 
    k int not null, 
    name varchar(16),
    index (k)
)engine=InnoDB;
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>表中R1~R5的(ID,k)值分别为(100,1)、(200,2)、(300,3)、(500,5)和(600,6)，两棵树的示例示意图如下。</p>
<p><img src="./README.assets/dcda101051f28502bd5c4402b292e38d.png" alt="img" loading="lazy"></p>
<p>从图中不难看出，根据叶子节点的内容，索引类型分为主键索引和非主键索引。</p>
<p>主键索引的叶子节点存的是整行数据。在InnoDB里，主键索引也被称为 <mark>聚簇索引</mark>（clustered index）。</p>
<p>非主键索引的叶子节点内容是主键的值。在InnoDB里，非主键索引也被称为 <mark>二级索引</mark>（secondary index）。</p>
<div><p>基于主键索引和普通索引的查询有什么区别？</p>
<ul>
<li>如果语句是 <code>select * from T where ID = 500</code>，即主键查询方式，则只需要搜索ID这棵B+树；</li>
<li>如果语句是 <code>select * from T where k = 5</code>，即普通索引查询方式，则需要先搜索k索引树，得到ID的值为500，再到ID索引树搜索一次。这个过程称为回表。</li>
</ul>
<p>也就是说，基于非主键索引的查询需要多扫描一棵索引树。因此，我们在应用中应该尽量使用主键查询。</p>
</div>
<h3 id="_2-2-索引维护"> 2.2 索引维护</h3>
<p>B+树为了维护索引有序性，在插入新值的时候需要做必要的维护。以上面这个图为例，如果插入新的行ID值为700，则只需要在R5的记录后面插入一个新记录。如果新插入的ID值为400，就相对麻烦了，需要逻辑上挪动后面的数据，空出位置。</p>
<p>而更糟的情况是，如果R5所在的数据页已经满了，根据B+树的算法，这时候需要申请一个新的数据页，然后挪动部分数据过去。这个过程称为 <mark>页分裂</mark> 。在这种情况下，性能自然会受影响。</p>
<p>除了性能外，页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%。</p>
<p>当然有分裂就有合并。当相邻两个页由于删除了数据，利用率很低之后，会将数据页做合并。合并的过程，可以认为是分裂过程的逆过程。</p>
<h3 id="_2-3-主键的选择"> 2.3 主键的选择</h3>
<p>基于上面的索引维护过程说明，我们来讨论一个案例：</p>
<blockquote>
<p>你可能在一些建表规范里面见到过类似的描述，要求建表语句里一定要有自增主键。当然事无绝对，我们来分析一下哪些场景下应该使用自增主键，而哪些场景下不应该。</p>
</blockquote>
<p><strong>适合用自增主键的场景：</strong></p>
<p>自增主键是指自增列上定义的主键，在建表语句中一般是这么定义的： <code>NOT NULL PRIMARY KEY AUTO_INCREMENT</code>。</p>
<p>插入新记录的时候可以不指定ID的值，系统会获取当前ID最大值加1作为下一条记录的ID值。</p>
<p>也就是说，自增主键的插入数据模式，正符合了我们前面提到的递增插入的场景。每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂。</p>
<p>而有业务逻辑的字段做主键，则往往不容易保证有序插入，这样写数据成本相对较高。</p>
<p>除了考虑性能外，我们还可以从存储空间的角度来看。假设你的表中确实有一个唯一字段，比如字符串类型的身份证号，那应该用身份证号做主键，还是用自增字段做主键呢？</p>
<p>由于每个非主键索引的叶子节点上都是主键的值。如果用身份证号做主键，那么每个二级索引的叶子节点占用约20个字节，而如果用整型做主键，则只要4个字节，如果是长整型（bigint）则是8个字节。</p>
<p><strong>显然，主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间也就越小。</strong></p>
<hr>
<p><strong>适合业务字段做主键的场景：</strong></p>
<ol>
<li>只有一个索引；</li>
<li>该索引必须是唯一索引。</li>
</ol>
<p>你一定看出来了，这就是典型的KV场景。</p>
<p>由于没有其他索引，所以也就不用考虑其他索引的叶子节点大小的问题。</p>
<p>这时候我们就要优先考虑上一段提到的【尽量使用主键查询】原则，直接将这个索引设置为主键，可以避免每次查询需要搜索两棵树。</p>
<h3 id="_2-4-回表"> 2.4 回表</h3>
<p>在下面这个表T中，如果我执行 <code>select * from T where k between 3 and 5</code>，需要执行几次树的搜索操作，会扫描多少行？</p>
<p>下面是这个表的初始化语句。</p>
<div><pre><code>create table T (
    ID int primary key,
    k int NOT NULL DEFAULT 0, 
    s varchar(16) NOT NULL DEFAULT &#39;&#39;,
    index k(k)
)engine=InnoDB;

insert into T values(100,1, &#39;aa&#39;),(200,2,&#39;bb&#39;),(300,3,&#39;cc&#39;),(500,5,&#39;ee&#39;),(600,6,&#39;ff&#39;),(700,7,&#39;gg&#39;);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><img src="./README.assets/dcda101051f28502bd5c4402b292e38d-16483930746385.png" alt="img" loading="lazy"></p>
<p>现在，我们一起来看看这条SQL查询语句的执行流程：</p>
<ol>
<li>在k索引树上找到k=3的记录，取得 ID = 300；</li>
<li>再到ID索引树查到ID=300对应的R3；</li>
<li>在k索引树取下一个值k=5，取得ID=500；</li>
<li>再回到ID索引树查到ID=500对应的R4；</li>
<li>在k索引树取下一个值k=6，不满足条件，循环结束。</li>
</ol>
<p>在这个过程中，<strong>回到主键索引树搜索的过程，我们称为回表</strong>。可以看到，这个查询过程读了k索引树的3条记录（步骤1、3和5），回表了两次（步骤2和4）。</p>
<p>在这个例子中，由于查询结果所需要的数据只在主键索引上有，所以不得不回表。那么，有没有可能经过索引优化，避免回表过程呢？</p>
<h3 id="_2-5-覆盖索引"> 2.5 覆盖索引</h3>
<p>如果执行的语句是 <code>select ID from T where k between 3 and 5</code>，这时只需要查ID的值，而ID的值已经在k索引树上了，因此可以直接提供查询结果，不需要回表。也就是说，在这个查询里面，索引k已经【覆盖了】我们的查询需求，我们称为覆盖索引。</p>
<p><strong>由于覆盖索引可以减少树的搜索次数，显著提升查询性能，所以使用覆盖索引是一个常用的性能优化手段。</strong></p>
<p>需要注意的是，在引擎内部使用覆盖索引在索引k上其实读了三个记录，R3~R5（对应的索引k上的记录项），但是对于MySQL的Server层来说，它就是找引擎拿到了两条记录，因此MySQL认为扫描行数是2。</p>
<h3 id="_2-6-联合索引"> 2.6 联合索引</h3>
<p>基于上面覆盖索引的说明，我们来讨论一个问题：<strong>在一个市民信息表上，是否有必要将身份证号和名字建立联合索引？</strong></p>
<p>假设这个市民表的定义是这样的：</p>
<div><pre><code>CREATE TABLE `tuser` (
    `id` int(11) NOT NULL,
    `id_card` varchar(32) DEFAULT NULL,
    `name` varchar(32) DEFAULT NULL,
    `age` int(11) DEFAULT NULL,
    `ismale` tinyint(1) DEFAULT NULL,
    PRIMARY KEY (`id`),
    KEY `id_card` (`id_card`),
    KEY `name_age` (`name`,`age`)
) ENGINE=InnoDB
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br></div></div><p>我们知道，身份证号是市民的唯一标识。也就是说，如果有根据身份证号查询市民信息的需求，我们只要在身份证号字段上建立索引就够了。而再建立一个（身份证号、姓名）的联合索引，是不是浪费空间？</p>
<p>如果现在有一个高频请求，要根据市民的身份证号查询他的姓名，这个联合索引就有意义了。它可以在这个高频请求上用到覆盖索引，不再需要回表查整行记录，减少语句的执行时间。</p>
<p>当然，索引字段的维护总是有代价的。因此，在建立冗余索引来支持覆盖索引时就需要权衡考虑了。这正是业务DBA，或者称为业务数据架构师的工作。</p>
<h3 id="_2-7-最左前缀原则"> 2.7 最左前缀原则</h3>
<p>看到这里你一定有一个疑问，如果为每一种查询都设计一个索引，索引是不是太多了。如果我现在要按照市民的身份证号去查他的家庭地址呢？虽然这个查询需求在业务中出现的概率不高，但总不能让它走全表扫描吧？反过来说，单独为一个不频繁的请求创建一个（身份证号，地址）的索引又感觉有点浪费。应该怎么做呢？</p>
<p>这里，我先和你说结论吧。<strong>B+树这种索引结构，可以利用索引的“最左前缀”，来定位记录。</strong></p>
<p>为了直观地说明这个概念，我们用（name，age）这个联合索引来分析。</p>
<p><img src="./README.assets/89f74c631110cfbc83298ef27dcd6370.jpg" alt="img" loading="lazy"></p>
<p>可以看到，索引项是按照索引定义里面出现的字段顺序排序的。</p>
<p>当你的逻辑需求是查到所有名字是“张三”的人时，可以快速定位到ID4，然后向后遍历得到所有需要的结果。</p>
<p>如果你要查的是所有名字第一个字是“张”的人，你的SQL语句的条件是 <code>where name like ‘张%’</code>。这时，你也能够用上这个索引，查找到第一个符合条件的记录是ID3，然后向后遍历，直到不满足条件为止。</p>
<p>可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。这个最左前缀可以是联合索引的最左N个字段，也可以是字符串索引的最左M个字符。</p>
<p>基于上面对最左前缀索引的说明，我们来讨论一个问题：<strong>在建立联合索引的时候，如何安排索引内的字段顺序。</strong></p>
<p>这里我们的评估标准是，索引的复用能力。因为可以支持最左前缀，所以当已经有了(a,b)这个联合索引后，一般就不需要单独在a上建立索引了。因此，<strong>第一原则是，如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。</strong></p>
<p>所以现在你知道了，这段开头的问题里，我们要为高频请求创建(身份证号，姓名）这个联合索引，并用这个索引支持“根据身份证号查询地址”的需求。</p>
<p>那么，如果既有联合查询，又有基于a、b各自的查询呢？查询条件里面只有b的语句，是无法使用(a,b)这个联合索引的，这时候你不得不维护另外一个索引，也就是说你需要同时维护(a,b)、(b) 这两个索引。</p>
<p>这时候，我们要<strong>考虑的原则就是空间</strong>了。比如上面这个市民表的情况，name字段是比age字段大的 ，那我就建议你创建一个（name,age)的联合索引和一个(age)的单字段索引。</p>
<h3 id="_2-8-索引下推"> 2.8 索引下推</h3>
<p>上一段我们说到满足最左前缀原则的时候，最左前缀可以用于在索引中定位记录。这时，你可能要问，那些不符合最左前缀的部分，会怎么样呢？</p>
<p>我们还是以市民表的联合索引（name, age）为例。如果现在有一个需求：检索出表中“名字第一个字是张，而且年龄是10岁的所有男孩”。那么，SQL语句是这么写的：</p>
<div><pre><code>mysql&gt; select * from tuser where name like &#39;张%&#39; and age = 10 and ismale = 1;
</code></pre>
<div><span>1</span><br></div></div><p>你已经知道了前缀索引规则，所以这个语句在搜索索引树的时候，只能用 “张”，找到第一个满足条件的记录ID3。当然，这还不错，总比全表扫描要好。</p>
<p>然后呢？</p>
<p>当然是判断其他条件是否满足。</p>
<p>在MySQL 5.6之前，只能从ID3开始一个个回表。到主键索引上找出数据行，再对比字段值。</p>
<p>而MySQL 5.6 引入的索引下推优化（index condition pushdown)， 可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</p>
<p>图3和图4，是这两个过程的执行流程图。</p>
<p>图3：无索引下推执行流程</p>
<p><img src="./README.assets/b32aa8b1f75611e0759e52f5915539ac.jpg" alt="img" loading="lazy"></p>
<p>图4：索引下推执行流程</p>
<p><img src="./README.assets/76e385f3df5a694cc4238c7b65acfe1b.jpg" alt="img" loading="lazy"></p>
<p>在图3和4这两个图里面，每一个虚线箭头表示回表一次。</p>
<p>图3中，在(name,age)索引里面我特意去掉了age的值，这个过程InnoDB并不会去看age的值，只是按顺序把“name第一个字是’张’”的记录一条条取出来回表。因此，需要回表4次。</p>
<p>图4跟图3的区别是，InnoDB在(name,age)索引内部就判断了age是否等于10，对于不等于10的记录，直接判断并跳过。在我们的这个例子中，只需要对ID4、ID5这两条记录回表取数据判断，就只需要回表2次。</p>
<h2 id="三、索引类型"> 三、索引类型</h2>
<p><a href="https://zhuanlan.zhihu.com/p/66553466" target="_blank" rel="noopener noreferrer">通俗易懂 索引、单列索引、复合索引、主键、唯一索引、聚簇索引、非聚簇索引、唯一聚簇索引 的区别与联系 - 知乎 (zhihu.com)</a></p>
<h2 id="索引命中"> 索引命中</h2>
<p><a href="https://blog.csdn.net/ba_qi/article/details/88799093" target="_blank" rel="noopener noreferrer">如何监测MySQL是否命中索引？_空心人(・。・)的博客-CSDN博客_mysql怎么查看索引是否命中</a></p>
<h2 id="索引失效"> 索引失效</h2>
<p><a href="https://blog.csdn.net/sy_white/article/details/122112440" target="_blank" rel="noopener noreferrer">索引失效的情况及解决(超详细)_zyy_demon的博客-CSDN博客_索引失效的几种情况和解决</a></p>
<ol>
<li>or 条件中含有非索引</li>
<li>左模糊查询</li>
<li>索引参与计算</li>
<li>违背最左匹配原则</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T15:49:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">next-key 锁</title>
    <id>https://notes.lllllan.cn/mysql/next-key-lock/</id>
    <link href="https://notes.lllllan.cn/mysql/next-key-lock/"/>
    <updated>2022-04-16T01:31:02.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://funnylog.gitee.io/mysql45/iframe/" target="_blank" rel="noopener noreferrer">MySQL实战45讲 (gitee.io)</a></li>
<li><a href="https://www.cnblogs.com/wudanyang/p/10655180.html#%E4%B8%89mysql-%E6%98%AF%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E5%B9%BB%E8%AF%BB%E7%9A%84" target="_blank" rel="noopener noreferrer">MySQL 是如何解决幻读的 - 吴丹阳-cn</a></li>
<li><a href="https://www.jianshu.com/p/32904ee07e56" target="_blank" rel="noopener noreferrer">MYSQL（04）-间隙锁详解</a></li>
</ul>
</div>
<h2 id="next-key-锁"> next-key 锁</h2>
<p>next-key 锁包含两部分：</p>
<ul>
<li>行锁（锁住记录）</li>
<li>间隙锁（锁住记录之间的间隙）</li>
</ul>
<p>假设有如下的表和数据。</p>
<div><pre><code>CREATE TABLE `t` (
  `id` int(11) NOT NULL,
  `c` int(11) DEFAULT NULL,
  `d` int(11) DEFAULT NULL,
  PRIMARY KEY (`id`),
  KEY `c` (`c`)
) ENGINE=InnoDB;

insert into t values(0,0,0), (5,5,5), (10,10,10), (15,15,15), (20,20,20), (25,25,25);
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p>为了解决幻读的问题，InnoDB引入了间隙锁，就是锁住两个值之间的间隙：</p>
<p><img src="./README.assets/e7f7ca0d3dab2f48c588d714ee3ac861.png" alt="img" loading="lazy"></p>
<p>这样，当你执行 <code>select * from t where d = 5 for update</code> 的时候，就不止是给数据库中已有的6个记录加上了行锁，还同时加了7个间隙锁。这样就确保了无法再插入新的记录，从而解决了幻读。</p>
<p>间隙锁和行锁合称【next-key lock】，每个 next-key lock 是 <strong>前开后闭区间</strong> 。也就是说，我们的表t初始化以后，如果用 <code>select * from t for update</code> 要把整个表所有记录锁起来，就形成了7个next-key lock，分别是 (-∞,0]、(0,5]、(5,10]、(10,15]、(15,20]、(20, 25]、(25, +suprenum]。</p>
<blockquote>
<p>InnoDB给每个索引加了一个不存在的最大值suprenum，这样才符合我们前面说的“都是前开后闭区间”</p>
</blockquote>
<div><p>锁冲突</p>
<p>现在你知道了，数据行是可以加上锁的实体，数据行之间的间隙，也是可以加上锁的实体。但是间隙锁跟我们之前碰到过的锁都不太一样。</p>
<p>比如行锁，分成读锁和写锁。下图就是这两种类型行锁的冲突关系。</p>
<p><img src="./README.assets/c435c765556c0f3735a6eda0779ff151.png" alt="img" loading="lazy"></p>
<hr>
<p>但是间隙锁不一样，**跟间隙锁存在冲突关系的，是“往这个间隙中插入一个记录”这个操作。**间隙锁之间都不存在冲突关系。</p>
<p><img src="./README.assets/7c37732d936650f1cda7dbf27daf7498.png" alt="img" loading="lazy"></p>
<p>这里session B并不会被堵住。因为表t里并没有c=7这个记录，因此session A加的是间隙锁(5,10)。而session B也是在这个间隙加的间隙锁。它们有共同的目标，即：保护这个间隙，不允许插入值。但，它们之间是不冲突的。</p>
</div>
<h2 id="间隙锁加锁机制"> 间隙锁加锁机制</h2>
<p>看了几篇博客，甚至不能统一，看不太懂，不知道哪个准确，就先放着</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-04-16T01:31:02.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">MVCC</title>
    <id>https://notes.lllllan.cn/mysql/mvcc/</id>
    <link href="https://notes.lllllan.cn/mysql/mvcc/"/>
    <updated>2022-04-15T15:25:34.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://blog.csdn.net/flying_hengfei/article/details/106965517" target="_blank" rel="noopener noreferrer">MVCC到底是什么？</a></li>
<li><a href="https://juejin.cn/post/7016165148020703246#heading-15" target="_blank" rel="noopener noreferrer">看一遍就理解：MVCC原理详解</a></li>
<li><a href="https://www.php.cn/mysql-tutorials-460111.html" target="_blank" rel="noopener noreferrer">全网最全的一篇数据库MVCC详解</a></li>
</ul>
</div>
<h2 id="mvcc"> MVCC</h2>
<p>【Multi-Version Concurrency Control】多版本并发控制，MVCC 是一种并发控制的方法，一般在数据库管理系统中，实现对数据库的并发访问；在编程语言中实现事务内存。</p>
<blockquote>
<p>通俗地讲，数据库中每条数据拥有多个版本，在某个事务要对数据进行操作时，取出该数据合适的版本，在整个事务的执行过程中，就依赖这个版本进行查询。</p>
<p>这种情况下的查询，查询得到的数据不一定是最新的，可能是历史版本</p>
</blockquote>
<div><p>MVCC 的作用</p>
<ol>
<li>MVCC 在 MySQL InnoDB 中的实现主要是为了提高数据库并发性能，用更好的方式去处理【读-写冲突】，做到即使可能有读-写冲突时，也能做到不加锁，非阻塞并发读</li>
<li>MVCC 在尽量较少使用锁的情况下高效避免并发操作下可能导致的一些问题 <a href="./../transaction/#事务并发的问题">脏读、不可重复读、幻读</a></li>
</ol>
</div>
<h3 id="读已提交"> 读已提交</h3>
<p>【读已提交】隔离级别下，每条 select 生成一个快照，未提交的事务数据不会出现在快照当中。因此可以解决【脏读】，但不能解决【不可重复读】和【幻读】</p>
<h3 id="可重复读"> 可重复读</h3>
<p>【可重复读】隔离级别下，一个事务只会生成一次快照，同一事务下都是读取同一快照。因此进一步解决了【不可重复读】，并且在快照读的场景下还能避免【幻读】（当前读的场景下需要借助 next-key 锁）；</p>
<h2 id="实现基础"> 实现基础</h2>
<h3 id="隐藏列"> 隐藏列</h3>
<p>对于 InnoDB 存储引擎，会有三个隐藏的列</p>
<table>
<thead>
<tr>
<th style="text-align:center">列名</th>
<th style="text-align:center">是否必须</th>
<th style="text-align:center">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">row_id</td>
<td style="text-align:center">否</td>
<td style="text-align:center">行ID，唯一标识一条记录（如果定义主键，它就没有啦）</td>
</tr>
<tr>
<td style="text-align:center">transaction_id</td>
<td style="text-align:center">是</td>
<td style="text-align:center">记录操作该数据的事务ID</td>
</tr>
<tr>
<td style="text-align:center">roll_pointer</td>
<td style="text-align:center">是</td>
<td style="text-align:center">DB_ROLL_PTR是一个回滚指针，用于配合undo日志，指向上一个旧版本</td>
</tr>
</tbody>
</table>
<h3 id="undo-log"> undo log</h3>
<p>undo log，回滚日志。用于记录数据被修改前的信息。在表记录修改之前，会先把数据拷贝到undo log里，如果事务回滚，即可以通过undo log来还原数据。</p>
<hr>
<p><strong>insert undo log</strong></p>
<p>代表事务在 insert 新记录时产生的 undo log，只在事务回滚时需要，并且在事务提交后可以被立即丢弃。</p>
<hr>
<p><strong>update undo log</strong></p>
<p>事务在进行 update 或 delete 时产生的 undo log，不仅在事务回滚时需要，在快照读时也需要。</p>
<p>不能随便删除，只有在快照读或事务回滚不涉及该日志时，对应的日志才会被 purge 线程统一清楚。</p>
<h3 id="版本链"> 版本链</h3>
<p>假设初始添加一条数据：</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWluZ19oZW5nZmVp,size_16,color_FFFFFF,t_70.png" alt="掘金小册淘到的" loading="lazy"></p>
<p>有两个事务同时进行更新信息，事务执行流程：</p>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWluZ19oZW5nZmVp,size_16,color_FFFFFF,t_70-16481287527892.png" alt="掘金小册淘到的" loading="lazy"></p>
<blockquote>
<p>如果两个事务同时修改了这条数据，就会造成丢失修改。因此在 trx 100 进行修改的时候，对数据加锁， trx 200 必须等待 trx 100 提交事务以后才能继续操作。</p>
</blockquote>
<p><img src="./README.assets/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2ZseWluZ19oZW5nZmVp,size_16,color_FFFFFF,t_70-16481288140874.png" alt="掘金小册淘到的" loading="lazy"></p>
<p>对该记录每次更新后，都会将旧值放到一条undo日志中，就算是该记录的一个旧版本，随着更新次数的增多，所有的版本都会被【roll_pointer】属性连接成一个链表，我们把这个链表称之为版本链，版本链的头节点就是当前记录最新的值。另外，每个版本中还包含生成该版本时对应的事务id</p>
<h3 id="快照读"> 快照读</h3>
<p><strong>快照读：</strong> 读取的是记录数据的可见版本（有旧的版本）。不加锁，普通的select语句都是快照读，如：</p>
<div><pre><code>select * from core_user where id &gt; 2;
</code></pre>
<div><span>1</span><br></div></div><p><strong>当前读</strong>：读取的是记录数据的最新版本，显式加锁的都是当前读</p>
<div><pre><code>select * from core_user where id &gt; 2 for update;
select * from account where id &gt; 2 lock in share mode;
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="read-view"> Read View</h3>
<p>Read View 就是事务进行快照读操作的时候生产的读视图（Read View），在该事务执行的快照读的那一刻，会生成数据库系统当前的一个【快照】，记录并维护系统当前活跃事务的 ID（当每个事务开启时，都会被分配一个 ID，这个 ID 是递增的，所以最新的事务，ID 值越大）</p>
<hr>
<p><strong>四个属性</strong></p>
<ul>
<li>m_ids：表示在生成 ReadView 时当前系统中活跃的读写事务的事务id列表。</li>
<li>min_trx_id：表示在生成 ReadView 时当前系统中活跃的读写事务中最小的事务id，也就是m_ids中的最小值。</li>
<li>max_trx_id：表示生成 ReadView 时系统中应该分配给下一个事务的id值。</li>
<li>creator_trx_id：表示生成该 ReadView 的事务的事务id。</li>
</ul>
<hr>
<p><strong>Read View 匹配规则</strong></p>
<div><p>trx_id < min_trx_id</p>
<p>【数据的事务ID，trx_id】小于【视图创建时活跃事务的最小ID，min_trx_id】，说明这条数据在该事务开启之前就已经存在了，所以这条记录 <mark>可见</mark></p>
</div>
<div><p>trx_id >= max_trx_id</p>
<p>【数据的事务ID，trx_id】小于【视图创建时下一个事务的ID，max_trx_id】，说明这条数据是在视图创建之后才产生的，所以这条记录不可见</p>
</div>
<div><p>min_trx_id <= trx_id < max_trx_id</p>
<ul>
<li>
<p><code>trx_id 存在于 m_ids &amp;&amp; trx_id == creator_id</code></p>
<p>【数据的事务ID，trx_id】等于【创建视图的事务ID，creator_id】，说明事务正在访问自己修改过的记录，所以这条记录 <mark>可见</mark></p>
</li>
<li>
<p><code>trx_id 存在于 m_ids &amp;&amp; trx_id != creator_id</code></p>
<p>【数据的事务ID，trx_id】存在于【创建视图时活跃的事务列表，m_ids】，说明视图创建的时候，该事务还在活跃（还没提交），所以这条记录不可见</p>
</li>
<li>
<p><code>trx_id 不存在于 m_ids</code></p>
<p>【数据的事务ID，trx_id】不存在于【创建视图时活跃的事务列表，m_ids】，说明视图创建的时候，该事务就已经提交了，这条事务 <mark>可见</mark></p>
</li>
</ul>
</div>
<h2 id="实现原理"> 实现原理</h2>
<ol>
<li>获取事务自己的版本号，即事务 ID</li>
<li>获取 Read View</li>
<li>查询得到的数据，然后 Read View 中的事务版本号进行比较。</li>
<li>如果不符合 Read View 的可见性规则， 即就需要 Undo log 中历史快照;</li>
<li>最后返回符合规则的数据</li>
</ol>
<h3 id="生成快照时机"> 生成快照时机</h3>
<div><p>Warning</p>
<p><mark>只有【读已提交】【可重复读】两种隔离级别下会使用MVCC</mark>；【读未提交】连脏读都不能避免，基本没有数据库会支持这种隔离级别了；【串行化】最高级别隔离直接上锁，让各个事务串行执行，自然也不需要MVCC。</p>
</div>
<ul>
<li>读已提交：每次快照读都会获取最新的 Read View</li>
<li>可重复读：同一事务下，只有第一次快照读会创建 Read View，之后的所有快照读都是使用这个视图。（也就是在 InnoDB 的可重复读隔离级别下，实现了避免幻读的问题）</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T15:49:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">事务</title>
    <id>https://notes.lllllan.cn/mysql/transaction/</id>
    <link href="https://notes.lllllan.cn/mysql/transaction/"/>
    <updated>2022-04-16T01:31:02.000Z</updated>
    <content type="html"><![CDATA[<div><p>转载声明</p>
<ul>
<li><a href="https://funnylog.gitee.io/mysql45/iframe/" target="_blank" rel="noopener noreferrer">MySQL实战45讲 (gitee.io)</a></li>
<li><a href="https://blog.csdn.net/wang_luwei/article/details/119619105" target="_blank" rel="noopener noreferrer">MySQL事务【详解-最新的总结】</a></li>
<li><a href="https://www.jianshu.com/p/081a3e208e32" target="_blank" rel="noopener noreferrer">MySQL事务 - 简书 (jianshu.com)</a></li>
<li><a href="https://www.runoob.com/mysql/mysql-transaction.html" target="_blank" rel="noopener noreferrer">MySQL 事务 | 菜鸟教程 (runoob.com)</a></li>
<li><a href="https://blog.csdn.net/dingguanyi/article/details/80888441" target="_blank" rel="noopener noreferrer">事务并发的问题</a></li>
<li><a href="https://zhuanlan.zhihu.com/p/117476959" target="_blank" rel="noopener noreferrer">MySQL事务隔离级别和实现原理</a></li>
</ul>
</div>
<h2 id="什么是事务"> 什么是事务</h2>
<div><p>事务</p>
<p>是指对数据库执行一批操作，在同一个事务当中，这些操作最终要么全部执行成功，要么全部失败，不会存在部分成功的情况。</p>
</div>
<ul>
<li>事务是一个原子操作。是一个最小执行单元。可以甶一个或多个SQL语句组成</li>
<li>在同一个事务当中，所有的SQL语句都成功执行时，整 个事务成功，有一个SQL语句执行失败，整个事务都执行失败。</li>
</ul>
<h2 id="事务四大特征"> 事务四大特征</h2>
<h3 id="原子性"> 原子性</h3>
<p>原子性（<strong>A</strong>tomicity，或称不可分割性）</p>
<p>一个事务（transaction）中的所有操作，要么全部完成，要么全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样</p>
<div><p>回滚？</p>
</div>
<hr>
<h3 id="一致性"> 一致性</h3>
<p>一致性（<strong>C</strong>onsistency）</p>
<p>在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设规则，这包含资料的精确度、串联性以及后续数据库可以自发性地完成预定的工作。</p>
<blockquote>
<p>例如从帐户A转一笔钱到帐户B上，如果帐户A上的钱减少了，而帐户B上的钱却没有增加，那么我们认为此时数据处于不一致的状态。</p>
</blockquote>
<hr>
<h3 id="隔离性"> 隔离性</h3>
<p>隔离性（<strong>I</strong>solation，又称独立性）</p>
<p>数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。</p>
<p>事务隔离分为不同级别，包括读未提交（Read uncommitted）、读提交（read committed）、可重复读（repeatable read）和串行化（Serializable）</p>
<hr>
<h3 id="持久性"> 持久性</h3>
<p>持久性（<strong>D</strong>urability）</p>
<p>事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失</p>
<h2 id="事务并发的问题"> 事务并发的问题</h2>
<p>一个数据库可能拥有多个访问客户端，这些客户端都可以并发方式访问数据库。数据库中的相同数据可能同时被多个事务访问，如果没有采取必要的隔离措施，就会导致各种并发问题，破坏数据的完整性。</p>
<p>这些问题可以归结为5类，包括3类数据读问题（ 脏读、 不可重复读和幻象读）以及2类数据更新问题（两类丢失更新）</p>
<h3 id="脏读"> 脏读</h3>
<p><strong>因为事务的撤销，导致另一事务读到了提交以前的脏数据。</strong></p>
<p>脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的，值得注意的是，脏读一般是针对于update操作的。</p>
<p><img src="./README.assets/15150645_B8Se.jpg" alt="img" loading="lazy"></p>
<h3 id="不可重复度"> 不可重复度</h3>
<p><strong>因为事务的提交修改了数据，导致另一事务的前后两次查询得到了不同的结果。</strong></p>
<p><img src="./README.assets/15150645_2bou.jpg" alt="img" loading="lazy"></p>
<h3 id="幻读"> 幻读</h3>
<p><strong>因为事务的提交增删了数据，导致另一事务的前后两次查询得到了不同的结果</strong></p>
<p><img src="./README.assets/15150645_d6yw.jpg" alt="img" loading="lazy"></p>
<div><p>Tips</p>
<p><strong>不可重复读</strong> ，是因为 <code>update</code> 操作，导致某个事务的前后两次查询，得到了不一致的结果。</p>
<p><strong>幻读</strong> ，是因为 <code>insert, delete</code> 操作，导致某个事务的第二次查询比前一次查询多了或少了某条数据</p>
</div>
<h3 id="丢失更新"> 丢失更新</h3>
<p><strong>因为事务的撤销，覆盖了另一事务的修改</strong></p>
<p><img src="./README.assets/15150645_nAuV.jpg" alt="img" loading="lazy"></p>
<p><strong>因为事务的提交，覆盖了另一事务的修改</strong></p>
<p><img src="./README.assets/15150645_3e53.jpg" alt="img" loading="lazy"></p>
<h2 id="事务隔离级别"> 事务隔离级别</h2>
<ul>
<li>读未提交：read uncommitted</li>
<li>读已提交：read committed</li>
<li>可重复读：repeatable read</li>
<li>串行化：serializable</li>
</ul>
<p><img src="./README.assets/webp.png" alt="img" loading="lazy"></p>
<h3 id="读未提交"> 读未提交</h3>
<p><mark>读未提交不加锁</mark>，没有隔离，因此性能最好。</p>
<div>
<p><img src="./README.assets/v2-77225da0805e43183c076c24f270e75b_720w.jpg" alt="img" loading="lazy"></p>
</div>
<div><p>事务能够读到另一事务提交以前所修改的数据</p>
</div>
<div><p>脏读、不可重复读、幻读</p>
</div>
<h3 id="读已提交"> 读已提交</h3>
<p><mark>MVCC - 每个 select 语句都有自己的一份快照</mark>，而不是一个事务一份，所以在不同的时刻，查询出来的数据可能是不一致的</p>
<blockquote>
<p>快照：读取的记录数据是可见版本（含久版本）</p>
</blockquote>
<div>
<p><img src="./README.assets/v2-90289243339a900aaf3f87d9c9930258_720w.jpg" alt="img" loading="lazy"></p>
</div>
<div><p>解决了脏读。事务只能读到其他事务提交以后的数据</p>
</div>
<div><p>不可重复读、幻读</p>
</div>
<h3 id="可重复读"> 可重复读</h3>
<p><mark>MVCC - 一次事务只在第一次 select 时生成快照</mark></p>
<div>
<p><img src="./README.assets/v2-85fd2da20ae7cf219bf55d8b81f8bd94_720w.jpg" alt="img" loading="lazy"></p>
</div>
<div><p>事务范围内如果有其他事务提交，必须自己也提交事务后才能读取到该结果。</p>
<p>MVCC 解决了不可重复读</p>
<ul>
<li>MySQL的快照读，<a href="./../mvcc/">MVCC</a>避免了幻读</li>
<li>MySQL的当前读，<a href="./../next-key-lock/">next-key 锁</a>解决了幻读</li>
</ul>
</div>
<h3 id="串行化"> 串行化</h3>
<p><mark>串行化可以并发读，但是在写的时候加排他锁</mark>，其他事务不能并发写也不能在某个事务写的时候去并发读。</p>
<div><p>解决了所有问题</p>
</div>
<div><p>性能最差</p>
</div>
<h2 id="事务操作"> 事务操作</h2>
<h3 id="显式事务"> 显式事务</h3>
<p>事务需要手动开启、提交或回滚，由开发者自己控制。</p>
<p><strong>手动开启事务</strong></p>
<div><pre><code>mysql&gt; start transaction;
</code></pre>
<div><span>1</span><br></div></div><p><strong>执行语句</strong></p>
<div><pre><code>mysql&gt; update ...
</code></pre>
<div><span>1</span><br></div></div><p><strong>提交事务</strong></p>
<div><pre><code>mysql&gt; commit;
</code></pre>
<div><span>1</span><br></div></div><p><strong>回滚事务</strong></p>
<div><pre><code>mysql&gt; rollback;
</code></pre>
<div><span>1</span><br></div></div><h3 id="隐式事务"> 隐式事务</h3>
<p>事务自动开启、提交或回滚，比如insert、update、delete语句，事务的开启、提交或回滚由mysql内部自动控制的。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="数据库"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-03-31T15:49:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">项目主页</title>
    <id>https://notes.lllllan.cn/</id>
    <link href="https://notes.lllllan.cn/"/>
    <updated>2022-05-03T16:18:47.000Z</updated>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T05:26:23.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
</feed>