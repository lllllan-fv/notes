---
# 这是页面的图标
icon: page

# 这是文章的标题
title: 死锁

# 设置作者
author: lllllan

# 设置写作时间
# time: 2020-01-20

# 一个页面只能有一个分类
category: 计算机基础

# 一个页面可以有多个标签
tag:
- 操作系统
- 王道-操作系统

# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在首页的文章板块中
star: true

# 你可以自定义页脚
# footer: 
---



::: warning 转载声明

- 《王道考研-操作系统》

:::



## 死锁的概念



### 死锁的定义

在多道程序系统中，由于多个进程的并发执行，改善了系统资源的利用率并提高了系统的处
理能力。然而，多个进程的并发执行也带来了新的问题一死锁。 所谓死锁，是指多个进程因竞争
资源而造成的一种僵局( 互相等待)，若无外力作用，这些进程都将无法向前推进。
下面通过一-些实例来说明死锁现象。
先看生活中的一一个实例。 在一条河上有- -座桥， 桥面很窄，只能容纳-辆汽车通行。若有两
辆汽车分别从桥的左右两端驶上该桥，则会出现下述冲突情况:此时，左边的汽车占有桥面左边
的一段，要想过桥还需等待右边的汽车让出桥面右边的一段:右边的汽车占有桥面右边的一段，
要想过桥还需等待左边的汽车让出桥面左边的一段。此时，若左右两边的汽车都只能向前行驶，
则两辆汽车都无法过桥。
在计算机系统中也存在类似的情况。例如，某计算机系统中只有一台打印机和一台输入设备,
进程PI正占用输入设备，同时又提出使用打印机的请求，但此时打印机正被进程P2 所占用，而
Pz在未释放打印机之前，又提出请求使用正被PI占用的输入设备。这样，两个进程相互无休止地
等待下去，均无法继续执行，此时两个进程陷入死锁状态。



### 死锁产生的原因

(1) 系统资源的竞争
通常系统中拥有的不可剥夺资源，其数量不足以满足多个进程运行的需要，使得进程在运行
过程中，会因争夺资源而陷入僵局，如磁带机、打印机等。只有对不可剥夺资源的竞争才可能产
生死锁，对可剥夺资源的竞争是不会引起死锁的。
(2)进程推进顺序非法.
进程在运行过程中，请求和释放资源的顺序不当，也同样会导致死锁。例如，并发进程PI, P2.
分别保持了资源RI, R2，而进程PI申请资源R2、进程P2申请资源R时，两者都会因为所需资源
被占用而阻塞，于是导致死锁。
信号量使用不当也会造成死锁。进程间彼此相互等待对方发来的消息，也会使得这些进程间
无法继续向前推进。例如，进程A等待进程B发的消息，进程B又在等待进程A发的消息，可
以看出进程A和B不是因为竞争同一资源，而是在等待对方的资源导致死锁。
(3)死锁产生的必要条件
产生死锁必须同时满足以下4个条件，只要其中任意一个条件不成立，死锁就不会发生。
1)互斥条件:进程要求对所分配的资源( 如打印机)进行排他性使用，即在一段时间内某
资源仅为-一个进程所占有。此时若有其他进程请求该资源，则请求进程只能等待。

2)不剥夺条件:进程所获得的资源在未使用完之前，不能被其他进程强行夺走，即只能由
获得该资源的进程自己来释放(只能是主动释放)。
3)请求并保持条件:进程已经保持了至少一个资源，但又提出了新的资源请求，而该资源
已被其他进程占有，此时请求进程被阻塞，但对自己已获得的资源保持不放。
4)循环等待条件:存在一-种进程资源的循环等待链，链中每个进程已获得的资源同时被链中
下一个进程所请求。即存在-一个处于等待态的进程集合{Pr, P..,. Pn},其中P;等待的资源被P+1 (i= .
0, 1,,n-1)占有，P,等待的资源被Po占有，如图2.13所示。
直观上看，循环等待条件似乎和死锁的定义-样，其实不然。按死锁定义构成等待环所要求
的条件更严，它要求P;等待的资源必须由P+1来满足，而循环等待条件则无此限制。例如，系统
中有两台输出设备，Po占有一台，Pr占有另一台，且K不属于集合{0, 1, .,n}. Pn等待一台输
出设备，它可从Po获得,也可能从PK获得。因此,虽然P Po和其他一些进程形成了循环等待圈，
但Pr不在圈内，若Pr释放了输出设备，则可打破循环等待，如图2.14所示。因此循环等待只是
死锁的必要条件。



![image-20220401193847560](README.assets/image-20220401193847560.png)



资源分配图含圈而系统又不一定有死锁的原因是，同类资源数大于1.但若系统中每类资源
都只有一个资源，则资源分配图含圈就变成了系统出现死锁的充分必要条件。
要注意区分不剥夺条件与请求并保持条件。下面用一个简单的例子进行说明:若你手.上拿着
一个苹果(即便你不打算吃)，别人不能把你手上的苹果拿走，则这就是不剥夺条件:若你左手
拿着一个苹果，允许你右手再去拿-一个苹 果，则这就是请求并保持条件。



### 死锁的处理策咯

为使系统不发生死锁，必须设法破坏产生死锁的4个必要条件之一，或允许死锁产生，但当
死锁发生时能检测出死锁，并有能力实现恢复。
1)死锁预防。设置某些限制条件，破坏产生死锁的4个必要条件中的一个或几个。
2)避免死锁。在资源的动态分配过程中，用某种方法防止系统进入不安全状态。
3)死锁的检测及解除。无须采取任何限制性措施，允许进程在运行过程中发生死锁。通过系
统的检测机构及时地检测出死锁的发生，然后采取某种措施解除死锁。
预防死锁和避免死锁都属于事先预防策略，预防死锁的限制条件比较严格，实现起来较为简
单，但往往导致系统的效率低，资源利用率低;避免死锁的限制条件相对宽松，资源分配后需要
通过算法来判断是否进入不安全状态，实现起来较为复杂。
死锁的几种处理策略的比较见表2.4。



|          |       资源分配策略       |               各种可能模式               |                   主要优点                   |                           主要缺点                           |
| :------: | :----------------------: | :--------------------------------------: | :------------------------------------------: | :----------------------------------------------------------: |
| 死锁预防 |    保守，宁可资源闲置    | 一次请求所有资源，资源剥夺，资源按序分配 |     适用于突发式处理的进程，不必进行剥夺     | 效率低，进程初始化时间延长；<br />剥夺次数过多；<br />不便灵活申请新资源 |
| 死锁避免 |    是预防和检测的这种    |          寻找可能的安全允许顺序          |                 不必进行剥夺                 |      必须知道将来的资源需求；<br />进程不能被长时间阻塞      |
| 死锁检测 | 宽松，只要允许就分配资源 |         定期检查死锁是否已经发生         | 不延长进程初始化时间，允许对死锁进行现场处理 |                  通过剥夺接触死锁，造成损失                  |



## 死锁预防

防止死锁的发生只需破坏死锁产生的4个必要条件之一即可。

### 破坏互斥条件

若允许系统资源都能共享使用，则系统不会进入死锁状态。但有些资源根本不能同时访问，
如打印机等临界资源只能互斥使用。所以，破坏互斥条件而预防死锁的方法不太可行，而且在有
的场合应该保护这种互斥性。
研祝您_ C库)



### 破坏不剥夺条件

当一个已保持了某些不可剥夺资源的进程请求新的资源而得不到满足时，它必须释放已经保
持的所有资源，待以后需要时再重新申请。这意味着，一个进程已占有的资源会被暂时释放，或
者说是被剥夺，或从而破坏了不剥夺条件。
该策略实现起来比较复杂，释放已获得的资源可能造成前一阶段工作的失效，反复地申请和
释放资源会增加系统开销,降低系统吞吐量。这种方法常用于状态易于保存和恢复的资源,如CPU
的寄存器及内存资源，- -般不能用于打印机之类的资源。



### 破坏请求并保持条件

采用预先静态分配方法，即进程在运行前一次申请完它所需要的全部资源，在它的资源未满
足前，不把它投入运行。一旦投入运行， 这些资源就-直归它所有，不再提出其他资源请求，这
样就可以保证系统不会发生死锁。
这种方式实现简单，但缺点也显而易见，系统资源被严重浪费，其中有些资源可能仅在运行
初期或运行快结束时才使用，甚至根本不使用。而且还会导致“饥饿”现象，由于个别资源长期.
被其他进程占用时，将致使等待该资源的进程迟迟不能开始运行。



### 破坏循环等待条件

为了破坏循环等待条件,可采用顺序资源分配法。首先给系统中的资源编号,规定每个进程
必须按编号递增的顺序请求资源，同类资源- -次申请完。 也就是说，只要进程提出申请分配资源
R，则该进程在以后的资源申请中就只能申请编号大于R,的资源。
这种方法存在的问题是，编号必须相对稳定，这就限制了新类型设备的增加;尽管在为资源
编号时已考虑到大多数作业实际使用这些资源的顺序，但也经常会发生作业使用资源的顺序与系
统规定顺序不同的情况，造成资源的浪费;此外，这种按规定次序申请资源的方法，也必然会给
用户的编程带来麻烦。



## 死锁避免

避免死锁同样属于事先预防策略，但并不是事先采取某种限制措施破坏死锁的必要条件，而
是在资源动态分配过程中，防止系统进入不安全状态，以避免发生死锁。这种方法所施加的限制
条件较弱，可以获得较好的系统性能。



### 系统安全状态

避免死锁的方法中，允许进程动态地申请资源，但系统在进行资源分配之前，应先计算此次
分配的安全性。若此次分配不会导致系统进入不安全状态，则允许分配;否则让进程等待。
所谓安全状态，是指系统能按某种进程推进顺序(P1, Pe...,. P,)为每个进程P;分配其所需的
资源，直至满足每个进程对资源的最大需求，使每个进程都可顺序完成。此时称P, P2,.，, Pn为
安全序列。若系统无法找到一个安全序列，则称系统处于不安全状态。
假设系统中有三个进程PI, P2和P3，共有12台磁带机。进程P:共需要10台磁带机，P2和

P3分别需要4台和9台。假设在To时刻，进程PI, P2和
P3已分别获得5台、2台和2台，尚有3台未分配，见
表2.5.
在To时刻是安全的，因为存在- -个安全序列P2, PI,
P3，只要系统按此进程序列分配资源，
那么每个进程都
能顺利完成。也就是说，当前可用磁带机为3台，先把

![image-20220401194518681](README.assets/image-20220401194518681.png)



3台磁带机分配给P2以满足其最大需求，P2 结束并归还资源后，系统有5台磁带机可用:接下来
给PI分配5台磁带机以满足其最大需求，P结束并归还资源后，剩余10台磁带机可用;最后分
配7台磁带机给P3,这样P3也能顺利完成。
若在Tg时刻后，系统分配1台磁带机给P3，系统剩余可用资源数为2，此时系统进入不
安全状态，因为此时已无法再找到一个安全序列。当系统进入不安全状态后，便可能导致死锁。
例如，把剩下的2台磁带机分配给P2，这样，P2 完成后只能释放4台磁带机，既不能满足P1
又不能满足P3,致使它们都无法推进到完成，彼此都在等待对方释放资源，陷入僵局，即导致
死锁。
并非所有的不安全状态都是死锁状态，但当系统进入不安全状态后，便可能进入死锁状态; .
反之，只要系统处于安全状态，系统便可避免进入死锁状态。



### 银行家算法

银行家算法是最著名的死锁避免算法，其思想是:把操作系统视为银行家，操作系统管理的
资源相当于银行家管理的资金，进程向操作系统请求分配资源相当于用户向银行家贷款。操作系
统按照银行家制定的规则为进程分配资源。进程运行之前先声明对各种资源的最大需求量，当进
程在执行中继续申请资源时，先测试该进程已占用的资源数与本次申请的资源数之和是否超过该
进程声明的最大需求量。若超过则拒绝分配资源，若未超过则再测试系统现存的资源能否满足该
进程尚需的最大资源量，若能满足则按当前的申请量分配资源，否则也要推迟分配。
(1)数据结构描述
可利用资源向量Available:含有m个元素的数组，其中每个元素代表- -类可用的资源数目。
Available[i] - K表示系统中现有R,类资源K个。
最大需求矩阵Max: nxm 矩阵，定义系统中n个进程中的每个进程对m类资源的最大需求。



简单来说，一行代表-一个进程，-列代表-类资源。Max[,j]=K表示进程i需要R;类资源的最
大数目为K。.
分配矩阵Allocation:nxm矩阵，定义系统中每类资源当前已分配给每个进程的资源数。
Allocation[i,j] =K表示进程i当前已分得R;类资源的数目为K。初学者容易混淆Available向量和
Allocation矩阵，在此特别提醒。
需求矩阵Need:nxm矩阵，表示每个进程接下来最多还需要多少资源。Need[i,j]=K表示进
程i还需要R;类资源的数目为K。
.上述三个矩阵间存在下述关系:
Need = Max - Allocation
一般情况下， 在银行家算法的题目中，Max 矩阵和Allocation矩阵是已知条件，而求出Need
矩阵是解题的第一步。
(2)银行家算法描述
设Request;是进程P;的请求向量，Request[] = K表示进程P;需要j类资源K个。当P，发出
资源请求后，系统按下述步骤进行检查:
①若Requesti[]≤Need[,],则转向步骤②;否则认为出错，因为它所需要的资源数已超过
它所宣布的最大值。
②若Request[V]≤Available[i],则转向步骤③;否则，表示尚无足够资源，P,须等待。
③系统试探着把资源分配给进程P;,并修改下面数据结构中的数值:



Available = Available- Request;
Allocation[L, j]= Allcation[i, )]+ Request,[J]; .
Need[i, j] = Need[i, j]- Request,[j];
④系统执行安全性算法，检查此次资源分配后，系统是否处于安全状态。若安全,才正式
将资源分配给进程P,以完成本次分配;否则，将本次的试探分配作废,恢复原来的资
源分配状态，让进程P/等待。
(3)安全性算法
设置工作向量Work,有m个元素，表示系统中的剩余可用资源数目。在执行安全性算法开
始时，Work = Available.
①初始时安全序列为空.
②从Nee矩阵中找出符合下面条件的行:该行对应的进程不在安全序列中，而且该行小于
等于Work向量，找到后，把对应的进程加入安全序列:若找不到，则执行步骤④。
③进程P;进入安全序列后，可顺利执行，直至完成，并释放分配给它的资源，因此应执行
Work = Work + Allocation[i],其中Allocation[i]表示进程P,代表的在Allocation矩阵中对
应的行，返回步骤②。
④若此时安全序列中已有所有进程，则系统处于安全状态，否则系统处于不安全状态。
看完上面对银行家算法的过程描述后，可能会有眼花缭乱的感觉,现在通过举例来加深理解。



### 安全性算法举例

假定系统中有5个进程{Po, P, P2, P3, P4}和三类资源{A, B, C),各种资源的数量分别为10,
5,7,在To时刻的资源分配情况见表2.6。
To时刻的安全性。利用安全性算法对To时刻的资源分配进行分析。



![image-20220401194651548](README.assets/image-20220401194651548.png)

①从题目中我们可以提取Max矩阵和Allocation矩阵，这两个矩阵相减可得到Need矩阵:
、、
②然后，将Work向量与Need矩阵的各行进行比较，找出比Work矩阵小的行。例如，在
初始时,
(3,3,2)> (1,2,2)
(3,3,2)> (0,1,1)
对应的两个进程分别为PI和P3，这里我们选择PI (也可以选择P3)暂时加入安全序列。
③释放P所占的资源，即把PI进程对应的Allocation矩阵中的一-行 与Work向量相加:
(3 3 2)+(2 0 0)=(5 3 2)= Work
此时需求矩阵更新为(去掉了P1对应的一~行):
。。



再用更新的Work向量和Need矩阵重复步骤②。利用安全性算法分析To时刻的资源分配
情况如表2.7所示，最后得到一个安全序列{P1, P3, P4, P2, Po}o

![image-20220401194800797](README.assets/image-20220401194800797.png)



### 银行家算法举例

安全性算法是银行家算法的核心，在银行家算法的题目中，一般会有某个进程的一个资源请
求向量，读者只要执行上面所介绍的银行家算法的前三步，马上就会得到更新的Allocation 矩阵
和Need矩阵，再按照上例的安全性算法判断，就能知道系统能否满足进程提出的资源请求。
假设当前系统中资源的分配和剩余情况如表2.6所示。
(1) P请求资源: P1发出请求向量Request(1, 0, 2)， 系统按银行家算法进行检查:
Request(1, 0, 2) S Need:(1,2, 2)
Request:(1, 0, 2)≤Available(3, 3, 2)
系统先假定可为P分配资源，并修改
Available = Available - Request!= (2, 3, 0)
Allocation = Allocation + Request1= (3, 0, 2)
Need! = Need; - Request= (0, 2, 0)
由此形成的资源变化情况如表2.6中的圆括号所示。
令Work = Available = (2, 3, 0)，再利用安全性算法检查此时系统是否安全，如表2.8所示。

![image-20220401194827898](README.assets/image-20220401194827898.png)

由所进行的安全性检查得知，可找到一一个安全序列{P1, P3, P4, P2, Po}。因此，系统是安全的，
可以立即将P所申请的资源分配给它。分配后系统中的资源情况如表2.9所示。

![image-20220401194845324](README.assets/image-20220401194845324.png)

(2) P4 请求资源: P4 发出请求向量Request, (3, 3, 0),系统按银行家算法进行检查:
Request4(3, 3, 0)≤Need4(4,3, 1);
Request(3, 3, 0)> Available(2,3, 0)，让P4 等待。
(3) Po请求资源: Po 发出请求向量Requsto(0, 2, 0)，系统按银行家算法进行检查:
Requesto(0, 2, 0)≤Needo(7, 4, 3);
Requesto(0, 2, 0)≤Available(2, 3, 0)

系统暂时先假定可为Po分配资源，并修改有关数据:
Available = Available - Requesto=(2, 1, 0)
Allocationo = Allocationo+ Requesto= (0,3, 0)
Needo= Needo - Requesto= (7, 2, 3),结果如表2.10所示。

![image-20220401194917962](README.assets/image-20220401194917962.png)

进行安全性检查:可用资源Available(2, 1, 0)已不能满足任何进程的需要，因此系统进入不安
全状态，因此拒绝Po的请求，让Po等待，并将Available, Allocationo, Needo恢复为之前的值。



## 死锁检 测和解除

万T大口你兰
前面介绍的死锁预防和避免算法，都是在为进程分配资源时施加限制条件或进行检测，若系
统为进程分配资源时不采取任何措施，则应该提供死锁检测和解除的手段。



### 资源分配图

系统死锁可利用资源分配图来描述。如图2.15 所示，用圆圈
代表-一个进程，用框代表-类资源。由于一种类型的资源可能有
多个，因此用框中的一个圆代表-类资源中的-一个资源。从进程
到资源的有向边称为请求边，表示该进程申请-一个单位的该类资
源;从资源到进程的边称为分配边，表示该类资源已有一-个资源
分配给了该进程。
在图2.15所示的资源分配图中，进程P1已经分得了两个R
资源，并又请求一个R2资源;进程P2分得了一个R资源和一一个
R2资源，并又请求-一个R|资源。.

![image-20220401194958504](README.assets/image-20220401194958504.png)



### 死锁定理

简化资源分配图可检测系统状态S是否为死锁状态。简化方法如下:
1)在资源分配图中， 找出既不阻塞又不孤点的进程P; (即找出一 条有向边与它相连，且该
有向边对应资源的申请数量小于等于系统中已有的空闲资源数量，如在图2.15中，R没
有空闲资源，R2 有一个空闲资源。若所有连接该进程的边均满足上述条件，则这个进程
能继续运行直至完成，然后释放它所占有的所有资源)。消去它所有的请求边和分配边，
使之成为孤立的结点。在图2.16(a)中，PI 是满足这一条件的进程结点，将P的所有边消
去，便得到图2.16(b)所示的情况。
这里要注意一个问题，判断某种资源是否有空闲，应该用它的资源数量减去它在资源分
配图中的出度，例如在图2.15中，R的资源数为3，而出度也为3,所以Ri没有空闲资
源，R2的资源数为2，出度为1,所以R2有一个空闲资源。

2)进程P;所释放的资源，可以唤醒某些因等待这些资源而阻塞的进程，原来的阻塞进程可
能变为非阻塞进程。在图2.15中，进程P2就满足这样的条件。根据1)中的方法进行一
系列简化后，若能消去图中所有的边，则称该图是可完全简化的，如图2.16(c)所示。

![image-20220401195040638](README.assets/image-20220401195040638.png)

S为死锁的条件是当且仅当S状态的资源分配图是不可完全简化的，该条件为死锁定理。

### 死锁解除

一旦检测 出死锁，就应立即采取相应的措施来解除死锁。死锁解除的主要方法有:
1)资源剥夺法。挂起某些死锁进程，并抢占它的资源，将这些资源分配给其他的死锁进程。
但应防止被挂起的进程长时间得不到资源而处于资源匮乏的状态。
2)撤销进程法。强制撤销部分甚至全部死锁进程并剥夺这些进程的资源。撤销的原则可以
按进程优先级和撤销进程代价的高低进行。
3)进程回退法。让一(或多) 个进程回退到足以回避死锁的地步，进程回退时自愿释放资
源而非被剥夺。要求系统保持进程的历史信息，设置还原点。
