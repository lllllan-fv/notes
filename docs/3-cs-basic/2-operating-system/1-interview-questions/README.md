---
# 这是页面的图标
icon: page

# 这是文章的标题
title: 操作系统-常见面试题

# 设置作者
author: lllllan

# 设置写作时间
# time: 2020-01-20

# 一个页面只能有一个分类
category: 计算机基础

# 一个页面可以有多个标签
tag:
- 操作系统
- 面试题

# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在首页的文章板块中
star: true

# 你可以自定义页脚
# footer: 
---



::: warning

本文转载自以下文章：

- [操作系统常见面试题总结 | JavaGuide](https://javaguide.cn/cs-basics/operating-system/操作系统常见面试题&知识点总结/)
- [什么是操作系统？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/105945721)
- [进程间通信IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)

:::

## 一、操作系统基础



### 1.1 操作系统

[什么是操作系统？ - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/105945721)

**操作系统(Operation System, OS) 是指控制和管理整个计算机系统的硬件和软件资源的系统软件。** 需要合理地组织和调度计算机的工作和资源的分配，以提供给用户和其它软件方便的接口和环境。

<img src="README.assets/v2-9e3753e45963e8de97ec5af05aa4f6e9_720w.jpg" alt="img" style="zoom: 33%;" />

**操作系统说明：**

1. 负责管理协调硬件、软件等计算机资源的工作
2. 为上层的应用程序、用户提供简单易用的服务
3. 操作系统是系统软件，而不是硬件

![img](README.assets/v2-80e382880632b6067b9c1b7c679de331_720w.jpg)



### 1.2 系统调用

根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：

1. **用户态**(user mode)：用户态运行的进程可以直接读取用户程序的数据。
2. **内核态**(kernel mode)：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。



我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！

也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。

这些系统调用按功能大致可分为如下几类：

- **设备管理**。完成设备的请求或释放，以及设备启动等功能。
- **文件管理**。完成文件的读、写、创建及删除等功能。
- **进程控制**。完成进程的创建、撤销、阻塞及唤醒等功能。
- **进程通信**。完成进程之间的消息传递或信号传递等功能。
- **内存管理**。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。



## 二、进程和线程



### 2.1 进程和线程的区别

**概念：**

- **进程**：是并发执行的程序在执行过程中**分配和管理资源的基本单位**，是一个动态概念，竞争计算机系统资源的基本单位。
- **线程**：是进程的一个执行单元，是进程内的调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。



**关系：**

1. 一个线程只属于一个进程，一个进程至少有一个线程
2. 资源分配给进程，同一进程的所有线程共享该进程的资源
3. 处理机分配给线程，真正在处理机上运行的是线程
4. 线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。



**区别：**

|          |              进程              |             线程             |
| :------: | :----------------------------: | :--------------------------: |
|   调度   |    分配和管理资源的基本单位    |     调度和分配的基本单位     |
|   资源   |           相互间独立           |       共享本进程的资源       |
|  健壮性  | 一个进程的崩溃不会影响其他进程 | 一个线程的崩溃会影响整个进程 |
|  并发性  |          可以并发执行          |         可以并发执行         |
| 系统开销 |               大               |              小              |



**JVM角度：**

一个进程中可以有多个线程，多个线程共享进程的**堆**和**方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器**、**虚拟机栈** 和 **本地方法栈**。

![img](README.assets/up-cd8ac705f6f004c01e0a1312f1599430ba5.png)



### 2.2 进程的状态

- **创建状态(new)** ：进程正在被创建，尚未到就绪状态。
- **就绪状态(ready)** ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。
- **运行状态(running)** ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。
- **阻塞状态(waiting)** ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。
- **结束状态(terminated)** ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。

![这里写图片描述](README.assets/20160906192211991.png)



### 2.3 进程间的通信方式

下面部分转载自 [进程间通信IPC (InterProcess Communication)](https://www.jianshu.com/p/c1015f5ffa74)

每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为**进程间通信**

![img](README.assets/webp.png)



#### 2.3.1 管道/匿名管道

**用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。**

> 管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
>  该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
>  当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。

特点和局限：

- 只支持单向数据流
- 只能用于具有亲缘关系的进程之间
- 没有名字
- 管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）
- 管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；



#### 2.3.2 有名管道 FIFO

**有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。**

> 有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，**以有名管道的文件形式存在于文件系统中**，这样，**即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信**，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循**先进先出(first in first out)**,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。**有名管道的名字存在于文件系统中，内容存放在内存中。**

管道总结：

- 管道是特殊类型的文件，在满足**先入先出**的原则条件下可以进行读写，但不能进行定位读写。
- 管道都是单向的。其中匿名管道只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。
- **匿名管道阻塞问题：** 匿名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。
- **有名管道阻塞问题：** 有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。



#### 2.3.3 信号

**信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生**

- 信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。
- 如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。
- 如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。

![img](README.assets/webp-16430301339574.png)



#### 2.3.4 消息队列

**消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。**

特点总结：

- 消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识
- 消息队列允许一个或多个进程向它写入与读取消息
- 管道和消息队列的通信数据都是先进先出的原则
- 消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势
- 消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺
- 目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。



#### 2.3.5 共享内存

**使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。**

- 使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。
- 为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。
- 由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。

![img](README.assets/webp-16430303402166.png)



#### 2.3.6 信号量

**信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。**

> 操作流程：
>
> 1. **创建一个信号量**：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。
> 2. **等待一个信号量**：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。
> 3. **挂出一个信号量**：该操作将信号量的值加1，也称为V操作。

![image-20220124212125134](README.assets/image-20220124212125134.png)



#### 2.3.7 套接字

**主要用于在客户端和服务器之间通过网络进行通信**

> 套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。
>
> 套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。



### 2.4 线程间的同步方式

**线程同步是两个或多个共享关键资源的线程的并发执行。** 应该同步线程以避免关键资源的使用冲突。线程同步有以下几种方式：

1. **互斥量 Mutex：** 采用互斥对象机制，只有拥有互斥对象的线程才有访问公共资源的权限。因为互斥对象只有一个，所以可以保证公共资源不会被多个线程同时访问。比如java中的 `synchronized` 关键词和各种 `Lock` 都是这种机制。
2. **信号量 Semphares：** 它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问次资源的最大线程数量。
3. **事件 Event：** `Wait/Notify`，通过通知操作的方式来保持多线程同步，还可以方便地实现多线程优先级的比较操作。



### 2.5 进程的调度算法

不论是在什么系统中，进程数量一般都会多于处理及数量，这将导致他们呢相互争夺处理机。这时就需要通过进程调度，来分配不同进程使用处理机的顺序，让这些进程**高效、及时、公平**地使用CPU，以提高CPU利用率。



1. **先来先服务调度算法 FCFS：** 所有进程按照 <u>先来后到</u> 的方式依次进入就绪队列，然后按照顺序为队列中的进程逐个分配资源，使他立即执行并且一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
2. **短作业优先调度算法 SJF：** 从就绪队列中选出一个 <u>估计运行时间最短</u> 的进程为止分配资源，使他立即执行并且一直执行到完成或发生某事件而被阻塞放弃占用CPU时再重新调度。
3. **时间片轮转调度算法 RR：** 所有进程按照 <u>先来后到</u> 的方式一次进入就绪队列，然后按照顺序为队列中的进程逐个 <u>分配固定时长的资源</u>，执行完成或时间结束都将放弃占用CPU，未执行完将重新调度。
4. **多级反馈队列调度算法：** 根据先来先服务原则给就绪队列排序，为就绪队列赋予<u>不同的优先级数，不同的时间片</u>，按照优先级抢占CPU
5. **优先级调度：** 为每个流程分配优先级，首先执行具有最高优先级的进程，以此类推。具有相同优先级的进程以 FCFS 方式执行。可以根据 <u>内存、时间或任何其他资源要求来确定优先级</u>。



### 2.6 死锁

死锁是指多个进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，他们都将无法推进下去。



#### 2.6.1 死锁产生的原因

- 系统资源不足
- 程序执行的顺序有问题
- 资源分配不当



#### 2.6.2 死锁产生的条件

- **互斥：** 指进程对所分配到的资源进行排他性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其他进程请求资源，则请求者只能等待，直到占有资源的进程释放。
- **请求和保持：** 指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其他进程占有，此时请求进程阻塞，但又对已获得的其他资源保持不放。
- **不剥夺：** 指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
- **环路等待：** 指在发生死锁时，必然存在一个进程-资源的环形链，即进程集合 `{P0, P1, P2, ... , Pn}` 中的 `P0` 正在等一个 `P1` 占用的资源； `P1` 正在等待 `P2` 占用的资源， ...... ，`Pn` 正在等待一个 `P0` 占用的资源。

**只有四个条件同时成立时，死锁才会出现。**



## 三、操作系统内存管理基础



### 3.1 内存管理介绍

- 内存空间的分配与回收
-  地址转换：把逻辑地址转换成相应的物理地址
- 内存空间的扩充：利用虚拟技术或自动覆盖技术，从逻辑上扩充内存
- 存储保护：保证各道作业在各自的存储空间内运行，互不干扰



### 3.2 内存管理机制

简单分为 **连续分配管理方式** 和 **非连续分配管理方式** 两种。

- 连续分配管理方式是指为一个用户程序分配一个连续的内存空间，常见的如 <u>块式管理</u>
- 非连续分配管理方式允许一个程序使用的内存分布在离散或者说不相邻的内存中，常见的如 <u>页式管理</u>、<u>段式管理</u>、<u>段页式管理</u>



1. **块式管理：** 将内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就会分配给它一块，如果程序运行只需要很小的空间的话，块中其余的部分将会被浪费。
2. **页式管理：** 把主存分为大小相等的一页一页的形式，页较小，相对比块式管理的划分力度更大，提高了内存利用率，减少了碎片（块中没有被利用的空间）。页式管理通过页表对应逻辑地址和物理地址
3. **段式管理：** 段式管理把主存分为一段段的，每个段定义了一组逻辑信息，例如有主程序的 Main、子程序段 X、数据段 D及栈段 S 等。段式管理通过段表对应逻辑地址和物理地址，相对于页式管理赋予了段的实际意义。
4. **段页式管理：** 把主存分成若干段，每个段分成若干页，结合了段式管理和页式管理的优点。



### 3.3 快表和多级页表



#### 快表

为了解决虚拟地址到物理地址的转换速度，操作系统在页表方案基础上引入了快表来加速虚拟地址到物理地址的转换。我们可以把快表理解为一种特殊的告诉缓冲存储器（Cache），其中的内容是页表的一部分或者全部内容。作为页表的Cache，它的作用与页表相似，但是提高了访问速率。由于采用页表做地址转换，读写内存数据CPU要访问两次主存。有了快表，有时只要访问一次告诉缓冲存储区，一次主存，这样可以加速查找并提高指令执行速度。

1. 根据虚拟地址中的页号查快表
2. 如果该页在快表中，直接从快表中读取相应的物理地址
3. 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将该映射添加到快表中
4. 当快表填满后，新添加时会按照一定的淘汰策略淘汰掉快表中的一页



#### 多级页表

引入多级页表的主要目的时为了避免把全部页表一直放在内存中占用过多的空间，特别是哪些根本不需要的页表就不需要保留在内存中。多级页表属于时间换空间的典型场景。



#### 总结

为了提高内存的空间性能，提出了多级页表的概念；但是提到空间性能是以浪费时间性能为基础的，因此为了补充损失的时间性能，提出了快表的概念。



### 3.4 分页机制和分段机制的异同

**共同点：**

- 都是为了提高内存利用率，减少内存碎片
- 都是离散分配内存的方式，但页和段中的内存都是连续的



**区别：**

- 页的大小是固定的，由操作系统决定；段的大小是不固定的，取决于当前运行的程序
- 分页仅仅是为了满足操作系统内存管理的需求；段是逻辑信息的单位，在程序中可以体现为代码段、数据段，能够更好满足用户的需求



### 3.5 逻辑地址和物理地址

比如在 C 语言中，指针里面存储的数值就可以理解成为内存里的一个地址，这个地址也就是我们说的逻辑地址，逻辑地址由操作系统决定。物理地址指的是真实物理内存中地址，更具体一点来说就是内存地址寄存器中的地址。物理地址是内存单元真正的地址



### 3.6 CPU 寻址

现代处理器使用的是 **虚拟寻址** 的方式。**使用虚拟寻址，CPU需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存。** 实际上完成虚拟地址转换为物理地址的硬件是 CPU 中的 **内存管理单元**

![MMU_principle_updated](README.assets/2b27dac8cc647f8aac989da2d1166db2.png)



#### 为什么要有虚拟地址空间？

在没有虚拟地址的时候，程序都是直接访问和操作物理内存的，存在以下问题：

1. 用户程序可以访问任意内存，寻址内存的每个字节，这样就很容易（有意或者无意）破坏操作系统，造成操作系统崩溃
2. 想要同时运行多个程序特别困难，困难会发生多个程序同时修改同个内存地址上的内容，从而导致程序的崩溃



**如果直接把物理地址暴露出来的话会带来严重问题，可能会对操作系统和程序造成上海和困难**



通过虚拟地址访问内存有以下优势：

1. 程序可以使用一系列相邻的虚拟地址来访问物理内存中不相邻的大内存缓冲区
2. 程序可以使用一系列虚拟地址访问大于可用物理内存的内存缓冲区。当物理内存的供应量变小时，内存管理器会将物理内存页保存到磁盘文件。数据或代码也会根据需要在物理内存与磁盘之间移动
3. 不同进程使用的虚拟地址彼此隔离。一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存



## 四、虚拟内存



### 4.1 什么是虚拟内存

> 虚拟内存是计算机系统内存管理的一种技术。它使得应用程序认为它拥有连续可用的内存（一个连续完整的地址空间），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换。
> 现代所有用于一般应用的操作系统都对普通的应用程序使用虚拟内存技术，老一些的操作系统，如DOS和1980年代的Windows，或者那些1960年代的大型机，一般都没有虚拟内存的功能
> ——维基百科

以下转载自 [如何理解虚拟内存 - 知乎 (zhihu.com)](https://zhuanlan.zhihu.com/p/96098896)

每个进程创建加载的时候，会被分配一个大小为4G的连续的虚拟地址空间，虚拟的意思就是，其实这个地址空间时不存在的，仅仅是每个进程“认为”自己拥有4G的内存，而实际上，它用了多少空间，操作系统就在磁盘上划出多少空间给它，等到进程真正运行的时候，需要某些数据并且数据不在物理内存中，才会触发缺页异常，进行数据拷贝

更准确一点的说，系统将虚拟内存分割为称为虚拟页(Virtual Page,VP)的大小固定的块，每个虚拟页的大小为P = 2^p字节，类似地，物理内存被分割为物理页(Physical Page,PP)，大小也为P字节（物理页也称为页帧(page frame)）。



### 4.2 局部性原理

程序执行的时候往往呈现局部性规律，即在某i个较短的时间内，程序执行局限于某一小部分，程序访问的存储空间也局限于某个区域。

1. **时间局部性：** 如果程序中某条指令一旦执行，不久以后该指令可能再次执行；如果某数据被访问过，不久以后该数据可能被再次访问。产生时间局部性的典型原因，是由于程序中存在着大量的循环操作。
2. **空间局部性：** 一旦程序访问了某个存储单元，在不久之后，其附近的存储单元也被访问，即程序在一段时间内所访问的地址，可能集中在一定的范围内。这是因为指令通常是顺序存放、顺序执行的，数据也一般是以向量、数组、表等形式簇聚存储的

时间局部性是通过将近来使用的指令和数据保存到高速缓存存储器中，并使用高速缓存的层次结构实现。空间局部性通常是使用较大的高速缓存，并将预取机制继承到高速缓存的控制逻辑中实现。虚拟内存技术实际上是建立了“内存-外村”的两级存储器的结构，利用局部性原理实现高速缓存。



### 4.3 虚拟内存的技术实现

**虚拟内存的实现需要建立在离散分配的内存管理方式的基础上。**

1. **请求分页存储管理：** 建立在分页管理之上，为了支持虚拟存储功能而增加了请求调页功能和页面置换功能。请求分页是目前最常用的一种实现虚拟存储器的方法。请求分页存储管理系统中，在作业开始运行之前，仅装入当前要执行的部分段即可运行。加入在作业运行的过程中发现要访问的页面不在内存，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入到主存，同时操作系统可以将暂时不用的页面置换到外存中。
2. **请求分段存储管理：** 建立在分段存储管理之上，增加了请求调段功能、分段置换功能。请求分段存储管理方式就如同请求分页存储管理方式一样，在作业开始运行之前，仅装入当前要执行的部分段即可运行；在执行过程中，可使用请求调入中断动态装入要访问但又不在内存的程序段；当内存空间已满，而又需要装入新的段时，根据置换功能适当调出某个段，以便腾出空间而装入新的段
3. **请求段页式存储管理**



::: info 请求分页和分页存储管理的区别

请求分页建立在分页管理之上。他们的根本区别是是否将程序所需要的全部地址空间都装入主存，这也是请求分页存储管理可以提供虚拟内存的原因。请求分页不要求将作业全部地址同时装入主存，基于这一点，请求分页可以提供虚存，而分页管理不能。

:::



不管是上面哪种实现方式，我们一般都需要：

1. 一定容量的内存和外存：在载入程序的时候，直选哟将程序的一部分装入内存，而将其他部分留在外存，然后程序就可以执行了。
2. **缺页中断：** 如果需要执行的指令或访问的数据尚未在内存（称为缺页或缺段），则由处理器通知操作系统将相应的页面或段调入到内存，然后继续执行程序
3. **虚拟地址空间：** 逻辑地址到物理地址的变换



