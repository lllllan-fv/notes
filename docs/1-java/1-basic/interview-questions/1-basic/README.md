---
# 这是页面的图标
icon: page

# 这是文章的标题
title: java 面试题 - 基础知识

# 设置作者
author: lllllan

# 设置写作时间
# time: 2020-01-20

# 一个页面只能有一个分类
category: Java

# 一个页面可以有多个标签
tag:
- 面试题

# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在首页的文章板块中
star: true

# 你可以自定义页脚
# footer: 
---

::: warning 

本文所有题目整理及答案全部来自 [帅地玩编程-校招|面试|学习路线](https://www.iamshuaidi.com/)，略有改动

:::



## 17. final、finally、finalize 的区别

- `final`：⽤于声明属性、⽅法和类，分别表示属性不可变、⽅法不可覆盖、被其修饰的类不可继承； 
- `finally`：异常处理语句结构的⼀部分，表示总是执⾏； 
- `finallize`：Object类的⼀个⽅法，在垃圾回收时会调⽤被回收对象的finalize



## 19. 两个对象的 hashCode() 相同，则 equals() 也⼀定为 true 吗？

 两个对象的 hashCode() 相同，equals() 不⼀定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希 值相等，然⽽哈希值相等，并不⼀定能得出键值对相等【散列冲突】

更多详见 [JavaGuide - Java基础知识 | lllllan](../2-java-guide-basic/#_2-5-hashcode-与-equals)



## 20. 为什么重写 equals() 就⼀定要重写 hashCode() 方法

理解 hashCode 的作用👉 [JavaGuide - Java基础知识 | lllllan](../1-basic/2-java-guide-basic/#_2-5-hashcode-与-equals)



## 21. & 和 && 的区别

 Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算 结果才为 true，否则为 false。

- &&：有短路功能，当第⼀个表达式的值为 false 的时候，则不再计算第⼆个表达式；
-  &：不管第⼀个表达式结果是否为 true，第⼆个都会执⾏。除此之外，& 还可以⽤作位运算符：当 & 两边的表达式 不是 Boolean 类型的时候，& 表示按位操作。



## 22. Java 的参数传递都是值传递

当传递⽅法参数类型为基本数据类型（数字以及布尔值）时，⼀个⽅法是不可能修改⼀个基本数据类型的参数。 当传递⽅法参数类型为引⽤数据类型时，⼀个⽅法将修改⼀个引⽤数据类型的参数所指向对象的值。即使 Java 函 数在传递引⽤数据类型时，也只是拷⻉了引⽤的值罢了，之所以能修改引⽤数据是因为它们同时指向了⼀个对象， 但这仍然是按值调⽤⽽不是引⽤调⽤



## 23. `a ^ b = | a - b |`



## 24. 如何实现对象的克隆

- 实现 `Cloneable` 接⼝并᯿写 `Object` 类中的 `clone()`⽅法；
- 实现 `Serializable` 接⼝，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆



## 25. 深克隆和浅克隆

- 浅克隆：拷⻉对象和原始对象的引⽤类型引⽤同⼀个对象。浅克隆只是复制了对象的引⽤地址，两个对象指 向同⼀个内存地址，所以修改其中任意的值，另⼀个值都会随之变化，这就是浅克隆。
- 深克隆：拷⻉对象和原始对象的引⽤类型引⽤不同对象。深拷⻉是将对象及值复制过来，两个对象修改其中 任意的值另⼀个值不会改变，这就是深拷⻉（例：`JSON.parse()` 和 `JSON.stringify()`，但是此⽅法⽆法复制函数类 型）。 



**补充：**

 深克隆的实现就是在引⽤类型所在的类实现 `Cloneable` 接⼝，并使⽤ public 访问修饰符᯿写 clone ⽅法。 Java 中定义的 clone 没有深浅之分，都是统⼀的调⽤ Object 的 clone ⽅法。

为什么会有深克隆的概念？是由于我 们在实现的过程中刻意的嵌套了 clone ⽅法的调⽤。也就是说深克隆就是在需要克隆的对象类型的类中᯿新实现克 隆⽅法 clone()



## 29. 类型擦除

泛型信息只存在于代码编译阶段，在进⼊ JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型 擦除。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 < T > 则会被转译成普通 的 Object 类型，如果指定了上限如 `< T extends String >` 则类型参数就被替换成类型上限。



```java
List<String> list = new ArrayList<String>();
```

**补充**

1. 两个 String 其实只有第⼀个起作⽤，后⾯⼀个没什么卵⽤，只不过 `JDK7` 才开始⽀持 `Listlist = new ArrayList<> `这种写法。
2. 第⼀个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作⽤，之后编译器会擦除泛 型占位符，以保证兼容以前的代码

