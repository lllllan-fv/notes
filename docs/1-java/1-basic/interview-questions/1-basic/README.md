---
# 这是页面的图标
icon: page

# 这是文章的标题
title: java 面试题 - 基础知识

# 设置作者
author: lllllan

# 设置写作时间
# time: 2020-01-20

# 一个页面只能有一个分类
category: Java

# 一个页面可以有多个标签
tag:
- 面试题

# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在首页的文章板块中
star: true

# 你可以自定义页脚
# footer: 
---

::: warning 

本文所有题目整理及答案全部来自 [帅地玩编程-校招|面试|学习路线](https://www.iamshuaidi.com/)，略有改动

:::





## 15. switch 能否作用在  `byte`、`long`、`String`上？

switch 中放的只能是一个整数表达式或枚举常量。而整数表达式可以是 `int` 或 `Integer`

- 由于 `byte`、`short`、`char` 都可以隐式转换为 `int`，因此这些类型以及他们的包装类都是可以用的。
- `long` 不可以
- `String` 在 JDK1.7 之后可以使用



## 16. Object 的常用方法

- `clone` ⽅法：⽤于创建并返回当前对象的⼀份拷⻉； 
- `getClass` ⽅法：⽤于返回当前**运⾏时对象**的 Class； 
- `toString` ⽅法：返回对象的字符串表示形式； 
- `finalize` ⽅法：实例被垃圾回收器回收时触发的⽅法； 
- `equals` ⽅法：⽤于⽐较两个对象的内存地址是否相等，⼀般需要重写； 
- `hashCode` ⽅法：⽤于返回对象的哈希值； 
- `notify` ⽅法：唤醒⼀个在此对象监视器上等待的线程。如果有多个线程在等待只会唤醒⼀个。 
- `notifyAll` ⽅法：作⽤跟 notify() ⼀样，只不过会唤醒在此对象监视器上等待的所有线程，⽽不是⼀个线程。 
- `wait` ⽅法：让当前对象等待



## 17. final、finally、finalize 的区别

- `final`：⽤于声明属性、⽅法和类，分别表示属性不可变、⽅法不可覆盖、被其修饰的类不可继承； 
- `finally`：异常处理语句结构的⼀部分，表示总是执⾏； 
- `finallize`：Object类的⼀个⽅法，在垃圾回收时会调⽤被回收对象的finalize



## 18. == 和 equals 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。



::: tip

因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

:::



**`equals()`** 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类。



## 19. 两个对象的 hashCode() 相同，则 equals() 也⼀定为 true 吗？

 两个对象的 hashCode() 相同，equals() 不⼀定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希 值相等，然⽽哈希值相等，并不⼀定能得出键值对相等【散列冲突】

更多详见 [JavaGuide - Java基础知识 | lllllan](../2-java-guide-basic/#_2-5-hashcode-与-equals)



## 20. 为什么重写 equals() 就⼀定要重写 hashCode() 方法

理解 hashCode 的作用👉 [JavaGuide - Java基础知识 | lllllan](../1-basic/2-java-guide-basic/#_2-5-hashcode-与-equals)



## 21. & 和 && 的区别

 Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算 结果才为 true，否则为 false。

- &&：有短路功能，当第⼀个表达式的值为 false 的时候，则不再计算第⼆个表达式；
-  &：不管第⼀个表达式结果是否为 true，第⼆个都会执⾏。除此之外，& 还可以⽤作位运算符：当 & 两边的表达式 不是 Boolean 类型的时候，& 表示按位操作。



## 22. Java 的参数传递都是值传递

当传递⽅法参数类型为基本数据类型（数字以及布尔值）时，⼀个⽅法是不可能修改⼀个基本数据类型的参数。 当传递⽅法参数类型为引⽤数据类型时，⼀个⽅法将修改⼀个引⽤数据类型的参数所指向对象的值。即使 Java 函 数在传递引⽤数据类型时，也只是拷⻉了引⽤的值罢了，之所以能修改引⽤数据是因为它们同时指向了⼀个对象， 但这仍然是按值调⽤⽽不是引⽤调⽤



## 23. `a ^ b = | a - b |`



## 24. 如何实现对象的克隆

- 实现 `Cloneable` 接⼝并᯿写 `Object` 类中的 `clone()`⽅法；
- 实现 `Serializable` 接⼝，通过对象的序列化和反序列化实现克隆，可以实现真正的深克隆



## 25. 深克隆和浅克隆

- 浅克隆：拷⻉对象和原始对象的引⽤类型引⽤同⼀个对象。浅克隆只是复制了对象的引⽤地址，两个对象指 向同⼀个内存地址，所以修改其中任意的值，另⼀个值都会随之变化，这就是浅克隆。
- 深克隆：拷⻉对象和原始对象的引⽤类型引⽤不同对象。深拷⻉是将对象及值复制过来，两个对象修改其中 任意的值另⼀个值不会改变，这就是深拷⻉（例：`JSON.parse()` 和 `JSON.stringify()`，但是此⽅法⽆法复制函数类 型）。 



**补充：**

 深克隆的实现就是在引⽤类型所在的类实现 `Cloneable` 接⼝，并使⽤ public 访问修饰符᯿写 clone ⽅法。 Java 中定义的 clone 没有深浅之分，都是统⼀的调⽤ Object 的 clone ⽅法。

为什么会有深克隆的概念？是由于我 们在实现的过程中刻意的嵌套了 clone ⽅法的调⽤。也就是说深克隆就是在需要克隆的对象类型的类中᯿新实现克 隆⽅法 clone()



## 26. Java 序列化

对象序列化是⼀个⽤于将对象状态转换为字节流的过程，可以将其保存到磁盘⽂件中或通过⽹络发送到任何其他程 序。从字节流创建对象的相反的过程称为反序列化。⽽创建的字节流是与平台⽆关的，在⼀个平台上序列化的对象 可以在不同的平台上反序列化。序列化是为了解决在对象流进⾏读写操作时所引发的问题。

 序列化的实现：将需要被序列化的类实现 `Serializable` 接⼝，该接⼝没有需要实现的⽅法，只是⽤于标注该对象是 可被序列化的，然后使⽤⼀个输出流（如：`FileOutputStream`）来构造⼀个 `ObjectOutputStream` 对象，接着使 ⽤ `ObjectOutputStream` 对象的 `writeObject(Object obj)` ⽅法可以将参数为 obj 的对象写出，要恢复的话则使⽤ 输⼊流



## 27. 什么时候需要序列化

- 当你想把的内存中的对象状态保存到⼀个⽂件中或者数据库中时候；
- 当你想⽤套接字在⽹络上传送对象的时候； 
- 当你想通过 `RMI` 传输对象的时候





## 28. Java 泛型是如何工作的

泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运⾏时不存在任何类型相关的 信息。例如：List 在运⾏时仅⽤⼀个 List 来表示。这样做的⽬的，是确保能和 Java 5 之前的版本开发⼆进 制类库进⾏兼容。



## 29. 类型擦除

泛型信息只存在于代码编译阶段，在进⼊ JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型 擦除。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 < T > 则会被转译成普通 的 Object 类型，如果指定了上限如 `< T extends String >` 则类型参数就被替换成类型上限。



```java
List<String> list = new ArrayList<String>();
```

**补充**

1. 两个 String 其实只有第⼀个起作⽤，后⾯⼀个没什么卵⽤，只不过 `JDK7` 才开始⽀持 `Listlist = new ArrayList<> `这种写法。
2. 第⼀个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作⽤，之后编译器会擦除泛 型占位符，以保证兼容以前的代码



## 30. 限定通配符

限定通配符对类型进⾏了限制。有两种限定通配符，⼀种是 `< ? extends T >`  它通过确保类型必须是 T 的⼦类来设定 类型的上界，另⼀种是 `< ? super T >` 它通过确保类型必须是 T 的⽗类来设定类型的下界。泛型类型必须⽤限定内的 类型来进⾏初始化，否则会导致编译错误。另⼀⽅⾯ < ? > 表示了⾮限定通配符，因为 < ? > 可以⽤任意类型来替 代。

