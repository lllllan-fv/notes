---
# 这是页面的图标
icon: page

# 这是文章的标题
title: Java 基础面试题

# 设置作者
author: lllllan

# 设置写作时间
# time: 2020-01-20

# 一个页面只能有一个分类
category: Java

# 一个页面可以有多个标签
tag:
- 面试题

# 此页面会在文章列表指定
# sticky: true

# 此页面会出现在首页的文章板块中
star: true

# 你可以自定义页脚
# footer: 
---

::: warning 

本文所有题目整理及答案全部来自 [帅地玩编程-校招|面试|学习路线](https://www.iamshuaidi.com/)，略有改动

:::



## 1. 面向对象和面向过程

**面向过程：**

面向过程的思想会将一件事情，拆分成一个个更具体的小任务，由一个个方法去完成他们。只要按顺序执行这些方法，就能完成这件事情。

**面向对象：**

面向对象的思想会把事物抽象成对象的概念，把一件事情拆分成一个个更具体的小问题，交由不同的对象分别完成以解决问题。

更详细生动的说明详见 [2分钟让你明白什么是面向对象编程](https://zhuanlan.zhihu.com/p/75265007)

| 项目名称 |                       面向对象程序设计                       |              面向过程程序设计（也叫结构化编程）              |
| :------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
|   定义   | 面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。 | 面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现main()函数中所要用到的其他方法。 |
|   特点   |                       封装、继承、多态                       |                        算法+数据结构                         |
|   优势   |                适用于大型复杂系统，方便复用、                |                   适用于简单系统，容易理解                   |
|   劣势   |                  比较抽象、性能比面向过程低                  |        难以应对复杂系统，难以复用，不易维护、不易扩展        |
|   对比   | 易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护 | 性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素 |
| 设计语言 |    Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等    |                          C、Fortran                          |



## 2. 面向对象三大特性

更多详见 [JavaGuide - Java基础知识 | lllllan](../2-java-guide-basic/#_4-6-面向对象三大特征)



### 2.1 封装

封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。



::: tip 封装的好处

- 隐藏实现细节，提供公共的访问方式
- 提高代码的复用性
- 提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）

:::



### 2.2 继承

继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。

1. 子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，**只是拥有**。
2. 子类可以拥有自己属性和方法，即子类可以对父类进行扩展。
3. 子类可以用自己的方式实现父类的方法。



::: tip 继承的优点

1. 提高代码的复用性
2. 提高代码的易维护性
3. 提高代码的可扩展性
4. 使代码结构清晰

:::



::: tip 继承的缺点

1. 高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类
2. 破坏封装性、降低灵活性

:::



### 2.3 多态

表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。

- 对象类型和引用类型之间具有继承（类）/实现（接口）的关系；
- 引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序**运行期间**才能确定；
- 多态不能调用“**只在子类存在但在父类不存在**”的方法；
- 如果子类重写了父类的方法，真正执行的是**子类覆盖**的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。



::: tip 多态存在的必要条件

1. 要有继承
2. 要有重写
3. **父类引用指向子类对象**

::: 



::: tip 多态的好处

1. 提高了代码的可扩展性
2. 可替换性
3. 接口性：向子类提供共同接口，由子类来完善或覆盖
4. 灵活性
5. 简化性

::: 



## 3. JDK、JRE、JVM三者关系

JDK 是 Java 开发工具包、JRE 是 Java 运行环境、JVM 是 Java 虚拟机。



::: tip JDK > JRE > JVM

1. JVM不能单独执行class
2. JRE = JVM + lib（jvm工作需要的类库）。可以执行class
3. JDK包含JRE。可以开发、编译、执行

:::



## 4. 重载和重写

- 重载：编译时多态，同一个类中同名的方法具有不同的参数列表、返回类型。
- 重写：运行时多态，子类重写父类的方法实现不同的功能，具有相同的参数列表、返回类型。

更多详见 [JavaGuide - Java基础知识 | lllllan](../2-java-guide-basic/#_2-1-静态方法为什么不能调用非静态方法)

​	

## 5. Java 中是否可以重写一个 private 或者 static 方法？

重写，又称覆盖，是在运行时绑定的。

- 子类不能访问或使用父类中的 private 方法，因此不能实现重写
- static 方法是编译时静态绑定的，就算子类中再写了一个同名同参的相同方法，也只是两个毫不相干的方法，不能称为重写。



## 6. 构造器是否可以被重写？

父类的私有属性、方法以及构造器都是不能被重写的。



## 7. 构造⽅法有哪些特性

1. 名字与类名相同
2. 没有返回值，但不能⽤ void 声明构造函数
3. 成类的对象时⾃动执⾏，⽆需调⽤



## 8. 无参构造函数的作用

1. 不写任何构造器，也会有一个默认的无参构造。但如果写了有参构造，就必须另写一个无参构造，否则就无法执行无参构造。
2. 子类的构造当中，如果没有指定 super() 来调用父类中某个构造方法，则会调用父类中的无参构。如果这个时候父类中存在有参构造而没有无参构造，就会出错。



## 9. Java 中创建对象的几种方式

1. `new()`
2. `Class.forName().newInstance()`
3. `clone()`
4. `ObjectInputStream.readObject()`



## 10. 抽象类和接口的区别

1. 抽象类中可以定义构造函数，接口不能定义构造函数
2. 抽象类中可以有抽象方法和具体方法，接口中只能有抽象方法
3. 抽象类中的成员权限可以是 `public`、默认、`protected`，**抽象方法不能被 `private` 修饰**，具体方法可以；接口中的成员只能是 `public`
4. 抽象类中可以包含静态方法（**具体方法可以是静态的，抽象方法不行**），接口中不能包含静态方法（因为接口中定义的方法就是为了让实现类去实现，但是静态方法必须在编译时实现）



### 10.1 JDK8 的改变

1. 允许在接口中包含具体实现的方法，使用 `default` 修饰
2. 因为允许具体实现的放，接口中也就允许有静态方法



## 11. 静态变量和实例变量的区别

- 静态变量：被 `static` 修饰，也称类变量。它属于类，因此不管创建多少个对象，该静态变量在内存中有且仅有一个拷贝。静态变量可以实现多个对象共享内存
- 实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问得到



## 12. `short s1 = 1; s1 = s1 + 1` 为什么错？ `short s1 = 1; s1 += 1` 为什么没错？

运算中的 `1` 默认是 `int`类型，那么将 `int` 类型赋值给 `short` 类型时，会出现类型转换错误。

而对于 `+=`，是 Java 语言规定的运算符， Java 编译器自己会进行特殊处理



## 13. Integer 和 int 的区别？ 

1. int 是 Java 的⼋种基本数据类型之⼀，⽽ `Integer` 是 Java 为 int 类型提供的封装类
2. int 型变量的默认值是 0，Integer 变量的默认值是 null，这⼀点说明 Integer 可以区分出未赋值和值为 0 的 区分
3. Integer 变量必须实例化后才可以使⽤，⽽ int 不需要。



### 13.1 Integer 之间的比较

1. 两个 `new()` 出来的 `Integer` 进行比较：因为是两个对象，进行比较的其内存地址，结果均为 false
2. `Integer` 和 `int` 进行比较：包装类和基本数据类型进行比较时，会对包装类进行拆包装为基本数据类型，所以最后是两个 `int` 在比较。只要数值相等就为 true
3. 非new生成的 `Integer` 和 `new integer()` 进行比较：前者指向 Java 常量池中的对象、后者指向堆中的对象，内存地址不同，结果均为 false
4. 两个非new生成的 `Integer` 进行比较：如果数值相等并且变量值在 `[-128, 127]` 之间，比较结果为 true，否则为 false。

```java
public static Integer valueOf(int var0) { 
    return var0 >= -128 && var0 <= Integer.IntegerCache.high ?
		Integer.IntegerCache.cache[var0 + 128] : new Integer(var0);
}
```



### 13.2 包装类的缓存

- Boolean：全部缓存 
- Byte：全部缓存 
- Character：<= 127 缓存 
- Short：-128 — 127 缓存 
- Long：-128 — 127 缓存 
- Integer：-128 — 127 缓存 
- Float：没有缓存 
- Doulbe：没有缓存



### 14 装箱和拆箱

⾃动装箱是 Java 编译器在基本数据类型和对应得包装类之间做的⼀个转化。⽐如：把 int 转化成 Integer，double 转化成 Double 等等。反之就是⾃动拆箱。 

原始类型：boolean、char、byte、short、int、long、float、double 

封装类型：Boolean、Character、Byte、Short、Integer、Long、Float、Double



## 15. switch 能否作用在  `byte`、`long`、`String`上？

switch 中放的只能是一个整数表达式或枚举常量。而整数表达式可以是 `int` 或 `Integer`

- 由于 `byte`、`short`、`char` 都可以隐式转换为 `int`，因此这些类型以及他们的包装类都是可以用的。
- `long` 不可以
- `String` 在 JDK1.7 之后可以使用



## 16. Object 的常用方法

- `clone` ⽅法：⽤于创建并返回当前对象的⼀份拷⻉； 
- `getClass` ⽅法：⽤于返回当前**运⾏时对象**的 Class； 
- `toString` ⽅法：返回对象的字符串表示形式； 
- `finalize` ⽅法：实例被垃圾回收器回收时触发的⽅法； 
- `equals` ⽅法：⽤于⽐较两个对象的内存地址是否相等，⼀般需要重写； 
- `hashCode` ⽅法：⽤于返回对象的哈希值； 
- `notify` ⽅法：唤醒⼀个在此对象监视器上等待的线程。如果有多个线程在等待只会唤醒⼀个。 
- `notifyAll` ⽅法：作⽤跟 notify() ⼀样，只不过会唤醒在此对象监视器上等待的所有线程，⽽不是⼀个线程。 
- `wait` ⽅法：让当前对象等待



## 16. final、finally、finalize 的区别

- `final`：⽤于声明属性、⽅法和类，分别表示属性不可变、⽅法不可覆盖、被其修饰的类不可继承； 
- `finally`：异常处理语句结构的⼀部分，表示总是执⾏； 
- `finallize`：Object类的⼀个⽅法，在垃圾回收时会调⽤被回收对象的finalize



## 17. == 和 equals 的区别

**`==`** 对于基本类型和引用类型的作用效果是不同的：

- 对于基本数据类型来说，`==` 比较的是值。
- 对于引用数据类型来说，`==` 比较的是对象的内存地址。



::: tip

因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。

:::



**`equals()`** 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。`equals()`方法存在于`Object`类中，而`Object`类是所有类的直接或间接父类。



## 18. 两个对象的 hashCode() 相同，则 equals() 也⼀定为 true 吗？

 两个对象的 hashCode() 相同，equals() 不⼀定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希 值相等，然⽽哈希值相等，并不⼀定能得出键值对相等【散列冲突】

更多详见 [JavaGuide - Java基础知识 | lllllan](../2-java-guide-basic/#_2-5-hashcode-与-equals)



## 19. 为什么重写 equals() 就⼀定要重写 hashCode() 方法

理解 hashCode 的作用👉 [JavaGuide - Java基础知识 | lllllan](../1-basic/2-java-guide-basic/#_2-5-hashcode-与-equals)



## 20. & 和 && 的区别

 Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算 结果才为 true，否则为 false。

- &&：有短路功能，当第⼀个表达式的值为 false 的时候，则不再计算第⼆个表达式；
-  &：不管第⼀个表达式结果是否为 true，第⼆个都会执⾏。除此之外，& 还可以⽤作位运算符：当 & 两边的表达式 不是 Boolean 类型的时候，& 表示按位操作。

