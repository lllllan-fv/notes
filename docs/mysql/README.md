---
# 这是页面的图标
icon: page

# 这是文章的标题
title: MySQL 面试题合集

# 设置作者
author: lllllan

# 设置写作时间
# time: 2020-01-20

# 一个页面只能有一个分类
category: 数据库

# 一个页面可以有多个标签
tag:

# 此页面会在文章列表置顶
# sticky: true

# 此页面会出现在首页的文章板块中
star: true

# 你可以自定义页脚
# footer: 
---



::: warning 转载自一下文章，略有改动

- [SQL：多表查询](https://zhuanlan.zhihu.com/p/91973413)
- [MySQL中的悲观锁](https://www.jianshu.com/p/8a70a4af7eac)
- [什么是乐观锁，什么是悲观锁 - 简书 (jianshu.com)](https://www.jianshu.com/p/d2ac26ca6525)
- [数据库——彻底明白超键、候选键、主键、外键](https://blog.csdn.net/jerry11112/article/details/78160771)

:::



## 数据库【常识】



### 数据三范式

1. 第一范式：属性不可再分
2. 第二范式：第一范式基础上，消除了非主属性对于码的部分函数依赖
3. 第三范式，第二范式基础上，消除了非主属性对于码的传递函数依赖





## 事务

**事务：** 多条sql语句，要么全部成功，要么全部失败。



### 事务的特性

- **原子性 - Atomicity：** 一个事务是一个不可分割的工作单位，事务中包括的操作要么都做，要么都不做。

- **一致性 - Consistency：** 事务的执行使数据从一个状态转换为另一个状态，但是对于整个数据的完整性保持稳定。

    > 比如A转账100元给B，不管操作是否成功，A和B的账户总额是不变的。

- **隔离性 - Isolation：** 一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

- **持久性 - Durability：** 一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。



### 并发事务带来的问题

1. **脏读：** 脏读又称无效数据的读出，是指在数据库访问中，事务T1将某一值修改，然后事务T2读取该值，此后T1因为某种原因撤销对该值的修改，这就导致了T2所读取到的数据是无效的，值得注意的是，脏读一般是针对于update操作的。

2. **丢失修改：** 两个事务同时访问并修改了同一个数据，但最后只保留了其中一个修改，而丢失了另一个修改

    > 事务1、2同时读取表中的数据 `A = 20`，并且都做了相同的修改 `A = A - 1`。两次修改应该让 `A = A - 2 = 18`，但是因为 **丢失修改** ，只有一次修改成功，最后数据变成 `A = A - 1 = 19`

3. **不可重复读：** 由于一个事务对数据的修改，导致另一个事务对这个数据的两次访问前后不一致
4. **幻读：** 由于一个事务插入了新的数据，导致另一个事务的某次查询比之前多了一些本来不存在的记录



::: info 不可重复读和幻读的区别

- 不可重复读的重点是 **修改** ，导致另一个事务对某个数据的访问前后不一致
- 幻读的重点在于 **新增或删除** ，导致另一个事务多次读取记录时发现增多或减少

:::



### 事务隔离级别

1. **READ-UNCOMMITTED 读取未提交：** 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致 脏读、幻读、不可重复读
2. **READ-COMMITTED 读取已提交：** 允许读取并发事务已提交的数据，可以阻止脏读，但是幻读和不可重复读扔有可能发生
3. **REPEATABLE-READ 可重复读：** 对同意字段的多次读取结果是一致的，除非数据被本身事务修改，可以阻止脏读和不可重复度，但幻读仍有可能发生
4. **SERIALZABLE 可串行化：** 最高的隔离级别，所有的事务依次逐个执行，事务之间不可能产生干扰。

|     隔离级别     | 脏读 | 不可重复读 | 幻读 |
| :--------------: | :--: | :--------: | :--: |
| READ-UNCOMMITTED |  √   |     √      |  √   |
|  READ-COMMITTED  |      |     √      |  √   |
| REPEATABLE-READ  |      |            |  √   |
|   SERIALIZABLE   |      |            |      |



::: tip MySQL 的默认隔离级别

InnoDB 存储引擎在 ==**REPEATABLE-READ**== 事务隔离级别下使用的是 ==**Next-Key Lock算法**== ，可以做到避免幻读。

因为隔离的级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是 **READ-COMMITTED**，而 InnoDB 默认使用 **REPEATABLE-READ** 既能达到最高的隔离级别、也不会任何性能损失。

==InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到 **SERIALIZABLE** 隔离级别==

:::



## 索引

在关系数据库中，索引是一种**单独的、物理的**对数据库表中一列或多列的值进行排序的一种 ==存储结构== ，它是某个表中<u>一列或若干列值的集合和相应的指向表中物理标识这些值的数据页的逻辑指针清单</u>。索引的作用相当于图书的目录，可以根据目录中的页码快速找到所需的内容。



### 索引的优缺点

**优点**

1. 大大加快数据的检索速度
2. 创建唯一性索引，保证数据库表中每一行数据的唯一性
3. 加速表和表之间的连接
4. 在使用分组和排序子句进行数据检索时，可以显著减少查询中分组和排序的时间。



**缺点**

1. 索引需要占物理空间。
2. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，降低了数据的维护速度。



### 聚簇索引

[聚簇索引与非聚簇索引（也叫二级索引） - 简书 (jianshu.com)](https://www.jianshu.com/p/fa8192853184)

[《高性能MySQL》读后感——聚簇索引 - 简书 (jianshu.com)](https://www.jianshu.com/p/54c6d5db4fe6)



### 什么时候不要使用索引

- 经常增删改的列不要建立索引
- 有大量重复的列不要建立索引
- 表记录太少不要建立索引







## MySQL 存储引擎及使用场景



### 什么是存储引擎

**数据库引擎是数据库 ==底层软件组织==**

MySQL中的数据用各种不同的技术存储在文件（或者内存）中。这些技术中的每一种技术都使用不同的存储机制、索引技巧、锁定水平并且最终提供广泛的不同的功能和能力。通过选择不同的技术，你能够获得额外的速度或者功能，从而改善你的应用的整体功能。



### MySQL 各种存储引擎

|     功能     | MyISAM  | MEMORY  |   InnoDB   | Archive |
| :----------: | :-----: | :-----: | :--------: | :-----: |
|   存储限制   |  256TB  |   RAM   |    64TB    |  None   |
|   支持事务   |   No    |   No    |  ==Yes==   |   No    |
| 支持全文索引 | ==Yes== |   No    |     No     |   No    |
|  支持树索引  |   Yes   |   Yes   |    Yes     |   No    |
| 支持哈希索引 |   No    | ==Yes== |     No     |   No    |
| 支持数据缓存 |   No    |   N/A   |  ==Yes==   |   No    |
|   支持外键   |   No    |   No    |  ==Yes==   |   No    |
|      锁      | 全表锁  | 全表锁  | ==行级锁== |         |



### 存储引擎的选择

1. 如果需要提供提交、回滚和恢复的 ==事务安全== 能力，并要求 ==并发控制==  → InnoDB
2. 如果数据表主要用来 ==插入和查询== 记录 → MyISAM
3. 如果只是临时存放数据，==数据量不大==，并且**不需要提高数据的安全性** → MEMORY
4. 如果 ==只有插入和查询== → Archive，支持高并发的插入，但是非事务安全



### MyISAM 和 InnoDB 的区别

**区别：**

1. InnoDB 支持事务，MyISAM 不支持事务。这是 MySQL 将默认存储引擎从 MyISAM 编程的 InnoDB 的重要原因之一。
2. InnoDB 支持外键，MyISAM 不支持。
3. InnoDB 是聚集索引，MyISAM 是非聚集索引。
4. InnoDB 不保存表的具体行数，执行 `select count(*) from table` 需要全表扫描。 而 MyISAM 用一个变量保存了整个表的行数，查询行数时速度更快。
5. InnoDB 最小的锁粒度是行锁，MyISAM 最小的锁粒度是表锁。一个更新语句会锁住整张表，导致其他查询和更新都会被阻塞，因此并发访问受限。



**如何选择：**

1. 需要支持事务，InnoDB
2. 主要是查询工作，MyISAM；如果读写也频繁，InnoDB
3. MyISAM 系统崩溃后恢复更困难





## 关键字



### drop、delete、truncate



- drop 丢弃数据：`drop table`，直接删除表
- truncate 清空数据：`truncate table`，值删除表中的数据，再插入数据时自增id又从1开始
- delete 删除数据：`delete from table where ?`，删除某一列的数据



::: note 执行速度

一般来说：drop > truncate > delete

- `delete`命令执行的时候会产生数据库的`binlog`日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。
- `truncate`命令执行的时候不会产生数据库日志，因此比`delete`要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。
- `drop`命令会把表占用的空间全部释放掉。

 :::



### varchar 和 char 的区别

- char 固定长度，加入申请了 `char(10)` ，那么无论实际存储多少内容，该字段都占用了10个字符
- varchr 是变长，申请的只是最大长度，占用的控件时实际的字符长度+1

从效率角度 `char > varchar` ，因此使用中如果确定某字段值的长度，可以使用 char，否则应该尽量使用 varchar



###  varchar(10) 和 int(10)

varchar的10代表了申请的空间长度,也是可以存储的数据的最大长度,而int的10只是代表了展示的长度,不足10位以0填充.也就是说,int(1)和int(10)所能存储的数字大小以及占用的空间都是相同的,只是在展示时按照长度展示.



## 查询

![img](README.assets/v2-ab43140ca2435d62d1bf501051cc558a_720w.jpg)




