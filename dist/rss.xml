<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vue-blog.lllllan.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>lllllan notes</title>
    <link>https://vue-blog.lllllan.cn/</link>
    <description></description>
    <language>en-US</language>
    <pubDate>Thu, 20 Jan 2022 14:32:05 GMT</pubDate>
    <lastBuildDate>Thu, 20 Jan 2022 14:32:05 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by lllllan</copyright>
    <category>Java</category>
    <category>刷题</category>
    <category>计算机基础</category>
    <category>使用指南</category>
    <category>MySQL</category>
    <item>
      <title>R2Coding - Java 基础核心总结</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/1-java-basic-core-summary/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/1-java-basic-core-summary/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">R2Coding - Java 基础核心总结</source>
      <category>Java</category>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>全部抄自<a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a>上提供资料</p>
</div>
<h2 id="一、-java语言的特点"> 一、 java语言的特点</h2>
<ul>
<li>面向对象</li>
<li>平台无关性</li>
</ul>
<blockquote>
<p>已编译的java程序可以在任何带 有jvm的平台上运行。</p>
<p><code>java</code> 代码编译为 <code>.class</code> 文件，然后打包成 <code>.jar</code> 文件，这样就能够在不同系统下运行了。</p>
</blockquote>
<ul>
<li>简单性</li>
</ul>
<blockquote>
<p>摒弃了C++中难以理解的多继承、指针、内存管理等概念，不用手动管理对象的生命周期</p>
</blockquote>
<ul>
<li>解释执行</li>
</ul>
<blockquote>
<p>静态页面，在编译期间救恩那个直到数据类型的语言，在运行前就能检查类型的正确性。</p>
<p>执行效率相比动态语言更高，速度更快</p>
</blockquote>
<ul>
<li>多线程</li>
</ul>
<blockquote>
<p>java <strong>应该</strong> 在 <code>用户空间</code> 实现的多线程，内核感知不到 java 存在多线程机制。</p>
</blockquote>
<ul>
<li>分布式</li>
</ul>
<blockquote>
<p><img src="./README.assets/image-20211213091134933.png" alt="image-20211213091134933" /></p>
</blockquote>
<ul>
<li>健壮性</li>
</ul>
<blockquote>
<p>强类型机制、异常处理、垃圾的自动收集</p>
</blockquote>
<ul>
<li>高性能</li>
</ul>
<blockquote>
<p><img src="./README.assets/image-20211213090952974.png" alt="image-20211213090952974" /></p>
</blockquote>
<ul>
<li>安全性</li>
</ul>
<h2 id="二、面向对象"> 二、面向对象</h2>
<h3 id="_2-1-初始化顺序"> 2.1 初始化顺序</h3>
<blockquote>
<ul>
<li>静态属性</li>
<li>静态方法快</li>
<li>普通方法</li>
<li>普通方法块</li>
<li>构造函数</li>
<li>方法</li>
</ul>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>static</span> <span>String</span> staticField <span>=</span> <span>getStaticField</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>String</span> <span>getStaticField</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> staticFiled <span>=</span> <span>"静态属性初始化"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>staticFiled<span>)</span><span>;</span>
        <span>return</span> staticFiled<span>;</span>
    <span>}</span>

    <span>static</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"静态方法块初始化"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>String</span> field <span>=</span> <span>getField</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>String</span> <span>getField</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> field <span>=</span> <span>"普通属性初始化"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>field<span>)</span><span>;</span>
        <span>return</span> field<span>;</span>
    <span>}</span>

    <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"普通方法块初始化"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Solution</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"构造函数"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code>静态属性初始化
静态方法块初始化
普通属性初始化
普通方法块初始化
构造函数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><hr>
<h3 id="_2-2-三大特性"> 2.2 三大特性</h3>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h4 id="访问控制权限"> 访问控制权限</h4>
<p><img src="./README.assets/image-20211217195521425.png" alt="image-20211217195521425" /></p>
<hr>
<h3 id="_2-3-接口"> 2.3 接口</h3>
<ul>
<li>interface、implements</li>
<li>接口只能使用 <code>public</code> <code>default</code>  两种访问修饰符</li>
<li>接口只提供方法的定义。</li>
<li>接口不能被实例化，所以接口中不能有构造方法。</li>
<li>接口的实现类必须实现接口的全部方法。</li>
</ul>
<hr>
<h3 id="_2-4-抽象类"> 2.4 抽象类</h3>
<ul>
<li>abstract</li>
<li>只有抽象类中能有抽象方法，抽象类中不只有抽象方法。</li>
<li>抽象类不能被实例化。</li>
</ul>
<hr>
<h3 id="_2-5-内部类"> 2.5 内部类</h3>
<ul>
<li>内部类拥有外部类的访问权限</li>
</ul>
<p><img src="./README.assets/image-20211217195726947.png" alt="image-20211217195726947" /></p>
<h2 id="三、异常"> 三、异常</h2>
<h3 id="_3-1-throwable"> 3.1 Throwable</h3>
<p><code>Throable</code> 类是Java语言中所有 <code>错误(errors)</code> 和 <code>异常(exceptions)</code> 的父类。</p>
<p><img src="./README.assets/image-20211217184906894.png" alt="image-20211217184906894" /></p>
<h3 id="_3-2-常见异常"> 3.2 常见异常</h3>
<p><img src="./README.assets/image-20211217193021056.png" alt="image-20211217193021056" /></p>
<h3 id="_3-3-error"> 3.3 Error</h3>
<p><img src="./README.assets/image-20211217194119016.png" alt="image-20211217194119016" /></p>
<h2 id="四、集合"> 四、集合</h2>
<p><img src="./README.assets/image-20211218142929505.png" alt="image-20211218142929505" /></p>
<p><img src="./README.assets/image-20211218182136734.png" alt="image-20211218182136734" /></p>
<h2 id="五、反射"> 五、反射</h2>
<p>Java反射机制是在程序的运行过程中，对于任何一个类，都能知道它的所有属性和方法；对于任意一个对象，都能知道调用它的任意属性和方法。</p>
<p>这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时判断任意一个类的对象</li>
<li>在运行时判断任意一个类所有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<h3 id="_5-1-class-类"> 5.1 Class 类</h3>
<p>当我们编写一个类，在生产的<code>.class</code> 文件中，就会产生一个 Class 对象。这个 Class 对象用于标识这个类的类型信息。</p>
<p>Class中没有公共的构造器，也就是说Class对象不能杯实例化。</p>
<p>其中包含了很多方法，详见《Java基础核心总结》P54</p>
<h3 id="_5-2-field-类"> 5.2 Field 类</h3>
<p>Field 类提供类或接口中单独字段的信息，以及对单独字段的动态访问。</p>
<h3 id="_5-3-method-类"> 5.3 Method 类</h3>
<p>传递 Object 对象及参数调用该对象对应的方法</p>
<h3 id="_5-4-classloader-类"> 5.4 ClassLoader 类</h3>
<p>类装载器是用来把类装载进JVM的。ClassLoader使用的是双亲委托模型来搜索加载类的。</p>
<p><img src="./README.assets/image-20211224112354940.png" alt="image-20211224112354940" /></p>
<h2 id="六、枚举"> 六、枚举</h2>
<p>枚举是一个特殊的类，一般表示一组常量</p>
<div><pre><code><span>public</span> <span>enum</span> <span>Family</span> <span>{</span>
    FATHER<span>,</span>
    MOTHER<span>,</span>
    SON<span>,</span>
    <span>Daughter</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./README.assets/image-20211224185753390.png" alt="image-20211224185753390" /></p>
<p>一般 switch 可以和 enum 一起连用，来构造一个小型的状态转换机</p>
<div><pre><code><span>enum</span> <span>Signal</span> <span>{</span>
    GREEN<span>,</span> YELLOW<span>,</span> RED
<span>}</span>
<span>public</span> <span>class</span> <span>TrafficLight</span> <span>{</span>
    <span>Signal</span> color <span>=</span> <span>Signal</span><span>.</span>RED<span>;</span>
    <span>public</span> <span>void</span> <span>change</span><span>(</span><span>)</span> <span>{</span>
        <span>switch</span> <span>(</span>color<span>)</span> <span>{</span>
            <span>case</span> RED<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>GREEN<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> YELLOW<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>RED<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> GREEN<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>YELLOW<span>;</span>
                <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="七、io"> 七、IO</h2>
<p><img src="./README.assets/image-20211224191321306.png" alt="image-20211224191321306" /></p>
<p><img src="./README.assets/image-20211224191353166.png" alt="image-20211224191353166" /></p>
<h3 id="_7-1-file-类"> 7.1 File 类</h3>
<p>主要涉及 <strong>文件创建、删除文件、获取文件描述</strong></p>
<p><img src="./README.assets/image-20211224191614348.png" alt="image-20211224191614348" /></p>
<h3 id="_7-2-inputstream"> 7.2 InputStream</h3>
<p>字节输入模式的抽象类</p>
<p><img src="./README.assets/image-20211224191724340.png" alt="image-20211224191724340" /></p>
<h3 id="_7-3-outputstream"> 7.3 OutputStream</h3>
<p>字节输出模式的抽象类</p>
<p><img src="./README.assets/image-20211224191752947.png" alt="image-20211224191752947" /></p>
<h3 id="_7-4-reader"> 7.4 Reader</h3>
<p>字符输入模式的抽象类</p>
<p><img src="./README.assets/image-20211224191816351.png" alt="image-20211224191816351" /></p>
<h3 id="_7-5-writer"> 7.5 Writer</h3>
<p>字符输出模式的抽象类</p>
<p><img src="./README.assets/image-20211224191839037.png" alt="image-20211224191839037" /></p>
<h3 id="_7-6-更多其他子类"> 7.6 更多其他子类</h3>
<p>详见 《Java基础核心总结》 p67</p>
<h2 id="插眼"> 插眼：</h2>
<h3 id="jdk、jre、jvm"> JDK、JRE、JVM</h3>
<h3 id="switch-实现原理"> switch 实现原理</h3>
<h3 id="深浅拷贝"> 深浅拷贝</h3>
<h3 id="代理-意义何在"> 代理，意义何在</h3>
<h3 id="面向对象三大特性"> 面向对象三大特性</h3>
<h3 id="修饰符"> 修饰符</h3>
<h3 id="集合"> 集合</h3>
]]></content:encoded>
    </item>
    <item>
      <title>java 是值传递</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/1-java-value-passed/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/1-java-value-passed/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">java 是值传递</source>
      <category>Java</category>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>全部抄自 <a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java/" target="_blank" rel="noopener noreferrer">为什么 Java 中只有值传递？ | JavaGuide</a>，略有改动</p>
</div>
<h2 id="值传递-引用传递"> 值传递 &amp; 引用传递</h2>
<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h2 id="实例"> 实例</h2>
<h3 id="对基本数据类型进行修改"> 对基本数据类型进行修改</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>
    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>int</span> temp <span>=</span> a<span>;</span>
    a <span>=</span> b<span>;</span>
    b <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a = "</span> <span>+</span> a<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b = "</span> <span>+</span> b<span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
    
a <span>=</span> <span>20</span>
b <span>=</span> <span>10</span>
num1 <span>=</span> <span>10</span>
num2 <span>=</span> <span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>a和b只是从num1和num2复制得到了值，怎么操作都不会产生影响</li>
</ul>
<p><img src="./README.assets/java-value-passing-01.ab88fb01.png" alt="基本数据类型参数" /></p>
<h3 id="修改引用类型中的值"> 修改引用类型中的值</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>change</span><span>(</span>arr<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
    <span>// 将数组的第一个元素变为0</span>
    array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
   
<span>1</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src="./README.assets/java-value-passing-02.ff1b76c9.png" alt="引用数据类型参数1" /></p>
<h3 id="修改引用类型的对象"> 修改引用类型的对象</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
   <span>// 省略构造函数、Getter&amp;Setter方法</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Person</span> xiaoZhang <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
    <span>Person</span> xiaoLi <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小李"</span><span>)</span><span>;</span>
    <span>swap</span><span>(</span>xiaoZhang<span>,</span> xiaoLi<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoZhang:"</span> <span>+</span> xiaoZhang<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoLi:"</span> <span>+</span> xiaoLi<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>
    <span>Person</span> temp <span>=</span> person1<span>;</span>
    person1 <span>=</span> person2<span>;</span>
    person2 <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person1:"</span> <span>+</span> person1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person2:"</span> <span>+</span> person2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
    
person1<span>:</span>小李
person2<span>:</span>小张
xiaoZhang<span>:</span>小张
xiaoLi<span>:</span>小李
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><img src="./README.assets/java-value-passing-03.da4d0422.png" alt="引用数据类型参数2" /></p>
<h2 id="总结"> 总结</h2>
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>反射机制</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/2-reflection/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/2-reflection/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">反射机制</source>
      <category>Java</category>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>全部抄自 <a href="https://javaguide.cn/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">反射机制详解！ | JavaGuide</a>，列有改动</p>
</div>
<blockquote>
<p>总之反射就是能获取一个类的所有方法和属性，并能够调用。</p>
<p>然后还能增加代码的灵活性。</p>
<p>但是，我还是没有感受到，灵活在哪里。。。</p>
</blockquote>
<h2 id="什么是反射"> 什么是反射？</h2>
<p>反射就是Reflection，Java的反射是指程序在<strong>运行期</strong>可以拿到一个对象的所有信息，，你还可以调用这些方法和属性。</p>
<h2 id="反射的应用场景"> 反射的应用场景</h2>
<ul>
<li>模块化的开发，通过反射去调用对应的字节码</li>
<li>框架中大量使用动态代理，而动态代理依赖反射机制实现</li>
<li>注解的实现也用到了反射</li>
</ul>
<p><strong>JDBC的数据库连接</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>String</span> DBDRIVER <span>=</span> <span>"com.mysql.jdbc.Driver"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBURL <span>=</span> <span>"jdbc:mysql://localhost:3306/test"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBUSER <span>=</span> <span>"root"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBPASS <span>=</span> <span>""</span><span>;</span>  

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>  
    <span>Connection</span> con <span>=</span> <span>null</span><span>;</span>
    <span>Class</span><span>.</span><span>forName</span><span>(</span>DBDRIVER<span>)</span><span>;</span> <span>//1、使用CLASS 类加载驱动程序 ,反射机制的体现 </span>
    con <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>DBURL<span>,</span>DBUSER<span>,</span>DBPASS<span>)</span><span>;</span> <span>//2、连接数据库  </span>
    <span>.</span><span>.</span><span>.</span>
    con<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> <span>// 3、关闭数据库  </span>
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="反射的优缺点"> 反射的优缺点</h2>
<p><strong>优点：</strong> 让代码更加灵、为各种框架提供开箱即用的功能提供便利</p>
<p><strong>缺点：</strong> 在运行时有了分析操作类的能力，同样增加了安全问题。性能略差，不过对于框架的影响比较小。</p>
<h2 id="反射的使用"> 反射的使用</h2>
<h3 id="获取class对象的四种方式"> 获取Class对象的四种方式</h3>
<p><strong>1.知道具体类的情况下可以使用</strong></p>
<div><pre><code><span>Class</span> alunbarClass <span>=</span> <span>TargetObject</span><span>.</span><span>class</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2.通过 <code>Class.forName()</code> 传入类的路径获取</strong></p>
<div><pre><code><span>Class</span> alunbarClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>3.通过对象实例 <code>instance.getClass()</code> 获取</strong></p>
<div><pre><code><span>TargetObject</span> o <span>=</span> <span>new</span> <span>TargetObject</span><span>(</span><span>)</span><span>;</span>
<span>Class</span> alunbarClass2 <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取</strong></p>
<div><pre><code><span>Class</span> clazz <span>=</span> <span>ClassLoader</span><span>.</span><span>loadClass</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="反射的基本操作"> 反射的基本操作</h3>
<p><strong>1.定义一个类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>TargetObject</span> <span>{</span>
    <span>private</span> <span>String</span> value<span>;</span>

    <span>public</span> <span>TargetObject</span><span>(</span><span>)</span> <span>{</span>
        value <span>=</span> <span>"JavaGuide"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>publicMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I love "</span> <span>+</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>privateMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"value is "</span> <span>+</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>2.使用反射来操作这个类的方法及参数</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span><span>,</span> <span>NoSuchMethodException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InstantiationException</span><span>,</span> <span>InvocationTargetException</span><span>,</span> <span>NoSuchFieldException</span> <span>{</span>
        <span>/**
         * 获取TargetObject类的Class对象并且创建TargetObject类实例
         */</span>
        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
        <span>TargetObject</span> targetObject <span>=</span> <span>(</span><span>TargetObject</span><span>)</span> tagetClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>/**
         * 获取所有类中所有定义的方法
         */</span>
        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> tagetClass<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>/**
         * 获取指定方法并调用
         */</span>
        <span>Method</span> publicMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"publicMethod"</span><span>,</span>
                <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>

        publicMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 获取指定参数并对参数进行修改
         */</span>
        <span>Field</span> field <span>=</span> tagetClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
        <span>//为了对类中的参数进行修改我们取消安全检查</span>
        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        field<span>.</span><span>set</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 调用 private 方法
         */</span>
        <span>Method</span> privateMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"privateMethod"</span><span>)</span><span>;</span>
        <span>//为了调用private方法我们取消安全检查</span>
        privateMethod<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        privateMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>3.输出结果</strong></p>
<div><pre><code>publicMethod
privateMethod
<span>I</span> love <span>JavaGuide</span>
value is <span>JavaGuide</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JavaGuide - Java基础知识</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/2-java-guide-basic/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/2-java-guide-basic/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">JavaGuide - Java基础知识</source>
      <category>Java</category>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>全部抄自<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide</a>，略有改动</p>
</div>
<h2 id="一-基础概念与常识"> 一 基础概念与常识</h2>
<h3 id="_1-1-java语言的特点"> 1.1 Java语言的特点</h3>
<ol>
<li>简单易学</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机，一次编译到处运行）</li>
<li>解释执行（编译成字节码文件，java解释器对字节码进行解释执行）</li>
<li>多线程</li>
<li>分布式（强大、易于使用的联网能力）</li>
<li>高性能（相对其他高级语言，<a href="https://zhuanlan.zhihu.com/p/361250220" target="_blank" rel="noopener noreferrer">JIT</a>的发展）</li>
<li>健壮性（强类型机制、异常处理、垃圾回收机制）</li>
<li>安全性（安全机制以防止恶意代码的攻击）</li>
<li></li>
</ol>
<h3 id="_1-2-jvm-jdk-jre"> 1.2 JVM &amp; JDK &amp; JRE</h3>
<ol>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li>
<li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 <u>Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</u>。但是，它不能用于创建新程序。</li>
<li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。</li>
</ol>
<div><p>JDK > JRE > JVM</p>
<p><a href="https://blog.csdn.net/ancientear/article/details/79483592" target="_blank" rel="noopener noreferrer">浅谈JDK、JRE、JVM区别与联系</a></p>
<ol>
<li>JVM不能单独执行class</li>
<li>JRE = JVM + lib（jvm工作需要的类库）。可以执行class</li>
<li>JDK包含JRE。可以开发、编译、执行</li>
</ol>
</div>
<p><img src="./README.assets/0cc3f4a15d3184391a98a7b1c58f6e5f_720w.jpg" alt="img" /></p>
<h3 id="_1-3-字节码及优点"> 1.3 字节码及优点</h3>
<p>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<ul>
<li>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</li>
<li>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</li>
</ul>
<p><img src="./README.assets/java程序转变为机器代码的过程.3dbbbc5a.png" alt="Java程序转变为机器代码的过程" /></p>
<h3 id="_1-4-编译与解释并存"> 1.4 编译与解释并存</h3>
<p>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<div><p>为什么要这么做？</p>
<p>编译型语言执行速度快、开发效率低，解释型语言开发效率快、执行速度慢。</p>
<p>编译与解释并存，（猜测应该）能融合两者的优点，提升开发效率的同时、保证执行速度。</p>
</div>
<h3 id="_1-5-oracle-jdk-openjdk-不懂"> 1.5 Oracle JDK &amp; OpenJDK （不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#oracle-jdk-vs-openjdk" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide</a></p>
<h3 id="_1-6-java-和-c-的区别"> 1.6 Java 和 C++ 的区别</h3>
<ul>
<li>都是面向对象的语言，都支持封装、继承、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，但是接口可以多继承；C++支持类多重继承</li>
<li>Java有自动内存管理垃圾回收机制 （GC），不需要程序员手动释放无用内存</li>
<li>C++同时支持方法重载和操作符重载，但是Java只支持方法重载（重载操作符增加了复杂性）</li>
<li>。。。</li>
</ul>
<h2 id="二、基本语法"> 二、基本语法</h2>
<h3 id="_2-0-详见javaguide-基本语法"> 2.0 详见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">JavaGuide #基本语法</a></h3>
<h3 id="_2-1-静态方法为什么不能调用非静态方法"> 2.1 静态方法为什么不能调用非静态方法？</h3>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<div><p>为什么要用静态方法？</p>
<p>静态方法的好处就是不用生成类的实例就可以直接调用。只需要通过其类名就可以访问，不需要再消耗资源反复创建对象。</p>
</div>
<h3 id="_2-2-重载和重写的区别"> 2.2 重载和重写的区别</h3>
<div><p>Tips</p>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</div>
<p><strong>重载：</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别点</th>
<th style="text-align:left">重载方法</th>
<th style="text-align:left">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">发生范围</td>
<td style="text-align:left">同一个类</td>
<td style="text-align:left">子类</td>
</tr>
<tr>
<td style="text-align:left">参数列表</td>
<td style="text-align:left">必须修改</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">返回类型</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td style="text-align:left">异常</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td style="text-align:left">发生阶段</td>
<td style="text-align:left">编译期</td>
<td style="text-align:left">运行期</td>
</tr>
</tbody>
</table>
<h3 id="_2-3-泛型"> 2.3 泛型</h3>
<blockquote>
<p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
</blockquote>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>详见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener noreferrer">JavaGuide #泛型</a></p>
<h3 id="_2-4-和-equals-的区别"> 2.4 == 和 equals() 的区别</h3>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<div><p>Tips</p>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</div>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<h3 id="_2-5-hashcode-与-equals"> 2.5 hashCode() 与 equals()</h3>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>更多解释见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#hashcode-%E4%B8%8E-equals" target="_blank" rel="noopener noreferrer">JavaGuide #hashcode-与-equals</a></p>
<div><p>hashCode的作用</p>
<p>hashCode和equals有一个相同的作用，就是用作比较：</p>
<ul>
<li>equals 为true的两个对象相等，false则两个对象不相等</li>
<li>hashCode 相同的两个对象不一定相等，但不同的两个对象一定不相等</li>
</ul>
</div>
<div><p>为什么要有 hashCode？</p>
<p><strong>效率</strong>
当一个对象逐渐复杂时，equals方法中的判定条件也会逐渐复杂，这个时候比较两个对象是否相等依旧使用equals的话，就会变得低效。</p>
<p>因此引出hashCode，通过一定的计算方式，为每个对象分配一个“哈希码”，让相等的对象都拥有相同的哈希码。之后需要比较两个对象的时候，先比较哈希码，如果哈希码都不相同，两个对象一定不相等。如果哈希码相同，再继续使用equals确定对象是否相等。</p>
<p>hashCode 方法相对与 equals 会更加高效，通过这两步判断，来确定两个对象是否相等</p>
</div>
<h2 id="三、基本数据类型"> 三、基本数据类型</h2>
<h3 id="_3-0-基本数据类型存放位置"> 3.0 基本数据类型存放位置</h3>
<p>一：在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p>
<p>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p>
<p>​     （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p>
<p>​     （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p>
<p>二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p>
<p>​    同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p>
<p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p>
<p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</p>
<h3 id="_3-1-包装类型的常量池"> 3.1 包装类型的常量池</h3>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>解释来说呢，大概就是以上几种类型中，创建的对象大小在约定的范围之内，该对象会在cache中长生（如果已存在将会复用）。</p>
<ul>
<li>节省内存空间：常量池中所有相同的对象常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<h2 id="四、java面向对象"> 四、Java面向对象</h2>
<h3 id="_4-1-面向对象和面向过程的区别"> 4.1 面向对象和面向过程的区别</h3>
<ul>
<li>
<p>因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。</p>
</li>
<li>
<p>因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</li>
</ul>
<div><p>Tips</p>
<p><strong>面向对象易维护、易复用、易扩展。面向过程性能相对较高。</strong></p>
</div>
<h3 id="_4-2-成员变量和局部变量的区别"> 4.2 成员变量和局部变量的区别</h3>
<p><img src="./README.assets/image-20220116180214826.png" alt="image-20220116180214826" /></p>
<h3 id="_4-3-对象实体和对象引用"> 4.3 对象实体和对象引用</h3>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="_4-4-对象相等和引用相等"> 4.4 对象相等和引用相等</h3>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="_4-5-构造方法的特点"> 4.5 构造方法的特点</h3>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<div><p>Tips</p>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
</div>
<h3 id="_4-6-面向对象三大特征"> 4.6 面向对象三大特征</h3>
<h4 id="_4-6-1-封装"> 4.6.1 封装</h4>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<div><p>封装的好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高代码的复用性</li>
<li>提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）</li>
</ul>
</div>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span><span>//id属性私有化</span>
    <span>private</span> <span>String</span> name<span>;</span><span>//name属性私有化</span>

    <span>//获取id的方法</span>
    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span> <span>return</span> id<span>;</span> <span>}</span>

    <span>//设置id的方法</span>
    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span> <span>this</span><span>.</span>id <span>=</span> id<span>;</span> <span>}</span>

    <span>//获取name的方法</span>
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span> <span>return</span> name<span>;</span> <span>}</span>

    <span>//设置name的方法</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span> <span>this</span><span>.</span>name <span>=</span> name<span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_4-6-2-继承"> 4.6.2 继承</h4>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<div><p>继承的优点</p>
<ol>
<li>提高代码的复用性</li>
<li>提高代码的易维护性</li>
<li>提高代码的可扩展性</li>
<li>使代码结构清晰</li>
</ol>
</div>
<div><p>继承的缺点</p>
<ol>
<li>高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类</li>
<li>破坏封装性、降低灵活性</li>
</ol>
</div>
<h4 id="_4-6-3-多态"> 4.6.3 多态</h4>
<p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间</strong>才能确定；</li>
<li>多态不能调用“<strong>只在子类存在但在父类不存在</strong>”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是<strong>子类覆盖</strong>的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<div><p>多态存在的必要条件</p>
<ol>
<li>要有继承</li>
<li>要有重写</li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
</div>
<div><p>多态的好处</p>
<ol>
<li>提高了代码的可扩展性</li>
<li>可替换性</li>
<li>接口性：向子类提供共同接口，由子类来完善或覆盖</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
</div>
<h3 id="_4-7-string、stringbuffer、stringbuilder"> 4.7 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code></h3>
<h4 id="_4-7-1-string-为什么是不可变的"> 4.7.1 <code>String</code> 为什么是不可变的</h4>
<p><a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener noreferrer">String为什么不可变 - 梦醒点灯</a></p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h4 id="_4-7-2-stringbuffer、stringbuilder"> 4.7.2 <code>StringBuffer</code>、<code>StringBuilder</code></h4>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> value<span>;</span>
    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>
        str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> value<span>,</span> count<span>)</span><span>;</span>
        count <span>+=</span> len<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
  	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_4-7-3-线程安全性"> 4.7.3 线程安全性</h4>
<div><p>Tips</p>
<p><code>String</code>、<code>StringBuffer</code> 是线程安全的，<code>StringBuilder</code> 非线程安全。</p>
</div>
<ul>
<li><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</li>
<li><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。
<ul>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li>
<li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
</li>
</ul>
<h4 id="_4-7-4-性能"> 4.7.4 性能</h4>
<p><code>StringBuilder</code> &gt; <code>StringBuffer</code> &gt; <code>String</code></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="_4-8-object-类的常见方法"> 4.8 <code>Object</code> 类的常见方法</h3>
<div><pre><code><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>
<span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span>
    
<span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> 
    
<span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span>
    
<span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>
<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span>
    
<span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span>

<span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//实例被垃圾回收器回收的时候触发的操作</span>
<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id="_4-9-深拷贝和浅拷贝、引用拷贝"> 4.9 深拷贝和浅拷贝、引用拷贝</h3>
<div><p>Tips</p>
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</div>
<p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="./README.assets/shallow&deep-copy.64ee0760.png" alt="img" /></p>
<h2 id="五、反射"> 五、反射</h2>
<h3 id="_5-1-什么是反射"> 5.1 什么是反射</h3>
<p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）语言的一个关键性质。</p>
<h3 id="_5-2-反射能做什么"> 5.2 反射能做什么？</h3>
<p>我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！</p>
<h3 id="_5-3-反射机制优缺点"> 5.3 反射机制优缺点</h3>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h3 id="_5-4-反射的应用场景"> 5.4 反射的应用场景</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide # 反射的应用场景</a></p>
<p>（看不懂）</p>
<h2 id="六、注解"> 六、注解</h2>
<p><a href="https://zhuanlan.zhihu.com/p/37701743" target="_blank" rel="noopener noreferrer">java 注解-最通俗易懂的讲解</a></p>
<h3 id="_6-0-注解是什么"> 6.0 注解是什么</h3>
<p><strong>初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。</strong></p>
<h3 id="_6-1-注解的作用"> 6.1 注解的作用</h3>
<ul>
<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。</li>
<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取
值得注意的是，注解不是代码本身的一部分。</li>
</ul>
<h3 id="_6-2-注解的语法、定义、运用"> 6.2 注解的语法、定义、运用</h3>
<p>暂且不谈，等到练习中认识即可</p>
<h2 id="七、异常"> 七、异常</h2>
<h3 id="_7-1-异常类层次结构图"> 7.1 异常类层次结构图</h3>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<ul>
<li>
<p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常</strong>(必须处理) 和 <strong>不受检查异常</strong>(可以不处理)。</p>
</li>
<li>
<p><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择<strong>线程终止</strong>。</p>
</li>
</ul>
<p><img src="./README.assets/Java异常类层次结构图.png" alt="img" /></p>
<p><img src="./README.assets/Java异常类层次结构图2.png" alt="img" /></p>
<h4 id="_7-1-1-受检查异常"> 7.1.1 受检查异常</h4>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码</p>
<p><img src="./README.assets/check-exception.png" alt="check-exception" /></p>
<h4 id="_7-1-2-不受检查异常"> 7.1.2 不受检查异常</h4>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="_7-2-throwable-类常用方法"> 7.2 Throwable 类常用方法</h3>
<ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="_7-3-try-catch-finally"> 7.3 try-catch-finally</h3>
<ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<strong><code>finally</code> 语句块将在方法返回之前被执行。</strong></li>
</ul>
<div><p>Tips</p>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>
<p>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</p>
</li>
<li>
<p>程序所在的线程死亡。</p>
</li>
<li>
<p>关闭 CPU。</p>
</li>
</ol>
</div>
<h3 id="_7-4-使用-try-with-resources-来代替try-catch-finally"> 7.4 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<div><pre><code><span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"test.txt"</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> fnfe<span>)</span> <span>{</span>
    fnfe<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="八、io流"> 八、IO流</h2>
<h3 id="_8-1-反-序列化"> 8.1 （反）序列化</h3>
<p>理解序列化 -&gt; <a href="https://zhuanlan.zhihu.com/p/40462507" target="_blank" rel="noopener noreferrer">序列化理解起来很简单</a></p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h4 id="_8-1-1-为什么要序列化"> 8.1.1 为什么要序列化？</h4>
<blockquote>
<p>序列化最终的目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p>
</blockquote>
<p>我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</p>
<p>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则**（序列化）<strong>，那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来</strong>（反序列化）。**</p>
<p>如果我们要把一栋房子从一个地方运输到另一个地方去，<strong>序列化</strong>就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，<strong>反序列化</strong>就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</p>
<h4 id="_8-1-2-什么时候需要序列化"> 8.1.2 什么时候需要序列化？</h4>
<p>凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。</p>
<p>本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。</p>
<h3 id="_8-2-如果有些字段不想进行序列化-看不懂"> 8.2 如果有些字段不想进行序列化（看不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96-%E6%80%8E%E4%B9%88%E5%8A%9E" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide # 如果有些字段不想进行序列化</a></p>
<h3 id="_8-3-获取用键盘输入常用的两种方法"> 8.3 获取用键盘输入常用的两种方法</h3>
<ol>
<li><code>Scanner</code></li>
</ol>
<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>String</span> s  <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>
input<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li><code>BufferedReader</code></li>
</ol>
<div><pre><code><span>BufferedReader</span> input <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>
<span>String</span> s <span>=</span> input<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_8-4-io流分类"> 8.4 IO流分类</h3>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流（<strong>对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写</strong>）。</li>
</ul>
<p><img src="./README.assets/IO-操作方式分类.png" alt="IO-操作方式分类" /></p>
<p><img src="./README.assets/IO-操作对象分类.png" alt="IO-操作对象分类" /></p>
<h3 id="_8-5-字符流的意义"> 8.5 字符流的意义</h3>
<p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
]]></content:encoded>
    </item>
    <item>
      <title>代理详解</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/3-agent/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/3-agent/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">代理详解</source>
      <category>Java</category>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>全部抄自 <a href="https://javaguide.cn/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">代理详解！静态代理+JDK/CGLIB 动态代理实战 | JavaGuide</a>， 略有改动</p>
</div>
<h2 id="代理模式"> 代理模式</h2>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p><img src="./README.assets/1DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" /></p>
<h2 id="静态代理"> 静态代理</h2>
<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1. 定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsProxy</span> <span>implements</span> <span>SmsService</span> <span>{</span>

    <span>private</span> <span>final</span> <span>SmsService</span> smsService<span>;</span>

    <span>public</span> <span>SmsProxy</span><span>(</span><span>SmsService</span> smsService<span>)</span> <span>{</span>
        <span>this</span><span>.</span>smsService <span>=</span> smsService<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method send()"</span><span>)</span><span>;</span>
        smsService<span>.</span><span>send</span><span>(</span>message<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method send()"</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4.实际使用</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SmsService</span> smsService <span>=</span> <span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>;</span>
        <span>SmsProxy</span> smsProxy <span>=</span> <span>new</span> <span>SmsProxy</span><span>(</span>smsService<span>)</span><span>;</span>
        smsProxy<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send<span>(</span><span>)</span>
send message:java
after method send<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="动态代理"> 动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<blockquote>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的</strong></p>
</blockquote>
<p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk-动态代理机制-没看懂"> JDK 动态代理机制（没看懂）</h3>
<h4 id="介绍"> 介绍</h4>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<div><pre><code><span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>
                                      <span>InvocationHandler</span> h<span>)</span>
    <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>

    <span>/**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */</span>
    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>
        <span>throws</span> <span>Throwable</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<blockquote>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
</blockquote>
<h4 id="使用步骤"> 使用步骤</h4>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="代码示例"> 代码示例</h4>
<p><strong>1.定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.定义一个 JDK 动态代理类</strong></p>
<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationHandler</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>/**
 * @author shuang.kou
 * @createTime 2020年05月11日 11:23:00
 */</span>
<span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>


    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>JdkProxyFactory</span> <span>{</span>
    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>
                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>
        <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<div><pre><code><span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>
smsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>java 内存区域详解</title>
      <link>https://vue-blog.lllllan.cn/1-java/2-jvm/1-memory-area-details/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/2-jvm/1-memory-area-details/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">java 内存区域详解</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 08:35:36 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p>本文抄自 <a href="https://javaguide.cn/java/jvm/memory-area/" target="_blank" rel="noopener noreferrer">Java 内存区域详解 | JavaGuide Java 内存区域详解</a></p>
<p>这部分内容未免有些太过抽象，这次作为 <strong>泛读</strong>，大概看一眼有一个印象，<s>（因为实在是看不懂）</s></p>
</blockquote>
<h1 id="一-概述"> 一 概述</h1>
<p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务</p>
<h1 id="二-运行时数据区域"> 二 运行时数据区域</h1>
<p><strong>JDK 1.8 之前：</strong></p>
<p><img src="./README.assets/JVM运行时数据区域.150c33e1.png" alt="img" /></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><img src="./README.assets/Java运行时数据区域JDK1.8.37016205.png" alt="img" /></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h2 id="_2-1-程序计数器"> 2.1 程序计数器</h2>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡</strong></p>
<h2 id="_2-2-java-虚拟机栈"> 2.2 Java 虚拟机栈</h2>
<p><strong>与程序计数器一样，<u>Java 虚拟机栈也是线程私有的</u>，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p><img src="./README.assets/《深入理解虚拟机》第三版的第2章-虚拟机栈.5cc9c70c.png" alt="img" /></p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h2 id="_2-3-本地方法栈"> 2.3 本地方法栈</h2>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</p>
<h2 id="_2-4-堆"> 2.4 堆</h2>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="./README.assets/JVM堆内存结构-JDK7.7d9166eb.png" alt="JVM堆内存结构-JDK7" /></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="./README.assets/JVM堆内存结构-jdk8.919b9959.png" alt="JVM堆内存结构-JDK8" /></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size" target="_blank" rel="noopener noreferrer">Default Java 8 max heap size  (opens new window)</a>)</li>
<li>......</li>
</ol>
<h2 id="_2-5-方法区"> 2.5 方法区</h2>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h3 id="_2-5-1-方法区和永久代的关系"> 2.5.1 方法区和永久代的关系</h3>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
<h3 id="_2-5-2-常用参数"> 2.5.2 常用参数</h3>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<div><pre><code><span>-</span>XX<span>:</span><span>PermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 初始大小</span>
<span>-</span>XX<span>:</span><span>MaxPermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<div><pre><code><span>-</span>XX<span>:</span><span>MetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的初始（和最小大小）</span>
<span>-</span>XX<span>:</span><span>MaxMetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的最大大小</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h3 id="_2-5-3-为什么要将永久代-permgen-替换为元空间-metaspace-呢"> 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h3>
<p><img src="./README.assets/20210425134508117.png" alt="img" /></p>
<ol>
<li>
<p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
</li>
<li>
<p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li>
<p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h2 id="_2-6-运行时常量池"> 2.6 运行时常量池</h2>
<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<blockquote>
<ol>
<li>
<p><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></p>
</li>
<li>
<p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</p>
</li>
<li>
<p><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p>
</li>
</ol>
</blockquote>
<h2 id="_2-7-直接内存"> 2.7 直接内存</h2>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于**通道（Channel）**与**缓存区（Buffer）*<em>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为*<em>避免了在 Java 堆和 Native 堆之间来回复制数据</em></em>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h1 id="三-hotspot-虚拟机对象"> 三 HotSpot 虚拟机对象</h1>
<h2 id="_3-1-对象的创建"> 3.1 对象的创建</h2>
<p><img src="./README.assets/Java创建对象的过程.dbe33c41.png" alt="Java创建对象的过程" /></p>
<h3 id="_3-1-1-类加载检查"> 3.1.1 类加载检查</h3>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="_3-1-2-分配内存"> 3.1.2 分配内存</h3>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<img src="README.assets/内存分配的两种方式.9ecae4c9.png" alt="内存分配的两种方式" style="zoom:150%;" />
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="_3-1-3-初始化零值"> 3.1.3 初始化零值</h3>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="_3-1-4-设置对象头"> 3.1.4 设置对象头</h3>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="_3-1-5-执行-init-方法"> 3.1.5 执行 init 方法</h3>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="_3-2-对象的内存布局"> 3.2 对象的内存布局</h2>
<blockquote>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
</blockquote>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="_3-3-对象的访问定位"> 3.3 对象的访问定位</h2>
<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<blockquote>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
</blockquote>
<ol>
<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
</ol>
<p><img src="./README.assets/对象的访问定位-使用句柄.53859387.png" alt="对象的访问定位-使用句柄" /></p>
<ol start="2">
<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址</li>
</ol>
<p><img src="./README.assets/对象的访问定位-直接指针.c3bbe790.png" alt="对象的访问定位-直接指针" /></p>
<h1 id="四-重点补充内容"> 四 重点补充内容</h1>
<h2 id="_4-1-字符串常量池常见问题"> 4.1 字符串常量池常见问题</h2>
<h3 id="_4-1-1-和-equals"> 4.1.1 <code>==</code> 和 <code>equals</code></h3>
<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><img src="./README.assets/image-20210817123252441.png" alt="img" /></p>
<blockquote>
<p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p>
</blockquote>
<h3 id="_4-1-2-存入常量池"> 4.1.2 存入常量池</h3>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</strong></p>
<blockquote>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<div><pre><code><span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
</blockquote>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ol>
<li>基本数据类型(byte、boolean、short、char、int、float、long、double)以及字符串常量</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ol>
<h3 id="_4-1-3-字符串拼接"> 4.1.3 字符串拼接</h3>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>//常量池中的对象</span>
<span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象</span>
<span>String</span> str5 <span>=</span> <span>"string"</span><span>;</span><span>//常量池中的对象</span>

<span>String</span> str4 <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>str1<span>)</span><span>.</span><span>append</span><span>(</span>str2<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="./README.assets/字符串拼接-常量池.png" alt="img" /></p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>// 下面两个表达式其实是等价的</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_4-1-4-创建字符串对象的方式"> 4.1.4 创建字符串对象的方式</h3>
<div><pre><code><span>// 从字符串常量池中拿对象</span>
<span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 直接在堆内存空间创建一个新的对象。</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>只要使用 new 的方式创建对象，便需要创建新的对象</strong> 。</p>
<p>使用 new 的方式创建对象的方式如下，可以简单概括为 3 步：</p>
<ol>
<li>在堆中创建一个字符串对象</li>
<li>检查字符串常量池中是否有和 new 的字符串值相等的字符串常量</li>
<li>如果没有的话需要在字符串常量池中也创建一个值相等的字符串常量，如果有的话，就直接返回堆中的字符串实例对象地址。</li>
</ol>
<h3 id="_4-1-5-总结"> 4.1.5 总结</h3>
<ol>
<li>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</li>
<li>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</li>
<li>一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 <code>String</code> 对象（ <code>String s1 = &quot;java&quot;</code> ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。</li>
<li>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。</li>
</ol>
<h2 id="_4-2-string-s1-new-string-abc-这句话创建了几个字符串对象"> 4.2 String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</h2>
<p><strong>会创建 1 或 2 个字符串：</strong></p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</li>
<li>如果字符串常量池中没有字符串常量“abc”，<strong>那么它将首先在字符串常量池中创建</strong>，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>
</ul>
<h2 id="_4-3-8-种基本类型的包装类和常量池"> 4.3 8 种基本类型的包装类和常量池</h2>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<blockquote>
<h2 id="常量池技术的作用"> 常量池技术的作用</h2>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ol>
<li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ol>
</blockquote>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>
<span>Integer</span> i11 <span>=</span> <span>333</span><span>;</span>
<span>Integer</span> i22 <span>=</span> <span>333</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>
<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>
<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_4-3-0-整型包装类对象之间的比较"> 4.3.0 整型包装类对象之间的比较</h3>
<p><img src="./README.assets/20210313164740893.png" alt="img" /></p>
<h3 id="_4-3-1-integer-缓存源代码"> 4.3.1 <code>Integer</code> 缓存源代码</h3>
<div><pre><code><span>/**
*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/</span>
<span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
      <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
<span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>
    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>
    <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_4-3-2-character-缓存源码"> 4.3.2 <code>Character</code> 缓存源码</h3>
<div><pre><code><span>public</span> <span>static</span> <span>Character</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>
      <span>return</span> <span>CharacterCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>c<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>Character</span><span>(</span>c<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>CharacterCache</span> <span>{</span>
    <span>private</span> <span>CharacterCache</span><span>(</span><span>)</span><span>{</span><span>}</span>

    <span>static</span> <span>final</span> <span>Character</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>[</span><span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>static</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>(</span><span>char</span><span>)</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_4-3-3-boolean-缓存源码"> 4.3.3 <code>Boolean</code> 缓存源码</h3>
<div><pre><code><span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 垃圾回收</title>
      <link>https://vue-blog.lllllan.cn/1-java/2-jvm/2-garbage-collection/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/2-jvm/2-garbage-collection/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Java 垃圾回收</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 08:35:36 GMT</pubDate>
      <content:encoded><![CDATA[<blockquote>
<p><a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide</a></p>
</blockquote>
<h1 id="写在前面"> 写在前面</h1>
<h2 id="常见面试题"> 常见面试题</h2>
<ul>
<li>如何判断对象是否死亡（两种方法）。</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>
<li>如何判断一个常量是废弃常量</li>
<li>如何判断一个类是无用的类</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>HotSpot 为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有哪些？</li>
<li>介绍一下 CMS,G1 收集器。</li>
<li>Minor Gc 和 Full GC 有什么不同呢？</li>
</ul>
<h2 id="核心问题"> 核心问题</h2>
<ol>
<li>内存如何分配和回收</li>
<li>哪些垃圾需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<p><img src="./README.assets/image-20220118102736004.png" alt="image-20220118102736004" /></p>
<h1 id="一、jvm内存分配与回收"> 一、JVM内存分配与回收</h1>
<p>Java 的自动内存管理主要是针对<strong>对象内存</strong>的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p><img src="./README.assets/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.fac41c8a.png" alt="img" /></p>
<blockquote>
<h2 id="第一次理解"> 第一次理解</h2>
<p>如图所示，一般对象的创建，会先分配到图左1的 <code>Eden</code> 区域，随着垃圾回收的进行，仍然存活的对象会根据存活时间向老年代转移。</p>
<h2 id="常见分配策略"> 常见分配策略</h2>
<ol>
<li>对象优先在 <code>Eden</code> 区域分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代</li>
</ol>
</blockquote>
<h2 id="_1-1-对象优先在-eden-区域分配"> 1.1 对象优先在 <code>Eden</code> 区域分配</h2>
<p>目前主流的垃圾收集器都会采用<strong>分代回收算法</strong>，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.</p>
<p>具体测试见 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/#_1-1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%8C%BA%E5%88%86%E9%85%8D" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide | 1.1 对象优先在 <code>Eden</code> 区域分配</a></p>
<h2 id="_1-2-大对象直接进入老年代"> 1.2 大对象直接进入老年代</h2>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。（我的理解是：eden中内存分配不足时，总有对象要被转移到老年代的，不如一开始就将比较大的对象直接分配在老年代）</p>
<h2 id="_1-3-长期存活的对象将进入老年代"> 1.3 长期存活的对象将进入老年代</h2>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
]]></content:encoded>
    </item>
    <item>
      <title>刷题 笔记</title>
      <link>https://vue-blog.lllllan.cn/4-practice/</link>
      <guid>https://vue-blog.lllllan.cn/4-practice/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">刷题 笔记</source>
      <category>刷题</category>
    </item>
    <item>
      <title>Java 笔记</title>
      <link>https://vue-blog.lllllan.cn/1-java/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Java 笔记</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 09:33:02 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>重要声明</p>
<p>既然作为笔记，就存在着大量的摘抄（也就是俗话说的copy）。为了尊重原作者的劳动，此处以及每篇文章都会列出原文出处。如有遗漏，欢迎指出</p>
</div>
<h2 id="参考"> 参考</h2>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p><a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>计算机基础</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">计算机基础</source>
      <category>计算机基础</category>
    </item>
    <item>
      <title>密码加密的文章</title>
      <link>https://vue-blog.lllllan.cn/guide/encrypt/</link>
      <guid>https://vue-blog.lllllan.cn/guide/encrypt/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">密码加密的文章</source>
      <category>使用指南</category>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
      <content:encoded><![CDATA[<h1 id="密码加密的文章"> 密码加密的文章</h1>
<p>实际的文章内容。</p>
<p>段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字段落 1 文字。</p>
<p>段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字段落 2 文字。</p>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL 笔记</title>
      <link>https://vue-blog.lllllan.cn/2-mysql/</link>
      <guid>https://vue-blog.lllllan.cn/2-mysql/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">MySQL 笔记</source>
      <category>MySQL</category>
      <content:encoded><![CDATA[<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener noreferrer">【宋红康】MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili</a></p>
<p>MySQL上过一个学期，可以说啥也没听，啥也没学，基本的语句全靠临时百度。</p>
<p>现在跟着这个视频，重新学一遍MySQL，希望能加深理解。</p>
]]></content:encoded>
    </item>
    <item>
      <title>组件禁用</title>
      <link>https://vue-blog.lllllan.cn/guide/disable/</link>
      <guid>https://vue-blog.lllllan.cn/guide/disable/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">组件禁用</source>
      <description>&amp;lt;p&amp;gt;你可以通过设置页面的 Frontmatter，在页面禁用一些功能。&amp;lt;/p&amp;gt;
</description>
      <category>使用指南</category>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
      <content:encoded><![CDATA[<p>你可以通过设置页面的 Frontmatter，在页面禁用一些功能。</p>

<p>本页面应当禁用了:</p>
<ul>
<li>导航栏</li>
<li>侧边栏</li>
<li>路径导航</li>
<li>页面信息</li>
<li>贡献者</li>
<li>编辑此页链接</li>
<li>更新时间</li>
<li>上一篇/下一篇 链接</li>
<li>评论</li>
<li>页脚</li>
<li>返回顶部按钮</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>页面配置</title>
      <link>https://vue-blog.lllllan.cn/guide/page/</link>
      <guid>https://vue-blog.lllllan.cn/guide/page/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">页面配置</source>
      <category>使用指南</category>
      <pubDate>Wed, 01 Jan 2020 00:00:00 GMT</pubDate>
      <content:encoded><![CDATA[<h2 id="页面信息"> 页面信息</h2>
<p>你可以在 Markdown 的 Frontmatter 中设置页面信息。</p>
<ul>
<li>
<p>作者设置为 Ms.Hope。</p>
</li>
<li>
<p>写作时间应为 2020 年 1 月 1 日</p>
</li>
<li>
<p>分类为 “使用指南”</p>
</li>
<li>
<p>标签为 “页面配置” 和 “使用指南”</p>
</li>
</ul>
<h2 id="页面内容"> 页面内容</h2>
<p>你可以自由在这里书写你的 Markdown。</p>
<div><p>Tips</p>
<ul>
<li>
<p>Markdown 文件夹的图片请使用相对链接 <code>./</code> 进行引用。</p>
</li>
<li>
<p><code>.vuepress/public</code> 文件夹的图片，请使用绝对链接 <code>/</code> 进行引用</p>
</li>
</ul>
</div>
<p>主题包含了一个自定义徽章章可以使用:</p>
<blockquote>
<p>文字结尾应该有深蓝色的 徽章文字 徽章。 <i>Not supported content</i></p>
</blockquote>
<h2 id="页面结构"> 页面结构</h2>
<p>此页面应当包含：</p>
<ul>
<li>返回顶部按钮</li>
<li>路径导航</li>
<li>评论</li>
<li>页脚</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 笔记</title>
      <link>https://vue-blog.lllllan.cn/guide/</link>
      <guid>https://vue-blog.lllllan.cn/guide/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Java 笔记</source>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
    </item>
    <item>
      <title>Markdown 增强</title>
      <link>https://vue-blog.lllllan.cn/guide/markdown/</link>
      <guid>https://vue-blog.lllllan.cn/guide/markdown/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Markdown 增强</source>
      <description>&amp;lt;p&amp;gt;&amp;lt;code&amp;gt;vuepress-theme-hope&amp;lt;/code&amp;gt; 通过内置 &amp;lt;a href=&amp;quot;https://vuepress-theme-hope.github.io/md-enhance&amp;quot; target=&amp;quot;_blank&amp;quot; rel=&amp;quot;noopener noreferrer&amp;quot;&amp;gt;md-enhance&amp;lt;/a&amp;gt;，在 Markdown 中启用了更多的语法与新功能。&amp;lt;/p&amp;gt;
</description>
      <category>使用指南</category>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
      <content:encoded><![CDATA[<p><code>vuepress-theme-hope</code> 通过内置 <a href="https://vuepress-theme-hope.github.io/md-enhance" target="_blank" rel="noopener noreferrer">md-enhance</a>，在 Markdown 中启用了更多的语法与新功能。</p>

<h2 id="一键启用"> 一键启用</h2>
<p>你可以设置 <code>themeconfig.mdEnhance.enableAll</code> 启用 <a href="https://vuepress-theme-hope.github.io/md-enhance" target="_blank" rel="noopener noreferrer">md-enhance</a> 插件的所有功能。</p>
<div><div><br><br><div>&nbsp;</div><div>&nbsp;</div><div>&nbsp;</div><br><br><br></div><pre><code>module<span>.</span>exports <span>=</span> <span>{</span>
  <span>themeConfig</span><span>:</span> <span>{</span>
    <span>mdEnhance</span><span>:</span> <span>{</span>
      <span>enableAll</span><span>:</span> <span>true</span><span>,</span>
    <span>}</span><span>,</span>
  <span>}</span><span>,</span>
<span>}</span><span>;</span>
</code></pre><div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="新增的更多语法"> 新增的更多语法</h2>
<h3 id="上下角标"> 上下角标</h3>
<p>19<sup>th</sup> H<sub>2</sub>O</p>
<details><summary>代码</summary>
<div><pre><code>19^th^ H<span><span>~</span><span>2</span><span>~</span></span>O
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/sup-sub/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="自定义对齐"> 自定义对齐</h3>
<div>
<p>我是居中的</p>
</div>
<div>
<p>我在右对齐</p>
</div>
<details><summary>代码</summary>
<div><pre><code>::: center

我是居中的

:::

::: right

我在右对齐

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/align/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="脚注"> 脚注</h3>
<p>此文字有脚注<sup></sup>.</p>
<details><summary>代码</summary>
<div><pre><code>此文字有脚注[^first].

<span><span>[</span><span>^first</span><span>]</span><span>:</span> 这是脚注内容</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/footnote/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="标记"> 标记</h3>
<p>你可以标记 <mark>重要的内容</mark> 。</p>
<details><summary>代码</summary>
<div><pre><code>你可以标记 ==重要的内容== 。
</code></pre>
<div><span>1</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/mark/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="任务列表"> 任务列表</h3>
<ul>
<li><input type="checkbox"  disabled="disabled" id="task-item-0"><label for="task-item-0"> 计划 1</label></li>
<li><input type="checkbox"  disabled="disabled" id="task-item-1"><label for="task-item-1"> 计划 2</label></li>
</ul>
<details><summary>Code</summary>
<div><pre><code><span>-</span> [x] 计划 1
<span>-</span> [ ] 计划 2
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/guide/markdown/tasklist/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="流程图"> 流程图</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code><span><span>```</span><span>flow</span>
<span>cond=>condition: Process?
process=>operation: Process
e=>end: End

cond(yes)->process->e
cond(no)->e</span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/flowchart/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h2 id="mermaid"> Mermaid</h2>
<Mermaid id="mermaid-64a57060" data-code="graph%20TD%3B%0A%20%20%20%20A--%3EB%3B%0A%20%20%20%20A--%3EC%3B%0A%20%20%20%20B--%3ED%3B%0A%20%20%20%20C--%3ED%3B%0A"></Mermaid><details><summary>代码</summary>
<div><pre><code><span><span>```</span><span>mermaid</span>
<span>graph TD;
    A-->B;
    A-->C;
    B-->D;
    C-->D;</span>
<span>```</span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/mermaid/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="tex-语法"> Tex 语法</h3>
<p class='katex-block'><span><span><span><i>Not supported content</i></span><span aria-hidden="true"><span><span style="height:2.4em;vertical-align:-0.95em;"></span><span><span></span><span><span><span><span style="height:1.3714em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.05556em;">∂</span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.5904em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.05556em;">∂</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.2778em;"></span><span>=</span><span style="margin-right:0.2778em;"></span></span><span><span style="height:3.0277em;vertical-align:-1.2777em;"></span><span><span style="top:0em;"><span>(</span></span><span><span></span><span><span><span><span style="height:1.3414em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span style="margin-right:0.03588em;">ω</span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">y</span><span><span><span><span style="height:0.6644em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.03588em;">ω</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>)</span></span></span><span style="margin-right:0.1667em;"></span><span><span style="top:0em;"><span>{</span></span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.7144em;"><span style="top:-3.113em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span></span></span></span></span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span><span><span><span style="height:1.6514em;"><span style="top:-1.8723em;margin-left:0em;"><span style="height:3.05em;"></span><span><span><span>i</span><span>=</span><span>1</span></span></span></span><span style="top:-3.05em;"><span style="height:3.05em;"></span><span><span>∑</span></span></span><span style="top:-4.3em;margin-left:0em;"><span style="height:3.05em;"></span><span><span style="margin-right:0.02778em;">r</span></span></span></span><span>​</span></span><span><span style="height:1.2777em;"><span></span></span></span></span></span><span style="margin-right:0.1667em;"></span><span><span></span><span><span><span><span style="height:1.5017em;"><span style="top:-2.314em;"><span style="height:3em;"></span><span><span><span style="margin-right:0.03588em;">ω</span><span><span><span><span style="height:0.7507em;"><span style="top:-2.989em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span></span></span><span style="top:-3.23em;"><span style="height:3em;"></span><span style="border-bottom-width:0.04em;"></span></span><span style="top:-3.677em;"><span style="height:3em;"></span><span><span>(</span><span>−</span><span>1</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span>i</span></span></span></span></span></span></span></span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.1667em;"></span><span>⋯</span><span style="margin-right:0.1667em;"></span><span>(</span><span style="margin-right:0.02778em;">r</span><span style="margin-right:0.2222em;"></span><span>−</span><span style="margin-right:0.2222em;"></span><span>i</span><span style="margin-right:0.2222em;"></span><span>+</span><span style="margin-right:0.2222em;"></span><span>1</span><span>)</span><span>(</span><span>lo<span style="margin-right:0.01389em;">g</span></span><span style="margin-right:0.1667em;"></span><span style="margin-right:0.03588em;">y</span><span><span>)</span><span><span><span><span style="height:0.8247em;"><span style="top:-3.063em;margin-right:0.05em;"><span style="height:2.7em;"></span><span><span><span style="margin-right:0.02778em;">r</span><span>−</span><span>i</span></span></span></span></span></span></span></span></span></span></span></span><span>​</span></span><span><span style="height:0.686em;"><span></span></span></span></span></span><span></span></span><span style="top:0em;"><span>}</span></span></span></span></span></span></span></p>
<details><summary>代码</summary>
<div><pre><code>$$
\frac {\partial^r} {\partial \omega^r} \left(\frac {y^{\omega}} {\omega}\right)
= \left(\frac {y^{\omega}} {\omega}\right) \left\{(\log y)^r + \sum_{i=1}^r \frac {(-1)^i r \cdots (r-i+1) (\log y)^{r-i}} {\omega^i} \right\}
$$
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/tex/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="代码案例"> 代码案例</h3>

          <div
            id="code-demo-5ac6bc9f"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22html%22%3A%22%3Ch1%3EMr.Hope%3C%2Fh1%3E%5Cn%3Cp%3E%3Cspan%20id%3D%5C%22very%5C%22%3E%E5%8D%81%E5%88%86%3C%2Fspan%3E%20%E5%B8%85%3C%2Fp%3E%5Cn%22%2C%22js%22%3A%22document.querySelector(%5C%22%23very%5C%22).addEventListener(%5C%22click%5C%22%2C%20()%20%3D%3E%20%7B%5Cn%20%20alert(%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22)%3B%5Cn%7D)%3B%5Cn%22%2C%22css%22%3A%22span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"十分帅"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

<span><span>```</span><span>html</span>
<span><span><span><span>&lt;</span>h1</span><span>></span></span>Mr.Hope<span><span><span>&lt;/</span>h1</span><span>></span></span>
<span><span><span>&lt;</span>p</span><span>></span></span><span><span><span>&lt;</span>span</span> <span>id</span><span><span>=</span><span>"</span>very<span>"</span></span><span>></span></span>十分<span><span><span>&lt;/</span>span</span><span>></span></span> 帅<span><span><span>&lt;/</span>p</span><span>></span></span></span>
<span>```</span></span>

<span><span>```</span><span>js</span>
<span>document<span>.</span><span>querySelector</span><span>(</span><span>"#very"</span><span>)</span><span>.</span><span>addEventListener</span><span>(</span><span>"click"</span><span>,</span> <span>(</span><span>)</span> <span>=></span> <span>{</span>
  <span>alert</span><span>(</span><span>"十分帅"</span><span>)</span><span>;</span>
<span>}</span><span>)</span><span>;</span></span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div></details>

          <div
            id="code-demo-693e1878"
           
  data-type="react"
 data-title="%E4%B8%80%E4%B8%AA%20React%20Demo"

            data-code="%7B%22js%22%3A%22export%20default%20class%20App%20extends%20React.Component%20%7B%5Cn%20%20constructor(props)%20%7B%5Cn%20%20%20%20super(props)%3B%5Cn%20%20%20%20this.state%20%3D%20%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D%3B%5Cn%20%20%7D%5Cn%20%20render()%20%7B%5Cn%20%20%20%20return%20(%5Cn%20%20%20%20%20%20%3Cdiv%20className%3D%5C%22box-react%5C%22%3E%5Cn%20%20%20%20%20%20%20%20Mr.Hope%20%3Cspan%3E%7Bthis.state.message%7D%3C%2Fspan%3E%5Cn%20%20%20%20%20%20%3C%2Fdiv%3E%5Cn%20%20%20%20)%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%2C%22css%22%3A%22.box-react%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>"十分帅"</span> <span>}</span><span>;</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div className<span>=</span><span>"box-react"</span><span>></span>
        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>
      <span>&lt;</span><span>/</span>div<span>></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><div><pre><code><span>.box-react span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo [react] 一个 React Demo

<span><span>```</span><span>js</span>
<span><span>export</span> <span>default</span> <span>class</span> <span>App</span> <span>extends</span> <span>React<span>.</span>Component</span> <span>{</span>
  <span>constructor</span><span>(</span><span>props</span><span>)</span> <span>{</span>
    <span>super</span><span>(</span>props<span>)</span><span>;</span>
    <span>this</span><span>.</span>state <span>=</span> <span>{</span> <span>message</span><span>:</span> <span>"十分帅"</span> <span>}</span><span>;</span>
  <span>}</span>
  <span>render</span><span>(</span><span>)</span> <span>{</span>
    <span>return</span> <span>(</span>
      <span>&lt;</span>div className<span>=</span><span>"box-react"</span><span>></span>
        Mr<span>.</span>Hope <span>&lt;</span>span<span>></span><span>{</span><span>this</span><span>.</span>state<span>.</span>message<span>}</span><span>&lt;</span><span>/</span>span<span>></span>
      <span>&lt;</span><span>/</span>div<span>></span>
    <span>)</span><span>;</span>
  <span>}</span>
<span>}</span></span>
<span>```</span></span>

<span><span>```</span><span>css</span>
<span><span>.box-react span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>

          <div
            id="code-demo-2c0b9cdb"
           
  data-type="vue"
 data-title="%E4%B8%80%E4%B8%AA%20Vue%20Demo"

            data-code="%7B%22vue%22%3A%22%3Ctemplate%3E%5Cn%20%20%3Cdiv%20class%3D%5C%22box%5C%22%3E%5Cn%20%20%20%20Mr.Hope%20%3Cspan%3E%7B%7B%20message%20%7D%7D%3C%2Fspan%3E%5Cn%20%20%3C%2Fdiv%3E%5Cn%3C%2Ftemplate%3E%5Cn%3Cscript%3E%5Cnexport%20default%20%7B%5Cn%20%20data%3A%20()%20%3D%3E%20(%7B%20message%3A%20%5C%22%E5%8D%81%E5%88%86%E5%B8%85%5C%22%20%7D)%2C%5Cn%7D%3B%5Cn%3C%2Fscript%3E%5Cn%3Cstyle%3E%5Cn.box%20span%20%7B%5Cn%20%20color%3A%20red%3B%5Cn%7D%5Cn%3C%2Fstyle%3E%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span><span>&lt;</span>template</span><span>></span></span>
  <span><span><span>&lt;</span>div</span> <span>class</span><span><span>=</span><span>"</span>box<span>"</span></span><span>></span></span>
    Mr.Hope <span><span><span>&lt;</span>span</span><span>></span></span>{{ message }}<span><span><span>&lt;/</span>span</span><span>></span></span>
  <span><span><span>&lt;/</span>div</span><span>></span></span>
<span><span><span>&lt;/</span>template</span><span>></span></span>
<span><span><span>&lt;</span>script</span><span>></span></span><span><span>
<span>export</span> <span>default</span> <span>{</span>
  <span>data</span><span>:</span> <span>(</span><span>)</span> <span>=></span> <span>(</span><span>{</span> <span>message</span><span>:</span> <span>"十分帅"</span> <span>}</span><span>)</span><span>,</span>
<span>}</span><span>;</span>
</span></span><span><span><span>&lt;/</span>script</span><span>></span></span>
<span><span><span>&lt;</span>style</span><span>></span></span><span><span>
<span>.box span</span> <span>{</span>
  <span>color</span><span>:</span> red<span>;</span>
<span>}</span>
</span></span><span><span><span>&lt;/</span>style</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo [vue] 一个 Vue Demo

<span><span>```</span><span>vue</span>
<span>&lt;template>
  &lt;div>
    Mr.Hope &lt;span>{{ message }}&lt;/span>
  &lt;/div>
&lt;/template>
&lt;script>
export default {
  data: () => ({ message: "十分帅" }),
};
&lt;/script>
&lt;style>
.box span {
  color: red;
}
&lt;/style></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div></details>

          <div
            id="code-demo-2869b0e2"
           
  
 data-title="%E4%B8%80%E4%B8%AA%E6%99%AE%E9%80%9A%20Demo"

            data-code="%7B%22md%22%3A%22%23%20%E6%A0%87%E9%A2%98%5Cn%5Cn%E5%8D%81%E5%88%86%E5%B8%85%5Cn%22%2C%22ts%22%3A%22const%20message%3A%20string%20%3D%20%5C%22Mr.Hope%5C%22%3B%5Cn%5Cndocument.querySelector(%5C%22h1%5C%22).innerHTML%20%3D%20message%3B%5Cn%22%2C%22scss%22%3A%22h1%20%7B%5Cn%20%20font-style%3A%20italic%3B%5Cn%5Cn%20%20%2B%20p%20%7B%5Cn%20%20%20%20color%3A%20red%3B%5Cn%20%20%7D%5Cn%7D%5Cn%22%7D"
          >
              
              <div>
                <div>
<div><pre><code><span><span>#</span> 标题</span>

十分帅
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>"Mr.Hope"</span><span>;</span>

document<span>.</span><span>querySelector</span><span>(</span><span>"h1"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><div><pre><code><span>h1 </span><span>{</span>
  <span>font-style</span><span>:</span> italic<span>;</span>

  <span>+ p </span><span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
  <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div>
            </div>
          </div>
          
        </div>
<details><summary>代码</summary>
<div><pre><code>::: demo 一个普通 Demo

<span><span>```</span><span>md</span>
<span><span><span>#</span> 标题</span>

十分帅</span>
<span>```</span></span>

<span><span>```</span><span>ts</span>
<span><span>const</span> message<span>:</span> <span>string</span> <span>=</span> <span>"Mr.Hope"</span><span>;</span>

document<span>.</span><span>querySelector</span><span>(</span><span>"h1"</span><span>)</span><span>.</span>innerHTML <span>=</span> message<span>;</span></span>
<span>```</span></span>

<span><span>```</span><span>scss</span>
<span><span>h1 </span><span>{</span>
  <span>font-style</span><span>:</span> italic<span>;</span>

  <span>+ p </span><span>{</span>
    <span>color</span><span>:</span> red<span>;</span>
  <span>}</span>
<span>}</span></span>
<span>```</span></span>

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/demo/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h3 id="幻灯片"> 幻灯片</h3>
<i>Not supported content</i><details><summary>代码</summary>
<div><pre><code>@slidestart

<span><span>##</span> 幻灯片 1</span>

一个有文字和 <span>[<span>链接</span>](<span>https://mrhope.site</span>)</span> 的段落

<span>---</span>

<span><span>##</span> 幻灯片 2</span>

<span>-</span> 列表 1
<span>-</span> 列表 2

<span>---</span>

<span><span>##</span> 幻灯片 3.1</span>

<span><span>```</span><span>js</span>
<span><span>const</span> a <span>=</span> <span>1</span><span>;</span></span>
<span>```</span></span>

--

<span><span>##</span> 幻灯片 3.2</span>

$$
J(\theta_0,\theta_1) = \sum_{i=0}
$$

@slideend
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div></details>
<ul>
<li><a href="https://vuepress-theme-hope.github.io/zh/guide/markdown/presentation/" target="_blank" rel="noopener noreferrer">点击查看</a></li>
</ul>
<h2 id="其他语法"> 其他语法</h2>
<div><p>自定义标题</p>
<p>信息容器</p>
</div>
<div><p>自定义标题</p>
<p>提示容器</p>
</div>
<div><p>自定义标题</p>
<p>警告容器</p>
</div>
<div><p>自定义标题</p>
<p>危险容器</p>
</div>
<details><summary>自定义标题</summary>
<p>详情容器</p>
</details>
<details><summary>代码</summary>
<div><pre><code>::: info 自定义标题

信息容器

:::

::: tip 自定义标题

提示容器

:::

::: warning 自定义标题

警告容器

:::

::: danger 自定义标题

危险容器

:::

::: details 自定义标题

详情容器

:::
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br></div></div></details>
<hr>
<section>
<ol>
<li id="footnote1"><p>这是脚注内容 </p>
</li>
</ol>
</section>
]]></content:encoded>
    </item>
    <item>
      <title>项目主页</title>
      <link>https://vue-blog.lllllan.cn/home/</link>
      <guid>https://vue-blog.lllllan.cn/home/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">项目主页</source>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
    </item>
    <item>
      <title>博客主页</title>
      <link>https://vue-blog.lllllan.cn/</link>
      <guid>https://vue-blog.lllllan.cn/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">博客主页</source>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
    </item>
    <item>
      <title>幻灯片页</title>
      <link>https://vue-blog.lllllan.cn/slides/</link>
      <guid>https://vue-blog.lllllan.cn/slides/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">幻灯片页</source>
      <pubDate>Thu, 20 Jan 2022 05:26:23 GMT</pubDate>
      <content:encoded><![CDATA[
<i>Not supported content</i>]]></content:encoded>
      <enclosure url="https://vue-blog.lllllan.cn/logo.svg" type="image/svg+xml"/>
    </item>
  </channel>
</rss>