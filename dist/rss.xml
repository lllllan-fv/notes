<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:dc="http://purl.org/dc/elements/1.1/">
  <channel>
    <atom:link href="https://vue-blog.lllllan.cn/rss.xml" rel="self" type="application/rss+xml"/>
    <title>lllllan</title>
    <link>https://vue-blog.lllllan.cn/</link>
    <description></description>
    <language>en-US</language>
    <pubDate>Sat, 22 Jan 2022 07:56:43 GMT</pubDate>
    <lastBuildDate>Sat, 22 Jan 2022 07:56:43 GMT</lastBuildDate>
    <generator>@mr-hope/vuepress-plugin-feed</generator>
    <docs>https://validator.w3.org/feed/docs/rss2.html</docs>
    <copyright>Copyright by lllllan</copyright>
    <category>Java</category>
    <category>MySQL</category>
    <category>计算机基础</category>
    <category>刷题</category>
    <item>
      <title>R2Coding - Java 基础核心总结</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/1-java-basic-core-summary/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/1-java-basic-core-summary/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">R2Coding - Java 基础核心总结</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>全部抄自<a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a>上提供资料</p>
</div>
<h2 id="一、-java语言的特点"> 一、 java语言的特点</h2>
<ul>
<li>面向对象</li>
<li>平台无关性</li>
</ul>
<blockquote>
<p>已编译的java程序可以在任何带 有jvm的平台上运行。</p>
<p><code>java</code> 代码编译为 <code>.class</code> 文件，然后打包成 <code>.jar</code> 文件，这样就能够在不同系统下运行了。</p>
</blockquote>
<ul>
<li>简单性</li>
</ul>
<blockquote>
<p>摒弃了C++中难以理解的多继承、指针、内存管理等概念，不用手动管理对象的生命周期</p>
</blockquote>
<ul>
<li>解释执行</li>
</ul>
<blockquote>
<p>静态页面，在编译期间救恩那个直到数据类型的语言，在运行前就能检查类型的正确性。</p>
<p>执行效率相比动态语言更高，速度更快</p>
</blockquote>
<ul>
<li>多线程</li>
</ul>
<blockquote>
<p>java <strong>应该</strong> 在 <code>用户空间</code> 实现的多线程，内核感知不到 java 存在多线程机制。</p>
</blockquote>
<ul>
<li>分布式</li>
</ul>
<blockquote>
<p><img src="./README.assets/image-20211213091134933.png" alt="image-20211213091134933" /></p>
</blockquote>
<ul>
<li>健壮性</li>
</ul>
<blockquote>
<p>强类型机制、异常处理、垃圾的自动收集</p>
</blockquote>
<ul>
<li>高性能</li>
</ul>
<blockquote>
<p><img src="./README.assets/image-20211213090952974.png" alt="image-20211213090952974" /></p>
</blockquote>
<ul>
<li>安全性</li>
</ul>
<h2 id="二、面向对象"> 二、面向对象</h2>
<h3 id="_2-1-初始化顺序"> 2.1 初始化顺序</h3>
<blockquote>
<ul>
<li>静态属性</li>
<li>静态方法快</li>
<li>普通方法</li>
<li>普通方法块</li>
<li>构造函数</li>
<li>方法</li>
</ul>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>static</span> <span>String</span> staticField <span>=</span> <span>getStaticField</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>String</span> <span>getStaticField</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> staticFiled <span>=</span> <span>"静态属性初始化"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>staticFiled<span>)</span><span>;</span>
        <span>return</span> staticFiled<span>;</span>
    <span>}</span>

    <span>static</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"静态方法块初始化"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>String</span> field <span>=</span> <span>getField</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>String</span> <span>getField</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> field <span>=</span> <span>"普通属性初始化"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>field<span>)</span><span>;</span>
        <span>return</span> field<span>;</span>
    <span>}</span>

    <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"普通方法块初始化"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Solution</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"构造函数"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code>静态属性初始化
静态方法块初始化
普通属性初始化
普通方法块初始化
构造函数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><hr>
<h3 id="_2-2-三大特性"> 2.2 三大特性</h3>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h4 id="访问控制权限"> 访问控制权限</h4>
<p><img src="./README.assets/image-20211217195521425.png" alt="image-20211217195521425" /></p>
<hr>
<h3 id="_2-3-接口"> 2.3 接口</h3>
<ul>
<li>interface、implements</li>
<li>接口只能使用 <code>public</code> <code>default</code>  两种访问修饰符</li>
<li>接口只提供方法的定义。</li>
<li>接口不能被实例化，所以接口中不能有构造方法。</li>
<li>接口的实现类必须实现接口的全部方法。</li>
</ul>
<hr>
<h3 id="_2-4-抽象类"> 2.4 抽象类</h3>
<ul>
<li>abstract</li>
<li>只有抽象类中能有抽象方法，抽象类中不只有抽象方法。</li>
<li>抽象类不能被实例化。</li>
</ul>
<hr>
<h3 id="_2-5-内部类"> 2.5 内部类</h3>
<ul>
<li>内部类拥有外部类的访问权限</li>
</ul>
<p><img src="./README.assets/image-20211217195726947.png" alt="image-20211217195726947" /></p>
<h2 id="三、异常"> 三、异常</h2>
<h3 id="_3-1-throwable"> 3.1 Throwable</h3>
<p><code>Throable</code> 类是Java语言中所有 <code>错误(errors)</code> 和 <code>异常(exceptions)</code> 的父类。</p>
<p><img src="./README.assets/image-20211217184906894.png" alt="image-20211217184906894" /></p>
<h3 id="_3-2-常见异常"> 3.2 常见异常</h3>
<p><img src="./README.assets/image-20211217193021056.png" alt="image-20211217193021056" /></p>
<h3 id="_3-3-error"> 3.3 Error</h3>
<p><img src="./README.assets/image-20211217194119016.png" alt="image-20211217194119016" /></p>
<h2 id="四、集合"> 四、集合</h2>
<p><img src="./README.assets/image-20211218142929505.png" alt="image-20211218142929505" /></p>
<p><img src="./README.assets/image-20211218182136734.png" alt="image-20211218182136734" /></p>
<h2 id="五、反射"> 五、反射</h2>
<p>Java反射机制是在程序的运行过程中，对于任何一个类，都能知道它的所有属性和方法；对于任意一个对象，都能知道调用它的任意属性和方法。</p>
<p>这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时判断任意一个类的对象</li>
<li>在运行时判断任意一个类所有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<h3 id="_5-1-class-类"> 5.1 Class 类</h3>
<p>当我们编写一个类，在生产的<code>.class</code> 文件中，就会产生一个 Class 对象。这个 Class 对象用于标识这个类的类型信息。</p>
<p>Class中没有公共的构造器，也就是说Class对象不能杯实例化。</p>
<p>其中包含了很多方法，详见《Java基础核心总结》P54</p>
<h3 id="_5-2-field-类"> 5.2 Field 类</h3>
<p>Field 类提供类或接口中单独字段的信息，以及对单独字段的动态访问。</p>
<h3 id="_5-3-method-类"> 5.3 Method 类</h3>
<p>传递 Object 对象及参数调用该对象对应的方法</p>
<h3 id="_5-4-classloader-类"> 5.4 ClassLoader 类</h3>
<p>类装载器是用来把类装载进JVM的。ClassLoader使用的是双亲委托模型来搜索加载类的。</p>
<p><img src="./README.assets/image-20211224112354940.png" alt="image-20211224112354940" /></p>
<h2 id="六、枚举"> 六、枚举</h2>
<p>枚举是一个特殊的类，一般表示一组常量</p>
<div><pre><code><span>public</span> <span>enum</span> <span>Family</span> <span>{</span>
    FATHER<span>,</span>
    MOTHER<span>,</span>
    SON<span>,</span>
    <span>Daughter</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./README.assets/image-20211224185753390.png" alt="image-20211224185753390" /></p>
<p>一般 switch 可以和 enum 一起连用，来构造一个小型的状态转换机</p>
<div><pre><code><span>enum</span> <span>Signal</span> <span>{</span>
    GREEN<span>,</span> YELLOW<span>,</span> RED
<span>}</span>
<span>public</span> <span>class</span> <span>TrafficLight</span> <span>{</span>
    <span>Signal</span> color <span>=</span> <span>Signal</span><span>.</span>RED<span>;</span>
    <span>public</span> <span>void</span> <span>change</span><span>(</span><span>)</span> <span>{</span>
        <span>switch</span> <span>(</span>color<span>)</span> <span>{</span>
            <span>case</span> RED<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>GREEN<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> YELLOW<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>RED<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> GREEN<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>YELLOW<span>;</span>
                <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="七、io"> 七、IO</h2>
<p><img src="./README.assets/image-20211224191321306.png" alt="image-20211224191321306" /></p>
<p><img src="./README.assets/image-20211224191353166.png" alt="image-20211224191353166" /></p>
<h3 id="_7-1-file-类"> 7.1 File 类</h3>
<p>主要涉及 <strong>文件创建、删除文件、获取文件描述</strong></p>
<p><img src="./README.assets/image-20211224191614348.png" alt="image-20211224191614348" /></p>
<h3 id="_7-2-inputstream"> 7.2 InputStream</h3>
<p>字节输入模式的抽象类</p>
<p><img src="./README.assets/image-20211224191724340.png" alt="image-20211224191724340" /></p>
<h3 id="_7-3-outputstream"> 7.3 OutputStream</h3>
<p>字节输出模式的抽象类</p>
<p><img src="./README.assets/image-20211224191752947.png" alt="image-20211224191752947" /></p>
<h3 id="_7-4-reader"> 7.4 Reader</h3>
<p>字符输入模式的抽象类</p>
<p><img src="./README.assets/image-20211224191816351.png" alt="image-20211224191816351" /></p>
<h3 id="_7-5-writer"> 7.5 Writer</h3>
<p>字符输出模式的抽象类</p>
<p><img src="./README.assets/image-20211224191839037.png" alt="image-20211224191839037" /></p>
<h3 id="_7-6-更多其他子类"> 7.6 更多其他子类</h3>
<p>详见 《Java基础核心总结》 p67</p>
<h2 id="插眼"> 插眼：</h2>
<h3 id="jdk、jre、jvm"> JDK、JRE、JVM</h3>
<h3 id="switch-实现原理"> switch 实现原理</h3>
<h3 id="深浅拷贝"> 深浅拷贝</h3>
<h3 id="代理-意义何在"> 代理，意义何在</h3>
<h3 id="面向对象三大特性"> 面向对象三大特性</h3>
<h3 id="修饰符"> 修饰符</h3>
<h3 id="集合"> 集合</h3>
]]></content:encoded>
    </item>
    <item>
      <title>反射机制</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/2-reflection/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/2-reflection/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">反射机制</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">反射机制详解！ | JavaGuide</a>，略有改动</p>
</div>
<blockquote>
<p>总之反射就是能获取一个类的所有方法和属性，并能够调用。</p>
<p>然后还能增加代码的灵活性。</p>
<p>但是，我还是没有感受到，灵活在哪里。。。</p>
</blockquote>
<h2 id="什么是反射"> 什么是反射？</h2>
<p>反射就是Reflection，Java的反射是指程序在<strong>运行期</strong>可以拿到一个对象的所有信息，，你还可以调用这些方法和属性。</p>
<h2 id="反射的应用场景"> 反射的应用场景</h2>
<ul>
<li>模块化的开发，通过反射去调用对应的字节码</li>
<li>框架中大量使用动态代理，而动态代理依赖反射机制实现</li>
<li>注解的实现也用到了反射</li>
</ul>
<p><strong>JDBC的数据库连接</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>String</span> DBDRIVER <span>=</span> <span>"com.mysql.jdbc.Driver"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBURL <span>=</span> <span>"jdbc:mysql://localhost:3306/test"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBUSER <span>=</span> <span>"root"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBPASS <span>=</span> <span>""</span><span>;</span>  

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>  
    <span>Connection</span> con <span>=</span> <span>null</span><span>;</span>
    <span>Class</span><span>.</span><span>forName</span><span>(</span>DBDRIVER<span>)</span><span>;</span> <span>//1、使用CLASS 类加载驱动程序 ,反射机制的体现 </span>
    con <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>DBURL<span>,</span>DBUSER<span>,</span>DBPASS<span>)</span><span>;</span> <span>//2、连接数据库  </span>
    <span>.</span><span>.</span><span>.</span>
    con<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> <span>// 3、关闭数据库  </span>
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="反射的优缺点"> 反射的优缺点</h2>
<p><strong>优点：</strong> 让代码更加灵、为各种框架提供开箱即用的功能提供便利</p>
<p><strong>缺点：</strong> 在运行时有了分析操作类的能力，同样增加了安全问题。性能略差，不过对于框架的影响比较小。</p>
<h2 id="反射的使用"> 反射的使用</h2>
<h3 id="获取class对象的四种方式"> 获取Class对象的四种方式</h3>
<p><strong>1.知道具体类的情况下可以使用</strong></p>
<div><pre><code><span>Class</span> alunbarClass <span>=</span> <span>TargetObject</span><span>.</span><span>class</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2.通过 <code>Class.forName()</code> 传入类的路径获取</strong></p>
<div><pre><code><span>Class</span> alunbarClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>3.通过对象实例 <code>instance.getClass()</code> 获取</strong></p>
<div><pre><code><span>TargetObject</span> o <span>=</span> <span>new</span> <span>TargetObject</span><span>(</span><span>)</span><span>;</span>
<span>Class</span> alunbarClass2 <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取</strong></p>
<div><pre><code><span>Class</span> clazz <span>=</span> <span>ClassLoader</span><span>.</span><span>loadClass</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="反射的基本操作"> 反射的基本操作</h3>
<p><strong>1.定义一个类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>TargetObject</span> <span>{</span>
    <span>private</span> <span>String</span> value<span>;</span>

    <span>public</span> <span>TargetObject</span><span>(</span><span>)</span> <span>{</span>
        value <span>=</span> <span>"JavaGuide"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>publicMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I love "</span> <span>+</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>privateMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"value is "</span> <span>+</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>2.使用反射来操作这个类的方法及参数</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span><span>,</span> <span>NoSuchMethodException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InstantiationException</span><span>,</span> <span>InvocationTargetException</span><span>,</span> <span>NoSuchFieldException</span> <span>{</span>
        <span>/**
         * 获取TargetObject类的Class对象并且创建TargetObject类实例
         */</span>
        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
        <span>TargetObject</span> targetObject <span>=</span> <span>(</span><span>TargetObject</span><span>)</span> tagetClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>/**
         * 获取所有类中所有定义的方法
         */</span>
        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> tagetClass<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>/**
         * 获取指定方法并调用
         */</span>
        <span>Method</span> publicMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"publicMethod"</span><span>,</span>
                <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>

        publicMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 获取指定参数并对参数进行修改
         */</span>
        <span>Field</span> field <span>=</span> tagetClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
        <span>//为了对类中的参数进行修改我们取消安全检查</span>
        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        field<span>.</span><span>set</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 调用 private 方法
         */</span>
        <span>Method</span> privateMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"privateMethod"</span><span>)</span><span>;</span>
        <span>//为了调用private方法我们取消安全检查</span>
        privateMethod<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        privateMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>3.输出结果</strong></p>
<div><pre><code>publicMethod
privateMethod
<span>I</span> love <span>JavaGuide</span>
value is <span>JavaGuide</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>JavaGuide - Java基础知识</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/2-java-guide-basic/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/2-java-guide-basic/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">JavaGuide - Java基础知识</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide</a>，略有改动</p>
</div>
<h2 id="一-基础概念与常识"> 一 基础概念与常识</h2>
<h3 id="_1-1-java语言的特点"> 1.1 Java语言的特点</h3>
<ol>
<li>简单易学</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机，一次编译到处运行）</li>
<li>解释执行（编译成字节码文件，java解释器对字节码进行解释执行）</li>
<li>多线程</li>
<li>分布式（强大、易于使用的联网能力）</li>
<li>高性能（相对其他高级语言，<a href="https://zhuanlan.zhihu.com/p/361250220" target="_blank" rel="noopener noreferrer">JIT</a>的发展）</li>
<li>健壮性（强类型机制、异常处理、垃圾回收机制）</li>
<li>安全性（安全机制以防止恶意代码的攻击）</li>
<li></li>
</ol>
<h3 id="_1-2-jvm-jdk-jre"> 1.2 JVM &amp; JDK &amp; JRE</h3>
<ol>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li>
<li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 <u>Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</u>。但是，它不能用于创建新程序。</li>
<li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。</li>
</ol>
<div><p>JDK > JRE > JVM</p>
<p><a href="https://blog.csdn.net/ancientear/article/details/79483592" target="_blank" rel="noopener noreferrer">浅谈JDK、JRE、JVM区别与联系</a></p>
<ol>
<li>JVM不能单独执行class</li>
<li>JRE = JVM + lib（jvm工作需要的类库）。可以执行class</li>
<li>JDK包含JRE。可以开发、编译、执行</li>
</ol>
</div>
<p><img src="./README.assets/0cc3f4a15d3184391a98a7b1c58f6e5f_720w.jpg" alt="img" /></p>
<h3 id="_1-3-字节码及优点"> 1.3 字节码及优点</h3>
<p>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<ul>
<li>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</li>
<li>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</li>
</ul>
<p><img src="./README.assets/java程序转变为机器代码的过程.3dbbbc5a.png" alt="Java程序转变为机器代码的过程" /></p>
<h3 id="_1-4-编译与解释并存"> 1.4 编译与解释并存</h3>
<p>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<div><p>为什么要这么做？</p>
<p>编译型语言执行速度快、开发效率低，解释型语言开发效率快、执行速度慢。</p>
<p>编译与解释并存，（猜测应该）能融合两者的优点，提升开发效率的同时、保证执行速度。</p>
</div>
<h3 id="_1-5-oracle-jdk-openjdk-不懂"> 1.5 Oracle JDK &amp; OpenJDK （不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#oracle-jdk-vs-openjdk" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide</a></p>
<h3 id="_1-6-java-和-c-的区别"> 1.6 Java 和 C++ 的区别</h3>
<ul>
<li>都是面向对象的语言，都支持封装、继承、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，但是接口可以多继承；C++支持类多重继承</li>
<li>Java有自动内存管理垃圾回收机制 （GC），不需要程序员手动释放无用内存</li>
<li>C++同时支持方法重载和操作符重载，但是Java只支持方法重载（重载操作符增加了复杂性）</li>
<li>。。。</li>
</ul>
<h2 id="二、基本语法"> 二、基本语法</h2>
<h3 id="_2-0-详见javaguide-基本语法"> 2.0 详见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">JavaGuide #基本语法</a></h3>
<h3 id="_2-1-静态方法为什么不能调用非静态方法"> 2.1 静态方法为什么不能调用非静态方法？</h3>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<div><p>为什么要用静态方法？</p>
<p>静态方法的好处就是不用生成类的实例就可以直接调用。只需要通过其类名就可以访问，不需要再消耗资源反复创建对象。</p>
</div>
<h3 id="_2-2-重载和重写的区别"> 2.2 重载和重写的区别</h3>
<div><p>Tips</p>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</div>
<p><strong>重载：</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别点</th>
<th style="text-align:left">重载方法</th>
<th style="text-align:left">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">发生范围</td>
<td style="text-align:left">同一个类</td>
<td style="text-align:left">子类</td>
</tr>
<tr>
<td style="text-align:left">参数列表</td>
<td style="text-align:left">必须修改</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">返回类型</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td style="text-align:left">异常</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td style="text-align:left">发生阶段</td>
<td style="text-align:left">编译期</td>
<td style="text-align:left">运行期</td>
</tr>
</tbody>
</table>
<h3 id="_2-3-泛型"> 2.3 泛型</h3>
<blockquote>
<p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
</blockquote>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>详见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener noreferrer">JavaGuide #泛型</a></p>
<h3 id="_2-4-和-equals-的区别"> 2.4 == 和 equals() 的区别</h3>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<div><p>Tips</p>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</div>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<h3 id="_2-5-hashcode-与-equals"> 2.5 hashCode() 与 equals()</h3>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>更多解释见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#hashcode-%E4%B8%8E-equals" target="_blank" rel="noopener noreferrer">JavaGuide #hashcode-与-equals</a></p>
<div><p>hashCode的作用</p>
<p>hashCode和equals有一个相同的作用，就是用作比较：</p>
<ul>
<li>equals 为true的两个对象相等，false则两个对象不相等</li>
<li>hashCode 相同的两个对象不一定相等，但不同的两个对象一定不相等</li>
</ul>
</div>
<div><p>为什么要有 hashCode？</p>
<p><strong>效率</strong>
当一个对象逐渐复杂时，equals方法中的判定条件也会逐渐复杂，这个时候比较两个对象是否相等依旧使用equals的话，就会变得低效。</p>
<p>因此引出hashCode，通过一定的计算方式，为每个对象分配一个“哈希码”，让相等的对象都拥有相同的哈希码。之后需要比较两个对象的时候，先比较哈希码，如果哈希码都不相同，两个对象一定不相等。如果哈希码相同，再继续使用equals确定对象是否相等。</p>
<p>hashCode 方法相对与 equals 会更加高效，通过这两步判断，来确定两个对象是否相等</p>
</div>
<h2 id="三、基本数据类型"> 三、基本数据类型</h2>
<h3 id="_3-0-基本数据类型存放位置"> 3.0 基本数据类型存放位置</h3>
<p>一：在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p>
<p>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p>
<p>​     （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p>
<p>​     （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p>
<p>二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p>
<p>​    同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p>
<p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p>
<p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</p>
<h3 id="_3-1-包装类型的常量池"> 3.1 包装类型的常量池</h3>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>解释来说呢，大概就是以上几种类型中，创建的对象大小在约定的范围之内，该对象会在cache中长生（如果已存在将会复用）。</p>
<ul>
<li>节省内存空间：常量池中所有相同的对象常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<h2 id="四、java面向对象"> 四、Java面向对象</h2>
<h3 id="_4-1-面向对象和面向过程的区别"> 4.1 面向对象和面向过程的区别</h3>
<ul>
<li>
<p>因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。</p>
</li>
<li>
<p>因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</li>
</ul>
<div><p>Tips</p>
<p><strong>面向对象易维护、易复用、易扩展。面向过程性能相对较高。</strong></p>
</div>
<h3 id="_4-2-成员变量和局部变量的区别"> 4.2 成员变量和局部变量的区别</h3>
<p><img src="./README.assets/image-20220116180214826.png" alt="image-20220116180214826" /></p>
<h3 id="_4-3-对象实体和对象引用"> 4.3 对象实体和对象引用</h3>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="_4-4-对象相等和引用相等"> 4.4 对象相等和引用相等</h3>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="_4-5-构造方法的特点"> 4.5 构造方法的特点</h3>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<div><p>Tips</p>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
</div>
<h3 id="_4-6-面向对象三大特征"> 4.6 面向对象三大特征</h3>
<h4 id="_4-6-1-封装"> 4.6.1 封装</h4>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<div><p>封装的好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高代码的复用性</li>
<li>提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）</li>
</ul>
</div>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span><span>//id属性私有化</span>
    <span>private</span> <span>String</span> name<span>;</span><span>//name属性私有化</span>

    <span>//获取id的方法</span>
    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span> <span>return</span> id<span>;</span> <span>}</span>

    <span>//设置id的方法</span>
    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span> <span>this</span><span>.</span>id <span>=</span> id<span>;</span> <span>}</span>

    <span>//获取name的方法</span>
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span> <span>return</span> name<span>;</span> <span>}</span>

    <span>//设置name的方法</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span> <span>this</span><span>.</span>name <span>=</span> name<span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_4-6-2-继承"> 4.6.2 继承</h4>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<div><p>继承的优点</p>
<ol>
<li>提高代码的复用性</li>
<li>提高代码的易维护性</li>
<li>提高代码的可扩展性</li>
<li>使代码结构清晰</li>
</ol>
</div>
<div><p>继承的缺点</p>
<ol>
<li>高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类</li>
<li>破坏封装性、降低灵活性</li>
</ol>
</div>
<h4 id="_4-6-3-多态"> 4.6.3 多态</h4>
<p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间</strong>才能确定；</li>
<li>多态不能调用“<strong>只在子类存在但在父类不存在</strong>”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是<strong>子类覆盖</strong>的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<div><p>多态存在的必要条件</p>
<ol>
<li>要有继承</li>
<li>要有重写</li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
</div>
<div><p>多态的好处</p>
<ol>
<li>提高了代码的可扩展性</li>
<li>可替换性</li>
<li>接口性：向子类提供共同接口，由子类来完善或覆盖</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
</div>
<h3 id="_4-7-string、stringbuffer、stringbuilder"> 4.7 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code></h3>
<h4 id="_4-7-1-string-为什么是不可变的"> 4.7.1 <code>String</code> 为什么是不可变的</h4>
<p><a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener noreferrer">String为什么不可变 - 梦醒点灯</a></p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h4 id="_4-7-2-stringbuffer、stringbuilder"> 4.7.2 <code>StringBuffer</code>、<code>StringBuilder</code></h4>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> value<span>;</span>
    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>
        str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> value<span>,</span> count<span>)</span><span>;</span>
        count <span>+=</span> len<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
  	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_4-7-3-线程安全性"> 4.7.3 线程安全性</h4>
<div><p>Tips</p>
<p><code>String</code>、<code>StringBuffer</code> 是线程安全的，<code>StringBuilder</code> 非线程安全。</p>
</div>
<ul>
<li><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</li>
<li><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。
<ul>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li>
<li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
</li>
</ul>
<h4 id="_4-7-4-性能"> 4.7.4 性能</h4>
<p><code>StringBuilder</code> &gt; <code>StringBuffer</code> &gt; <code>String</code></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="_4-8-object-类的常见方法"> 4.8 <code>Object</code> 类的常见方法</h3>
<div><pre><code><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>
<span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span>
    
<span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> 
    
<span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span>
    
<span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>
<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span>
    
<span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span>

<span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//实例被垃圾回收器回收的时候触发的操作</span>
<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id="_4-9-深拷贝和浅拷贝、引用拷贝"> 4.9 深拷贝和浅拷贝、引用拷贝</h3>
<div><p>Tips</p>
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</div>
<p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="./README.assets/shallow&deep-copy.64ee0760.png" alt="img" /></p>
<h2 id="五、反射"> 五、反射</h2>
<h3 id="_5-1-什么是反射"> 5.1 什么是反射</h3>
<p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）语言的一个关键性质。</p>
<h3 id="_5-2-反射能做什么"> 5.2 反射能做什么？</h3>
<p>我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！</p>
<h3 id="_5-3-反射机制优缺点"> 5.3 反射机制优缺点</h3>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h3 id="_5-4-反射的应用场景"> 5.4 反射的应用场景</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide # 反射的应用场景</a></p>
<p>（看不懂）</p>
<h2 id="六、注解"> 六、注解</h2>
<p><a href="https://zhuanlan.zhihu.com/p/37701743" target="_blank" rel="noopener noreferrer">java 注解-最通俗易懂的讲解</a></p>
<h3 id="_6-0-注解是什么"> 6.0 注解是什么</h3>
<p><strong>初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。</strong></p>
<h3 id="_6-1-注解的作用"> 6.1 注解的作用</h3>
<ul>
<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。</li>
<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取
值得注意的是，注解不是代码本身的一部分。</li>
</ul>
<h3 id="_6-2-注解的语法、定义、运用"> 6.2 注解的语法、定义、运用</h3>
<p>暂且不谈，等到练习中认识即可</p>
<h2 id="七、异常"> 七、异常</h2>
<h3 id="_7-1-异常类层次结构图"> 7.1 异常类层次结构图</h3>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<ul>
<li>
<p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常</strong>(必须处理) 和 <strong>不受检查异常</strong>(可以不处理)。</p>
</li>
<li>
<p><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择<strong>线程终止</strong>。</p>
</li>
</ul>
<p><img src="./README.assets/Java异常类层次结构图.png" alt="img" /></p>
<p><img src="./README.assets/Java异常类层次结构图2.png" alt="img" /></p>
<h4 id="_7-1-1-受检查异常"> 7.1.1 受检查异常</h4>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码</p>
<p><img src="./README.assets/check-exception.png" alt="check-exception" /></p>
<h4 id="_7-1-2-不受检查异常"> 7.1.2 不受检查异常</h4>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="_7-2-throwable-类常用方法"> 7.2 Throwable 类常用方法</h3>
<ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="_7-3-try-catch-finally"> 7.3 try-catch-finally</h3>
<ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<strong><code>finally</code> 语句块将在方法返回之前被执行。</strong></li>
</ul>
<div><p>Tips</p>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>
<p>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</p>
</li>
<li>
<p>程序所在的线程死亡。</p>
</li>
<li>
<p>关闭 CPU。</p>
</li>
</ol>
</div>
<h3 id="_7-4-使用-try-with-resources-来代替try-catch-finally"> 7.4 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<div><pre><code><span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"test.txt"</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> fnfe<span>)</span> <span>{</span>
    fnfe<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="八、io流"> 八、IO流</h2>
<h3 id="_8-1-反-序列化"> 8.1 （反）序列化</h3>
<p>理解序列化 -&gt; <a href="https://zhuanlan.zhihu.com/p/40462507" target="_blank" rel="noopener noreferrer">序列化理解起来很简单</a></p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h4 id="_8-1-1-为什么要序列化"> 8.1.1 为什么要序列化？</h4>
<blockquote>
<p>序列化最终的目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p>
</blockquote>
<p>我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</p>
<p>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则**（序列化）<strong>，那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来</strong>（反序列化）。**</p>
<p>如果我们要把一栋房子从一个地方运输到另一个地方去，<strong>序列化</strong>就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，<strong>反序列化</strong>就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</p>
<h4 id="_8-1-2-什么时候需要序列化"> 8.1.2 什么时候需要序列化？</h4>
<p>凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。</p>
<p>本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。</p>
<h3 id="_8-2-如果有些字段不想进行序列化-看不懂"> 8.2 如果有些字段不想进行序列化（看不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96-%E6%80%8E%E4%B9%88%E5%8A%9E" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide # 如果有些字段不想进行序列化</a></p>
<h3 id="_8-3-获取用键盘输入常用的两种方法"> 8.3 获取用键盘输入常用的两种方法</h3>
<ol>
<li><code>Scanner</code></li>
</ol>
<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>String</span> s  <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>
input<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li><code>BufferedReader</code></li>
</ol>
<div><pre><code><span>BufferedReader</span> input <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>
<span>String</span> s <span>=</span> input<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_8-4-io流分类"> 8.4 IO流分类</h3>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流（<strong>对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写</strong>）。</li>
</ul>
<p><img src="./README.assets/IO-操作方式分类.png" alt="IO-操作方式分类" /></p>
<p><img src="./README.assets/IO-操作对象分类.png" alt="IO-操作对象分类" /></p>
<h3 id="_8-5-字符流的意义"> 8.5 字符流的意义</h3>
<p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
]]></content:encoded>
    </item>
    <item>
      <title>java 是值传递</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/1-java-value-passed/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/1-java-value-passed/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">java 是值传递</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java/" target="_blank" rel="noopener noreferrer">为什么 Java 中只有值传递？ | JavaGuide</a>，略有改动</p>
</div>
<h2 id="值传递-引用传递"> 值传递 &amp; 引用传递</h2>
<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h2 id="实例"> 实例</h2>
<h3 id="对基本数据类型进行修改"> 对基本数据类型进行修改</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>
    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>int</span> temp <span>=</span> a<span>;</span>
    a <span>=</span> b<span>;</span>
    b <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a = "</span> <span>+</span> a<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b = "</span> <span>+</span> b<span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
    
a <span>=</span> <span>20</span>
b <span>=</span> <span>10</span>
num1 <span>=</span> <span>10</span>
num2 <span>=</span> <span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>a和b只是从num1和num2复制得到了值，怎么操作都不会产生影响</li>
</ul>
<p><img src="./README.assets/java-value-passing-01.ab88fb01.png" alt="基本数据类型参数" /></p>
<h3 id="修改引用类型中的值"> 修改引用类型中的值</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>change</span><span>(</span>arr<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
    <span>// 将数组的第一个元素变为0</span>
    array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
   
<span>1</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src="./README.assets/java-value-passing-02.ff1b76c9.png" alt="引用数据类型参数1" /></p>
<h3 id="修改引用类型的对象"> 修改引用类型的对象</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
   <span>// 省略构造函数、Getter&amp;Setter方法</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Person</span> xiaoZhang <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
    <span>Person</span> xiaoLi <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小李"</span><span>)</span><span>;</span>
    <span>swap</span><span>(</span>xiaoZhang<span>,</span> xiaoLi<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoZhang:"</span> <span>+</span> xiaoZhang<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoLi:"</span> <span>+</span> xiaoLi<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>
    <span>Person</span> temp <span>=</span> person1<span>;</span>
    person1 <span>=</span> person2<span>;</span>
    person2 <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person1:"</span> <span>+</span> person1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person2:"</span> <span>+</span> person2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
    
person1<span>:</span>小李
person2<span>:</span>小张
xiaoZhang<span>:</span>小张
xiaoLi<span>:</span>小李
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><img src="./README.assets/java-value-passing-03.da4d0422.png" alt="引用数据类型参数2" /></p>
<h2 id="总结"> 总结</h2>
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 笔记</title>
      <link>https://vue-blog.lllllan.cn/1-java/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Java 笔记</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 09:33:02 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>重要声明</p>
<p>既然作为笔记，就存在着大量的摘抄（也就是俗话说的copy）。为了尊重原作者的劳动，此处以及每篇文章都会列出原文出处。如有遗漏，欢迎指出</p>
</div>
<h2 id="参考"> 参考</h2>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p><a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a></p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>Java 垃圾回收</title>
      <link>https://vue-blog.lllllan.cn/1-java/2-jvm/2-garbage-collection/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/2-jvm/2-garbage-collection/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Java 垃圾回收</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 08:35:36 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide</a></p>
</div>
<h1 id="写在前面"> 写在前面</h1>
<h2 id="常见面试题"> 常见面试题</h2>
<ul>
<li>如何判断对象是否死亡（两种方法）。</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>
<li>如何判断一个常量是废弃常量</li>
<li>如何判断一个类是无用的类</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>HotSpot 为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有哪些？</li>
<li>介绍一下 CMS,G1 收集器。</li>
<li>Minor Gc 和 Full GC 有什么不同呢？</li>
</ul>
<h2 id="核心问题"> 核心问题</h2>
<ol>
<li>内存如何分配和回收</li>
<li>哪些垃圾需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<p><img src="./README.assets/image-20220118102736004.png" alt="image-20220118102736004" /></p>
<h1 id="一、jvm内存分配与回收"> 一、JVM内存分配与回收</h1>
<p>Java 的自动内存管理主要是针对<strong>对象内存</strong>的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p><img src="./README.assets/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.fac41c8a.png" alt="img" /></p>
<blockquote>
<h2 id="第一次理解"> 第一次理解</h2>
<p>如图所示，一般对象的创建，会先分配到图左1的 <code>Eden</code> 区域，随着垃圾回收的进行，仍然存活的对象会根据存活时间向老年代转移。</p>
<h2 id="常见分配策略"> 常见分配策略</h2>
<ol>
<li>对象优先在 <code>Eden</code> 区域分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代</li>
</ol>
</blockquote>
<h2 id="_1-1-对象优先在-eden-区域分配"> 1.1 对象优先在 <code>Eden</code> 区域分配</h2>
<p>目前主流的垃圾收集器都会采用<strong>分代回收算法</strong>，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.</p>
<p>具体测试见 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/#_1-1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%8C%BA%E5%88%86%E9%85%8D" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide | 1.1 对象优先在 <code>Eden</code> 区域分配</a></p>
<h2 id="_1-2-大对象直接进入老年代"> 1.2 大对象直接进入老年代</h2>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。（我的理解是：eden中内存分配不足时，总有对象要被转移到老年代的，不如一开始就将比较大的对象直接分配在老年代）</p>
<h2 id="_1-3-长期存活的对象将进入老年代"> 1.3 长期存活的对象将进入老年代</h2>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
]]></content:encoded>
    </item>
    <item>
      <title>java 内存区域详解</title>
      <link>https://vue-blog.lllllan.cn/1-java/2-jvm/1-memory-area-details/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/2-jvm/1-memory-area-details/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">java 内存区域详解</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 08:35:36 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/jvm/memory-area/" target="_blank" rel="noopener noreferrer">Java 内存区域详解 | JavaGuide Java 内存区域详解</a></p>
<p>这部分内容未免有些太过抽象，这次作为 <strong>泛读</strong>，大概看一眼有一个印象，<s>（因为实在是看不懂）</s></p>
</div>
<h1 id="一-概述"> 一 概述</h1>
<p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务</p>
<h1 id="二-运行时数据区域"> 二 运行时数据区域</h1>
<p><strong>JDK 1.8 之前：</strong></p>
<p><img src="./README.assets/JVM运行时数据区域.150c33e1.png" alt="img" /></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><img src="./README.assets/Java运行时数据区域JDK1.8.37016205.png" alt="img" /></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h2 id="_2-1-程序计数器"> 2.1 程序计数器</h2>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡</strong></p>
<h2 id="_2-2-java-虚拟机栈"> 2.2 Java 虚拟机栈</h2>
<p><strong>与程序计数器一样，<u>Java 虚拟机栈也是线程私有的</u>，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p><img src="./README.assets/《深入理解虚拟机》第三版的第2章-虚拟机栈.5cc9c70c.png" alt="img" /></p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h2 id="_2-3-本地方法栈"> 2.3 本地方法栈</h2>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</p>
<h2 id="_2-4-堆"> 2.4 堆</h2>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="./README.assets/JVM堆内存结构-JDK7.7d9166eb.png" alt="JVM堆内存结构-JDK7" /></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="./README.assets/JVM堆内存结构-jdk8.919b9959.png" alt="JVM堆内存结构-JDK8" /></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size" target="_blank" rel="noopener noreferrer">Default Java 8 max heap size  (opens new window)</a>)</li>
<li>......</li>
</ol>
<h2 id="_2-5-方法区"> 2.5 方法区</h2>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h3 id="_2-5-1-方法区和永久代的关系"> 2.5.1 方法区和永久代的关系</h3>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
<h3 id="_2-5-2-常用参数"> 2.5.2 常用参数</h3>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<div><pre><code><span>-</span>XX<span>:</span><span>PermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 初始大小</span>
<span>-</span>XX<span>:</span><span>MaxPermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<div><pre><code><span>-</span>XX<span>:</span><span>MetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的初始（和最小大小）</span>
<span>-</span>XX<span>:</span><span>MaxMetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的最大大小</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h3 id="_2-5-3-为什么要将永久代-permgen-替换为元空间-metaspace-呢"> 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h3>
<p><img src="./README.assets/20210425134508117.png" alt="img" /></p>
<ol>
<li>
<p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
</li>
<li>
<p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li>
<p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h2 id="_2-6-运行时常量池"> 2.6 运行时常量池</h2>
<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<blockquote>
<ol>
<li>
<p><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></p>
</li>
<li>
<p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</p>
</li>
<li>
<p><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p>
</li>
</ol>
</blockquote>
<h2 id="_2-7-直接内存"> 2.7 直接内存</h2>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于**通道（Channel）**与**缓存区（Buffer）*<em>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为*<em>避免了在 Java 堆和 Native 堆之间来回复制数据</em></em>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h1 id="三-hotspot-虚拟机对象"> 三 HotSpot 虚拟机对象</h1>
<h2 id="_3-1-对象的创建"> 3.1 对象的创建</h2>
<p><img src="./README.assets/Java创建对象的过程.dbe33c41.png" alt="Java创建对象的过程" /></p>
<h3 id="_3-1-1-类加载检查"> 3.1.1 类加载检查</h3>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="_3-1-2-分配内存"> 3.1.2 分配内存</h3>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><img src="./README.assets/内存分配的两种方式.9ecae4c9.png" alt="" /></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="_3-1-3-初始化零值"> 3.1.3 初始化零值</h3>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="_3-1-4-设置对象头"> 3.1.4 设置对象头</h3>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="_3-1-5-执行-init-方法"> 3.1.5 执行 init 方法</h3>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="_3-2-对象的内存布局"> 3.2 对象的内存布局</h2>
<blockquote>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
</blockquote>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="_3-3-对象的访问定位"> 3.3 对象的访问定位</h2>
<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<blockquote>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
</blockquote>
<ol>
<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
</ol>
<p><img src="./README.assets/对象的访问定位-使用句柄.53859387.png" alt="对象的访问定位-使用句柄" /></p>
<ol start="2">
<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址</li>
</ol>
<p><img src="./README.assets/对象的访问定位-直接指针.c3bbe790.png" alt="对象的访问定位-直接指针" /></p>
<h1 id="四-重点补充内容"> 四 重点补充内容</h1>
<h2 id="_4-1-字符串常量池常见问题"> 4.1 字符串常量池常见问题</h2>
<h3 id="_4-1-1-和-equals"> 4.1.1 <code>==</code> 和 <code>equals</code></h3>
<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><img src="./README.assets/image-20210817123252441.png" alt="img" /></p>
<blockquote>
<p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p>
</blockquote>
<h3 id="_4-1-2-存入常量池"> 4.1.2 存入常量池</h3>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</strong></p>
<blockquote>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<div><pre><code><span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
</blockquote>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ol>
<li>基本数据类型(byte、boolean、short、char、int、float、long、double)以及字符串常量</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ol>
<h3 id="_4-1-3-字符串拼接"> 4.1.3 字符串拼接</h3>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>//常量池中的对象</span>
<span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象</span>
<span>String</span> str5 <span>=</span> <span>"string"</span><span>;</span><span>//常量池中的对象</span>

<span>String</span> str4 <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>str1<span>)</span><span>.</span><span>append</span><span>(</span>str2<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="./README.assets/字符串拼接-常量池.png" alt="img" /></p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>// 下面两个表达式其实是等价的</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_4-1-4-创建字符串对象的方式"> 4.1.4 创建字符串对象的方式</h3>
<div><pre><code><span>// 从字符串常量池中拿对象</span>
<span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 直接在堆内存空间创建一个新的对象。</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>只要使用 new 的方式创建对象，便需要创建新的对象</strong> 。</p>
<p>使用 new 的方式创建对象的方式如下，可以简单概括为 3 步：</p>
<ol>
<li>在堆中创建一个字符串对象</li>
<li>检查字符串常量池中是否有和 new 的字符串值相等的字符串常量</li>
<li>如果没有的话需要在字符串常量池中也创建一个值相等的字符串常量，如果有的话，就直接返回堆中的字符串实例对象地址。</li>
</ol>
<h3 id="_4-1-5-总结"> 4.1.5 总结</h3>
<ol>
<li>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</li>
<li>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</li>
<li>一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 <code>String</code> 对象（ <code>String s1 = &quot;java&quot;</code> ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。</li>
<li>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。</li>
</ol>
<h2 id="_4-2-string-s1-new-string-abc-这句话创建了几个字符串对象"> 4.2 String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</h2>
<p><strong>会创建 1 或 2 个字符串：</strong></p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</li>
<li>如果字符串常量池中没有字符串常量“abc”，<strong>那么它将首先在字符串常量池中创建</strong>，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>
</ul>
<h2 id="_4-3-8-种基本类型的包装类和常量池"> 4.3 8 种基本类型的包装类和常量池</h2>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<blockquote>
<h2 id="常量池技术的作用"> 常量池技术的作用</h2>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ol>
<li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ol>
</blockquote>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>
<span>Integer</span> i11 <span>=</span> <span>333</span><span>;</span>
<span>Integer</span> i22 <span>=</span> <span>333</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>
<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>
<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_4-3-0-整型包装类对象之间的比较"> 4.3.0 整型包装类对象之间的比较</h3>
<p><img src="./README.assets/20210313164740893.png" alt="img" /></p>
<h3 id="_4-3-1-integer-缓存源代码"> 4.3.1 <code>Integer</code> 缓存源代码</h3>
<div><pre><code><span>/**
*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/</span>
<span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
      <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
<span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>
    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>
    <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_4-3-2-character-缓存源码"> 4.3.2 <code>Character</code> 缓存源码</h3>
<div><pre><code><span>public</span> <span>static</span> <span>Character</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>
      <span>return</span> <span>CharacterCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>c<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>Character</span><span>(</span>c<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>CharacterCache</span> <span>{</span>
    <span>private</span> <span>CharacterCache</span><span>(</span><span>)</span><span>{</span><span>}</span>

    <span>static</span> <span>final</span> <span>Character</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>[</span><span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>static</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>(</span><span>char</span><span>)</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_4-3-3-boolean-缓存源码"> 4.3.3 <code>Boolean</code> 缓存源码</h3>
<div><pre><code><span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>代理详解</title>
      <link>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/3-agent/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/3-agent/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">代理详解</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">代理详解！静态代理+JDK/CGLIB 动态代理实战 | JavaGuide</a>， 略有改动</p>
</div>
<h2 id="代理模式"> 代理模式</h2>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p><img src="./README.assets/1DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" /></p>
<h2 id="静态代理"> 静态代理</h2>
<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1. 定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsProxy</span> <span>implements</span> <span>SmsService</span> <span>{</span>

    <span>private</span> <span>final</span> <span>SmsService</span> smsService<span>;</span>

    <span>public</span> <span>SmsProxy</span><span>(</span><span>SmsService</span> smsService<span>)</span> <span>{</span>
        <span>this</span><span>.</span>smsService <span>=</span> smsService<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method send()"</span><span>)</span><span>;</span>
        smsService<span>.</span><span>send</span><span>(</span>message<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method send()"</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4.实际使用</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SmsService</span> smsService <span>=</span> <span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>;</span>
        <span>SmsProxy</span> smsProxy <span>=</span> <span>new</span> <span>SmsProxy</span><span>(</span>smsService<span>)</span><span>;</span>
        smsProxy<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send<span>(</span><span>)</span>
send message:java
after method send<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="动态代理"> 动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<blockquote>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的</strong></p>
</blockquote>
<p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk-动态代理机制-没看懂"> JDK 动态代理机制（没看懂）</h3>
<h4 id="介绍"> 介绍</h4>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<div><pre><code><span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>
                                      <span>InvocationHandler</span> h<span>)</span>
    <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>

    <span>/**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */</span>
    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>
        <span>throws</span> <span>Throwable</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<blockquote>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
</blockquote>
<h4 id="使用步骤"> 使用步骤</h4>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="代码示例"> 代码示例</h4>
<p><strong>1.定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.定义一个 JDK 动态代理类</strong></p>
<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationHandler</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>/**
 * @author shuang.kou
 * @createTime 2020年05月11日 11:23:00
 */</span>
<span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>


    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>JdkProxyFactory</span> <span>{</span>
    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>
                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>
        <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<div><pre><code><span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>
smsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>Java 集合框架基础知识</title>
      <link>https://vue-blog.lllllan.cn/1-java/3-container/1-collection-basic/</link>
      <guid>https://vue-blog.lllllan.cn/1-java/3-container/1-collection-basic/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">Java 集合框架基础知识</source>
      <category>Java</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">Java集合框架基础知识&amp;面试题总结 | JavaGuide</a>，略有改动</p>
</div>
<h1 id="一、集合概述"> 一、集合概述</h1>
<h2 id="_1-0-java集合概览"> 1.0 Java集合概览</h2>
<p><img src="./README.assets/java-collection-hierarchy.71519bdb.png" alt="img" /></p>
<h2 id="_1-1-集合框架底层数据结构"> 1.1 集合框架底层数据结构</h2>
<ul>
<li><code>Collection</code>
<ul>
<li><code>List</code>
<ul>
<li><code>ArrayList</code>: Object[] 数组</li>
<li><code>Vector</code>: Object[] 数组</li>
<li><code>LinkedList</code>: 双向链表</li>
</ul>
</li>
<li><code>Set</code>
<ul>
<li><code>HashSet</code>（无序）: 基于 <code>HashMap</code> 实现</li>
<li><code>LinkedHashSet</code>: <code>HashSet</code> 的子类，基于 <code>LinkedHashMap</code> 实现</li>
<li><code>TreeSet</code>（有序）: 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
<li><code>Queue</code>
<ul>
<li><code>PriorityQueue</code> : Object[] 数组实现二叉堆</li>
<li><code>ArrayQueue</code> : Object[] 数组 + 双指针</li>
</ul>
</li>
</ul>
</li>
<li><code>Map</code>
<ul>
<li><code>HashMap</code> : 数组 + 链表 + 红黑树（链表根据大小和阈值进行扩容，扩容到一定大小转换为红黑树）</li>
<li><code>LinkedMap</code> : 继承自 <code>HashMap</code>，增加一条双向链表以保持插入顺序</li>
<li><code>Hashtable</code> : 数组 + 链表</li>
<li><code>TreeMap</code> : 红黑树</li>
</ul>
</li>
</ul>
<h2 id="_1-2-集合的选择"> 1.2 集合的选择</h2>
<p><img src="./README.assets/image-20220118101609300.png" alt="image-20220118101609300" /></p>
<h1 id="二、list"> 二、List</h1>
<h2 id="_2-1-arraylist-和-vector-的区别"> 2.1 ArrayList 和 Vector 的区别</h2>
<p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全的（代价就是效率差一些）。</p>
<h2 id="_2-2-arraylist-和-linkedlist-的区别"> 2.2 ArrayList  和 LinkedList 的区别</h2>
<p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h2 id="_2-3-randomaccess-接口"> 2.3 RandomAccess 接口</h2>
<div><pre><code><span>public</span> <span>interface</span> <span>RandomAccess</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch()</code>方法中，它要判断传入的 list 是否 <code>RamdomAccess</code>的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>
    <span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>
        <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
]]></content:encoded>
    </item>
    <item>
      <title>MySQL 笔记</title>
      <link>https://vue-blog.lllllan.cn/2-mysql/</link>
      <guid>https://vue-blog.lllllan.cn/2-mysql/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">MySQL 笔记</source>
      <category>MySQL</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener noreferrer">【宋红康】MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili</a></p>
<p>MySQL上过一个学期，可以说啥也没听，啥也没学，基本的语句全靠临时百度。</p>
<p>现在跟着这个视频，重新学一遍MySQL，希望能加深理解。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第三章、从网线到网络设备</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/3-network-cables-to-network-devices/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/3-network-cables-to-network-devices/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">第三章、从网线到网络设备</source>
      <category>计算机基础</category>
      <pubDate>Fri, 21 Jan 2022 02:30:27 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文作为 《网络是怎样连接的》 的笔记，绝大部分内容均抄自该书。</p>
</div>
<h2 id="一、信号在网线和集线器中传输"> 一、信号在网线和集线器中传输</h2>
<h3 id="_1-1-每个包都是独立传输的"> 1.1 每个包都是独立传输的</h3>
<p><img src="./README.assets/image-20220113145717884.png" alt="image-20220113145717884" /></p>
<h3 id="_1-2-网线中的信号衰减"> 1.2 网线中的信号衰减</h3>
<p>以太网信号的本质是正负变化的电压。</p>
<p>信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。</p>
<p>同时噪声也会进一步加剧信号的失真。</p>
<h3 id="_1-3-双绞线抑制噪声"> 1.3 双绞线抑制噪声</h3>
<blockquote>
<p>产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。信号和噪声的电流混杂在一起之后，导致信号的波形发生失真。</p>
</blockquote>
<p>影响网线的电磁波分为两种：</p>
<h4 id="来自网线之外的其他设备"> 来自网线之外的其他设备：</h4>
<p>当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流。</p>
<p>如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线产生的噪声电流方向就会相反，从而使得噪声电流相互抵消。</p>
<p><img src="./README.assets/image-20220113150630538.png" alt="image-20220113150630538" /></p>
<p><img src="./README.assets/image-20220113150651814.png" alt="image-20220113150651814" /></p>
<h4 id="相邻信号线泄露出来"> 相邻信号线泄露出来：</h4>
<p>这种内部产生的噪声称为 <strong>串扰</strong></p>
<p><img src="./README.assets/image-20220113151240119.png" alt="image-20220113151240119" /></p>
<p><img src="./README.assets/image-20220113151203170.png" alt="image-20220113151203170" /></p>
<h3 id="_1-4-集线器将信号发往所有线路"> 1.4 集线器将信号发往所有线路</h3>
<blockquote>
<p>集线器将信号发送给所有连接在它上面的线路。</p>
</blockquote>
<p><img src="./README.assets/image-20220113151435359.png" alt="image-20220113151435359" /></p>
<p><img src="./README.assets/image-20220113151613603.png" alt="image-20220113151613603" /></p>
]]></content:encoded>
    </item>
    <item>
      <title>第一章、浏览器生成消息</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/1-browser-generated-messages/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/1-browser-generated-messages/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">第一章、浏览器生成消息</source>
      <category>计算机基础</category>
      <pubDate>Fri, 21 Jan 2022 02:30:27 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文作为 《网络是怎样连接的》 的笔记，绝大部分内容均抄自该书。</p>
</div>
<h2 id="一、生成-http-请求消息"> 一、生成 HTTP 请求消息</h2>
<h3 id="_1-1-网址-url-uniform-resource-locator"> 1.1 网址（URL, Uniform Resource Locator）</h3>
<p><img src="./README.assets/image-20211217214228466.png" alt="image-20211217214228466" /></p>
<h3 id="_1-2-解析-url"> 1.2 解析 URL</h3>
<p><img src="./README.assets/image-20211217214541708.png" alt="image-20211217214541708" /></p>
<p><img src="./README.assets/image-20211217214555087.png" alt="image-20211217214555087" /></p>
<h3 id="_1-3-文件名省略"> 1.3 文件名省略</h3>
<ul>
<li>当 URL 以 <code>/</code> 结尾时，服务器会默认访问该路径下的 <code>index.html</code> 或 <code>default.html</code> 文件</li>
<li>当 URL 连 <code>/</code> 和文件类型都省略的时候：</li>
</ul>
<p><img src="./README.assets/image-20211217215354653.png" alt="image-20211217215354653" /></p>
<p>（实测：当一个文件没有文件类型的时候，不允许和一个同名文件夹同时存在。而当这个文件有后缀时，应该会访问同名文件夹）</p>
<h3 id="_1-4-http-基本思路"> 1.4 HTTP 基本思路</h3>
<ul>
<li>对什么 + 进行怎样的操作</li>
</ul>
<p><img src="./README.assets/image-20211217215856796.png" alt="image-20211217215856796" /></p>
<p><img src="./README.assets/image-20211217215922575.png" alt="image-20211217215922575" /></p>
<h3 id="_1-5-生成-http-请求信息"> 1.5 生成 HTTP 请求信息</h3>
<blockquote>
<p><strong>一条请求消息中只能写一个URI</strong>。如果需要获取多个文件，必须对每个文件单独发送一条请求</p>
</blockquote>
<p><img src="./README.assets/image-20211217223257489.png" alt="image-20211217223257489" /></p>
<p><img src="./../../../../../../data/r2coding/4.计算机基础/1.计算机网络/1.网络是怎样连接的/网络是怎样连接的.assets/image-20211217223351942.png" alt="image-20211217223351942" /></p>
<p>更多字段信息见文档 44 页。</p>
<h3 id="_1-6-服务器响应"> 1.6 服务器响应</h3>
<p><img src="./README.assets/image-20211217223257489.png" alt="image-20211217223257489" /></p>
<blockquote>
<p>状态码时一个数字，主要用来向程序告知执行的结果</p>
<p>响应短语是一段文字，用来向人们告知执行的结果</p>
</blockquote>
<p><img src="./README.assets/image-20211217224050584.png" alt="image-20211217224050584" /></p>
<p><img src="./README.assets/image-20211217224916808.png" alt="image-20211217224916808" /></p>
<h2 id="二、向-dns-服务器查询-web-服务器的-ip-地址"> 二、向 DNS 服务器查询 Web 服务器的 IP 地址</h2>
<h3 id="_2-1-ip-地址的基本知识"> 2.1 IP 地址的基本知识</h3>
<p><img src="./README.assets/image-20211219221243726.png" alt="image-20211219221243726" /></p>
<p><img src="./README.assets/image-20211219221343432.png" alt="image-20211219221343432" /></p>
<ul>
<li>IP 地址是 32 比特的数字，被分成了4组</li>
<li>子网掩码也是 32 比特的数字
<ul>
<li><strong>左边全1的部分表示网络号</strong></li>
<li><strong>右边全0的部分表示主机号</strong></li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20211219222137630.png" alt="image-20211219222137630" /></p>
<p><img src="./README.assets/image-20211219222245701.png" alt="image-20211219222245701" /></p>
<h3 id="_2-2-域名和ip地址并用的理由"> 2.2 域名和IP地址并用的理由</h3>
<ul>
<li>域名比IP地址更容易记忆</li>
<li>IP地址的传输比域名更高效（IP地址只是4字节的数字，域名最长可以是255字节的字符）</li>
</ul>
<p>于是让人来使用域名，让路由器来使用IP地址，这个机制就是<strong>DNS</strong>。</p>
<h3 id="_2-3-socket-库提供查询-ip-地址的功能"> 2.3 Socket 库提供查询 IP 地址的功能</h3>
<blockquote>
<p><strong>域名解析</strong>：通过DNS查询IP地址的操作。</p>
</blockquote>
<blockquote>
<p><strong>解析器</strong>：负责执行域名解析的DNS客户端。（解析器实际上是一段程序。）</p>
</blockquote>
<p>​	库是一堆通用程序组件的集合，他们具有诸多好处：</p>
<ul>
<li>节省编程工作量</li>
<li>实现程序的标准化</li>
<li>等等</li>
</ul>
<p>​	Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。</p>
<h3 id="_2-4-通过解析器向dns服务器发出查询"> 2.4 通过解析器向DNS服务器发出查询</h3>
<ul>
<li>调用解析器</li>
<li>解析器向DNS服务器发送查询消息</li>
<li>DNS服务器返回响应消息</li>
<li>解析器从响应消息中取出IP地址并写入内存</li>
</ul>
<p><img src="./README.assets/image-20211223215500444.png" alt="image-20211223215500444" /></p>
<p>根据域名查询IP地址时，浏览器会使用Socket库中的解析器。</p>
<h3 id="_2-5-解析器的内部原理"> 2.5 解析器的内部原理</h3>
<blockquote>
<p><strong>控制流程转移</strong>：由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行。</p>
</blockquote>
<ul>
<li>从上往下顺序执行应用程序编写的操作内容，当到达需要调用解析器的部分时</li>
<li>控制流程转移到解析器，解析器会生成要发送给DNS服务器的查询消息</li>
<li>委托操作系统内部的协议栈来发送这个消息（因为解析器本身并不具备使用网络收发数据的功能</li>
</ul>
<p><img src="./README.assets/image-20211224205322811.png" alt="image-20211224205322811" /></p>
<p>向DNS服务器发送消息时，也需要知道DNS服务器的IP地址。这是这个地址实现设置好了，不需要再查询。</p>
<p><img src="./README.assets/image-20211224213701480.png" alt="image-20211224213701480" /></p>
<h2 id="三、dns-服务器"> 三、DNS 服务器</h2>
<h3 id="_3-1-dns-服务器的基本工作"> 3.1 DNS 服务器的基本工作</h3>
<p>DNS 服务器的基本工作就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。</p>
<ul>
<li>域名：服务器、邮件服务器（邮件地址@后面的部分）的名称</li>
<li>Class：代表互联网的IN</li>
<li>记录类型：表示域名对应何种类型的记录。</li>
</ul>
<p><img src="./README.assets/image-20211224215024279.png" alt="image-20211224215024279" /></p>
<h3 id="_3-2-域名的层次结构"> 3.2 域名的层次结构</h3>
<p>由于存在着不计其数的服务器，不可能将所有服务器的信息保存在一台DNS服务器中，只能是将这些信息分布保存在多台DNS服务器中。</p>
<ul>
<li>按域名以分层次的结构来保存</li>
<li>域名中越靠右的位置表示气层级越高</li>
<li>每个域都是作为一个整体存放在DNS服务器中的</li>
</ul>
<h3 id="_3-3-寻找相应的-dns-服务器并获取-ip-地址"> 3.3 寻找相应的 DNS 服务器并获取 IP 地址</h3>
<ul>
<li>负责管理下级域的 DNS 服务器的 IP 地址注册到他们的上级 DNS 服务器中</li>
<li>com和jp 的上面存在一个 根域</li>
<li>所有 DNS 服务器中都保存有根域的 DNS 服务器信息</li>
</ul>
<p><img src="./README.assets/image-20211224220739596.png" alt="image-20211224220739596" /></p>
<p><img src="./README.assets/image-20211224220802400.png" alt="image-20211224220802400" /></p>
<h3 id="_3-4-通过缓存加快-dns-服务器的响应"> 3.4 通过缓存加快 DNS 服务器的响应</h3>
<p>DNS 服务器有一个缓存功能，可以记住之前查询过的域名</p>
<ul>
<li>如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应。</li>
<li>当查询的域名不存在时，“不存在”这一响应结果也会被缓存</li>
<li>缓存信息设置有一个有效期，当信息超过有效期后，数据会从缓存中删除</li>
<li>DNS服务器返回响应时，会告知这一响应结果是来自缓存还是来自负责管理该域名的DNS服务器</li>
</ul>
<h2 id="四、委托协议栈发送消息"> 四、委托协议栈发送消息</h2>
<h3 id="_4-1-数据收发操作概览"> 4.1 数据收发操作概览</h3>
<blockquote>
<p>委托操作系统内部的协议栈发送HTTP消息，适用于<strong>任何</strong>网络应用程序。</p>
</blockquote>
<p><img src="./README.assets/image-20211225120920801.png" alt="image-20211225120920801" /></p>
<ul>
<li>创建套接字（出入口） —— <strong>创建套接字阶段</strong></li>
<li>【客户端】向【服务器端】套接字连接管道 —— <strong>连接阶段</strong></li>
<li>收发数据 —— <strong>通信阶段</strong></li>
<li>断开管道并删除套接字 —— <strong>断开阶段</strong></li>
</ul>
<blockquote>
<p>这个管道中，<em>数据流动是<strong>双向</strong>的</em></p>
</blockquote>
<h3 id="_4-2-创建套接字阶段"> 4.2 创建套接字阶段</h3>
<blockquote>
<p>创建套接字需要调用 Socket 库中的 <strong>socket 程序组件</strong></p>
</blockquote>
<p>客户端创建套接字：</p>
<ul>
<li>调用 Socket 库中的 socket 程序组件</li>
<li>控制流程转移到 socket 内部并执行创建套接字操作</li>
<li>控制流程交回应用程序</li>
</ul>
<p><img src="./README.assets/image-20211225122553775.png" alt="image-20211225122553775" /></p>
<blockquote>
<p>套接字创建完成以后，协议栈返回一个<strong>描述符</strong>，用来标识该套接字</p>
</blockquote>
<h3 id="_4-3-连接阶段"> 4.3 连接阶段</h3>
<blockquote>
<p>连接阶段需要调用 Socket 库中的 <strong>connect 程序组件</strong></p>
</blockquote>
<p>调用 connect 时需要指定三个参数：描述符、服务器IP地址、端口号</p>
<p><img src="./README.assets/image-20211225130205613.png" alt="image-20211225130205613" /></p>
<h3 id="_4-4-通信阶段"> 4.4 通信阶段</h3>
<blockquote>
<p>通信阶段需要调用 Socket 库中的 <strong>write 程序组件</strong>、<strong>read 程序组件</strong></p>
</blockquote>
<p>发送数据：</p>
<ul>
<li>生成 HTTP 请求消息</li>
<li>指定描述符和要发送的数据，由协议栈将数据发送到服务器</li>
</ul>
<p>接收数据：</p>
<ul>
<li>指定存放响应消息的内存地址（称为接收缓冲区）</li>
<li>read 将接收到的响应消息存放到接收缓冲区中</li>
</ul>
<h3 id="_4-5-断开阶段"> 4.5 断开阶段</h3>
<blockquote>
<p>断开阶段需要调用 Socket 库中的 <strong>close 程序组件</strong></p>
</blockquote>
<ul>
<li>Web服务器在发送完响应消息之后，会首先调用 close 来断开连接</li>
<li>客户端中 read 执行接收数据时，会告知浏览器通信阶段已结束</li>
<li>浏览器调用 close 进入断开阶段</li>
</ul>
<h3 id="_4-6-各阶段功能和调用组件"> 4.6 各阶段功能和调用组件</h3>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:center">组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建套接字</td>
<td style="text-align:center">socket</td>
</tr>
<tr>
<td style="text-align:center">连接</td>
<td style="text-align:center">connect</td>
</tr>
<tr>
<td style="text-align:center">通信</td>
<td style="text-align:center">发送：write<br>接收：read</td>
</tr>
<tr>
<td style="text-align:center">断开</td>
<td style="text-align:center">close</td>
</tr>
</tbody>
</table>
<h2 id="五、本章回顾"> 五、本章回顾</h2>
<ul>
<li>网址前的 <code>http</code> 代表什么意思</li>
</ul>
<blockquote>
<p>HTTP，即超文本传输协议，是 HyperText Transfer Protocol的缩写。</p>
</blockquote>
<ul>
<li>用来识别连接在互联网上的计算机和服务器的地址叫什么</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<ul>
<li>根据Web服务器的域名来查询IP地址时所用的服务器叫什么</li>
</ul>
<blockquote>
<p>DNS 服务器</p>
</blockquote>
<ul>
<li>向DNS服务器发送请求消息的程序叫什么</li>
</ul>
<blockquote>
<p>协议栈</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>计算机网络-常见面试题</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/1-network/2-interview-questions/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/1-network/2-interview-questions/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">计算机网络-常见面试题</source>
      <category>计算机基础</category>
      <pubDate>Fri, 21 Jan 2022 02:30:27 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener noreferrer">计算机网络常见面试题 | JavaGuide</a>，略有改动。</p>
</div>
<h2 id="一、osi-与-tcp-ip-各层的结构与功能-都有哪些协议"> 一、OSI 与 TCP/ IP 各层的结构与功能，都有哪些协议？</h2>
<blockquote>
<p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为<strong>OSI模型</strong>（OSI model），一种<a href="https://baike.baidu.com/item/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B/3187025" target="_blank" rel="noopener noreferrer">概念模型</a>，由<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87/779832" target="_blank" rel="noopener noreferrer">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p>
<p>TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。</p>
</blockquote>
<p><img src="./README.assets/五层体系结构.png" alt="五层体系结构" /></p>
<h3 id="_1-1-应用层-进程之间"> 1.1 应用层 - 进程之间</h3>
<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为<strong>报文</strong>。</p>
<h3 id="_1-2-运输层-主机之间"> 1.2 运输层 - 主机之间</h3>
<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h4 id="运输层使用协议"> 运输层使用协议</h4>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<h3 id="_1-3-网络层"> 1.3 网络层</h3>
<p><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p>
<h3 id="_1-4-数据链路层"> 1.4 数据链路层</h3>
<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<blockquote>
<p>数据链路层不仅要查错，还要纠错。</p>
</blockquote>
<h3 id="_1-5-物理层"> 1.5 物理层</h3>
<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="总结-协议记不住"> 总结（协议记不住）</h3>
<p><img src="./README.assets/七层体系结构图.png" alt="七层体系结构图" /></p>
<h2 id="二、tcp-三次握手"> 二、TCP 三次握手</h2>
<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h3 id="_2-0-tcp-三次握手漫画图解"> 2.0 TCP 三次握手漫画图解</h3>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<p><img src="./README.assets/三次握手.png" alt="TCP三次握手" /></p>
<h3 id="_2-1-三次握手流程"> 2.1 三次握手流程</h3>
<blockquote>
<p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p>
</blockquote>
<ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位<strong>SYN=1</strong>，同时选择一个<strong>初始序列号 seq=x</strong> ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <strong>ACK=1，SYN=1</strong>，<strong>确认号是ack=x+1</strong>，同时也要为自己初始化一个<strong>序列号 seq=y</strong>，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<strong>ACK=1，ack=y+1</strong>，自己的<strong>序列号seq=x+1</strong>，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<p><img src="./README.assets/0c9f470819684156cfdc27c682db4def.png" alt="img" /></p>
<h3 id="_2-2-为什么要三次握手"> 2.2 为什么要三次握手</h3>
<p><strong>三次握手的目的是建立可靠的通信信道，就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<ol>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<h3 id="_2-3-第二次握手传回了ack-为什么还要传syn"> 2.3 第二次握手传回了ACK，为什么还要传SYN？</h3>
<blockquote>
<p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
</blockquote>
<p>**SYN 同步序列编号(**Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递</p>
<h3 id="_2-4-为什么还需要第三次握手"> 2.4 为什么还需要第三次握手？</h3>
<p><strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h2 id="三、tcp四次挥手"> 三、TCP四次挥手</h2>
<h3 id="_3-0-为什么要四次挥手"> 3.0 为什么要四次挥手</h3>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p><img src="./README.assets/TCP四次挥手.png" alt="TCP四次挥手" /></p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h3 id="_3-1-四次挥手流程"> 3.1 四次挥手流程</h3>
<blockquote>
<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，<strong>然后客户端主动关闭，服务器被动关闭</strong>。</p>
</blockquote>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<strong>FIN=1，其序列号为seq=u</strong>（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，<strong>ACK=1，ack=u+1，并且带上自己的序列号seq=v</strong>，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<strong>FIN=1，ack=u+1</strong>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<strong>序列号为seq=w</strong>，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，<strong>ACK=1，ack=w+1，而自己的序列号是seq=u+1</strong>，此时，客户端就进入了TIME-WAIT（时间等待）状态。<span style="color:red"><strong>注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</strong></span>。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<p><img src="./README.assets/format,png.png" alt="四次挥手" /></p>
<h3 id="_3-2-为什么客户端最后还要等待2msl"> 3.2 为什么客户端最后还要等待2MSL？</h3>
<p>MSL（Maximum Segment Lifetime）（最长报文段寿命），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3 id="_3-3-为什么建立连接是三次握手-关闭连接确是四次挥手呢"> 3.3 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3>
<p>客户端和服务端未必能同时结束通信，存在一方发送完全部数据、而另一方还有数据要继续发送的情况。所以双方都必须分别发送连接释放报文和ACK</p>
<h3 id="_3-4-如果已经建立了连接-但是客户端突然出现故障了怎么办"> 3.4 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
]]></content:encoded>
    </item>
    <item>
      <title>第二章、用电信号传输 TCP/IP 数据</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/2-transmission-of-electrical-signal/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/2-transmission-of-electrical-signal/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">第二章、用电信号传输 TCP/IP 数据</source>
      <category>计算机基础</category>
      <pubDate>Fri, 21 Jan 2022 02:30:27 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文作为 《网络是怎样连接的》 的笔记，绝大部分内容均抄自该书。</p>
</div>
<h2 id="零、前情提要"> 零、前情提要</h2>
<ol>
<li>创建套接字。</li>
<li>连接服务器。</li>
<li>收发数据。</li>
<li>断开连接并删除套接字。</li>
<li>IP与以太网的包收发操作。</li>
<li>用UDP协议收发数据的操作。</li>
</ol>
<p><img src="./README.assets/image-20211226140619512.png" alt="image-20211226140619512" /></p>
<h2 id="一、创建套接字"> 一、创建套接字</h2>
<h3 id="_1-1-协议栈的内部结构"> 1.1 协议栈的内部结构</h3>
<p><img src="./README.assets/image-20211226140825219.png" alt="image-20211226140825219" /></p>
<blockquote>
<p>浏览器、邮件等<strong>一般应用程序收发数据时用TCP</strong>；</p>
<p><strong>DNS查询等收发较短的控制数据时用UDP</strong>。</p>
</blockquote>
<blockquote>
<p><strong>ICMP用于告知网络包传送过程中产生的错误以及各种控制消息</strong>；</p>
<p><strong>ARP用于根据IP地址查询相应的以太网MAC地址</strong>。</p>
</blockquote>
<h3 id="_1-2-套接字的实体就是通信控制信息"> 1.2 套接字的实体就是通信控制信息</h3>
<blockquote>
<p>协议栈是根据套接字中记录的控制信息来工作的。</p>
</blockquote>
<p><img src="./README.assets/image-20211226141825503.png" alt="image-20211226141825503" /></p>
<p><img src="./README.assets/image-20211226141937848.png" alt="image-20211226141937848" /></p>
<h3 id="_1-3-调用-socket-时的操作"> 1.3 调用 socket 时的操作</h3>
<blockquote>
<p>创建套接字时，首先分配一个套接字所需的内存空间，让后向其中写入初始状态。</p>
</blockquote>
<p><img src="./README.assets/image-20211226142213413.png" alt="image-20211226142213413" /></p>
<h2 id="二、连接服务器"> 二、连接服务器</h2>
<h3 id="_2-1-连接"> 2.1 连接</h3>
<blockquote>
<p>连接实际上是通信双方交换控制信息，在套接字中记录一些必要信息并准备数据收发的一连串操作。</p>
</blockquote>
<ul>
<li>把服务器的IP地址和端口号等信息告知协议栈</li>
<li>客户端向服务器传达开始通信的请求</li>
<li>开辟一个空间作为缓冲区</li>
</ul>
<h3 id="_2-2-负责保存控制信息的头部"> 2.2 负责保存控制信息的头部</h3>
<p>通信操作中使用的控制信息分为两类：</p>
<ul>
<li>头部中记录的信息</li>
<li>套接字中记录的信息</li>
</ul>
<p><img src="../../../../../../data/r2coding/4.计算机基础/1.计算机网络/1.网络是怎样连接的/网络是怎样连接的.assets/image-20211227214442175.png" alt="image-20211227214442175" style="zoom:150%;" /><img src="./README.assets/image-20211227214507743.png" alt="image-20211227214507743" /></p>
<h3 id="_2-3-连接操作的实际过程"> 2.3 连接操作的实际过程</h3>
<ul>
<li>在TCP模块处创建表示连接控制信息的头部</li>
<li>通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字
<ul>
<li>TCP模块将信息发送给IP模块并委托它进行发送</li>
<li>IP模块执行网络包发送到达服务器</li>
<li>服务器上的IP模块将接收的信息传递给TCP模块</li>
<li>服务器上的TCP模块根据TCP头部中的信息找到端口号对应的套接字</li>
<li>在套接字中写入相应信息，修改状态为正在连接，并向客户端返回响应</li>
</ul>
</li>
<li>客户端接收到服务器的套接字信息，向服务器再次发回消息表示接收成功</li>
</ul>
<h2 id="三、收发数据"> 三、收发数据</h2>
<h3 id="_3-1-将-http-请求交给协议栈"> 3.1 将 HTTP 请求交给协议栈</h3>
<p>协议栈接收到数据后，先将数据存到内部的发送缓冲区。根据以下两个维度的判断，再将HTTP请求发送出去：</p>
<ul>
<li>当从应用程序收到的数据长度超过或接近MSS时再发送出去，可以避免发送大量小包的问题。
<ul>
<li><strong>MTU</strong>：一个网络包的最大长度，一般是1500字节</li>
<li><strong>MSS</strong>：除去头部之后，一个网络包所能容纳的TCP数据的最大长度</li>
</ul>
</li>
<li>协议栈内部有一个计时器，当经过一定时间以后，就会把网络包发送出去。</li>
</ul>
<blockquote>
<p>应用程序在发送数据时可以指定一些选项，比如指定“不等待填满缓冲区直接发送“，协议栈就会按照要求直接发送。</p>
</blockquote>
<h3 id="_3-2-对较大数据进行拆分"> 3.2 对较大数据进行拆分</h3>
<p>当一个HTTP请求的长度，超过了网络包的最大长度，就需要对该请求进行拆分。</p>
<p><img src="./README.assets/image-20211228205521676.png" alt="image-20211228205521676" /></p>
<h3 id="_3-3-使用ack号确认网络包收到"> 3.3 使用ACK号确认网络包收到</h3>
<ul>
<li>发送方：从第xxx字节开始，共有xxx字节</li>
<li>接收方：收到到第xxx字节之前的全部数据</li>
</ul>
<img src="README.assets/image-20211229180218040.png" alt="image-20211229180218040" style="zoom: 150%;" />
<p><img src="./README.assets/image-20211229181203165.png" alt="image-20211229181203165" /><img src="./README.assets/image-20211229181227356.png" alt="image-20211229181227356" /></p>
<blockquote>
<p>在得到对方的确认之前，发送过的包会保存在发送缓存区。如果对方一直没有返回某些包的ACK号，就会重新发送这些包。</p>
</blockquote>
<h3 id="_3-4-根据网络包平均往返时间调整ack号等待时间"> 3.4 根据网络包平均往返时间调整ACK号等待时间</h3>
<p>TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；如果ACK号马上就能返回，则相应缩短等待时间。</p>
<h3 id="_3-5-使用窗口有效管理ack号"> 3.5 使用窗口有效管理ACK号</h3>
<blockquote>
<p>滑动窗口：在发送一个包之后，不等待ACK号返回，直接发送后续的一系列包。</p>
<p>接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口的基本思路。</p>
</blockquote>
<p><img src="./README.assets/image-20211229190220706.png" alt="image-20211229190220706" /></p>
<p>如果不等待ACK号返回一直自顾自地持续发送，就可能出现发送包的频率超过接收方的处理能力的情况。</p>
<p>接收方收到包之后会保存在接收缓冲区中，计算ACK号并返回给发送方，还要将数据传递给应用程序。如果这些操作还未完成，就有新的数据包到达，都会暂存早接收缓冲区中。但是当接收缓冲区中已经存满，再发送数据包也不可能存的下，这时候发送方的发送频率就超出了接收方的处理能力。</p>
<p>因此接收方会实现告知发送方自己的处理能力（接收缓冲区的大小），发送方会根据已发送的数据包、接收方的缓冲区计算，判断是否还可以继续发送数据。</p>
<p><img src="./README.assets/image-20211229190610804.png" alt="image-20211229190610804" /></p>
<h3 id="_3-6-ack与窗口的合并"> 3.6 ACK与窗口的合并</h3>
<p><strong>问题描述：</strong></p>
<p>当接收方接收到一个数据包，计算好ACK号返回给发送方。假设接收方的接收缓冲区中就只够保存一个数据包，返回了ACK号并不代表他可以继续接收新的数据包。因为还需要将这个数据传递给应用程序，到这个时候才可以从缓冲区将数据包删除，腾出空间来接收新的数据包。</p>
<p>从这个角度出发，接收方收到一个数据包，分别要返回一个ACK号和更新窗口的信息。如果是这样的话，要返回的包就太多了，会导致网络效率的下降。</p>
<p><strong>解决：</strong></p>
<p>接收方计算好ACK号时、窗口更新时，不会马上把包发送出去。</p>
<p>而是等ACK号和窗口更新，或者多个ACK号一起合并发送，以此来减少包的数量。</p>
<h3 id="_3-7-接收http响应消息"> 3.7 接收HTTP响应消息</h3>
<p><img src="./README.assets/image-20211229200045483.png" alt="image-20211229200045483" /></p>
<h2 id="四、从服务器断开并删除套接字"> 四、从服务器断开并删除套接字</h2>
<h3 id="_4-1-断开连接"> 4.1 断开连接</h3>
<blockquote>
<ul>
<li>协议栈在设计上允许<strong>任何一方</strong>（客户端/服务器端）先发起断开过程</li>
<li>无论哪种，完成数据发送的一方都会发起断开过程。（无非谁先谁后而已）</li>
</ul>
</blockquote>
<p>eg：</p>
<ul>
<li>服务器端先断开连接：
<ul>
<li>调用 Socket 库中的 close</li>
<li>生成一个包含断开信息的 TCP 头部，控制位中 <strong>FIN</strong> 比特位为1</li>
<li>协议栈委托 IP 模块向客户端发送数据</li>
<li>套接字中记录断开操作的信息</li>
</ul>
</li>
<li>客户端接收断开信息：
<ul>
<li>收到服务器发来的 <strong>FIN</strong> 为1的 TCP 头部</li>
<li>协议栈将套接字标记为断开操作状态</li>
<li>向服务器返回一个 <strong>ACK</strong> 号</li>
</ul>
</li>
<li>客户端断开连接：
<ul>
<li>执行和服务器相同的操作</li>
<li>服务器也向客户端返回一个 <strong>ACK</strong> 号</li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20220107205801563.png" alt="image-20220107205801563" /></p>
<h3 id="_4-2-删除套接字"> 4.2 删除套接字</h3>
<blockquote>
<p>通信结束以后，会等待一段时间再删除套接字</p>
</blockquote>
<p><strong>原因：</strong></p>
<div><pre><code>	如果服务器向客户端发送 **FIN**，而客户端向服务器返回的 **ACK** 号丢失了，那么服务器可能会重新发送一次 **FIN**。但是服务器没有等待，直接删除了这个套接字。
</code></pre>
</div><p>​		之后新的任务到达，有一个新的套接字分配得到了这个端口号。而客户端因为服务器重新发送的 <strong>FIN</strong>，返回的 <strong>ACK</strong> 号达到了。这时候服务器就会断开这个刚刚创建的新的套接字。</p>
<h3 id="_4-3-数据收发小结"> 4.3 数据收发小结</h3>
<p><img src="./README.assets/image-20220107214550624.png" alt="image-20220107214550624" /></p>
<h2 id="五、ip-与以太网的包的收发操作"> 五、IP 与以太网的包的收发操作</h2>
<h3 id="_5-1-包的基本知识"> 5.1 包的基本知识</h3>
<p><img src="./README.assets/image-20220108091227641.png" alt="image-20220108091227641" /></p>
<p>数据收发过程中的双方，在不同时刻可能互为接收方和发送方，因此统称为 <strong>终端节点</strong></p>
<p>数据包会经过一个个的网络转发设备，最后到达接收方。</p>
<ul>
<li>发送方将接收方的 IP 地址写入 IP头部</li>
<li>IP 协议根据这一 IP地址查找包的传输方向，从而确定下一个路由器的位置</li>
<li><strong>IP协议查出下一个路由器的以太网地址（MAC地址）</strong>，并将地址写入MAC头部</li>
<li>IP协议委托以太网协议将包传输</li>
</ul>
<blockquote>
<ul>
<li>路由器根据目标地址判断下一个路由器的位置 —— IP协议</li>
<li>集线器在子网中将网络包传输到下一个路由 —— 以太网协议</li>
</ul>
</blockquote>
<p><img src="./README.assets/image-20220108093602850.png" alt="image-20220108093602850" /></p>
<h3 id="_5-2-包收发操作概览"> 5.2 包收发操作概览</h3>
<ol>
<li>TCP模块委托IP模块发送包：
<ul>
<li>TCP模块在数据块前面加上TCP头部</li>
<li><strong>指定通信对象的IP地址</strong></li>
<li>整个传递给IP模块</li>
</ul>
</li>
<li>IP模块封装数据包：
<ul>
<li><strong>IP模块会添加IP头部和MAC头部</strong></li>
<li>转交给网络硬件</li>
</ul>
</li>
<li>网络包在网卡间传递</li>
<li>接收方接收网络包：
<ul>
<li>网卡将包转化为数字信息传递给IP模块</li>
<li>IP模块解除IP头部和MAC头部，将TCP头部和数据块传递给TCP模块</li>
<li>TCP模块处理数据</li>
</ul>
</li>
</ol>
<p><img src="./README.assets/image-20220108105125589.png" alt="image-20220108105125589" /></p>
<blockquote>
<p><strong>IP模块的职责就是将委托的东西打包送到对方手里。不关心TCP头部和数据内容，也不关心TCP的操作。</strong></p>
</blockquote>
<h3 id="_5-3-ip头部"> 5.3 IP头部</h3>
<img src="README.assets/image-20220108124243007.png" alt="image-20220108124243007" style="zoom:150%;" />
<p><img src="./README.assets/image-20220108124706189.png" alt="image-20220108124706189" /></p>
<h3 id="_5-4-mac头部"> 5.4 MAC头部</h3>
<p>IP模块根据路由表 Gateway 栏的内容判断应该把包发送给谁。</p>
<p>再根据IP地址查询MAC地址</p>
<p><img src="./README.assets/image-20220108161553247.png" alt="image-20220108161553247" /></p>
<h3 id="_5-5-arp查询目标路由器的mac地址"> 5.5 ARP查询目标路由器的MAC地址</h3>
<ul>
<li>ARP利用广播对所有设备问 <code>XX这个IP地址是谁的，请把你的MAC地址告诉我</code>，然后等待目标路由器将MAC地址返回</li>
</ul>
<p><img src="./README.assets/image-20220108162056855.png" alt="image-20220108162056855" /></p>
<ul>
<li>ARP缓存</li>
</ul>
<p><img src="./README.assets/image-20220108163905777.png" alt="image-20220108163905777" /></p>
<ul>
<li>MAC地址</li>
</ul>
<p><img src="./README.assets/image-20220108163921704.png" alt="image-20220108163921704" /></p>
<ul>
<li>ARP缓存过几分钟就会将原记录删除，以防因为IP地址的改变而导致通信异常</li>
</ul>
<h3 id="_5-6-以太网基本知识"> 5.6 以太网基本知识</h3>
<img src="README.assets/image-20220108164652863.png" alt="image-20220108164652863" style="zoom:150%;" />
<h3 id="_5-7-发送光电信号"> 5.7 发送光电信号</h3>
<blockquote>
<p>网卡的ROM中保存着全世界唯一的MAC地址，这是在生产网卡时写入的</p>
<p>网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块</p>
</blockquote>
<p><img src="./README.assets/image-20220108165951786.png" alt="image-20220108165951786" /></p>
<h3 id="_5-8-给网络包添加控制数据"> 5.8 给网络包添加控制数据</h3>
<blockquote>
<p>MAC模块将网络包从缓存中取出，并在开头加上 <strong>报头</strong> 和 <strong>起始帧分节符</strong>，在末尾加上 <strong>帧校验序列(FCS)</strong></p>
</blockquote>
<p><img src="./README.assets/image-20220109091031789.png" alt="image-20220109091031789" /></p>
<ul>
<li>用电信号来表达数字信息，让0和1分别对应特定的电压和电流
<ul>
<li><strong>数据信号如果出现连续的1或0，由于电流和电压没有变化，我们没办法判断其中每个比特从哪里切分</strong></li>
</ul>
</li>
<li>再发送一组用来区分比特间隔的时钟信号
<ul>
<li><strong>当距离较远、网线较长时，两条线路的长度可能会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会偏移</strong></li>
</ul>
</li>
<li>将数据信号和时钟信号叠加在一起
<ul>
<li><strong>由于时钟信号是按固定频率变化的，只要找到这个变化的周期就能从中提取出时钟信号，进而计算出数据信号</strong></li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20220109091740442.png" alt="image-20220109091740442" /></p>
<h3 id="_5-9-向集线器发送网络包"> 5.9 向集线器发送网络包</h3>
<blockquote>
<p>发送信号的两种操作：使用集线器的<strong>半双工模式</strong>、使用交换机的<strong>全双工模式</strong></p>
</blockquote>
<p>​	半双工模式中，需要先判断网线中是否存在其他设备发送的信号。如果有，需要等待信号传输完毕才能发送，否则两组信号会发生碰撞。</p>
<ol>
<li>
<p><strong>MAC 模块将数字信号按每个比特转换成电信号</strong></p>
</li>
<li>
<p><strong>PHY（MAU）模块将该信号进行格式转换</strong>并通过网线发送出去、监控接受线路中有无信号进来</p>
</li>
</ol>
<blockquote>
<p>协议栈的TCP会负责搞定可能发生的错误，因此发送信号是没有必要检查错误</p>
</blockquote>
<h3 id="_5-10-接受返回包"> 5.10 接受返回包</h3>
<p><strong>接受步骤：</strong></p>
<ol>
<li>把通过接受线路的所有信号都接收进来</li>
<li>PHY（MAU）模块将信号转换成通用格式并发送给 MAC 模块</li>
<li>MAC 模块从头开始将信号转换成数字信息，并存放到缓冲区</li>
<li>检查 FCS 和 MAC 地址，将数据受污染和地址不一致的包直接丢弃</li>
<li>网卡通过 <strong>中断机制</strong> 通知计算机收到一个包
<ol>
<li>网卡向扩展总线中的中断信号发送信号</li>
<li>该信号通过中断控制器连接到CPU</li>
<li>CPU暂时挂起正在处理的任务，切换到中断处理程序</li>
<li>中断处理程序调用网卡驱动</li>
<li>网卡执行接收操作</li>
</ol>
</li>
<li>网卡根据包中不同协议类型，将包发送给不同的栈</li>
</ol>
<h3 id="_5-11-将服务器的响应包从ip传递给tcp"> 5.11 将服务器的响应包从IP传递给TCP</h3>
<p><strong>IP模块的任务：</strong></p>
<ol>
<li>检查IP头部，确认格式是否正确</li>
<li>查看接收方IP地址，如果有误通过ICMP消息告知对方</li>
<li>分片重组：如果原始的包被分成了多个小包，需要将他们还原成原始的包</li>
</ol>
<p><img src="./README.assets/image-20220111144946393.png" alt="image-20220111144946393" /></p>
<p><strong>TCP模块的任务：</strong></p>
<ol>
<li>找到对应套接字，根据通信记录执行操作：
<ul>
<li>如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取</li>
<li>如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立或断开连接的操作状态</li>
</ul>
</li>
</ol>
<h2 id="六、udp-协议的收发操作"> 六、UDP 协议的收发操作</h2>
<h3 id="_6-1-不需要重发的数据用-udp-更高效"> 6.1 不需要重发的数据用 UDP 更高效</h3>
<blockquote>
<p>TCP为了实现可靠性和高效传输，需要将数据分片发送，并将对方未接收的数据包重新发送。</p>
</blockquote>
<h3 id="_6-2-控制用的短数据"> 6.2 控制用的短数据</h3>
<p>像DNS查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种场景既可以用UDP来代替TCP</p>
<blockquote>
<p>UDP只负责发送包，不管任何可能出现的错误</p>
</blockquote>
<p><img src="./README.assets/image-20220111153930637.png" alt="image-20220111153930637" /></p>
<h3 id="_6-3-音频和视频数据"> 6.3 音频和视频数据</h3>
<p>音频和视频数据必须在规定时间内送达，（一旦错过播放时间，重发数据也没用）因此无需重发数据。这种情况下使用UDP发送数据的效率更高</p>
<h2 id="七、本章回顾"> 七、本章回顾</h2>
<ul>
<li>表示网络包收件人的接收方IP地址是位于IP头部还是TCP头部？</li>
</ul>
<blockquote>
<p>**IP头部。**接收方IP地址最初从应用程序获得， 经由TCP模块告知IP模块</p>
</blockquote>
<ul>
<li>端口号所用来指定服务器程序的种类，那么他位于TCP头部还是IP头部？</li>
</ul>
<blockquote>
<p>**TCP头部。**连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。</p>
</blockquote>
<ul>
<li>会对包是否正确送达进行确认的是TCP还是IP呢？</li>
</ul>
<blockquote>
<p>TCP</p>
</blockquote>
<ul>
<li>根据IP地址查询MAC地址的机制叫什么？</li>
</ul>
<blockquote>
<p>ARP</p>
<p>在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就是利用广播对所有设备提问：“××这个IP地址是谁的？请把你的MAC地址告诉我。”然后就会有人回答：“这个IP地址是我的，我的MAC地址是××××。”</p>
</blockquote>
<ul>
<li>在收到ACK号之前继续发送下一个包的方式叫什么？</li>
</ul>
<blockquote>
<p>滑动窗口方式</p>
</blockquote>
]]></content:encoded>
    </item>
    <item>
      <title>操作系统-常见面试题</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/2-operating-system/1-interview-questions/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/2-operating-system/1-interview-questions/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">操作系统-常见面试题</source>
      <category>计算机基础</category>
      <pubDate>Fri, 21 Jan 2022 02:30:27 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/cs-basics/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98&amp;%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">操作系统常见面试题总结 | JavaGuide</a></p>
</div>
<h2 id="一、操作系统基础"> 一、操作系统基础</h2>
<h3 id="_1-1-操作系统"> 1.1 操作系统</h3>
<p><a href="https://zhuanlan.zhihu.com/p/105945721" target="_blank" rel="noopener noreferrer">什么是操作系统？ - 知乎 (zhihu.com)</a></p>
<p>操作系统(Operation System, OS) 是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织和调度计算机的工作和资源的分配，以提供给用户和其它软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<img src="README.assets/v2-9e3753e45963e8de97ec5af05aa4f6e9_720w.jpg" alt="img" style="zoom: 33%;" />
<p><strong>操作系统说明：</strong></p>
<ol>
<li>负责管理协调硬件、软件等计算机资源的工作</li>
<li>为上层的应用程序、用户提供简单易用的服务</li>
<li>操作系统是系统软件，而不是硬件</li>
</ol>
<p><img src="./README.assets/v2-80e382880632b6067b9c1b7c679de331_720w.jpg" alt="img" /></p>
<h3 id="_1-2-系统调用"> 1.2 系统调用</h3>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode)：用户态运行的进程可以直接读取用户程序的数据。</li>
<li>内核态(kernel mode)：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>数组练习</title>
      <link>https://vue-blog.lllllan.cn/4-practice/1-group/1-array/</link>
      <guid>https://vue-blog.lllllan.cn/4-practice/1-group/1-array/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">数组练习</source>
      <category>刷题</category>
      <pubDate>Fri, 21 Jan 2022 11:45:45 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>Info</p>
<p>感谢 <a href="https://mp.weixin.qq.com/s/3olK6pBq1tzdoz2EzQZ6Gg" target="_blank" rel="noopener noreferrer">「代码随想录」刷题攻略 (qq.com)</a> 的整理，本章是数组相关题型的简单整理</p>
</div>
<h2 id="二分"> 二分</h2>
<p><a href="https://blog.csdn.net/qq_45978890/article/details/116094046" target="_blank" rel="noopener noreferrer">【二分查找】详细图解</a></p>
<h3 id="_1-704-二分查找"> 1. <a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener noreferrer">704-二分查找</a></h3>
<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>search</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>;</span>
        <span>int</span> r <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>

        <span>int</span> mid <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>l <span>>=</span> nums<span>.</span>length <span>||</span> nums<span>[</span>l<span>]</span> <span>!=</span> target<span>)</span> l <span>=</span> <span>-</span><span>1</span><span>;</span>

        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="_2-35-搜索插入位置"> 2. <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener noreferrer">35-搜索插入位置</a></h3>
<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>searchInsert</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>

        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span> 

        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_3-34-在排序数组中查找元素的第一个和最后一个位置"> 3. <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener noreferrer">34-在排序数组中查找元素的第一个和最后一个位置</a></h3>
<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>bs</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>,</span> <span>int</span> tmp<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> val<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        l <span>-=</span> tmp<span>;</span>
        <span>if</span> <span>(</span>l <span>>=</span> <span>0</span> <span>&amp;&amp;</span> l <span>&lt;</span> nums<span>.</span>length <span>&amp;&amp;</span> nums<span>[</span>l<span>]</span> <span>==</span> val <span>-</span> tmp<span>)</span> <span>return</span> l<span>;</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>searchRange</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>bs</span><span>(</span>nums<span>,</span> target<span>,</span> <span>0</span><span>)</span><span>,</span> <span>bs</span><span>(</span>nums<span>,</span> target <span>+</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="_4-69-sqrt-x"> 4. <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener noreferrer">69-Sqrt(x)</a></h3>
<blockquote>
<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
</blockquote>
<p>注意x的范围，无脑平方可能会爆出int的范围</p>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>mySqrt</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> x<span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> mid <span>*</span> mid<span>;</span>
            <span>if</span> <span>(</span>tmp <span>&lt;</span> x<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> l <span>*</span> l<span>;</span>
        <span>if</span> <span>(</span>tmp <span>></span> x<span>)</span> l<span>--</span><span>;</span>
        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_5-367-有效的完全平方数"> 5. <a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener noreferrer">367-有效的完全平方数</a></h3>
<blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>boolean</span> <span>isPerfectSquare</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> num<span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> mid <span>*</span> mid<span>;</span>
            <span>if</span> <span>(</span>tmp <span>&lt;</span> num<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> l <span>*</span> l<span>;</span>
        <span>return</span> tmp <span>==</span> num<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="移除元素-双指针"> 移除元素/双指针</h2>
<h3 id="_1-27-移除元素"> 1. <a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener noreferrer">27-移除元素</a></h3>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>removeElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>

            <span>if</span> <span>(</span>num <span>!=</span> val<span>)</span> nums<span>[</span>l<span>++</span><span>]</span> <span>=</span> num<span>;</span>
        <span>}</span>

        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_2-26-删除有序数组中的重复项"> 2. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener noreferrer">26-删除有序数组中的重复项</a></h3>
<blockquote>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>0</span><span>;</span>

        <span>int</span> ans <span>=</span> <span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>,</span> len <span>=</span> nums<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>ans<span>]</span><span>)</span> <span>{</span>
                nums<span>[</span><span>++</span>ans<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> ans <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_3-283-移动零"> 3. <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">283-移动零</a></h3>
<blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>void</span> <span>moveZeroes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> nums<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                nums<span>[</span>l<span>++</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>,</span> len <span>=</span> nums<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            nums<span>[</span>i<span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_4-844-比较含退格的字符串"> 4. <a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener noreferrer">844-比较含退格的字符串</a></h3>
<blockquote>
<p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p>
<p>如果相等，返回 true ；否则，返回 false 。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>boolean</span> <span>backspaceCompare</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
        <span>String</span> ss <span>=</span> <span>back</span><span>(</span>s<span>)</span><span>;</span>
        <span>String</span> tt <span>=</span> <span>back</span><span>(</span>t<span>)</span><span>;</span>
        <span>return</span> ss<span>.</span><span>equals</span><span>(</span>tt<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>back</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>""</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> <span>'#'</span><span>)</span> <span>{</span>
                <span>int</span> sz <span>=</span> sb<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>sz <span>></span> <span>0</span><span>)</span> <span>{</span>
                    sb<span>.</span><span>deleteCharAt</span><span>(</span>sz <span>-</span> <span>1</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>else</span> <span>{</span>
                sb<span>.</span><span>append</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="_5-977-有序数组的平方"> 5. <a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener noreferrer">977-有序数组的平方</a></h3>
<blockquote>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>sortedSquares</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span><span>[</span><span>]</span> ans <span>=</span> <span>new</span> <span>int</span><span>[</span>len<span>]</span><span>;</span>

        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> <span>--</span>len<span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> lef <span>=</span> nums<span>[</span>l<span>]</span> <span>*</span> nums<span>[</span>l<span>]</span><span>;</span>
            <span>int</span> rig <span>=</span> nums<span>[</span>r<span>]</span> <span>*</span> nums<span>[</span>r<span>]</span><span>;</span>
            <span>if</span> <span>(</span>lef <span>>=</span> rig<span>)</span> <span>{</span>
                l<span>++</span><span>;</span>
                ans<span>[</span>len<span>--</span><span>]</span> <span>=</span> lef<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r<span>--</span><span>;</span>
                ans<span>[</span>len<span>--</span><span>]</span> <span>=</span> rig<span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> ans<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="滑动窗口"> 滑动窗口</h2>
<h3 id="_1-209-长度最小的子数组"> 1. <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener noreferrer">209-长度最小的子数组</a></h3>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>minSubArrayLen</span><span>(</span><span>int</span> target<span>,</span> <span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> ans <span>=</span> len<span>;</span>

        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> <span>0</span><span>,</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>r <span>&lt;</span> len<span>)</span> <span>{</span>
            sum <span>+=</span> nums<span>[</span>r<span>++</span><span>]</span><span>;</span>
            <span>if</span> <span>(</span>sum <span>>=</span> target<span>)</span> <span>{</span>
                ans <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>ans<span>,</span> r <span>-</span> l<span>)</span><span>;</span>
            <span>}</span>
            <span>while</span> <span>(</span>l <span>&lt;</span> r<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>sum <span>-</span> nums<span>[</span>l<span>]</span> <span>>=</span> target<span>)</span> <span>{</span>
                    sum <span>-=</span> nums<span>[</span>l<span>++</span><span>]</span><span>;</span>
                    ans <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>ans<span>,</span> r <span>-</span> l<span>)</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>sum <span>&lt;</span> target<span>)</span> <span>return</span> <span>0</span><span>;</span>

        <span>return</span> ans<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="_2-904-水果成篮"> 2. <a href="https://leetcode-cn.com/problems/fruit-into-baskets/" target="_blank" rel="noopener noreferrer">904-水果成篮</a></h3>
<blockquote>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>class</span> node <span>{</span>
        <span>private</span> <span>int</span> num<span>;</span>
        <span>private</span> <span>int</span> cnt<span>;</span>

        <span>public</span> <span>node</span><span>(</span><span>)</span> <span>{</span>
            num <span>=</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>cnt <span>==</span> <span>0</span><span>)</span> <span>{</span>
                num <span>=</span> x<span>;</span>
                cnt <span>=</span> <span>1</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>num <span>==</span> x<span>)</span> <span>{</span>
                cnt<span>++</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>public</span> <span>void</span> <span>del</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>num <span>==</span> x <span>&amp;&amp;</span> cnt <span>></span> <span>0</span><span>)</span> <span>{</span>
                cnt<span>--</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>totalFruit</span><span>(</span><span>int</span><span>[</span><span>]</span> fruits<span>)</span> <span>{</span>
        <span>int</span> ans <span>=</span> <span>0</span><span>,</span> right <span>=</span> <span>0</span><span>;</span>

        node a <span>=</span> <span>new</span> <span>node</span><span>(</span><span>)</span><span>,</span> b <span>=</span> <span>new</span> <span>node</span><span>(</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>fruits<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        a<span>.</span><span>add</span><span>(</span>fruits<span>[</span>right<span>++</span><span>]</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> fruits<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>while</span> <span>(</span>right <span>&lt;</span> len<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>a<span>.</span><span>add</span><span>(</span>fruits<span>[</span>right<span>]</span><span>)</span> <span>||</span> b<span>.</span><span>add</span><span>(</span>fruits<span>[</span>right<span>]</span><span>)</span><span>)</span> <span>{</span>
                    right<span>++</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>

            ans <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>ans<span>,</span> right <span>-</span> i<span>)</span><span>;</span>

            a<span>.</span><span>del</span><span>(</span>fruits<span>[</span>i<span>]</span><span>)</span><span>;</span>
            b<span>.</span><span>del</span><span>(</span>fruits<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>return</span> ans<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div>]]></content:encoded>
    </item>
    <item>
      <title>计算机基础</title>
      <link>https://vue-blog.lllllan.cn/3-cs-basic/</link>
      <guid>https://vue-blog.lllllan.cn/3-cs-basic/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">计算机基础</source>
      <category>计算机基础</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
      <content:encoded><![CDATA[<div><p>重要声明</p>
<p>既然作为笔记，就存在着大量的摘抄（也就是俗话说的copy）。为了尊重原作者的劳动，此处以及每篇文章都会列出原文出处。如有遗漏，欢迎指出</p>
</div>
<h2 id="参考"> 参考</h2>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p>《网络是怎样连接的》</p>
</li>
</ul>
]]></content:encoded>
    </item>
    <item>
      <title>项目主页</title>
      <link>https://vue-blog.lllllan.cn/</link>
      <guid>https://vue-blog.lllllan.cn/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">项目主页</source>
    </item>
    <item>
      <title>刷题笔记</title>
      <link>https://vue-blog.lllllan.cn/4-practice/</link>
      <guid>https://vue-blog.lllllan.cn/4-practice/</guid>
      <source url="https://vue-blog.lllllan.cn/rss.xml">刷题笔记</source>
      <category>刷题</category>
      <pubDate>Thu, 20 Jan 2022 14:33:14 GMT</pubDate>
    </item>
  </channel>
</rss>