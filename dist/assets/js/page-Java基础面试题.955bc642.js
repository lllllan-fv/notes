(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{645:function(t,a,v){"use strict";v.r(a);var _=v(1),e=Object(_.a)({},(function(){var t=this,a=t.$createElement,v=t._self._c||a;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("div",{staticClass:"custom-block warning"},[v("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),v("p",[t._v("本文所有题目整理及答案全部来自 "),v("a",{attrs:{href:"https://www.iamshuaidi.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("帅地玩编程-校招|面试|学习路线"),v("OutboundLink")],1),t._v("，略有改动")])]),t._v(" "),v("h2",{attrs:{id:"_1-面向对象和面向过程"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_1-面向对象和面向过程"}},[t._v("#")]),t._v(" 1. 面向对象和面向过程")]),t._v(" "),v("p",[v("strong",[t._v("面向过程：")])]),t._v(" "),v("p",[t._v("面向过程的思想会将一件事情，拆分成一个个更具体的小任务，由一个个方法去完成他们。只要按顺序执行这些方法，就能完成这件事情。")]),t._v(" "),v("p",[v("strong",[t._v("面向对象：")])]),t._v(" "),v("p",[t._v("面向对象的思想会把事物抽象成对象的概念，把一件事情拆分成一个个更具体的小问题，交由不同的对象分别完成以解决问题。")]),t._v(" "),v("p",[t._v("更详细生动的说明详见 "),v("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/75265007",target:"_blank",rel:"noopener noreferrer"}},[t._v("2分钟让你明白什么是面向对象编程"),v("OutboundLink")],1)]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",{staticStyle:{"text-align":"center"}},[t._v("项目名称")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("面向对象程序设计")]),t._v(" "),v("th",{staticStyle:{"text-align":"center"}},[t._v("面向过程程序设计（也叫结构化编程）")])])]),t._v(" "),v("tbody",[v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("定义")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现main()函数中所要用到的其他方法。")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("特点")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("封装、继承、多态")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("算法+数据结构")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("优势")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("适用于大型复杂系统，方便复用、")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("适用于简单系统，容易理解")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("劣势")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("比较抽象、性能比面向过程低")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("难以应对复杂系统，难以复用，不易维护、不易扩展")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("对比")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素")])]),t._v(" "),v("tr",[v("td",{staticStyle:{"text-align":"center"}},[t._v("设计语言")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等")]),t._v(" "),v("td",{staticStyle:{"text-align":"center"}},[t._v("C、Fortran")])])])]),t._v(" "),v("h2",{attrs:{id:"_2-面向对象三大特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-面向对象三大特性"}},[t._v("#")]),t._v(" 2. 面向对象三大特性")]),t._v(" "),v("p",[t._v("更多详见 "),v("RouterLink",{attrs:{to:"/1-java/1-basic/2-java-guide-basic/#_4-6-面向对象三大特征"}},[t._v("JavaGuide - Java基础知识 | lllllan")])],1),t._v(" "),v("h3",{attrs:{id:"_2-1-封装"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-封装"}},[t._v("#")]),t._v(" 2.1 封装")]),t._v(" "),v("p",[t._v("封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("封装的好处")]),t._v(" "),v("ul",[v("li",[t._v("隐藏实现细节，提供公共的访问方式")]),t._v(" "),v("li",[t._v("提高代码的复用性")]),t._v(" "),v("li",[t._v("提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）")])])]),t._v(" "),v("h3",{attrs:{id:"_2-2-继承"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-继承"}},[t._v("#")]),t._v(" 2.2 继承")]),t._v(" "),v("p",[t._v("继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。")]),t._v(" "),v("ol",[v("li",[t._v("子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"),v("strong",[t._v("只是拥有")]),t._v("。")]),t._v(" "),v("li",[t._v("子类可以拥有自己属性和方法，即子类可以对父类进行扩展。")]),t._v(" "),v("li",[t._v("子类可以用自己的方式实现父类的方法。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("继承的优点")]),t._v(" "),v("ol",[v("li",[t._v("提高代码的复用性")]),t._v(" "),v("li",[t._v("提高代码的易维护性")]),t._v(" "),v("li",[t._v("提高代码的可扩展性")]),t._v(" "),v("li",[t._v("使代码结构清晰")])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("继承的缺点")]),t._v(" "),v("ol",[v("li",[t._v("高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类")]),t._v(" "),v("li",[t._v("破坏封装性、降低灵活性")])])]),t._v(" "),v("h3",{attrs:{id:"_2-3-多态"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-多态"}},[t._v("#")]),t._v(" 2.3 多态")]),t._v(" "),v("p",[t._v("表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。")]),t._v(" "),v("ul",[v("li",[t._v("对象类型和引用类型之间具有继承（类）/实现（接口）的关系；")]),t._v(" "),v("li",[t._v("引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序"),v("strong",[t._v("运行期间")]),t._v("才能确定；")]),t._v(" "),v("li",[t._v("多态不能调用“"),v("strong",[t._v("只在子类存在但在父类不存在")]),t._v("”的方法；")]),t._v(" "),v("li",[t._v("如果子类重写了父类的方法，真正执行的是"),v("strong",[t._v("子类覆盖")]),t._v("的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("多态存在的必要条件")]),t._v(" "),v("ol",[v("li",[t._v("要有继承")]),t._v(" "),v("li",[t._v("要有重写")]),t._v(" "),v("li",[v("strong",[t._v("父类引用指向子类对象")])])])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("多态的好处")]),t._v(" "),v("ol",[v("li",[t._v("提高了代码的可扩展性")]),t._v(" "),v("li",[t._v("可替换性")]),t._v(" "),v("li",[t._v("接口性：向子类提供共同接口，由子类来完善或覆盖")]),t._v(" "),v("li",[t._v("灵活性")]),t._v(" "),v("li",[t._v("简化性")])])]),t._v(" "),v("h2",{attrs:{id:"_3-jdk、jre、jvm三者关系"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_3-jdk、jre、jvm三者关系"}},[t._v("#")]),t._v(" 3. JDK、JRE、JVM三者关系")]),t._v(" "),v("p",[t._v("JDK 是 Java 开发工具包、JRE 是 Java 运行环境、JVM 是 Java 虚拟机。")]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("JDK > JRE > JVM")]),t._v(" "),v("ol",[v("li",[t._v("JVM不能单独执行class")]),t._v(" "),v("li",[t._v("JRE = JVM + lib（jvm工作需要的类库）。可以执行class")]),t._v(" "),v("li",[t._v("JDK包含JRE。可以开发、编译、执行")])])]),t._v(" "),v("h2",{attrs:{id:"_4-重载和重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_4-重载和重写"}},[t._v("#")]),t._v(" 4. 重载和重写")]),t._v(" "),v("ul",[v("li",[t._v("重载：编译时多态，同一个类中同名的方法具有不同的参数列表、返回类型。")]),t._v(" "),v("li",[t._v("重写：运行时多态，子类重写父类的方法实现不同的功能，具有相同的参数列表、返回类型。")])]),t._v(" "),v("p",[t._v("更多详见 "),v("RouterLink",{attrs:{to:"/1-java/1-basic/2-java-guide-basic/#_2-1-静态方法为什么不能调用非静态方法"}},[t._v("JavaGuide - Java基础知识 | lllllan")])],1),t._v(" "),v("p",[t._v("​")]),t._v(" "),v("h2",{attrs:{id:"_5-java-中是否可以重写一个-private-或者-static-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5-java-中是否可以重写一个-private-或者-static-方法"}},[t._v("#")]),t._v(" 5. Java 中是否可以重写一个 private 或者 static 方法？")]),t._v(" "),v("p",[t._v("重写，又称覆盖，是在运行时绑定的。")]),t._v(" "),v("ul",[v("li",[t._v("子类不能访问或使用父类中的 private 方法，因此不能实现重写")]),t._v(" "),v("li",[t._v("static 方法是编译时静态绑定的，就算子类中再写了一个同名同参的相同方法，也只是两个毫不相干的方法，不能称为重写。")])]),t._v(" "),v("h2",{attrs:{id:"_6-构造器是否可以被重写"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_6-构造器是否可以被重写"}},[t._v("#")]),t._v(" 6. 构造器是否可以被重写？")]),t._v(" "),v("p",[t._v("父类的私有属性、方法以及构造器都是不能被重写的。")]),t._v(" "),v("h2",{attrs:{id:"_7-构造方法有哪些特性"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_7-构造方法有哪些特性"}},[t._v("#")]),t._v(" 7. 构造⽅法有哪些特性")]),t._v(" "),v("ol",[v("li",[t._v("名字与类名相同")]),t._v(" "),v("li",[t._v("没有返回值，但不能⽤ void 声明构造函数")]),t._v(" "),v("li",[t._v("成类的对象时⾃动执⾏，⽆需调⽤")])]),t._v(" "),v("h2",{attrs:{id:"_8-无参构造函数的作用"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_8-无参构造函数的作用"}},[t._v("#")]),t._v(" 8. 无参构造函数的作用")]),t._v(" "),v("ol",[v("li",[t._v("不写任何构造器，也会有一个默认的无参构造。但如果写了有参构造，就必须另写一个无参构造，否则就无法执行无参构造。")]),t._v(" "),v("li",[t._v("子类的构造当中，如果没有指定 super() 来调用父类中某个构造方法，则会调用父类中的无参构。如果这个时候父类中存在有参构造而没有无参构造，就会出错。")])]),t._v(" "),v("h2",{attrs:{id:"_9-java-中创建对象的几种方式"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_9-java-中创建对象的几种方式"}},[t._v("#")]),t._v(" 9. Java 中创建对象的几种方式")]),t._v(" "),v("ol",[v("li",[v("code",[t._v("new()")])]),t._v(" "),v("li",[v("code",[t._v("Class.forName().newInstance()")])]),t._v(" "),v("li",[v("code",[t._v("clone()")])]),t._v(" "),v("li",[v("code",[t._v("ObjectInputStream.readObject()")])])]),t._v(" "),v("h2",{attrs:{id:"_10-抽象类和接口的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-抽象类和接口的区别"}},[t._v("#")]),t._v(" 10. 抽象类和接口的区别")]),t._v(" "),v("ol",[v("li",[t._v("抽象类中可以定义构造函数，接口不能定义构造函数")]),t._v(" "),v("li",[t._v("抽象类中可以有抽象方法和具体方法，接口中只能有抽象方法")]),t._v(" "),v("li",[t._v("抽象类中的成员权限可以是 "),v("code",[t._v("public")]),t._v("、默认、"),v("code",[t._v("protected")]),t._v("，"),v("strong",[t._v("抽象方法不能被 "),v("code",[t._v("private")]),t._v(" 修饰")]),t._v("，具体方法可以；接口中的成员只能是 "),v("code",[t._v("public")])]),t._v(" "),v("li",[t._v("抽象类中可以包含静态方法（"),v("strong",[t._v("具体方法可以是静态的，抽象方法不行")]),t._v("），接口中不能包含静态方法（因为接口中定义的方法就是为了让实现类去实现，但是静态方法必须在编译时实现）")])]),t._v(" "),v("h3",{attrs:{id:"_10-1-jdk8-的改变"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_10-1-jdk8-的改变"}},[t._v("#")]),t._v(" 10.1 JDK8 的改变")]),t._v(" "),v("ol",[v("li",[t._v("允许在接口中包含具体实现的方法，使用 "),v("code",[t._v("default")]),t._v(" 修饰")]),t._v(" "),v("li",[t._v("因为允许具体实现的放，接口中也就允许有静态方法")])]),t._v(" "),v("h2",{attrs:{id:"_11-静态变量和实例变量的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_11-静态变量和实例变量的区别"}},[t._v("#")]),t._v(" 11. 静态变量和实例变量的区别")]),t._v(" "),v("ul",[v("li",[t._v("静态变量：被 "),v("code",[t._v("static")]),t._v(" 修饰，也称类变量。它属于类，因此不管创建多少个对象，该静态变量在内存中有且仅有一个拷贝。静态变量可以实现多个对象共享内存")]),t._v(" "),v("li",[t._v("实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问得到")])]),t._v(" "),v("h2",{attrs:{id:"_12-short-s1-1-s1-s1-1-为什么错-short-s1-1-s1-1-为什么没错"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_12-short-s1-1-s1-s1-1-为什么错-short-s1-1-s1-1-为什么没错"}},[t._v("#")]),t._v(" 12. "),v("code",[t._v("short s1 = 1; s1 = s1 + 1")]),t._v(" 为什么错？ "),v("code",[t._v("short s1 = 1; s1 += 1")]),t._v(" 为什么没错？")]),t._v(" "),v("p",[t._v("运算中的 "),v("code",[t._v("1")]),t._v(" 默认是 "),v("code",[t._v("int")]),t._v("类型，那么将 "),v("code",[t._v("int")]),t._v(" 类型赋值给 "),v("code",[t._v("short")]),t._v(" 类型时，会出现类型转换错误。")]),t._v(" "),v("p",[t._v("而对于 "),v("code",[t._v("+=")]),t._v("，是 Java 语言规定的运算符， Java 编译器自己会进行特殊处理")]),t._v(" "),v("h2",{attrs:{id:"_13-integer-和-int-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-integer-和-int-的区别"}},[t._v("#")]),t._v(" 13. Integer 和 int 的区别？")]),t._v(" "),v("ol",[v("li",[t._v("int 是 Java 的⼋种基本数据类型之⼀，⽽ "),v("code",[t._v("Integer")]),t._v(" 是 Java 为 int 类型提供的封装类")]),t._v(" "),v("li",[t._v("int 型变量的默认值是 0，Integer 变量的默认值是 null，这⼀点说明 Integer 可以区分出未赋值和值为 0 的 区分")]),t._v(" "),v("li",[t._v("Integer 变量必须实例化后才可以使⽤，⽽ int 不需要。")])]),t._v(" "),v("h3",{attrs:{id:"_13-1-integer-之间的比较"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-1-integer-之间的比较"}},[t._v("#")]),t._v(" 13.1 Integer 之间的比较")]),t._v(" "),v("ol",[v("li",[t._v("两个 "),v("code",[t._v("new()")]),t._v(" 出来的 "),v("code",[t._v("Integer")]),t._v(" 进行比较：因为是两个对象，进行比较的其内存地址，结果均为 false")]),t._v(" "),v("li",[v("code",[t._v("Integer")]),t._v(" 和 "),v("code",[t._v("int")]),t._v(" 进行比较：包装类和基本数据类型进行比较时，会对包装类进行拆包装为基本数据类型，所以最后是两个 "),v("code",[t._v("int")]),t._v(" 在比较。只要数值相等就为 true")]),t._v(" "),v("li",[t._v("非new生成的 "),v("code",[t._v("Integer")]),t._v(" 和 "),v("code",[t._v("new integer()")]),t._v(" 进行比较：前者指向 Java 常量池中的对象、后者指向堆中的对象，内存地址不同，结果均为 false")]),t._v(" "),v("li",[t._v("两个非new生成的 "),v("code",[t._v("Integer")]),t._v(" 进行比较：如果数值相等并且变量值在 "),v("code",[t._v("[-128, 127]")]),t._v(" 之间，比较结果为 true，否则为 false。")])]),t._v(" "),v("div",{staticClass:"language-java line-numbers-mode"},[v("pre",{pre:!0,attrs:{class:"language-java"}},[v("code",[v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("public")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("static")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token function"}},[t._v("valueOf")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("int")]),t._v(" var0"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("{")]),t._v(" \n    "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("return")]),t._v(" var0 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(">=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("-")]),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("128")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("&&")]),t._v(" var0 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("<=")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("IntegerCache")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("high "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("?")]),t._v("\n\t\t"),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("IntegerCache")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(".")]),t._v("cache"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("[")]),t._v("var0 "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v("+")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token number"}},[t._v("128")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("]")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token operator"}},[t._v(":")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),v("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("Integer")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),t._v("var0"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n"),v("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("}")]),t._v("\n")])]),t._v(" "),v("div",{staticClass:"line-numbers-wrapper"},[v("span",{staticClass:"line-number"},[t._v("1")]),v("br"),v("span",{staticClass:"line-number"},[t._v("2")]),v("br"),v("span",{staticClass:"line-number"},[t._v("3")]),v("br"),v("span",{staticClass:"line-number"},[t._v("4")]),v("br")])]),v("h3",{attrs:{id:"_13-2-包装类的缓存"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_13-2-包装类的缓存"}},[t._v("#")]),t._v(" 13.2 包装类的缓存")]),t._v(" "),v("ul",[v("li",[t._v("Boolean：全部缓存")]),t._v(" "),v("li",[t._v("Byte：全部缓存")]),t._v(" "),v("li",[t._v("Character：<= 127 缓存")]),t._v(" "),v("li",[t._v("Short：-128 — 127 缓存")]),t._v(" "),v("li",[t._v("Long：-128 — 127 缓存")]),t._v(" "),v("li",[t._v("Integer：-128 — 127 缓存")]),t._v(" "),v("li",[t._v("Float：没有缓存")]),t._v(" "),v("li",[t._v("Doulbe：没有缓存")])]),t._v(" "),v("h2",{attrs:{id:"_14-装箱和拆箱"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_14-装箱和拆箱"}},[t._v("#")]),t._v(" 14 装箱和拆箱")]),t._v(" "),v("p",[t._v("⾃动装箱是 Java 编译器在基本数据类型和对应得包装类之间做的⼀个转化。⽐如：把 int 转化成 Integer，double 转化成 Double 等等。反之就是⾃动拆箱。")]),t._v(" "),v("p",[t._v("原始类型：boolean、char、byte、short、int、long、float、double")]),t._v(" "),v("p",[t._v("封装类型：Boolean、Character、Byte、Short、Integer、Long、Float、Double")]),t._v(" "),v("h2",{attrs:{id:"_15-switch-能否作用在-byte、long、string上"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_15-switch-能否作用在-byte、long、string上"}},[t._v("#")]),t._v(" 15. switch 能否作用在  "),v("code",[t._v("byte")]),t._v("、"),v("code",[t._v("long")]),t._v("、"),v("code",[t._v("String")]),t._v("上？")]),t._v(" "),v("p",[t._v("switch 中放的只能是一个整数表达式或枚举常量。而整数表达式可以是 "),v("code",[t._v("int")]),t._v(" 或 "),v("code",[t._v("Integer")])]),t._v(" "),v("ul",[v("li",[t._v("由于 "),v("code",[t._v("byte")]),t._v("、"),v("code",[t._v("short")]),t._v("、"),v("code",[t._v("char")]),t._v(" 都可以隐式转换为 "),v("code",[t._v("int")]),t._v("，因此这些类型以及他们的包装类都是可以用的。")]),t._v(" "),v("li",[v("code",[t._v("long")]),t._v(" 不可以")]),t._v(" "),v("li",[v("code",[t._v("String")]),t._v(" 在 JDK1.7 之后可以使用")])]),t._v(" "),v("h2",{attrs:{id:"_16-object-的常用方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-object-的常用方法"}},[t._v("#")]),t._v(" 16. Object 的常用方法")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("clone")]),t._v(" ⽅法：⽤于创建并返回当前对象的⼀份拷⻉；")]),t._v(" "),v("li",[v("code",[t._v("getClass")]),t._v(" ⽅法：⽤于返回当前"),v("strong",[t._v("运⾏时对象")]),t._v("的 Class；")]),t._v(" "),v("li",[v("code",[t._v("toString")]),t._v(" ⽅法：返回对象的字符串表示形式；")]),t._v(" "),v("li",[v("code",[t._v("finalize")]),t._v(" ⽅法：实例被垃圾回收器回收时触发的⽅法；")]),t._v(" "),v("li",[v("code",[t._v("equals")]),t._v(" ⽅法：⽤于⽐较两个对象的内存地址是否相等，⼀般需要重写；")]),t._v(" "),v("li",[v("code",[t._v("hashCode")]),t._v(" ⽅法：⽤于返回对象的哈希值；")]),t._v(" "),v("li",[v("code",[t._v("notify")]),t._v(" ⽅法：唤醒⼀个在此对象监视器上等待的线程。如果有多个线程在等待只会唤醒⼀个。")]),t._v(" "),v("li",[v("code",[t._v("notifyAll")]),t._v(" ⽅法：作⽤跟 notify() ⼀样，只不过会唤醒在此对象监视器上等待的所有线程，⽽不是⼀个线程。")]),t._v(" "),v("li",[v("code",[t._v("wait")]),t._v(" ⽅法：让当前对象等待")])]),t._v(" "),v("h2",{attrs:{id:"_16-final、finally、finalize-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_16-final、finally、finalize-的区别"}},[t._v("#")]),t._v(" 16. final、finally、finalize 的区别")]),t._v(" "),v("ul",[v("li",[v("code",[t._v("final")]),t._v("：⽤于声明属性、⽅法和类，分别表示属性不可变、⽅法不可覆盖、被其修饰的类不可继承；")]),t._v(" "),v("li",[v("code",[t._v("finally")]),t._v("：异常处理语句结构的⼀部分，表示总是执⾏；")]),t._v(" "),v("li",[v("code",[t._v("finallize")]),t._v("：Object类的⼀个⽅法，在垃圾回收时会调⽤被回收对象的finalize")])]),t._v(" "),v("h2",{attrs:{id:"_17-和-equals-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_17-和-equals-的区别"}},[t._v("#")]),t._v(" 17. == 和 equals 的区别")]),t._v(" "),v("p",[v("strong",[v("code",[t._v("==")])]),t._v(" 对于基本类型和引用类型的作用效果是不同的：")]),t._v(" "),v("ul",[v("li",[t._v("对于基本数据类型来说，"),v("code",[t._v("==")]),t._v(" 比较的是值。")]),t._v(" "),v("li",[t._v("对于引用数据类型来说，"),v("code",[t._v("==")]),t._v(" 比较的是对象的内存地址。")])]),t._v(" "),v("div",{staticClass:"custom-block tip"},[v("p",{staticClass:"custom-block-title"},[t._v("Tips")]),t._v(" "),v("p",[t._v("因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。")])]),t._v(" "),v("p",[v("strong",[v("code",[t._v("equals()")])]),t._v(" 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。"),v("code",[t._v("equals()")]),t._v("方法存在于"),v("code",[t._v("Object")]),t._v("类中，而"),v("code",[t._v("Object")]),t._v("类是所有类的直接或间接父类。")]),t._v(" "),v("h2",{attrs:{id:"_18-两个对象的-hashcode-相同-则-equals-也一定为-true-吗"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_18-两个对象的-hashcode-相同-则-equals-也一定为-true-吗"}},[t._v("#")]),t._v(" 18. 两个对象的 hashCode() 相同，则 equals() 也⼀定为 true 吗？")]),t._v(" "),v("p",[t._v("两个对象的 hashCode() 相同，equals() 不⼀定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希 值相等，然⽽哈希值相等，并不⼀定能得出键值对相等【散列冲突】")]),t._v(" "),v("p",[t._v("更多详见 "),v("RouterLink",{attrs:{to:"/1-java/1-basic/2-java-guide-basic/#_2-5-hashcode-与-equals"}},[t._v("JavaGuide - Java基础知识 | lllllan")])],1),t._v(" "),v("h2",{attrs:{id:"_19-为什么重写-equals-就一定要重写-hashcode-方法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_19-为什么重写-equals-就一定要重写-hashcode-方法"}},[t._v("#")]),t._v(" 19. 为什么重写 equals() 就⼀定要重写 hashCode() 方法")]),t._v(" "),v("p",[t._v("理解 hashCode 的作用👉 "),v("RouterLink",{attrs:{to:"/1-java/1-basic/1-basic/2-java-guide-basic/#_2-5-hashcode-与-equals"}},[t._v("JavaGuide - Java基础知识 | lllllan")])],1),t._v(" "),v("h2",{attrs:{id:"_20-和-的区别"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_20-和-的区别"}},[t._v("#")]),t._v(" 20. & 和 && 的区别")]),t._v(" "),v("p",[t._v("Java 中 && 和 & 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算 结果才为 true，否则为 false。")]),t._v(" "),v("ul",[v("li",[t._v("&&：有短路功能，当第⼀个表达式的值为 false 的时候，则不再计算第⼆个表达式；")]),t._v(" "),v("li",[t._v("&：不管第⼀个表达式结果是否为 true，第⼆个都会执⾏。除此之外，& 还可以⽤作位运算符：当 & 两边的表达式 不是 Boolean 类型的时候，& 表示按位操作。")])])])}),[],!1,null,null,null);a.default=e.exports}}]);