(window.webpackJsonp=window.webpackJsonp||[]).push([[12],{604:function(s,a,t){s.exports=t.p+"assets/img/java-collection-hierarchy.71519bdb.71519bdb.png"},605:function(s,a,t){s.exports=t.p+"assets/img/image-20220118101609300.0511829b.png"},660:function(s,a,t){"use strict";t.r(a);var e=t(1),r=Object(e.a)({},(function(){var s=this,a=s.$createElement,e=s._self._c||a;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("div",{staticClass:"custom-block warning"},[e("p",{staticClass:"custom-block-title"},[s._v("Note")]),s._v(" "),e("p",[s._v("本文转载自 "),e("a",{attrs:{href:"https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/",target:"_blank",rel:"noopener noreferrer"}},[s._v("Java集合框架基础知识&面试题总结 | JavaGuide"),e("OutboundLink")],1),s._v("，略有改动")])]),s._v(" "),e("h2",{attrs:{id:"一、集合概述"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、集合概述"}},[s._v("#")]),s._v(" 一、集合概述")]),s._v(" "),e("h3",{attrs:{id:"_1-0-java集合概览"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-0-java集合概览"}},[s._v("#")]),s._v(" 1.0 Java集合概览")]),s._v(" "),e("p",[e("img",{attrs:{src:t(604),alt:"img"}})]),s._v(" "),e("h3",{attrs:{id:"_1-1-集合框架底层数据结构"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-1-集合框架底层数据结构"}},[s._v("#")]),s._v(" 1.1 集合框架底层数据结构")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("Collection")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("List")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("ArrayList")]),s._v(": Object[] 数组")]),s._v(" "),e("li",[e("code",[s._v("Vector")]),s._v(": Object[] 数组")]),s._v(" "),e("li",[e("code",[s._v("LinkedList")]),s._v(": 双向链表")])])]),s._v(" "),e("li",[e("code",[s._v("Set")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("HashSet")]),s._v("（无序）: 基于 "),e("code",[s._v("HashMap")]),s._v(" 实现")]),s._v(" "),e("li",[e("code",[s._v("LinkedHashSet")]),s._v(": "),e("code",[s._v("HashSet")]),s._v(" 的子类，基于 "),e("code",[s._v("LinkedHashMap")]),s._v(" 实现")]),s._v(" "),e("li",[e("code",[s._v("TreeSet")]),s._v("（有序）: 红黑树（自平衡的排序二叉树）")])])]),s._v(" "),e("li",[e("code",[s._v("Queue")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("PriorityQueue")]),s._v(" : Object[] 数组实现二叉堆")]),s._v(" "),e("li",[e("code",[s._v("ArrayQueue")]),s._v(" : Object[] 数组 + 双指针")])])])])]),s._v(" "),e("li",[e("code",[s._v("Map")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("HashMap")]),s._v(" : 数组 + 链表 + 红黑树（链表根据大小和阈值进行扩容，扩容到一定大小转换为红黑树）")]),s._v(" "),e("li",[e("code",[s._v("LinkedMap")]),s._v(" : 继承自 "),e("code",[s._v("HashMap")]),s._v("，增加一条双向链表以保持插入顺序")]),s._v(" "),e("li",[e("code",[s._v("Hashtable")]),s._v(" : 数组 + 链表")]),s._v(" "),e("li",[e("code",[s._v("TreeMap")]),s._v(" : 红黑树")])])])]),s._v(" "),e("h3",{attrs:{id:"_1-2-集合的选择"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_1-2-集合的选择"}},[s._v("#")]),s._v(" 1.2 集合的选择")]),s._v(" "),e("p",[e("img",{attrs:{src:t(605),alt:"image-20220118101609300"}})]),s._v(" "),e("h2",{attrs:{id:"二、list"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、list"}},[s._v("#")]),s._v(" 二、List")]),s._v(" "),e("h3",{attrs:{id:"_2-1-arraylist-和-vector-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-arraylist-和-vector-的区别"}},[s._v("#")]),s._v(" 2.1 ArrayList 和 Vector 的区别")]),s._v(" "),e("p",[e("code",[s._v("ArrayList")]),s._v(" 是 "),e("code",[s._v("List")]),s._v(" 的主要实现类，底层使用 "),e("code",[s._v("Object[]")]),s._v("存储，适用于频繁的查找工作，线程不安全 ；")]),s._v(" "),e("p",[e("code",[s._v("Vector")]),s._v(" 是 "),e("code",[s._v("List")]),s._v(" 的古老实现类，底层使用"),e("code",[s._v("Object[]")]),s._v(" 存储，线程安全的（代价就是效率差一些）。")]),s._v(" "),e("h3",{attrs:{id:"_2-2-arraylist-和-linkedlist-的区别"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-arraylist-和-linkedlist-的区别"}},[s._v("#")]),s._v(" 2.2 ArrayList  和 LinkedList 的区别")]),s._v(" "),e("p",[e("strong",[s._v("是否保证线程安全：")]),s._v(" "),e("code",[s._v("ArrayList")]),s._v(" 和 "),e("code",[s._v("LinkedList")]),s._v(" 都是不同步的，也就是不保证线程安全；")]),s._v(" "),e("p",[e("strong",[s._v("底层数据结构：")]),s._v(" "),e("code",[s._v("Arraylist")]),s._v(" 底层使用的是 "),e("strong",[e("code",[s._v("Object")]),s._v(" 数组")]),s._v("；"),e("code",[s._v("LinkedList")]),s._v(" 底层使用的是 "),e("strong",[s._v("双向链表")]),s._v(" 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）")]),s._v(" "),e("p",[e("strong",[s._v("插入和删除是否受元素位置的影响：")])]),s._v(" "),e("ul",[e("li",[e("code",[s._v("ArrayList")]),s._v(" 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行"),e("code",[s._v("add(E e)")]),s._v("方法的时候， "),e("code",[s._v("ArrayList")]),s._v(" 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（"),e("code",[s._v("add(int index, E element)")]),s._v("）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。")]),s._v(" "),e("li",[e("code",[s._v("LinkedList")]),s._v(" 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（"),e("code",[s._v("add(E e)")]),s._v("、"),e("code",[s._v("addFirst(E e)")]),s._v("、"),e("code",[s._v("addLast(E e)")]),s._v("、"),e("code",[s._v("removeFirst()")]),s._v(" 、 "),e("code",[s._v("removeLast()")]),s._v("），近似 O(1)，如果是要在指定位置 "),e("code",[s._v("i")]),s._v(" 插入和删除元素的话（"),e("code",[s._v("add(int index, E element)")]),s._v("，"),e("code",[s._v("remove(Object o)")]),s._v("） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。")])]),s._v(" "),e("p",[e("strong",[s._v("是否支持快速随机访问：")]),s._v(" "),e("code",[s._v("LinkedList")]),s._v(" 不支持高效的随机元素访问，而 "),e("code",[s._v("ArrayList")]),s._v(" 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于"),e("code",[s._v("get(int index)")]),s._v("方法)。")]),s._v(" "),e("p",[e("strong",[s._v("内存空间占用：")]),s._v(" ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。")]),s._v(" "),e("h3",{attrs:{id:"_2-3-randomaccess-接口"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-randomaccess-接口"}},[s._v("#")]),s._v(" 2.3 RandomAccess 接口")]),s._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("interface")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("RandomAccess")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br")])]),e("p",[s._v("查看源码我们发现实际上 "),e("code",[s._v("RandomAccess")]),s._v(" 接口中什么都没有定义。所以，在我看来 "),e("code",[s._v("RandomAccess")]),s._v(" 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。")]),s._v(" "),e("p",[s._v("在 "),e("code",[s._v("binarySearch()")]),s._v("方法中，它要判断传入的 list 是否 "),e("code",[s._v("RamdomAccess")]),s._v("的实例，如果是，调用"),e("code",[s._v("indexedBinarySearch()")]),s._v("方法，如果不是，那么调用"),e("code",[s._v("iteratorBinarySearch()")]),s._v("方法")]),s._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("static")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("binarySearch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("List")]),e("span",{pre:!0,attrs:{class:"token generics"}},[e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("extends")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Comparable")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("super")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("T")]),s._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("if")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("list "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("instanceof")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("RandomAccess")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("||")]),s._v(" list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("size")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[s._v("<")]),s._v("BINARYSEARCH_THRESHOLD"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Collections")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("indexedBinarySearch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n    "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("else")]),s._v("\n        "),e("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("return")]),s._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Collections")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(".")]),e("span",{pre:!0,attrs:{class:"token function"}},[s._v("iteratorBinarySearch")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),s._v("list"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" key"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(";")]),s._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[s._v("1")]),e("br"),e("span",{staticClass:"line-number"},[s._v("2")]),e("br"),e("span",{staticClass:"line-number"},[s._v("3")]),e("br"),e("span",{staticClass:"line-number"},[s._v("4")]),e("br"),e("span",{staticClass:"line-number"},[s._v("5")]),e("br"),e("span",{staticClass:"line-number"},[s._v("6")]),e("br"),e("span",{staticClass:"line-number"},[s._v("7")]),e("br")])]),e("p",[e("code",[s._v("ArrayList")]),s._v(" 实现了 "),e("code",[s._v("RandomAccess")]),s._v(" 接口， 而 "),e("code",[s._v("LinkedList")]),s._v(" 没有实现。为什么呢？我觉得还是和底层数据结构有关！"),e("code",[s._v("ArrayList")]),s._v(" 底层是数组，而 "),e("code",[s._v("LinkedList")]),s._v(" 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，"),e("code",[s._v("ArrayList")]),s._v(" 实现了 "),e("code",[s._v("RandomAccess")]),s._v(" 接口，就表明了他具有快速随机访问功能。 "),e("code",[s._v("RandomAccess")]),s._v(" 接口只是标识，并不是说 "),e("code",[s._v("ArrayList")]),s._v(" 实现 "),e("code",[s._v("RandomAccess")]),s._v(" 接口才具有快速随机访问功能的！")]),s._v(" "),e("h3",{attrs:{id:"_2-4-arraylist-扩容机制"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#_2-4-arraylist-扩容机制"}},[s._v("#")]),s._v(" 2.4 ArrayList 扩容机制")]),s._v(" "),e("p",[s._v("详见另一篇 "),e("a",{attrs:{href:"../2-source-code/1-arraylist"}},[s._v("ArrayList 源码解读")])])])}),[],!1,null,null,null);a.default=r.exports}}]);