(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{654:function(t,s,a){"use strict";a.r(s);var e=a(1),r=Object(e.a)({},(function(){var t=this,s=t.$createElement,a=t._self._c||s;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("div",{staticClass:"custom-block warning"},[a("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),a("p",[t._v("本文所有题目整理及答案全部来自 "),a("a",{attrs:{href:"https://www.iamshuaidi.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("帅地玩编程-校招|面试|学习路线"),a("OutboundLink")],1),t._v("，略有改动")])]),t._v(" "),a("h2",{attrs:{id:"_1-java-泛型是如何工作的"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_1-java-泛型是如何工作的"}},[t._v("#")]),t._v(" 1. Java 泛型是如何工作的")]),t._v(" "),a("p",[t._v("泛型是通过类型擦除来实现的，编译器在编译时擦除了所有类型相关的信息，所以在运⾏时不存在任何类型相关的 信息。例如：List 在运⾏时仅⽤⼀个 List 来表示。这样做的⽬的，是确保能和 Java 5 之前的版本开发⼆进 制类库进⾏兼容。")]),t._v(" "),a("h2",{attrs:{id:"_2-类型擦除"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_2-类型擦除"}},[t._v("#")]),t._v(" 2. 类型擦除")]),t._v(" "),a("p",[t._v("泛型信息只存在于代码编译阶段，在进⼊ JVM 之前，与泛型相关的信息会被擦除掉，专业术语叫做类型 擦除。在泛型类被类型擦除的时候，之前泛型类中的类型参数部分如果没有指定上限，如 < T > 则会被转译成普通 的 Object 类型，如果指定了上限如 "),a("code",[t._v("< T extends String >")]),t._v(" 则类型参数就被替换成类型上限。")]),t._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("List")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),t._v(" list "),a("span",{pre:!0,attrs:{class:"token operator"}},[t._v("=")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[t._v("new")]),t._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("ArrayList")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("<")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[t._v("String")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(">")])]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(")")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[t._v(";")]),t._v("\n")])]),t._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[t._v("1")]),a("br")])]),a("p",[a("strong",[t._v("补充")])]),t._v(" "),a("ol",[a("li",[t._v("两个 String 其实只有第⼀个起作⽤，后⾯⼀个没什么卵⽤，只不过 "),a("code",[t._v("JDK7")]),t._v(" 才开始⽀持 "),a("code",[t._v("Listlist = new ArrayList<>")]),t._v("这种写法。")]),t._v(" "),a("li",[t._v("第⼀个 String 就是告诉编译器，List 中存储的是 String 对象，也就是起类型检查的作⽤，之后编译器会擦除泛 型占位符，以保证兼容以前的代码")])]),t._v(" "),a("h2",{attrs:{id:"_3-限定通配符"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_3-限定通配符"}},[t._v("#")]),t._v(" 3. 限定通配符")]),t._v(" "),a("p",[t._v("限定通配符对类型进⾏了限制。有两种限定通配符，⼀种是 "),a("code",[t._v("< ? extends T >")]),t._v("  它通过确保类型必须是 T 的⼦类来设定 类型的上界，另⼀种是 "),a("code",[t._v("< ? super T >")]),t._v(" 它通过确保类型必须是 T 的⽗类来设定类型的下界。泛型类型必须⽤限定内的 类型来进⾏初始化，否则会导致编译错误。另⼀⽅⾯ < ? > 表示了⾮限定通配符，因为 < ? > 可以⽤任意类型来替 代。")]),t._v(" "),a("h2",{attrs:{id:"_4-什么是反射"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#_4-什么是反射"}},[t._v("#")]),t._v(" 4. 什么是反射")]),t._v(" "),a("h2",{attrs:{id:"未完待续"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#未完待续"}},[t._v("#")]),t._v(" 未完待续")])])}),[],!1,null,null,null);s.default=r.exports}}]);