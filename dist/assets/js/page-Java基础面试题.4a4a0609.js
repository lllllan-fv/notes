(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{641:function(t,v,_){"use strict";_.r(v);var a=_(1),e=Object(a.a)({},(function(){var t=this,v=t.$createElement,_=t._self._c||v;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("div",{staticClass:"custom-block warning"},[_("p",{staticClass:"custom-block-title"},[t._v("Note")]),t._v(" "),_("p",[t._v("本文所有题目整理及答案全部来自 "),_("a",{attrs:{href:"https://www.iamshuaidi.com/",target:"_blank",rel:"noopener noreferrer"}},[t._v("帅地玩编程-校招|面试|学习路线"),_("OutboundLink")],1),t._v("，略有改动")])]),t._v(" "),_("h2",{attrs:{id:"_1-面向对象和面向过程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1-面向对象和面向过程"}},[t._v("#")]),t._v(" 1. 面向对象和面向过程")]),t._v(" "),_("p",[_("strong",[t._v("面向过程：")])]),t._v(" "),_("p",[t._v("面向过程的思想会将一件事情，拆分成一个个更具体的小任务，由一个个方法去完成他们。只要按顺序执行这些方法，就能完成这件事情。")]),t._v(" "),_("p",[_("strong",[t._v("面向对象：")])]),t._v(" "),_("p",[t._v("面向对象的思想会把事物抽象成对象的概念，把一件事情拆分成一个个更具体的小问题，交由不同的对象分别完成以解决问题。")]),t._v(" "),_("p",[t._v("更详细生动的说明详见 "),_("a",{attrs:{href:"https://zhuanlan.zhihu.com/p/75265007",target:"_blank",rel:"noopener noreferrer"}},[t._v("2分钟让你明白什么是面向对象编程"),_("OutboundLink")],1)]),t._v(" "),_("table",[_("thead",[_("tr",[_("th",{staticStyle:{"text-align":"center"}},[t._v("项目名称")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("面向对象程序设计")]),t._v(" "),_("th",{staticStyle:{"text-align":"center"}},[t._v("面向过程程序设计（也叫结构化编程）")])])]),t._v(" "),_("tbody",[_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("定义")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现main()函数中所要用到的其他方法。")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("特点")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("封装、继承、多态")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("算法+数据结构")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("优势")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("适用于大型复杂系统，方便复用、")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("适用于简单系统，容易理解")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("劣势")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("比较抽象、性能比面向过程低")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("难以应对复杂系统，难以复用，不易维护、不易扩展")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("对比")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素")])]),t._v(" "),_("tr",[_("td",{staticStyle:{"text-align":"center"}},[t._v("设计语言")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等")]),t._v(" "),_("td",{staticStyle:{"text-align":"center"}},[t._v("C、Fortran")])])])]),t._v(" "),_("h2",{attrs:{id:"_2-面向对象三大特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-面向对象三大特性"}},[t._v("#")]),t._v(" 2. 面向对象三大特性")]),t._v(" "),_("p",[t._v("更多详见 "),_("RouterLink",{attrs:{to:"/1-java/1-basic/2-java-guide-basic/#_4-6-面向对象三大特征"}},[t._v("JavaGuide - Java基础知识 | lllllan")])],1),t._v(" "),_("h3",{attrs:{id:"_2-1-封装"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-1-封装"}},[t._v("#")]),t._v(" 2.1 封装")]),t._v(" "),_("p",[t._v("封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("封装的好处")]),t._v(" "),_("ul",[_("li",[t._v("隐藏实现细节，提供公共的访问方式")]),t._v(" "),_("li",[t._v("提高代码的复用性")]),t._v(" "),_("li",[t._v("提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）")])])]),t._v(" "),_("h3",{attrs:{id:"_2-2-继承"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-2-继承"}},[t._v("#")]),t._v(" 2.2 继承")]),t._v(" "),_("p",[t._v("继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。")]),t._v(" "),_("ol",[_("li",[t._v("子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"),_("strong",[t._v("只是拥有")]),t._v("。")]),t._v(" "),_("li",[t._v("子类可以拥有自己属性和方法，即子类可以对父类进行扩展。")]),t._v(" "),_("li",[t._v("子类可以用自己的方式实现父类的方法。")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("继承的优点")]),t._v(" "),_("ol",[_("li",[t._v("提高代码的复用性")]),t._v(" "),_("li",[t._v("提高代码的易维护性")]),t._v(" "),_("li",[t._v("提高代码的可扩展性")]),t._v(" "),_("li",[t._v("使代码结构清晰")])])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("继承的缺点")]),t._v(" "),_("ol",[_("li",[t._v("高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类")]),t._v(" "),_("li",[t._v("破坏封装性、降低灵活性")])])]),t._v(" "),_("h3",{attrs:{id:"_2-3-多态"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2-3-多态"}},[t._v("#")]),t._v(" 2.3 多态")]),t._v(" "),_("p",[t._v("表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。")]),t._v(" "),_("ul",[_("li",[t._v("对象类型和引用类型之间具有继承（类）/实现（接口）的关系；")]),t._v(" "),_("li",[t._v("引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序"),_("strong",[t._v("运行期间")]),t._v("才能确定；")]),t._v(" "),_("li",[t._v("多态不能调用“"),_("strong",[t._v("只在子类存在但在父类不存在")]),t._v("”的方法；")]),t._v(" "),_("li",[t._v("如果子类重写了父类的方法，真正执行的是"),_("strong",[t._v("子类覆盖")]),t._v("的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。")])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("多态存在的必要条件")]),t._v(" "),_("ol",[_("li",[t._v("要有继承")]),t._v(" "),_("li",[t._v("要有重写")]),t._v(" "),_("li",[_("strong",[t._v("父类引用指向子类对象")])])])]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("多态的好处")]),t._v(" "),_("ol",[_("li",[t._v("提高了代码的可扩展性")]),t._v(" "),_("li",[t._v("可替换性")]),t._v(" "),_("li",[t._v("接口性：向子类提供共同接口，由子类来完善或覆盖")]),t._v(" "),_("li",[t._v("灵活性")]),t._v(" "),_("li",[t._v("简化性")])])]),t._v(" "),_("h2",{attrs:{id:"_3-jdk、jre、jvm三者关系"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3-jdk、jre、jvm三者关系"}},[t._v("#")]),t._v(" 3. JDK、JRE、JVM三者关系")]),t._v(" "),_("p",[t._v("JDK 是 Java 开发工具包、JRE 是 Java 运行环境、JVM 是 Java 虚拟机。")]),t._v(" "),_("div",{staticClass:"custom-block tip"},[_("p",{staticClass:"custom-block-title"},[t._v("JDK > JRE > JVM")]),t._v(" "),_("ol",[_("li",[t._v("JVM不能单独执行class")]),t._v(" "),_("li",[t._v("JRE = JVM + lib（jvm工作需要的类库）。可以执行class")]),t._v(" "),_("li",[t._v("JDK包含JRE。可以开发、编译、执行")])])]),t._v(" "),_("h2",{attrs:{id:"_4-重载和重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_4-重载和重写"}},[t._v("#")]),t._v(" 4. 重载和重写")]),t._v(" "),_("ul",[_("li",[t._v("重载：编译时多态，同一个类中同名的方法具有不同的参数列表、返回类型。")]),t._v(" "),_("li",[t._v("重写：运行时多态，子类重写父类的方法实现不同的功能，具有相同的参数列表、返回类型。")])]),t._v(" "),_("p",[t._v("更多详见 "),_("RouterLink",{attrs:{to:"/1-java/1-basic/2-java-guide-basic/#_2-1-静态方法为什么不能调用非静态方法"}},[t._v("JavaGuide - Java基础知识 | lllllan")])],1),t._v(" "),_("p",[t._v("​")]),t._v(" "),_("h2",{attrs:{id:"_5-java-中是否可以重写一个-private-或者-static-方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_5-java-中是否可以重写一个-private-或者-static-方法"}},[t._v("#")]),t._v(" 5. Java 中是否可以重写一个 private 或者 static 方法？")]),t._v(" "),_("p",[t._v("重写，又称覆盖，是在运行时绑定的。")]),t._v(" "),_("ul",[_("li",[t._v("子类不能访问或使用父类中的 private 方法，因此不能实现重写")]),t._v(" "),_("li",[t._v("static 方法是编译时静态绑定的，就算子类中再写了一个同名同参的相同方法，也只是两个毫不相干的方法，不能称为重写。")])]),t._v(" "),_("h2",{attrs:{id:"_6-构造器是否可以被重写"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_6-构造器是否可以被重写"}},[t._v("#")]),t._v(" 6. 构造器是否可以被重写？")]),t._v(" "),_("p",[t._v("父类的私有属性、方法以及构造器都是不能被重写的。")]),t._v(" "),_("h2",{attrs:{id:"_7-构造方法有哪些特性"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_7-构造方法有哪些特性"}},[t._v("#")]),t._v(" 7. 构造⽅法有哪些特性")]),t._v(" "),_("ol",[_("li",[t._v("名字与类名相同")]),t._v(" "),_("li",[t._v("没有返回值，但不能⽤ void 声明构造函数")]),t._v(" "),_("li",[t._v("成类的对象时⾃动执⾏，⽆需调⽤")])]),t._v(" "),_("h2",{attrs:{id:"_8-无参构造函数的作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_8-无参构造函数的作用"}},[t._v("#")]),t._v(" 8. 无参构造函数的作用")])])}),[],!1,null,null,null);v.default=e.exports}}]);