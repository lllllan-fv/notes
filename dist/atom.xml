<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en-US">
  <id>https://vue-blog.lllllan.cn/</id>
  <title>lllllan</title>
  <author>
    <name>lllllan</name>
  </author>
  <updated>2022-01-29T14:26:44.197Z</updated>
  <generator>@mr-hope/vuepress-plugin-feed</generator>
  <link rel="self" href="https://vue-blog.lllllan.cn/atom.xml"/>
  <link rel="alternate" href="https://vue-blog.lllllan.cn/"/>
  <rights>Copyright by lllllan</rights>
  <category term="Java"/>
  <category term="MySQL"/>
  <category term="计算机基础"/>
  <category term="刷题"/>
  <contributor>
    <name>lllllan</name>
  </contributor>
  <entry>
    <title type="html">java 是值传递</title>
    <id>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/1-java-value-passed/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/1-java-value-passed/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/why-there-only-value-passing-in-java/" target="_blank" rel="noopener noreferrer">为什么 Java 中只有值传递？ | JavaGuide</a>，略有改动</p>
</div>
<h2 id="值传递-引用传递"> 值传递 &amp; 引用传递</h2>
<p>程序设计语言将实参传递给方法（或函数）的方式分为两种：</p>
<ul>
<li><strong>值传递</strong> ：方法接收的是实参值的拷贝，会创建副本。</li>
<li><strong>引用传递</strong> ：方法接收的直接是实参所引用的对象在堆中的地址，不会创建副本，对形参的修改将影响到实参。</li>
</ul>
<p>很多程序设计语言（比如 C++、 Pascal )提供了两种参数传递的方式，不过，在 Java 中只有值传递。</p>
<h2 id="实例"> 实例</h2>
<h3 id="对基本数据类型进行修改"> 对基本数据类型进行修改</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span> num1 <span>=</span> <span>10</span><span>;</span>
    <span>int</span> num2 <span>=</span> <span>20</span><span>;</span>
    <span>swap</span><span>(</span>num1<span>,</span> num2<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num1 = "</span> <span>+</span> num1<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"num2 = "</span> <span>+</span> num2<span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>int</span> a<span>,</span> <span>int</span> b<span>)</span> <span>{</span>
    <span>int</span> temp <span>=</span> a<span>;</span>
    a <span>=</span> b<span>;</span>
    b <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"a = "</span> <span>+</span> a<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"b = "</span> <span>+</span> b<span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
    
a <span>=</span> <span>20</span>
b <span>=</span> <span>10</span>
num1 <span>=</span> <span>10</span>
num2 <span>=</span> <span>20</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br></div></div><ul>
<li>a和b只是从num1和num2复制得到了值，怎么操作都不会产生影响</li>
</ul>
<p><img src="./README.assets/java-value-passing-01.ab88fb01.png" alt="基本数据类型参数" /></p>
<h3 id="修改引用类型中的值"> 修改引用类型中的值</h3>
<div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>int</span><span>[</span><span>]</span> arr <span>=</span> <span>{</span> <span>1</span><span>,</span> <span>2</span><span>,</span> <span>3</span><span>,</span> <span>4</span><span>,</span> <span>5</span> <span>}</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
    <span>change</span><span>(</span>arr<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arr<span>[</span><span>0</span><span>]</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>change</span><span>(</span><span>int</span><span>[</span><span>]</span> array<span>)</span> <span>{</span>
    <span>// 将数组的第一个元素变为0</span>
    array<span>[</span><span>0</span><span>]</span> <span>=</span> <span>0</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
   
<span>1</span>
<span>0</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><p><img src="./README.assets/java-value-passing-02.ff1b76c9.png" alt="引用数据类型参数1" /></p>
<h3 id="修改引用类型的对象"> 修改引用类型的对象</h3>
<div><pre><code><span>public</span> <span>class</span> <span>Person</span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
   <span>// 省略构造函数、Getter&amp;Setter方法</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>Person</span> xiaoZhang <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小张"</span><span>)</span><span>;</span>
    <span>Person</span> xiaoLi <span>=</span> <span>new</span> <span>Person</span><span>(</span><span>"小李"</span><span>)</span><span>;</span>
    <span>swap</span><span>(</span>xiaoZhang<span>,</span> xiaoLi<span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoZhang:"</span> <span>+</span> xiaoZhang<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"xiaoLi:"</span> <span>+</span> xiaoLi<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>public</span> <span>static</span> <span>void</span> <span>swap</span><span>(</span><span>Person</span> person1<span>,</span> <span>Person</span> person2<span>)</span> <span>{</span>
    <span>Person</span> temp <span>=</span> person1<span>;</span>
    person1 <span>=</span> person2<span>;</span>
    person2 <span>=</span> temp<span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person1:"</span> <span>+</span> person1<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"person2:"</span> <span>+</span> person2<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
<span>}</span>

<span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>--</span><span>-</span>
    
person1<span>:</span>小李
person2<span>:</span>小张
xiaoZhang<span>:</span>小张
xiaoLi<span>:</span>小李
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br></div></div><p><img src="./README.assets/java-value-passing-03.da4d0422.png" alt="引用数据类型参数2" /></p>
<h2 id="总结"> 总结</h2>
<p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p>
<ul>
<li>如果参数是基本类型的话，很简单，传递的就是基本类型的字面量值的拷贝，会创建副本。</li>
<li>如果参数是引用类型，传递的就是实参所引用的对象在堆中地址值的拷贝，同样也会创建副本。</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">JavaGuide - Java 基础知识</title>
    <id>https://vue-blog.lllllan.cn/1-java/1-basic/2-java-guide-basic/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/1-basic/2-java-guide-basic/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide</a>，略有改动</p>
</div>
<h2 id="一-基础概念与常识"> 一 基础概念与常识</h2>
<h3 id="_1-1-java语言的特点"> 1.1 Java语言的特点</h3>
<ol>
<li>简单易学</li>
<li>面向对象（封装，继承，多态）</li>
<li>平台无关性（Java虚拟机，一次编译到处运行）</li>
<li>解释执行（编译成字节码文件，java解释器对字节码进行解释执行）</li>
<li>多线程</li>
<li>分布式（强大、易于使用的联网能力）</li>
<li>高性能（相对其他高级语言，<a href="https://zhuanlan.zhihu.com/p/361250220" target="_blank" rel="noopener noreferrer">JIT</a>的发展）</li>
<li>健壮性（强类型机制、异常处理、垃圾回收机制）</li>
<li>安全性（安全机制以防止恶意代码的攻击）</li>
<li></li>
</ol>
<h3 id="_1-2-jvm-jdk-jre"> 1.2 JVM &amp; JDK &amp; JRE</h3>
<ol>
<li>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。</li>
<li>JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 <u>Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件</u>。但是，它不能用于创建新程序。</li>
<li>JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。</li>
</ol>
<div><p>JDK > JRE > JVM</p>
<p><a href="https://blog.csdn.net/ancientear/article/details/79483592" target="_blank" rel="noopener noreferrer">浅谈JDK、JRE、JVM区别与联系</a></p>
<ol>
<li>JVM不能单独执行class</li>
<li>JRE = JVM + lib（jvm工作需要的类库）。可以执行class</li>
<li>JDK包含JRE。可以开发、编译、执行</li>
</ol>
</div>
<p><img src="./README.assets/0cc3f4a15d3184391a98a7b1c58f6e5f_720w.jpg" alt="img" /></p>
<h3 id="_1-3-字节码及优点"> 1.3 字节码及优点</h3>
<p>JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p>
<ul>
<li>Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</li>
<li>由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</li>
</ul>
<p><img src="./README.assets/java程序转变为机器代码的过程.3dbbbc5a.png" alt="Java程序转变为机器代码的过程" /></p>
<h3 id="_1-4-编译与解释并存"> 1.4 编译与解释并存</h3>
<p>由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p>
<div><p>为什么要这么做？</p>
<p>编译型语言执行速度快、开发效率低，解释型语言开发效率快、执行速度慢。</p>
<p>编译与解释并存，（猜测应该）能融合两者的优点，提升开发效率的同时、保证执行速度。</p>
</div>
<h3 id="_1-5-oracle-jdk-openjdk-不懂"> 1.5 Oracle JDK &amp; OpenJDK （不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#oracle-jdk-vs-openjdk" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide</a></p>
<h3 id="_1-6-java-和-c-的区别"> 1.6 Java 和 C++ 的区别</h3>
<ul>
<li>都是面向对象的语言，都支持封装、继承、多态</li>
<li>Java不提供指针来直接访问内存，程序内存更加安全</li>
<li>Java的类是单继承的，但是接口可以多继承；C++支持类多重继承</li>
<li>Java有自动内存管理垃圾回收机制 （GC），不需要程序员手动释放无用内存</li>
<li>C++同时支持方法重载和操作符重载，但是Java只支持方法重载（重载操作符增加了复杂性）</li>
<li>。。。</li>
</ul>
<h2 id="二、基本语法"> 二、基本语法</h2>
<h3 id="_2-0-详见javaguide-基本语法"> 2.0 详见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E5%9F%BA%E6%9C%AC%E8%AF%AD%E6%B3%95" target="_blank" rel="noopener noreferrer">JavaGuide #基本语法</a></h3>
<h3 id="_2-1-静态方法为什么不能调用非静态方法"> 2.1 静态方法为什么不能调用非静态方法？</h3>
<ol>
<li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li>
<li>在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li>
</ol>
<div><p>为什么要用静态方法？</p>
<p>静态方法的好处就是不用生成类的实例就可以直接调用。只需要通过其类名就可以访问，不需要再消耗资源反复创建对象。</p>
</div>
<h3 id="_2-2-重载和重写的区别"> 2.2 重载和重写的区别</h3>
<div><p>Tips</p>
<p>重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理</p>
<p>重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p>
</div>
<p><strong>重载：</strong></p>
<p>发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p>
<p><strong>重写</strong></p>
<p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p>
<ol>
<li>返回值类型、方法名、参数列表必须相同，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li>
<li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 static 修饰的方法能够被再次声明。</li>
<li>构造方法无法被重写</li>
</ol>
<p>综上：<strong>重写就是子类对父类方法的重新改造，外部样子不能改变，内部逻辑可以改变。</strong></p>
<table>
<thead>
<tr>
<th style="text-align:left">区别点</th>
<th style="text-align:left">重载方法</th>
<th style="text-align:left">重写方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">发生范围</td>
<td style="text-align:left">同一个类</td>
<td style="text-align:left">子类</td>
</tr>
<tr>
<td style="text-align:left">参数列表</td>
<td style="text-align:left">必须修改</td>
<td style="text-align:left">一定不能修改</td>
</tr>
<tr>
<td style="text-align:left">返回类型</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法返回值类型应比父类方法返回值类型更小或相等</td>
</tr>
<tr>
<td style="text-align:left">异常</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；</td>
</tr>
<tr>
<td style="text-align:left">访问修饰符</td>
<td style="text-align:left">可修改</td>
<td style="text-align:left">一定不能做更严格的限制（可以降低限制）</td>
</tr>
<tr>
<td style="text-align:left">发生阶段</td>
<td style="text-align:left">编译期</td>
<td style="text-align:left">运行期</td>
</tr>
</tbody>
</table>
<h3 id="_2-3-泛型"> 2.3 泛型</h3>
<blockquote>
<p><strong>Java 泛型（generics）</strong> 是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。</p>
</blockquote>
<p>Java 的泛型是伪泛型，这是因为 Java 在运行期间，所有的泛型信息都会被擦掉，这也就是通常所说类型擦除 。</p>
<p>详见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E6%B3%9B%E5%9E%8B" target="_blank" rel="noopener noreferrer">JavaGuide #泛型</a></p>
<h3 id="_2-4-和-equals-的区别"> 2.4 == 和 equals() 的区别</h3>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<div><p>Tips</p>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</div>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<h3 id="_2-5-hashcode-与-equals"> 2.5 hashCode() 与 equals()</h3>
<p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p>
<p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p>
<p>更多解释见<a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#hashcode-%E4%B8%8E-equals" target="_blank" rel="noopener noreferrer">JavaGuide #hashcode-与-equals</a></p>
<div><p>hashCode的作用</p>
<p>hashCode和equals有一个相同的作用，就是用作比较：</p>
<ul>
<li>equals 为true的两个对象相等，false则两个对象不相等</li>
<li>hashCode 相同的两个对象不一定相等，但不同的两个对象一定不相等</li>
</ul>
</div>
<div><p>为什么要有 hashCode？</p>
<p><strong>效率</strong>
当一个对象逐渐复杂时，equals方法中的判定条件也会逐渐复杂，这个时候比较两个对象是否相等依旧使用equals的话，就会变得低效。</p>
<p>因此引出hashCode，通过一定的计算方式，为每个对象分配一个“哈希码”，让相等的对象都拥有相同的哈希码。之后需要比较两个对象的时候，先比较哈希码，如果哈希码都不相同，两个对象一定不相等。如果哈希码相同，再继续使用equals确定对象是否相等。</p>
<p>hashCode 方法相对与 equals 会更加高效，通过这两步判断，来确定两个对象是否相等</p>
</div>
<h2 id="三、基本数据类型"> 三、基本数据类型</h2>
<h3 id="_3-0-基本数据类型存放位置"> 3.0 基本数据类型存放位置</h3>
<p>一：在方法中声明的变量，即该变量是局部变量，每当程序调用方法时，系统都会为该方法建立一个方法栈，其所在方法中声明的变量就放在方法栈中，当方法结束系统会释放方法栈，其对应在该方法中声明的变量随着栈的销毁而结束，这就局部变量只能在方法中有效的原因</p>
<p>在方法中声明的变量可以是基本类型的变量，也可以是引用类型的变量。</p>
<p>​     （1）当声明是基本类型的变量的时，其变量名及值（变量名及值是两个概念）是放在方法栈中</p>
<p>​     （2）当声明的是引用变量时，所声明的变量（该变量实际上是在方法中存储的是内存地址值）是放在方法的栈中，该变量所指向的对象是放在堆类存中的。</p>
<p>二：在类中声明的变量是成员变量，也叫全局变量，放在堆中的（因为全局变量不会随着某个方法执行结束而销毁）。</p>
<p>​    同样在类中声明的变量即可是基本类型的变量 也可是引用类型的变量</p>
<p>​    （1）当声明的是基本类型的变量其变量名及其值放在堆内存中的</p>
<p>​    （2）引用类型时，其声明的变量仍然会存储一个内存地址值，该内存地址值指向所引用的对象。引用变量名和对应的对象仍然存储在相应的堆中</p>
<h3 id="_3-1-包装类型的常量池"> 3.1 包装类型的常量池</h3>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p>
<p>解释来说呢，大概就是以上几种类型中，创建的对象大小在约定的范围之内，该对象会在cache中长生（如果已存在将会复用）。</p>
<ul>
<li>节省内存空间：常量池中所有相同的对象常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ul>
<h2 id="四、java面向对象"> 四、Java面向对象</h2>
<h3 id="_4-1-面向对象和面向过程的区别"> 4.1 面向对象和面向过程的区别</h3>
<ul>
<li>
<p>因为类调用时需要实例化，开销比较大，比较消耗资源，所以当性能是最重要的考量因素的时候，比如单片机、嵌入式开发、Linux/Unix 等一般采用面向过程开发。</p>
</li>
<li>
<p>因为面向对象有封装、继承、多态性的特性，所以可以设计出低耦合的系统，使系统更加灵活、更加易于维护。</p>
</li>
</ul>
<div><p>Tips</p>
<p><strong>面向对象易维护、易复用、易扩展。面向过程性能相对较高。</strong></p>
</div>
<h3 id="_4-2-成员变量和局部变量的区别"> 4.2 成员变量和局部变量的区别</h3>
<p><img src="./README.assets/image-20220116180214826.png" alt="image-20220116180214826" /></p>
<h3 id="_4-3-对象实体和对象引用"> 4.3 对象实体和对象引用</h3>
<p>一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。</p>
<h3 id="_4-4-对象相等和引用相等"> 4.4 对象相等和引用相等</h3>
<p>对象的相等，比的是内存中存放的内容是否相等。而引用相等，比较的是他们指向的内存地址是否相等。</p>
<h3 id="_4-5-构造方法的特点"> 4.5 构造方法的特点</h3>
<ol>
<li>名字与类名相同。</li>
<li>没有返回值，但不能用 void 声明构造函数。</li>
<li>生成类的对象时自动执行，无需调用。</li>
</ol>
<div><p>Tips</p>
<p>构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。</p>
</div>
<h3 id="_4-6-面向对象三大特征"> 4.6 面向对象三大特征</h3>
<h4 id="_4-6-1-封装"> 4.6.1 封装</h4>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<div><p>封装的好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高代码的复用性</li>
<li>提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）</li>
</ul>
</div>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>private</span> <span>int</span> id<span>;</span><span>//id属性私有化</span>
    <span>private</span> <span>String</span> name<span>;</span><span>//name属性私有化</span>

    <span>//获取id的方法</span>
    <span>public</span> <span>int</span> <span>getId</span><span>(</span><span>)</span> <span>{</span> <span>return</span> id<span>;</span> <span>}</span>

    <span>//设置id的方法</span>
    <span>public</span> <span>void</span> <span>setId</span><span>(</span><span>int</span> id<span>)</span> <span>{</span> <span>this</span><span>.</span>id <span>=</span> id<span>;</span> <span>}</span>

    <span>//获取name的方法</span>
    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span> <span>return</span> name<span>;</span> <span>}</span>

    <span>//设置name的方法</span>
    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span> <span>this</span><span>.</span>name <span>=</span> name<span>;</span> <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h4 id="_4-6-2-继承"> 4.6.2 继承</h4>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<div><p>继承的优点</p>
<ol>
<li>提高代码的复用性</li>
<li>提高代码的易维护性</li>
<li>提高代码的可扩展性</li>
<li>使代码结构清晰</li>
</ol>
</div>
<div><p>继承的缺点</p>
<ol>
<li>高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类</li>
<li>破坏封装性、降低灵活性</li>
</ol>
</div>
<h4 id="_4-6-3-多态"> 4.6.3 多态</h4>
<p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间</strong>才能确定；</li>
<li>多态不能调用“<strong>只在子类存在但在父类不存在</strong>”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是<strong>子类覆盖</strong>的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<div><p>多态存在的必要条件</p>
<ol>
<li>要有继承</li>
<li>要有重写</li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
</div>
<div><p>多态的好处</p>
<ol>
<li>提高了代码的可扩展性</li>
<li>可替换性</li>
<li>接口性：向子类提供共同接口，由子类来完善或覆盖</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
</div>
<h3 id="_4-7-string、stringbuffer、stringbuilder"> 4.7 <code>String</code>、<code>StringBuffer</code>、<code>StringBuilder</code></h3>
<h4 id="_4-7-1-string-为什么是不可变的"> 4.7.1 <code>String</code> 为什么是不可变的</h4>
<p><a href="https://www.cnblogs.com/leskang/p/6110631.html" target="_blank" rel="noopener noreferrer">String为什么不可变 - 梦醒点灯</a></p>
<div><pre><code><span>public</span> <span>final</span> <span>class</span> <span>String</span> <span>implements</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>,</span> <span>Comparable</span><span><span>&lt;</span><span>String</span><span>></span></span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>private</span> <span>final</span> <span>char</span> value<span>[</span><span>]</span><span>;</span>
	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ol>
<li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供/暴露修改这个字符串的方法。</li>
<li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变。</li>
</ol>
<h4 id="_4-7-2-stringbuffer、stringbuilder"> 4.7.2 <code>StringBuffer</code>、<code>StringBuilder</code></h4>
<p><code>StringBuilder</code> 与 <code>StringBuffer</code> 都继承自 <code>AbstractStringBuilder</code> 类，在 <code>AbstractStringBuilder</code> 中也是使用字符数组保存字符串，不过没有使用 <code>final</code> 和 <code>private</code> 关键字修饰，最关键的是这个 <code>AbstractStringBuilder</code> 类还提供了很多修改字符串的方法比如 <code>append</code> 方法。</p>
<div><pre><code><span>abstract</span> <span>class</span> <span>AbstractStringBuilder</span> <span>implements</span> <span>Appendable</span><span>,</span> <span>CharSequence</span> <span>{</span>
    <span>char</span><span>[</span><span>]</span> value<span>;</span>
    <span>public</span> <span>AbstractStringBuilder</span> <span>append</span><span>(</span><span>String</span> str<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>str <span>==</span> <span>null</span><span>)</span>
            <span>return</span> <span>appendNull</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> len <span>=</span> str<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>ensureCapacityInternal</span><span>(</span>count <span>+</span> len<span>)</span><span>;</span>
        str<span>.</span><span>getChars</span><span>(</span><span>0</span><span>,</span> len<span>,</span> value<span>,</span> count<span>)</span><span>;</span>
        count <span>+=</span> len<span>;</span>
        <span>return</span> <span>this</span><span>;</span>
    <span>}</span>
  	<span>//...</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h4 id="_4-7-3-线程安全性"> 4.7.3 线程安全性</h4>
<div><p>Tips</p>
<p><code>String</code>、<code>StringBuffer</code> 是线程安全的，<code>StringBuilder</code> 非线程安全。</p>
</div>
<ul>
<li><code>String</code> 中的对象是不可变的，也就可以理解为常量，线程安全。</li>
<li><code>AbstractStringBuilder</code> 是 <code>StringBuilder</code> 与 <code>StringBuffer</code> 的公共父类，定义了一些字符串的基本操作，如 <code>expandCapacity</code>、<code>append</code>、<code>insert</code>、<code>indexOf</code> 等公共方法。
<ul>
<li><code>StringBuffer</code> 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。</li>
<li><code>StringBuilder</code> 并没有对方法进行加同步锁，所以是非线程安全的。</li>
</ul>
</li>
</ul>
<h4 id="_4-7-4-性能"> 4.7.4 性能</h4>
<p><code>StringBuilder</code> &gt; <code>StringBuffer</code> &gt; <code>String</code></p>
<p>每次对 <code>String</code> 类型进行改变的时候，都会生成一个新的 <code>String</code> 对象，然后将指针指向新的 <code>String</code> 对象。<code>StringBuffer</code> 每次都会对 <code>StringBuffer</code> 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 <code>StringBuilder</code> 相比使用 <code>StringBuffer</code> 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。</p>
<ol>
<li>操作少量的数据: 适用 <code>String</code></li>
<li>单线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuilder</code></li>
<li>多线程操作字符串缓冲区下操作大量数据: 适用 <code>StringBuffer</code></li>
</ol>
<h3 id="_4-8-object-类的常见方法"> 4.8 <code>Object</code> 类的常见方法</h3>
<div><pre><code><span>//native方法，用于返回当前运行时对象的Class对象，使用了final关键字修饰，故不允许子类重写。</span>
<span>public</span> <span>final</span> <span>native</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> <span>getClass</span><span>(</span><span>)</span>
    
<span>//native方法，用于返回对象的哈希码，主要使用在哈希表中，比如JDK中的HashMap。</span>
<span>public</span> <span>native</span> <span>int</span> <span>hashCode</span><span>(</span><span>)</span> 
    
<span>//用于比较2个对象的内存地址是否相等，String类对该方法进行了重写用户比较字符串的值是否相等。</span>
<span>public</span> <span>boolean</span> <span>equals</span><span>(</span><span>Object</span> obj<span>)</span>
    
<span>//naitive方法，用于创建并返回当前对象的一份拷贝。一般情况下，对于任何对象 x，表达式 x.clone() != x 为true，x.clone().getClass() == x.getClass() 为true。Object本身没有实现Cloneable接口，所以不重写clone方法并且进行调用的话会发生CloneNotSupportedException异常。</span>
<span>protected</span> <span>native</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>throws</span> <span>CloneNotSupportedException</span>
    
<span>//返回类的名字@实例的哈希码的16进制的字符串。建议Object所有的子类都重写这个方法。</span>
<span>public</span> <span>String</span> <span>toString</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notify</span><span>(</span><span>)</span>

<span>//native方法，并且不能重写。跟notify一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>notifyAll</span><span>(</span><span>)</span>
    
<span>//native方法，并且不能重写。暂停线程的执行。注意：sleep方法没有释放锁，而wait方法释放了锁 。timeout是等待时间。</span>
<span>public</span> <span>final</span> <span>native</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//多了nanos参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上nanos毫秒。</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>long</span> timeout<span>,</span> <span>int</span> nanos<span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念</span>
<span>public</span> <span>final</span> <span>void</span> <span>wait</span><span>(</span><span>)</span> <span>throws</span> <span>InterruptedException</span>
    
<span>//实例被垃圾回收器回收的时候触发的操作</span>
<span>protected</span> <span>void</span> <span>finalize</span><span>(</span><span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span> <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br></div></div><h3 id="_4-9-深拷贝和浅拷贝、引用拷贝"> 4.9 深拷贝和浅拷贝、引用拷贝</h3>
<div><p>Tips</p>
<p><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</p>
<p><strong>深拷贝</strong> ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</p>
</div>
<p>引用拷贝就是两个不同的引用指向同一个对象。</p>
<p><img src="./README.assets/shallow&deep-copy.64ee0760.png" alt="img" /></p>
<h2 id="五、反射"> 五、反射</h2>
<h3 id="_5-1-什么是反射"> 5.1 什么是反射</h3>
<p>Java反射就是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意方法和属性；并且能改变它的属性。而这也是Java被视为动态（或准动态，为啥要说是准动态，因为一般而言的动态语言定义是程序运行时，允许改变程序结构或变量类型，这种语言称为动态语言。从这个观点看，Perl，Python，Ruby是动态语言，C++，Java，C#不是动态语言。）语言的一个关键性质。</p>
<h3 id="_5-2-反射能做什么"> 5.2 反射能做什么？</h3>
<p>我们知道反射机制允许程序在运行时取得任何一个已知名称的class的内部信息，包括包括其modifiers(修饰符)，fields(属性)，methods(方法)等，并可于运行时改变fields内容或调用methods。那么我们便可以更灵活的编写代码，代码可以在运行时装配，无需在组件之间进行源代码链接，降低代码的耦合度；还有动态代理的实现等等；但是需要注意的是反射使用不当会造成很高的资源消耗！</p>
<h3 id="_5-3-反射机制优缺点"> 5.3 反射机制优缺点</h3>
<ul>
<li><strong>优点</strong> ： 可以让咱们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利</li>
<li><strong>缺点</strong> ：让我们在运行时有了分析操作类的能力，这同样也增加了安全问题。比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的</li>
</ul>
<h3 id="_5-4-反射的应用场景"> 5.4 反射的应用场景</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#%E5%8F%8D%E5%B0%84%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide # 反射的应用场景</a></p>
<p>（看不懂）</p>
<h2 id="六、注解"> 六、注解</h2>
<p><a href="https://zhuanlan.zhihu.com/p/37701743" target="_blank" rel="noopener noreferrer">java 注解-最通俗易懂的讲解</a></p>
<h3 id="_6-0-注解是什么"> 6.0 注解是什么</h3>
<p><strong>初学者可以这样理解注解：想像代码具有生命，注解就是对于代码中某些鲜活个体的贴上去的一张标签。简化来讲，注解如同一张标签。</strong></p>
<h3 id="_6-1-注解的作用"> 6.1 注解的作用</h3>
<ul>
<li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li>
<li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html文档或者做其它相应处理。</li>
<li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取
值得注意的是，注解不是代码本身的一部分。</li>
</ul>
<h3 id="_6-2-注解的语法、定义、运用"> 6.2 注解的语法、定义、运用</h3>
<p>暂且不谈，等到练习中认识即可</p>
<h2 id="七、异常"> 七、异常</h2>
<h3 id="_7-1-异常类层次结构图"> 7.1 异常类层次结构图</h3>
<p>在 Java 中，所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类 <code>Exception</code>（异常）和 <code>Error</code>（错误）。<code>Exception</code> 能被程序本身处理(<code>try-catch</code>)， <code>Error</code> 是无法处理的(只能尽量避免)。</p>
<ul>
<li>
<p><strong><code>Exception</code></strong> :程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。<code>Exception</code> 又可以分为 <strong>受检查异常</strong>(必须处理) 和 <strong>不受检查异常</strong>(可以不处理)。</p>
</li>
<li>
<p><strong><code>Error</code></strong> ：<code>Error</code> 属于程序无法处理的错误 ，我们没办法通过 <code>catch</code> 来进行捕获 。例如，Java 虚拟机运行错误（<code>Virtual MachineError</code>）、虚拟机内存不够错误(<code>OutOfMemoryError</code>)、类定义错误（<code>NoClassDefFoundError</code>）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择<strong>线程终止</strong>。</p>
</li>
</ul>
<p><img src="./README.assets/Java异常类层次结构图.png" alt="img" /></p>
<p><img src="./README.assets/Java异常类层次结构图2.png" alt="img" /></p>
<h4 id="_7-1-1-受检查异常"> 7.1.1 受检查异常</h4>
<p>Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>/<code>throw</code> 处理的话，就没办法通过编译 。比如下面这段 IO 操作的代码</p>
<p><img src="./README.assets/check-exception.png" alt="check-exception" /></p>
<h4 id="_7-1-2-不受检查异常"> 7.1.2 不受检查异常</h4>
<p>Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p>
<p><code>RuntimeException</code> 及其子类都统称为非受检查异常，例如：<code>NullPointerException</code>、<code>NumberFormatException</code>（字符串转换为数字）、<code>ArrayIndexOutOfBoundsException</code>（数组越界）、<code>ClassCastException</code>（类型转换错误）、<code>ArithmeticException</code>（算术错误）等。</p>
<h3 id="_7-2-throwable-类常用方法"> 7.2 Throwable 类常用方法</h3>
<ul>
<li><strong><code>public String getMessage()</code></strong>:返回异常发生时的简要描述</li>
<li><strong><code>public String toString()</code></strong>:返回异常发生时的详细信息</li>
<li><strong><code>public String getLocalizedMessage()</code></strong>:返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li>
<li><strong><code>public void printStackTrace()</code></strong>:在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li>
</ul>
<h3 id="_7-3-try-catch-finally"> 7.3 try-catch-finally</h3>
<ul>
<li><strong><code>try</code>块：</strong> 用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li>
<li><strong><code>catch</code>块：</strong> 用于处理 try 捕获到的异常。</li>
<li><strong><code>finally</code> 块：</strong> 无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<strong><code>finally</code> 语句块将在方法返回之前被执行。</strong></li>
</ul>
<div><p>Tips</p>
<p><strong>在以下 3 种特殊情况下，<code>finally</code> 块不会被执行：</strong></p>
<ol>
<li>
<p>在 <code>try</code> 或 <code>finally</code>块中用了 <code>System.exit(int)</code>退出程序。但是，如果 <code>System.exit(int)</code> 在异常语句之后，<code>finally</code> 还是会被执行</p>
</li>
<li>
<p>程序所在的线程死亡。</p>
</li>
<li>
<p>关闭 CPU。</p>
</li>
</ol>
</div>
<h3 id="_7-4-使用-try-with-resources-来代替try-catch-finally"> 7.4 使用 <code>try-with-resources</code> 来代替<code>try-catch-finally</code></h3>
<ol>
<li><strong>适用范围（资源的定义）：</strong> 任何实现 <code>java.lang.AutoCloseable</code>或者 <code>java.io.Closeable</code> 的对象</li>
<li><strong>关闭资源和 finally 块的执行顺序：</strong> 在 <code>try-with-resources</code> 语句中，任何 catch 或 finally 块在声明的资源关闭后运行</li>
</ol>
<div><pre><code><span>try</span> <span>(</span><span>Scanner</span> scanner <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>new</span> <span>File</span><span>(</span><span>"test.txt"</span><span>)</span><span>)</span><span>)</span> <span>{</span>
    <span>while</span> <span>(</span>scanner<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>scanner<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span> <span>catch</span> <span>(</span><span>FileNotFoundException</span> fnfe<span>)</span> <span>{</span>
    fnfe<span>.</span><span>printStackTrace</span><span>(</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h2 id="八、io流"> 八、IO流</h2>
<h3 id="_8-1-反-序列化"> 8.1 （反）序列化</h3>
<p>理解序列化 -&gt; <a href="https://zhuanlan.zhihu.com/p/40462507" target="_blank" rel="noopener noreferrer">序列化理解起来很简单</a></p>
<ul>
<li><strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li>
<li><strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li>
</ul>
<h4 id="_8-1-1-为什么要序列化"> 8.1.1 为什么要序列化？</h4>
<blockquote>
<p>序列化最终的目的是为了对象可以<strong>跨平台存储，和进行网络传输</strong>。</p>
</blockquote>
<p>我们进行跨平台存储和网络传输的方式就是IO，而我们的IO支持的数据格式就是字节数组。</p>
<p>因为我们单方面的只把对象转成字节数组还不行，因为没有规则的字节数组我们是没办法把对象的本来面目还原回来的，所以我们必须在把对象转成字节数组的时候就制定一种规则**（序列化）<strong>，那么我们从IO流里面读出数据的时候再以这种规则把对象还原回来</strong>（反序列化）。**</p>
<p>如果我们要把一栋房子从一个地方运输到另一个地方去，<strong>序列化</strong>就是我把房子拆成一个个的砖块放到车子里，然后留下一张房子原来结构的图纸，<strong>反序列化</strong>就是我们把房子运输到了目的地以后，根据图纸把一块块砖头还原成房子原来面目的过程</p>
<h4 id="_8-1-2-什么时候需要序列化"> 8.1.2 什么时候需要序列化？</h4>
<p>凡是需要进行“跨平台存储”和”网络传输”的数据，都需要进行序列化。</p>
<p>本质上存储和网络传输 都需要经过 把一个对象状态保存成一种跨平台识别的字节格式，然后其他的平台才可以通过字节信息解析还原对象信息。</p>
<h3 id="_8-2-如果有些字段不想进行序列化-看不懂"> 8.2 如果有些字段不想进行序列化（看不懂）</h3>
<p><a href="https://javaguide.cn/java/basis/java%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93/#java-%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%AD%E5%A6%82%E6%9E%9C%E6%9C%89%E4%BA%9B%E5%AD%97%E6%AE%B5%E4%B8%8D%E6%83%B3%E8%BF%9B%E8%A1%8C%E5%BA%8F%E5%88%97%E5%8C%96-%E6%80%8E%E4%B9%88%E5%8A%9E" target="_blank" rel="noopener noreferrer">Java基础知识&amp;面试题总结 | JavaGuide # 如果有些字段不想进行序列化</a></p>
<h3 id="_8-3-获取用键盘输入常用的两种方法"> 8.3 获取用键盘输入常用的两种方法</h3>
<ol>
<li><code>Scanner</code></li>
</ol>
<div><pre><code><span>Scanner</span> input <span>=</span> <span>new</span> <span>Scanner</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>;</span>
<span>String</span> s  <span>=</span> input<span>.</span><span>nextLine</span><span>(</span><span>)</span><span>;</span>
input<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><ol start="2">
<li><code>BufferedReader</code></li>
</ol>
<div><pre><code><span>BufferedReader</span> input <span>=</span> <span>new</span> <span>BufferedReader</span><span>(</span><span>new</span> <span>InputStreamReader</span><span>(</span><span>System</span><span>.</span>in<span>)</span><span>)</span><span>;</span>
<span>String</span> s <span>=</span> input<span>.</span><span>readLine</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><h3 id="_8-4-io流分类"> 8.4 IO流分类</h3>
<ul>
<li>按照流的流向分，可以分为输入流和输出流；</li>
<li>按照操作单元划分，可以划分为字节流和字符流；</li>
<li>按照流的角色划分为节点流和处理流（<strong>对一个已存在的流的连接和封装，通过所封装的流的功能调用实现数据读写</strong>）。</li>
</ul>
<p><img src="./README.assets/IO-操作方式分类.png" alt="IO-操作方式分类" /></p>
<p><img src="./README.assets/IO-操作对象分类.png" alt="IO-操作对象分类" /></p>
<h3 id="_8-5-字符流的意义"> 8.5 字符流的意义</h3>
<p><strong>不管是文件读写还是网络发送接收，信息的最小存储单元都是字节，那为什么 I/O 流操作要分为字节流操作和字符流操作呢？</strong></p>
<p>字符流是由 Java 虚拟机将字节转换得到的，问题就出在这个过程还算是非常耗时，并且，如果我们不知道编码类型就很容易出现乱码问题。所以， I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java 基础面试题</title>
    <id>https://vue-blog.lllllan.cn/1-java/1-basic/4-interview-questions/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/1-basic/4-interview-questions/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文所有题目整理及答案全部来自 <a href="https://www.iamshuaidi.com/" target="_blank" rel="noopener noreferrer">帅地玩编程-校招|面试|学习路线</a>，略有改动</p>
</div>
<h2 id="_1-面向对象和面向过程"> 1. 面向对象和面向过程</h2>
<p><strong>面向过程：</strong></p>
<p>面向过程的思想会将一件事情，拆分成一个个更具体的小任务，由一个个方法去完成他们。只要按顺序执行这些方法，就能完成这件事情。</p>
<p><strong>面向对象：</strong></p>
<p>面向对象的思想会把事物抽象成对象的概念，把一件事情拆分成一个个更具体的小问题，交由不同的对象分别完成以解决问题。</p>
<p>更详细生动的说明详见 <a href="https://zhuanlan.zhihu.com/p/75265007" target="_blank" rel="noopener noreferrer">2分钟让你明白什么是面向对象编程</a></p>
<table>
<thead>
<tr>
<th style="text-align:center">项目名称</th>
<th style="text-align:center">面向对象程序设计</th>
<th style="text-align:center">面向过程程序设计（也叫结构化编程）</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">定义</td>
<td style="text-align:center">面向对象顾名思义就是把现实中的事务都抽象成为程序设计中的“对象”，其基本思想是一切皆对象，是一种“自下而上”的设计语言，先设计组件，再完成拼装。</td>
<td style="text-align:center">面向过程是“自上而下”的设计语言，先定好框架，再增砖添瓦。通俗点，就是先定好main()函数，然后再逐步实现main()函数中所要用到的其他方法。</td>
</tr>
<tr>
<td style="text-align:center">特点</td>
<td style="text-align:center">封装、继承、多态</td>
<td style="text-align:center">算法+数据结构</td>
</tr>
<tr>
<td style="text-align:center">优势</td>
<td style="text-align:center">适用于大型复杂系统，方便复用、</td>
<td style="text-align:center">适用于简单系统，容易理解</td>
</tr>
<tr>
<td style="text-align:center">劣势</td>
<td style="text-align:center">比较抽象、性能比面向过程低</td>
<td style="text-align:center">难以应对复杂系统，难以复用，不易维护、不易扩展</td>
</tr>
<tr>
<td style="text-align:center">对比</td>
<td style="text-align:center">易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td>
<td style="text-align:center">性能比面向对象高，因为类调用时需要实例化，开销比较大，比较消耗资源;比如单片机、嵌入式开发、 Linux/Unix等一般采用面向过程开发，性能是最重要的因素</td>
</tr>
<tr>
<td style="text-align:center">设计语言</td>
<td style="text-align:center">Java、Smalltalk、EIFFEL、C++、Objective-、C#、Python等</td>
<td style="text-align:center">C、Fortran</td>
</tr>
</tbody>
</table>
<h2 id="_2-面向对象三大特性"> 2. 面向对象三大特性</h2>
<p>更多详见 <a href="./../2-java-guide-basic/#_4-6-面向对象三大特征">JavaGuide - Java基础知识 | lllllan</a></p>
<h3 id="_2-1-封装"> 2.1 封装</h3>
<p>封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。</p>
<div><p>封装的好处</p>
<ul>
<li>隐藏实现细节，提供公共的访问方式</li>
<li>提高代码的复用性</li>
<li>提高安全性（别人不能通过 变量名.属性名 的方式来修改私有的成员属性）</li>
</ul>
</div>
<h3 id="_2-2-继承"> 2.2 继承</h3>
<p>继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。</p>
<ol>
<li>子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，<strong>只是拥有</strong>。</li>
<li>子类可以拥有自己属性和方法，即子类可以对父类进行扩展。</li>
<li>子类可以用自己的方式实现父类的方法。</li>
</ol>
<div><p>继承的优点</p>
<ol>
<li>提高代码的复用性</li>
<li>提高代码的易维护性</li>
<li>提高代码的可扩展性</li>
<li>使代码结构清晰</li>
</ol>
</div>
<div><p>继承的缺点</p>
<ol>
<li>高耦合性：父子类联系紧密，修改父类的同时，需要兼顾子类</li>
<li>破坏封装性、降低灵活性</li>
</ol>
</div>
<h3 id="_2-3-多态"> 2.3 多态</h3>
<p>表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。</p>
<ul>
<li>对象类型和引用类型之间具有继承（类）/实现（接口）的关系；</li>
<li>引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序<strong>运行期间</strong>才能确定；</li>
<li>多态不能调用“<strong>只在子类存在但在父类不存在</strong>”的方法；</li>
<li>如果子类重写了父类的方法，真正执行的是<strong>子类覆盖</strong>的方法，如果子类没有覆盖父类的方法，执行的是父类的方法。</li>
</ul>
<div><p>多态存在的必要条件</p>
<ol>
<li>要有继承</li>
<li>要有重写</li>
<li><strong>父类引用指向子类对象</strong></li>
</ol>
</div>
<div><p>多态的好处</p>
<ol>
<li>提高了代码的可扩展性</li>
<li>可替换性</li>
<li>接口性：向子类提供共同接口，由子类来完善或覆盖</li>
<li>灵活性</li>
<li>简化性</li>
</ol>
</div>
<h2 id="_3-jdk、jre、jvm三者关系"> 3. JDK、JRE、JVM三者关系</h2>
<p>JDK 是 Java 开发工具包、JRE 是 Java 运行环境、JVM 是 Java 虚拟机。</p>
<div><p>JDK > JRE > JVM</p>
<ol>
<li>JVM不能单独执行class</li>
<li>JRE = JVM + lib（jvm工作需要的类库）。可以执行class</li>
<li>JDK包含JRE。可以开发、编译、执行</li>
</ol>
</div>
<h2 id="_4-重载和重写"> 4. 重载和重写</h2>
<ul>
<li>重载：编译时多态，同一个类中同名的方法具有不同的参数列表、返回类型。</li>
<li>重写：运行时多态，子类重写父类的方法实现不同的功能，具有相同的参数列表、返回类型。</li>
</ul>
<p>更多详见 <a href="./../2-java-guide-basic/#_2-1-静态方法为什么不能调用非静态方法">JavaGuide - Java基础知识 | lllllan</a></p>
<p>​</p>
<h2 id="_5-java-中是否可以重写一个-private-或者-static-方法"> 5. Java 中是否可以重写一个 private 或者 static 方法？</h2>
<p>重写，又称覆盖，是在运行时绑定的。</p>
<ul>
<li>子类不能访问或使用父类中的 private 方法，因此不能实现重写</li>
<li>static 方法是编译时静态绑定的，就算子类中再写了一个同名同参的相同方法，也只是两个毫不相干的方法，不能称为重写。</li>
</ul>
<h2 id="_6-构造器是否可以被重写"> 6. 构造器是否可以被重写？</h2>
<p>父类的私有属性、方法以及构造器都是不能被重写的。</p>
<h2 id="_7-构造方法有哪些特性"> 7. 构造⽅法有哪些特性</h2>
<ol>
<li>名字与类名相同</li>
<li>没有返回值，但不能⽤ void 声明构造函数</li>
<li>成类的对象时⾃动执⾏，⽆需调⽤</li>
</ol>
<h2 id="_8-无参构造函数的作用"> 8. 无参构造函数的作用</h2>
<ol>
<li>不写任何构造器，也会有一个默认的无参构造。但如果写了有参构造，就必须另写一个无参构造，否则就无法执行无参构造。</li>
<li>子类的构造当中，如果没有指定 super() 来调用父类中某个构造方法，则会调用父类中的无参构。如果这个时候父类中存在有参构造而没有无参构造，就会出错。</li>
</ol>
<h2 id="_9-java-中创建对象的几种方式"> 9. Java 中创建对象的几种方式</h2>
<ol>
<li><code>new()</code></li>
<li><code>Class.forName().newInstance()</code></li>
<li><code>clone()</code></li>
<li><code>ObjectInputStream.readObject()</code></li>
</ol>
<h2 id="_10-抽象类和接口的区别"> 10. 抽象类和接口的区别</h2>
<ol>
<li>抽象类中可以定义构造函数，接口不能定义构造函数</li>
<li>抽象类中可以有抽象方法和具体方法，接口中只能有抽象方法</li>
<li>抽象类中的成员权限可以是 <code>public</code>、默认、<code>protected</code>，<strong>抽象方法不能被 <code>private</code> 修饰</strong>，具体方法可以；接口中的成员只能是 <code>public</code></li>
<li>抽象类中可以包含静态方法（<strong>具体方法可以是静态的，抽象方法不行</strong>），接口中不能包含静态方法（因为接口中定义的方法就是为了让实现类去实现，但是静态方法必须在编译时实现）</li>
</ol>
<h3 id="_10-1-jdk8-的改变"> 10.1 JDK8 的改变</h3>
<ol>
<li>允许在接口中包含具体实现的方法，使用 <code>default</code> 修饰</li>
<li>因为允许具体实现的放，接口中也就允许有静态方法</li>
</ol>
<h2 id="_11-静态变量和实例变量的区别"> 11. 静态变量和实例变量的区别</h2>
<ul>
<li>静态变量：被 <code>static</code> 修饰，也称类变量。它属于类，因此不管创建多少个对象，该静态变量在内存中有且仅有一个拷贝。静态变量可以实现多个对象共享内存</li>
<li>实例变量：属于某一实例，需要先创建对象，然后通过对象才能访问得到</li>
</ul>
<h2 id="_12-short-s1-1-s1-s1-1-为什么错-short-s1-1-s1-1-为什么没错"> 12. <code>short s1 = 1; s1 = s1 + 1</code> 为什么错？ <code>short s1 = 1; s1 += 1</code> 为什么没错？</h2>
<p>运算中的 <code>1</code> 默认是 <code>int</code>类型，那么将 <code>int</code> 类型赋值给 <code>short</code> 类型时，会出现类型转换错误。</p>
<p>而对于 <code>+=</code>，是 Java 语言规定的运算符， Java 编译器自己会进行特殊处理</p>
<h2 id="_13-integer-和-int-的区别"> 13. Integer 和 int 的区别？</h2>
<ol>
<li>int 是 Java 的⼋种基本数据类型之⼀，⽽ <code>Integer</code> 是 Java 为 int 类型提供的封装类</li>
<li>int 型变量的默认值是 0，Integer 变量的默认值是 null，这⼀点说明 Integer 可以区分出未赋值和值为 0 的 区分</li>
<li>Integer 变量必须实例化后才可以使⽤，⽽ int 不需要。</li>
</ol>
<h3 id="_13-1-integer-之间的比较"> 13.1 Integer 之间的比较</h3>
<ol>
<li>两个 <code>new()</code> 出来的 <code>Integer</code> 进行比较：因为是两个对象，进行比较的其内存地址，结果均为 false</li>
<li><code>Integer</code> 和 <code>int</code> 进行比较：包装类和基本数据类型进行比较时，会对包装类进行拆包装为基本数据类型，所以最后是两个 <code>int</code> 在比较。只要数值相等就为 true</li>
<li>非new生成的 <code>Integer</code> 和 <code>new integer()</code> 进行比较：前者指向 Java 常量池中的对象、后者指向堆中的对象，内存地址不同，结果均为 false</li>
<li>两个非new生成的 <code>Integer</code> 进行比较：如果数值相等并且变量值在 <code>[-128, 127]</code> 之间，比较结果为 true，否则为 false。</li>
</ol>
<div><pre><code><span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> var0<span>)</span> <span>{</span> 
    <span>return</span> var0 <span>>=</span> <span>-</span><span>128</span> <span>&amp;&amp;</span> var0 <span>&lt;=</span> <span>Integer<span>.</span>IntegerCache</span><span>.</span>high <span>?</span>
		<span>Integer<span>.</span>IntegerCache</span><span>.</span>cache<span>[</span>var0 <span>+</span> <span>128</span><span>]</span> <span>:</span> <span>new</span> <span>Integer</span><span>(</span>var0<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><h3 id="_13-2-包装类的缓存"> 13.2 包装类的缓存</h3>
<ul>
<li>Boolean：全部缓存</li>
<li>Byte：全部缓存</li>
<li>Character：&lt;= 127 缓存</li>
<li>Short：-128 — 127 缓存</li>
<li>Long：-128 — 127 缓存</li>
<li>Integer：-128 — 127 缓存</li>
<li>Float：没有缓存</li>
<li>Doulbe：没有缓存</li>
</ul>
<h2 id="_14-装箱和拆箱"> 14 装箱和拆箱</h2>
<p>⾃动装箱是 Java 编译器在基本数据类型和对应得包装类之间做的⼀个转化。⽐如：把 int 转化成 Integer，double 转化成 Double 等等。反之就是⾃动拆箱。</p>
<p>原始类型：boolean、char、byte、short、int、long、float、double</p>
<p>封装类型：Boolean、Character、Byte、Short、Integer、Long、Float、Double</p>
<h2 id="_15-switch-能否作用在-byte、long、string上"> 15. switch 能否作用在  <code>byte</code>、<code>long</code>、<code>String</code>上？</h2>
<p>switch 中放的只能是一个整数表达式或枚举常量。而整数表达式可以是 <code>int</code> 或 <code>Integer</code></p>
<ul>
<li>由于 <code>byte</code>、<code>short</code>、<code>char</code> 都可以隐式转换为 <code>int</code>，因此这些类型以及他们的包装类都是可以用的。</li>
<li><code>long</code> 不可以</li>
<li><code>String</code> 在 JDK1.7 之后可以使用</li>
</ul>
<h2 id="_16-object-的常用方法"> 16. Object 的常用方法</h2>
<ul>
<li><code>clone</code> ⽅法：⽤于创建并返回当前对象的⼀份拷⻉；</li>
<li><code>getClass</code> ⽅法：⽤于返回当前<strong>运⾏时对象</strong>的 Class；</li>
<li><code>toString</code> ⽅法：返回对象的字符串表示形式；</li>
<li><code>finalize</code> ⽅法：实例被垃圾回收器回收时触发的⽅法；</li>
<li><code>equals</code> ⽅法：⽤于⽐较两个对象的内存地址是否相等，⼀般需要重写；</li>
<li><code>hashCode</code> ⽅法：⽤于返回对象的哈希值；</li>
<li><code>notify</code> ⽅法：唤醒⼀个在此对象监视器上等待的线程。如果有多个线程在等待只会唤醒⼀个。</li>
<li><code>notifyAll</code> ⽅法：作⽤跟 notify() ⼀样，只不过会唤醒在此对象监视器上等待的所有线程，⽽不是⼀个线程。</li>
<li><code>wait</code> ⽅法：让当前对象等待</li>
</ul>
<h2 id="_16-final、finally、finalize-的区别"> 16. final、finally、finalize 的区别</h2>
<ul>
<li><code>final</code>：⽤于声明属性、⽅法和类，分别表示属性不可变、⽅法不可覆盖、被其修饰的类不可继承；</li>
<li><code>finally</code>：异常处理语句结构的⼀部分，表示总是执⾏；</li>
<li><code>finallize</code>：Object类的⼀个⽅法，在垃圾回收时会调⽤被回收对象的finalize</li>
</ul>
<h2 id="_17-和-equals-的区别"> 17. == 和 equals 的区别</h2>
<p><strong><code>==</code></strong> 对于基本类型和引用类型的作用效果是不同的：</p>
<ul>
<li>对于基本数据类型来说，<code>==</code> 比较的是值。</li>
<li>对于引用数据类型来说，<code>==</code> 比较的是对象的内存地址。</li>
</ul>
<div><p>Tips</p>
<p>因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。</p>
</div>
<p><strong><code>equals()</code></strong> 作用不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。<code>equals()</code>方法存在于<code>Object</code>类中，而<code>Object</code>类是所有类的直接或间接父类。</p>
<h2 id="_18-两个对象的-hashcode-相同-则-equals-也一定为-true-吗"> 18. 两个对象的 hashCode() 相同，则 equals() 也⼀定为 true 吗？</h2>
<p>两个对象的 hashCode() 相同，equals() 不⼀定为 true。因为在散列表中，hashCode() 相等即两个键值对的哈希 值相等，然⽽哈希值相等，并不⼀定能得出键值对相等【散列冲突】</p>
<p>更多详见 <a href="./../2-java-guide-basic/#_2-5-hashcode-与-equals">JavaGuide - Java基础知识 | lllllan</a></p>
<h2 id="_19-为什么重写-equals-就一定要重写-hashcode-方法"> 19. 为什么重写 equals() 就⼀定要重写 hashCode() 方法</h2>
<p>理解 hashCode 的作用👉 <a href="./../1-basic/2-java-guide-basic/#_2-5-hashcode-与-equals">JavaGuide - Java基础知识 | lllllan</a></p>
<h2 id="_20-和-的区别"> 20. &amp; 和 &amp;&amp; 的区别</h2>
<p>Java 中 &amp;&amp; 和 &amp; 都是表示与的逻辑运算符，都表示逻辑运输符 and，当两边的表达式都为 true 的时候，整个运算 结果才为 true，否则为 false。</p>
<ul>
<li>&amp;&amp;：有短路功能，当第⼀个表达式的值为 false 的时候，则不再计算第⼆个表达式；</li>
<li>&amp;：不管第⼀个表达式结果是否为 true，第⼆个都会执⾏。除此之外，&amp; 还可以⽤作位运算符：当 &amp; 两边的表达式 不是 Boolean 类型的时候，&amp; 表示按位操作。</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-23T06:32:20.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">反射机制</title>
    <id>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/2-reflection/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/2-reflection/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">反射机制详解！ | JavaGuide</a>，略有改动</p>
</div>
<blockquote>
<p>总之反射就是能获取一个类的所有方法和属性，并能够调用。</p>
<p>然后还能增加代码的灵活性。</p>
<p>但是，我还是没有感受到，灵活在哪里。。。</p>
</blockquote>
<h2 id="什么是反射"> 什么是反射？</h2>
<p>反射就是Reflection，Java的反射是指程序在<strong>运行期</strong>可以拿到一个对象的所有信息，，你还可以调用这些方法和属性。</p>
<h2 id="反射的应用场景"> 反射的应用场景</h2>
<ul>
<li>模块化的开发，通过反射去调用对应的字节码</li>
<li>框架中大量使用动态代理，而动态代理依赖反射机制实现</li>
<li>注解的实现也用到了反射</li>
</ul>
<p><strong>JDBC的数据库连接</strong></p>
<div><pre><code><span>public</span> <span>static</span> <span>final</span> <span>String</span> DBDRIVER <span>=</span> <span>"com.mysql.jdbc.Driver"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBURL <span>=</span> <span>"jdbc:mysql://localhost:3306/test"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBUSER <span>=</span> <span>"root"</span><span>;</span>  
<span>public</span> <span>static</span> <span>final</span> <span>String</span> DBPASS <span>=</span> <span>""</span><span>;</span>  

<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>Exception</span> <span>{</span>  
    <span>Connection</span> con <span>=</span> <span>null</span><span>;</span>
    <span>Class</span><span>.</span><span>forName</span><span>(</span>DBDRIVER<span>)</span><span>;</span> <span>//1、使用CLASS 类加载驱动程序 ,反射机制的体现 </span>
    con <span>=</span> <span>DriverManager</span><span>.</span><span>getConnection</span><span>(</span>DBURL<span>,</span>DBUSER<span>,</span>DBPASS<span>)</span><span>;</span> <span>//2、连接数据库  </span>
    <span>.</span><span>.</span><span>.</span>
    con<span>.</span><span>close</span><span>(</span><span>)</span><span>;</span> <span>// 3、关闭数据库  </span>
<span>}</span>  
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h2 id="反射的优缺点"> 反射的优缺点</h2>
<p><strong>优点：</strong> 让代码更加灵、为各种框架提供开箱即用的功能提供便利</p>
<p><strong>缺点：</strong> 在运行时有了分析操作类的能力，同样增加了安全问题。性能略差，不过对于框架的影响比较小。</p>
<h2 id="反射的使用"> 反射的使用</h2>
<h3 id="获取class对象的四种方式"> 获取Class对象的四种方式</h3>
<p><strong>1.知道具体类的情况下可以使用</strong></p>
<div><pre><code><span>Class</span> alunbarClass <span>=</span> <span>TargetObject</span><span>.</span><span>class</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>2.通过 <code>Class.forName()</code> 传入类的路径获取</strong></p>
<div><pre><code><span>Class</span> alunbarClass1 <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><p><strong>3.通过对象实例 <code>instance.getClass()</code> 获取</strong></p>
<div><pre><code><span>TargetObject</span> o <span>=</span> <span>new</span> <span>TargetObject</span><span>(</span><span>)</span><span>;</span>
<span>Class</span> alunbarClass2 <span>=</span> o<span>.</span><span>getClass</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p><strong>4.通过类加载器 <code>xxxClassLoader.loadClass()</code> 传入类路径获取</strong></p>
<div><pre><code><span>Class</span> clazz <span>=</span> <span>ClassLoader</span><span>.</span><span>loadClass</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br></div></div><h3 id="反射的基本操作"> 反射的基本操作</h3>
<p><strong>1.定义一个类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>TargetObject</span> <span>{</span>
    <span>private</span> <span>String</span> value<span>;</span>

    <span>public</span> <span>TargetObject</span><span>(</span><span>)</span> <span>{</span>
        value <span>=</span> <span>"JavaGuide"</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>publicMethod</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"I love "</span> <span>+</span> s<span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>void</span> <span>privateMethod</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"value is "</span> <span>+</span> value<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><p><strong>2.使用反射来操作这个类的方法及参数</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>ClassNotFoundException</span><span>,</span> <span>NoSuchMethodException</span><span>,</span> <span>IllegalAccessException</span><span>,</span> <span>InstantiationException</span><span>,</span> <span>InvocationTargetException</span><span>,</span> <span>NoSuchFieldException</span> <span>{</span>
        <span>/**
         * 获取TargetObject类的Class对象并且创建TargetObject类实例
         */</span>
        <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> tagetClass <span>=</span> <span>Class</span><span>.</span><span>forName</span><span>(</span><span>"cn.javaguide.TargetObject"</span><span>)</span><span>;</span>
        <span>TargetObject</span> targetObject <span>=</span> <span>(</span><span>TargetObject</span><span>)</span> tagetClass<span>.</span><span>newInstance</span><span>(</span><span>)</span><span>;</span>
        <span>/**
         * 获取所有类中所有定义的方法
         */</span>
        <span>Method</span><span>[</span><span>]</span> methods <span>=</span> tagetClass<span>.</span><span>getDeclaredMethods</span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>Method</span> method <span>:</span> methods<span>)</span> <span>{</span>
            <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>}</span>
        <span>/**
         * 获取指定方法并调用
         */</span>
        <span>Method</span> publicMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"publicMethod"</span><span>,</span>
                <span>String</span><span>.</span><span>class</span><span>)</span><span>;</span>

        publicMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 获取指定参数并对参数进行修改
         */</span>
        <span>Field</span> field <span>=</span> tagetClass<span>.</span><span>getDeclaredField</span><span>(</span><span>"value"</span><span>)</span><span>;</span>
        <span>//为了对类中的参数进行修改我们取消安全检查</span>
        field<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        field<span>.</span><span>set</span><span>(</span>targetObject<span>,</span> <span>"JavaGuide"</span><span>)</span><span>;</span>
        <span>/**
         * 调用 private 方法
         */</span>
        <span>Method</span> privateMethod <span>=</span> tagetClass<span>.</span><span>getDeclaredMethod</span><span>(</span><span>"privateMethod"</span><span>)</span><span>;</span>
        <span>//为了调用private方法我们取消安全检查</span>
        privateMethod<span>.</span><span>setAccessible</span><span>(</span><span>true</span><span>)</span><span>;</span>
        privateMethod<span>.</span><span>invoke</span><span>(</span>targetObject<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br></div></div><p><strong>3.输出结果</strong></p>
<div><pre><code>publicMethod
privateMethod
<span>I</span> love <span>JavaGuide</span>
value is <span>JavaGuide</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">R2Coding - Java 基础知识</title>
    <id>https://vue-blog.lllllan.cn/1-java/1-basic/1-r2coding-basic/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/1-basic/1-r2coding-basic/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>全部抄自<a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a>上提供资料</p>
</div>
<h2 id="一、-java语言的特点"> 一、 java语言的特点</h2>
<ul>
<li>面向对象</li>
<li>平台无关性</li>
</ul>
<blockquote>
<p>已编译的java程序可以在任何带 有jvm的平台上运行。</p>
<p><code>java</code> 代码编译为 <code>.class</code> 文件，然后打包成 <code>.jar</code> 文件，这样就能够在不同系统下运行了。</p>
</blockquote>
<ul>
<li>简单性</li>
</ul>
<blockquote>
<p>摒弃了C++中难以理解的多继承、指针、内存管理等概念，不用手动管理对象的生命周期</p>
</blockquote>
<ul>
<li>解释执行</li>
</ul>
<blockquote>
<p>静态页面，在编译期间救恩那个直到数据类型的语言，在运行前就能检查类型的正确性。</p>
<p>执行效率相比动态语言更高，速度更快</p>
</blockquote>
<ul>
<li>多线程</li>
</ul>
<blockquote>
<p>java <strong>应该</strong> 在 <code>用户空间</code> 实现的多线程，内核感知不到 java 存在多线程机制。</p>
</blockquote>
<ul>
<li>分布式</li>
</ul>
<blockquote>
<p><img src="./README.assets/image-20211213091134933.png" alt="image-20211213091134933" /></p>
</blockquote>
<ul>
<li>健壮性</li>
</ul>
<blockquote>
<p>强类型机制、异常处理、垃圾的自动收集</p>
</blockquote>
<ul>
<li>高性能</li>
</ul>
<blockquote>
<p><img src="./README.assets/image-20211213090952974.png" alt="image-20211213090952974" /></p>
</blockquote>
<ul>
<li>安全性</li>
</ul>
<h2 id="二、面向对象"> 二、面向对象</h2>
<h3 id="_2-1-初始化顺序"> 2.1 初始化顺序</h3>
<blockquote>
<ul>
<li>静态属性</li>
<li>静态方法快</li>
<li>普通方法</li>
<li>普通方法块</li>
<li>构造函数</li>
<li>方法</li>
</ul>
</blockquote>
<div><pre><code><span>public</span> <span>class</span> <span>Solution</span> <span>{</span>

    <span>private</span> <span>static</span> <span>String</span> staticField <span>=</span> <span>getStaticField</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>static</span> <span>String</span> <span>getStaticField</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> staticFiled <span>=</span> <span>"静态属性初始化"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>staticFiled<span>)</span><span>;</span>
        <span>return</span> staticFiled<span>;</span>
    <span>}</span>

    <span>static</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"静态方法块初始化"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>private</span> <span>String</span> field <span>=</span> <span>getField</span><span>(</span><span>)</span><span>;</span>

    <span>public</span> <span>String</span> <span>getField</span><span>(</span><span>)</span> <span>{</span>
        <span>String</span> field <span>=</span> <span>"普通属性初始化"</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>field<span>)</span><span>;</span>
        <span>return</span> field<span>;</span>
    <span>}</span>

    <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"普通方法块初始化"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>Solution</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"构造函数"</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>new</span> <span>Solution</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br></div></div><div><pre><code>静态属性初始化
静态方法块初始化
普通属性初始化
普通方法块初始化
构造函数
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><hr>
<h3 id="_2-2-三大特性"> 2.2 三大特性</h3>
<ul>
<li>封装</li>
<li>继承</li>
<li>多态</li>
</ul>
<h4 id="访问控制权限"> 访问控制权限</h4>
<p><img src="./README.assets/image-20211217195521425.png" alt="image-20211217195521425" /></p>
<hr>
<h3 id="_2-3-接口"> 2.3 接口</h3>
<ul>
<li>interface、implements</li>
<li>接口只能使用 <code>public</code> <code>default</code>  两种访问修饰符</li>
<li>接口只提供方法的定义。</li>
<li>接口不能被实例化，所以接口中不能有构造方法。</li>
<li>接口的实现类必须实现接口的全部方法。</li>
</ul>
<hr>
<h3 id="_2-4-抽象类"> 2.4 抽象类</h3>
<ul>
<li>abstract</li>
<li>只有抽象类中能有抽象方法，抽象类中不只有抽象方法。</li>
<li>抽象类不能被实例化。</li>
</ul>
<hr>
<h3 id="_2-5-内部类"> 2.5 内部类</h3>
<ul>
<li>内部类拥有外部类的访问权限</li>
</ul>
<p><img src="./README.assets/image-20211217195726947.png" alt="image-20211217195726947" /></p>
<h2 id="三、异常"> 三、异常</h2>
<h3 id="_3-1-throwable"> 3.1 Throwable</h3>
<p><code>Throable</code> 类是Java语言中所有 <code>错误(errors)</code> 和 <code>异常(exceptions)</code> 的父类。</p>
<p><img src="./README.assets/image-20211217184906894.png" alt="image-20211217184906894" /></p>
<h3 id="_3-2-常见异常"> 3.2 常见异常</h3>
<p><img src="./README.assets/image-20211217193021056.png" alt="image-20211217193021056" /></p>
<h3 id="_3-3-error"> 3.3 Error</h3>
<p><img src="./README.assets/image-20211217194119016.png" alt="image-20211217194119016" /></p>
<h2 id="四、集合"> 四、集合</h2>
<p><img src="./README.assets/image-20211218142929505.png" alt="image-20211218142929505" /></p>
<p><img src="./README.assets/image-20211218182136734.png" alt="image-20211218182136734" /></p>
<h2 id="五、反射"> 五、反射</h2>
<p>Java反射机制是在程序的运行过程中，对于任何一个类，都能知道它的所有属性和方法；对于任意一个对象，都能知道调用它的任意属性和方法。</p>
<p>这种动态获取信息以及动态调用对象方法的功能称为Java语言的反射机制。</p>
<ul>
<li>在运行时判断任意一个对象所属的类</li>
<li>在运行时判断任意一个类的对象</li>
<li>在运行时判断任意一个类所有的成员变量和方法</li>
<li>在运行时调用任意一个对象的方法</li>
</ul>
<h3 id="_5-1-class-类"> 5.1 Class 类</h3>
<p>当我们编写一个类，在生产的<code>.class</code> 文件中，就会产生一个 Class 对象。这个 Class 对象用于标识这个类的类型信息。</p>
<p>Class中没有公共的构造器，也就是说Class对象不能杯实例化。</p>
<p>其中包含了很多方法，详见《Java基础核心总结》P54</p>
<h3 id="_5-2-field-类"> 5.2 Field 类</h3>
<p>Field 类提供类或接口中单独字段的信息，以及对单独字段的动态访问。</p>
<h3 id="_5-3-method-类"> 5.3 Method 类</h3>
<p>传递 Object 对象及参数调用该对象对应的方法</p>
<h3 id="_5-4-classloader-类"> 5.4 ClassLoader 类</h3>
<p>类装载器是用来把类装载进JVM的。ClassLoader使用的是双亲委托模型来搜索加载类的。</p>
<p><img src="./README.assets/image-20211224112354940.png" alt="image-20211224112354940" /></p>
<h2 id="六、枚举"> 六、枚举</h2>
<p>枚举是一个特殊的类，一般表示一组常量</p>
<div><pre><code><span>public</span> <span>enum</span> <span>Family</span> <span>{</span>
    FATHER<span>,</span>
    MOTHER<span>,</span>
    SON<span>,</span>
    <span>Daughter</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><img src="./README.assets/image-20211224185753390.png" alt="image-20211224185753390" /></p>
<p>一般 switch 可以和 enum 一起连用，来构造一个小型的状态转换机</p>
<div><pre><code><span>enum</span> <span>Signal</span> <span>{</span>
    GREEN<span>,</span> YELLOW<span>,</span> RED
<span>}</span>
<span>public</span> <span>class</span> <span>TrafficLight</span> <span>{</span>
    <span>Signal</span> color <span>=</span> <span>Signal</span><span>.</span>RED<span>;</span>
    <span>public</span> <span>void</span> <span>change</span><span>(</span><span>)</span> <span>{</span>
        <span>switch</span> <span>(</span>color<span>)</span> <span>{</span>
            <span>case</span> RED<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>GREEN<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> YELLOW<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>RED<span>;</span>
                <span>break</span><span>;</span>
            <span>case</span> GREEN<span>:</span>
                color <span>=</span> <span>Signal</span><span>.</span>YELLOW<span>;</span>
                <span>break</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h2 id="七、io"> 七、IO</h2>
<p><img src="./README.assets/image-20211224191321306.png" alt="image-20211224191321306" /></p>
<p><img src="./README.assets/image-20211224191353166.png" alt="image-20211224191353166" /></p>
<h3 id="_7-1-file-类"> 7.1 File 类</h3>
<p>主要涉及 <strong>文件创建、删除文件、获取文件描述</strong></p>
<p><img src="./README.assets/image-20211224191614348.png" alt="image-20211224191614348" /></p>
<h3 id="_7-2-inputstream"> 7.2 InputStream</h3>
<p>字节输入模式的抽象类</p>
<p><img src="./README.assets/image-20211224191724340.png" alt="image-20211224191724340" /></p>
<h3 id="_7-3-outputstream"> 7.3 OutputStream</h3>
<p>字节输出模式的抽象类</p>
<p><img src="./README.assets/image-20211224191752947.png" alt="image-20211224191752947" /></p>
<h3 id="_7-4-reader"> 7.4 Reader</h3>
<p>字符输入模式的抽象类</p>
<p><img src="./README.assets/image-20211224191816351.png" alt="image-20211224191816351" /></p>
<h3 id="_7-5-writer"> 7.5 Writer</h3>
<p>字符输出模式的抽象类</p>
<p><img src="./README.assets/image-20211224191839037.png" alt="image-20211224191839037" /></p>
<h3 id="_7-6-更多其他子类"> 7.6 更多其他子类</h3>
<p>详见 《Java基础核心总结》 p67</p>
<h2 id="插眼"> 插眼：</h2>
<h3 id="jdk、jre、jvm"> JDK、JRE、JVM</h3>
<h3 id="switch-实现原理"> switch 实现原理</h3>
<h3 id="深浅拷贝"> 深浅拷贝</h3>
<h3 id="代理-意义何在"> 代理，意义何在</h3>
<h3 id="面向对象三大特性"> 面向对象三大特性</h3>
<h3 id="修饰符"> 修饰符</h3>
<h3 id="集合"> 集合</h3>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-24T04:08:33.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java 垃圾回收</title>
    <id>https://vue-blog.lllllan.cn/1-java/2-jvm/2-garbage-collection/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/2-jvm/2-garbage-collection/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide</a>，略有改动</p>
</div>
<h2 id="写在前面"> 写在前面</h2>
<h3 id="常见面试题"> 常见面试题</h3>
<ul>
<li>如何判断对象是否死亡（两种方法）。</li>
<li>简单的介绍一下强引用、软引用、弱引用、虚引用（虚引用与软引用和弱引用的区别、使用软引用能带来的好处）。</li>
<li>如何判断一个常量是废弃常量</li>
<li>如何判断一个类是无用的类</li>
<li>垃圾收集有哪些算法，各自的特点？</li>
<li>HotSpot 为什么要分为新生代和老年代？</li>
<li>常见的垃圾回收器有哪些？</li>
<li>介绍一下 CMS,G1 收集器。</li>
<li>Minor Gc 和 Full GC 有什么不同呢？</li>
</ul>
<h3 id="核心问题"> 核心问题</h3>
<ol>
<li>内存如何分配和回收</li>
<li>哪些垃圾需要回收</li>
<li>什么时候回收</li>
<li>如何回收</li>
</ol>
<p><img src="./README.assets/image-20220118102736004.png" alt="image-20220118102736004" /></p>
<h2 id="一、jvm内存分配与回收"> 一、JVM内存分配与回收</h2>
<p>Java 的自动内存管理主要是针对<strong>对象内存</strong>的回收和对象内存的分配。同时，Java 自动内存管理最核心的功能是 <strong>堆</strong> 内存中对象的分配与回收。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>.从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代：再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p><img src="./README.assets/01d330d8-2710-4fad-a91c-7bbbfaaefc0e.fac41c8a.png" alt="img" /></p>
<div><p>第一次理解</p>
<p>如图所示，一般对象的创建，会先分配到图左1的 <code>Eden</code> 区域，随着垃圾回收的进行，仍然存活的对象会根据存活时间向老年代转移。</p>
</div>
<div><p>常见分配策略</p>
<ol>
<li>对象优先在 <code>Eden</code> 区域分配</li>
<li>大对象直接进入老年代</li>
<li>长期存活的对象将进入老年代</li>
</ol>
</div>
<h3 id="_1-1-对象优先在-eden-区域分配"> 1.1 对象优先在 <code>Eden</code> 区域分配</h3>
<p>目前主流的垃圾收集器都会采用<strong>分代回收算法</strong>，因此需要将堆内存分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p>大多数情况下，对象在新生代中 eden 区分配。当 eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC.</p>
<p>具体测试见 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/#_1-1-%E5%AF%B9%E8%B1%A1%E4%BC%98%E5%85%88%E5%9C%A8-eden-%E5%8C%BA%E5%88%86%E9%85%8D" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide | 1.1 对象优先在 <code>Eden</code> 区域分配</a></p>
<h3 id="_1-2-大对象直接进入老年代"> 1.2 大对象直接进入老年代</h3>
<p><strong>为什么要这样呢？</strong></p>
<p>为了避免为大对象分配内存时由于分配担保机制带来的复制而降低效率。（我的理解是：eden中内存分配不足时，总有对象要被转移到老年代的，不如一开始就将比较大的对象直接分配在老年代）</p>
<h3 id="_1-3-长期存活的对象将进入老年代"> 1.3 长期存活的对象将进入老年代</h3>
<p>如果对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间中，并将对象年龄设为 1.对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<h3 id="_1-4-动态对象年龄判断"> 1.4 动态对象年龄判断</h3>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置</p>
<div><p>晋升年龄阈值</p>
<p>Hotspot 遍历所有对象时，按照年龄从小到大对其所占用的大小进行累积，当累积的某个年龄大小超过了 survivor 区的 50% 时（默认值是 50%，可以通过 <code>-XX:TargetSurvivorRatio=percent</code> 来设置，参见 <a href="https://github.com/Snailclimb/JavaGuide/issues/1199" target="_blank" rel="noopener noreferrer">issue1199  (opens new window)</a> ），取这个年龄和 MaxTenuringThreshold 中更小的一个值，作为新的晋升年龄阈值</p>
</div>
<div><p>默认晋升年龄</p>
<p><strong>《深入理解 Java 虚拟机》</strong> 中说默认的晋升年龄是15，但是 Oracle 官网中说明这个晋升年龄并不都是15，这个是要区分垃圾收集器的，CMS 就是 6</p>
</div>
<h3 id="_1-5-主要进行gc的区域"> 1.5 主要进行GC的区域</h3>
<p>针对 HotSpot VM 的实现，它里面的 GC 其实准确分类只有两大种：</p>
<p>部分收集 (Partial GC)：</p>
<ul>
<li>新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li>
<li>老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。需要注意的是 Major GC 在有的语境中也用于指代整堆收集；</li>
<li>混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li>
</ul>
<p>整堆收集 (Full GC)：收集整个 Java 堆和方法区</p>
<h3 id="_1-6-空间分配担保"> 1.6 空间分配担保</h3>
<p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间</p>
<blockquote>
<p>JDK 6 Update 24 之前，在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。如果不成立，则虚拟机会先查看 <code>-XX:HandlePromotionFailure</code> 参数的设置值是否允许担保失败(Handle Promotion Failure);如果允许，那会继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小，如果大于，将尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的;如果小于，或者 <code>-XX: HandlePromotionFailure</code> 设置不允许冒险，那这时就要改为进行一次 Full GC。</p>
<p>JDK 6 Update 24 之后的规则变为只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小，就会进行 Minor GC，否则将进行 Full GC。</p>
</blockquote>
<h2 id="二、对象死亡"> 二、对象死亡</h2>
<p>堆中几乎放着所有的对象实例，对堆垃圾回收前的第一步就是要判断哪些对象已经死亡（即不能再被任何途径使用的对象）。</p>
<p><img src="./README.assets/11034259.2dc6983d.png" alt="img" /></p>
<h3 id="_2-1-引用计数法"> 2.1 引用计数法</h3>
<p>给对象中添加一个引用计数器，每当有一个地方引用它，计数器就加 1；当引用失效，计数器就减 1；任何时候计数器为 0 的对象就是不可能再被使用的。</p>
<p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong> 所谓对象之间的相互引用问题，如下面代码所示：除了对象 objA 和 objB 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，于是引用计数算法无法通知 GC 回收器回收他们。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ReferenceCountingGc</span> <span>{</span>
    <span>Object</span> instance <span>=</span> <span>null</span><span>;</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>ReferenceCountingGc</span> objA <span>=</span> <span>new</span> <span>ReferenceCountingGc</span><span>(</span><span>)</span><span>;</span>
		<span>ReferenceCountingGc</span> objB <span>=</span> <span>new</span> <span>ReferenceCountingGc</span><span>(</span><span>)</span><span>;</span>
		objA<span>.</span>instance <span>=</span> objB<span>;</span>
		objB<span>.</span>instance <span>=</span> objA<span>;</span>
		objA <span>=</span> <span>null</span><span>;</span>
		objB <span>=</span> <span>null</span><span>;</span>

	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_2-2-可达性分析算法"> 2.2 可达性分析算法</h3>
<p>这个算法的基本思想就是通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的。</p>
<p>可作为 GC Roots 的对象包括下面几种:</p>
<ul>
<li>虚拟机栈(栈帧中的本地变量表)中引用的对象</li>
<li>本地方法栈(Native 方法)中引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象</li>
<li>所有被同步锁持有的对象</li>
</ul>
<p><img src="./README.assets/下载.png" alt="下载" /></p>
<h3 id="_2-3-引用"> 2.3 引用</h3>
<p>无论是通过引用计数法判断对象引用数量，还是通过可达性分析法判断对象的引用链是否可达，判定对象的存活都与“引用”有关。</p>
<p>JDK1.2 之前，Java 中引用的定义很传统：如果 reference 类型的数据存储的数值代表的是另一块内存的起始地址，就称这块内存代表一个引用。</p>
<p>JDK1.2 以后，Java 对引用的概念进行了扩充，将引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p>
<div><pre><code><span>String</span> str<span>=</span><span>new</span> <span>String</span><span>(</span><span>"abc"</span><span>)</span><span>;</span>                                     <span>// 强引用</span>
<span>SoftReference</span><span><span>&lt;</span><span>String</span><span>></span></span> softRef<span>=</span><span>new</span> <span>SoftReference</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span>str<span>)</span><span>;</span>     <span>// 软引用</span>
<span>WeakReference</span><span><span>&lt;</span><span>String</span><span>></span></span> abcWeakRef <span>=</span> <span>new</span> <span>WeakReference</span><span><span>&lt;</span><span>String</span><span>></span></span><span>(</span>str<span>)</span><span>;</span><span>// 弱引用</span>
<span>?</span><span>?</span><span>?</span>                                                               <span>// 虚引用</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><p>更多解释见 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/#_2-3-%E5%86%8D%E8%B0%88%E5%BC%95%E7%94%A8" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide</a></p>
<p><img src="./README.assets/8vvr30i6ew.png" alt="8vvr30i6ew" /></p>
<p><img src="./README.assets/a3je2pxov.png" alt="a3je2pxov" /></p>
<h3 id="_2-4-不可达的对象并非-非死不可"> 2.4 不可达的对象并非“非死不可”</h3>
<p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程；可达性分析法中不可达的对象被第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行 <code>finalize</code> 方法。当对象没有覆盖 <code>finalize</code> 方法，或 <code>finalize</code> 方法已经被虚拟机调用过时，虚拟机将这两种情况视为没有必要执行。</p>
<p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收。</p>
<blockquote>
<p><code>Object</code> 类中的 <code>finalize</code> 方法一直被认为是一个糟糕的设计，成为了 Java 语言的负担，影响了 Java 语言的安全和 GC 的性能。JDK9 版本及后续版本中各个类中的 <code>finalize</code> 方法会被逐渐弃用移除。忘掉它的存在吧！</p>
<p>参考：</p>
<ul>
<li><a href="https://openjdk.java.net/jeps/421" target="_blank" rel="noopener noreferrer">JEP 421: Deprecate Finalization for Removal  (opens new window)</a></li>
<li><a href="https://mp.weixin.qq.com/s/LW-paZAMD08DP_3-XCUxmg" target="_blank" rel="noopener noreferrer">是时候忘掉 finalize 方法了</a></li>
</ul>
</blockquote>
<h3 id="_2-5-如何判断一个常量是废弃常量"> 2.5 如何判断一个常量是废弃常量</h3>
<ol>
<li><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></li>
<li><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</li>
<li><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></li>
</ol>
<p>假如在字符串常量池中存在字符串 &quot;abc&quot;，如果当前没有任何 String 对象引用该字符串常量的话，就说明常量 &quot;abc&quot; 就是废弃常量，如果这时发生内存回收的话而且有必要的话，&quot;abc&quot; 就会被系统清理出常量池了</p>
<h3 id="_2-6-如何判断一个类是无用的类"> 2.6 如何判断一个类是无用的类</h3>
<p>方法区主要回收的是无用的类，那么如何判断一个类是无用的类的呢？</p>
<p>判定一个常量是否是“废弃常量”比较简单，而要判定一个类是否是“无用的类”的条件则相对苛刻许多。类需要同时满足下面 3 个条件才能算是 <strong>“无用的类”</strong> ：</p>
<ul>
<li>该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li>
<li>加载该类的 <code>ClassLoader</code> 已经被回收。</li>
<li>该类对应的 <code>java.lang.Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li>
</ul>
<p>虚拟机可以对满足上述 3 个条件的无用类进行回收，这里说的仅仅是“可以”，而并不是和对象一样不使用了就会必然被回收。</p>
<h2 id="三、垃圾收集算法"> 三、垃圾收集算法</h2>
<p><img src="./README.assets/下载-16429996288571.png" alt="下载" /></p>
<h3 id="_3-1-标记-清除算法"> 3.1 标记-清除算法</h3>
<p>该算法分为“标记”和“清除”阶段：首先标记出所有不需要回收的对象，在标记完成后统一回收掉所有没有被标记的对象。它是最基础的收集算法，后续的算法都是对其不足进行改进得到。这种垃圾收集算法会带来两个明显的问题：</p>
<ol>
<li><strong>效率问题</strong></li>
<li><strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li>
</ol>
<p><img src="./README.assets/标记-清除算法.65bd8fdd.jpeg" alt="img" /></p>
<h3 id="_3-2-标记-复制算法"> 3.2 标记-复制算法</h3>
<p>为了解决效率问题，“标记-复制”收集算法出现了。它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。这样就使每次的内存回收都是对内存区间的一半进行回收。</p>
<p><img src="./README.assets/90984624.fed0b8a5.png" alt="复制算法" /></p>
<h3 id="_3-3-标记-整理算法"> 3.3 标记-整理算法</h3>
<p>根据老年代的特点提出的一种标记算法，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象回收，而是让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p>
<p><img src="./README.assets/94057049.6e404020.png" alt="标记-整理算法 " /></p>
<h3 id="_3-4-分代收集算法"> 3.4 分代收集算法</h3>
<p>当前虚拟机的垃圾收集都采用分代收集算法，这种算法没有什么新的思想，只是根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p>
<p><strong>比如在新生代中，每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。而老年代的对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</strong></p>
<h2 id="四、垃圾收集器"> 四、垃圾收集器</h2>
<p><img src="./README.assets/下载-16430012712675.png" alt="下载" /></p>
<p><strong>如果说收集算法是内存回收的方法论，那么垃圾收集器就是内存回收的具体实现。</strong></p>
<p>虽然我们对各个收集器进行比较，但并非要挑选出一个最好的收集器。因为直到现在为止还没有最好的垃圾收集器出现，更加没有万能的垃圾收集器，<strong>我们能做的就是根据具体应用场景选择适合自己的垃圾收集器</strong>。</p>
<h3 id="_4-1-serial-收集器"> 4.1 Serial 收集器</h3>
<p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。大家看名字就知道这个收集器是一个单线程收集器了。它的 <strong>“单线程”</strong> 的意义不仅仅意味着它只会使用一条垃圾收集线程去完成垃圾收集工作，更重要的是它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>&quot;Stop The World&quot;</strong> ），直到它收集结束。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="./README.assets/下载-16430015977726.png" alt="下载" /></p>
<p>虚拟机的设计者们当然知道 Stop The World 带来的不良用户体验，所以在后续的垃圾收集器设计中停顿时间在不断缩短（仍然还有停顿，寻找最优秀的垃圾收集器的过程仍然在继续）。</p>
<p>但是 Serial 收集器有没有优于其他垃圾收集器的地方呢？当然有，它<strong>简单而高效（与其他收集器的单线程相比）</strong>。Serial 收集器由于没有线程交互的开销，自然可以获得很高的单线程收集效率。Serial 收集器对于运行在 Client 模式下的虚拟机来说是个不错的选择</p>
<h3 id="_4-2-parnew-收集器"> 4.2 ParNew 收集器</h3>
<p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="./README.assets/下载-16430016989647.png" alt="下载" /></p>
<p>它是许多运行在 Server 模式下的虚拟机的首要选择，除了 Serial 收集器外，只有它能与 CMS 收集器（真正意义上的并发收集器，后面会介绍到）配合工作。</p>
<p><strong>并行和并发概念补充：</strong></p>
<ul>
<li><strong>并行（Parallel）</strong> ：指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。</li>
<li><strong>并发（Concurrent）</strong>：指用户线程与垃圾收集线程同时执行（但不一定是并行，可能会交替执行），用户程序在继续运行，而垃圾收集器运行在另一个 CPU 上。</li>
</ul>
<h3 id="_4-3-parallel-scavenge-收集器"> 4.3 Parallel Scavenge 收集器</h3>
<p><strong>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。CMS 等垃圾收集器的关注点更多的是用户线程的停顿时间（提高用户体验）。所谓吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</strong> Parallel Scavenge 收集器提供了很多参数供用户找到最合适的停顿时间或最大吞吐量，如果对于收集器运作不太了解，手工优化存在困难的时候，使用 Parallel Scavenge 收集器配合自适应调节策略，把内存管理优化交给虚拟机去完成也是一个不错的选择。</p>
<p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p>
<p><img src="./README.assets/下载-16430020217288.png" alt="下载" /></p>
<blockquote>
<p>JDK1.8 默认使用的是 Parallel Scavenge + Parallel Old，如果指定了-XX:+UseParallelGC 参数，则默认指定了-XX:+UseParallelOldGC，可以使用-XX:-UseParallelOldGC 来禁用该功能</p>
</blockquote>
<h3 id="_4-4-更多其他收集器"> 4.4 更多其他收集器</h3>
<p>详见 <a href="https://javaguide.cn/java/jvm/jvm-garbage-collection/#_4-%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8" target="_blank" rel="noopener noreferrer">JVM 垃圾回收详解 | JavaGuide</a></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T08:35:36.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">代理详解</title>
    <id>https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/3-agent/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/1-basic/3-important-points/3-agent/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/basis/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E8%AF%A6%E8%A7%A3/" target="_blank" rel="noopener noreferrer">代理详解！静态代理+JDK/CGLIB 动态代理实战 | JavaGuide</a>， 略有改动</p>
<p>（完全不懂）</p>
</div>
<h2 id="代理模式"> 代理模式</h2>
<p>代理模式是一种比较好理解的设计模式。简单来说就是 <strong>我们使用代理对象来代替对真实对象(real object)的访问，这样就可以在不修改原目标对象的前提下，提供额外的功能操作，扩展目标对象的功能。</strong></p>
<p><strong>代理模式的主要作用是扩展目标对象的功能，比如说在目标对象的某个方法执行前后你可以增加一些自定义的操作。</strong></p>
<p><img src="./README.assets/1DjWCgTFm-xqbhbNQVsaWQw.png" alt="Understanding the Proxy Design Pattern | by Mithun Sasidharan | Medium" /></p>
<h2 id="静态代理"> 静态代理</h2>
<p><strong>静态代理中，我们对目标对象的每个方法的增强都是手动完成的（<em>后面会具体演示代码</em>），非常不灵活（<em>比如接口一旦新增加方法，目标对象和代理对象都要进行修改</em>）且麻烦(<em>需要对每个目标类都单独写一个代理类</em>)。</strong> 实际应用场景非常非常少，日常开发几乎看不到使用静态代理的场景。</p>
<p>上面我们是从实现和应用角度来说的静态代理，从 JVM 层面来说， <strong>静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。</strong></p>
<p>静态代理实现步骤:</p>
<ol>
<li>定义一个接口及其实现类；</li>
<li>创建一个代理类同样实现这个接口</li>
<li>将目标对象注入进代理类，然后在代理类的对应方法调用目标类中的对应方法。这样的话，我们就可以通过代理类屏蔽对目标对象的访问，并且可以在目标方法执行前后做一些自己想做的事情。</li>
</ol>
<p>下面通过代码展示！</p>
<p><strong>1. 定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.创建代理类并同样实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsProxy</span> <span>implements</span> <span>SmsService</span> <span>{</span>

    <span>private</span> <span>final</span> <span>SmsService</span> smsService<span>;</span>

    <span>public</span> <span>SmsProxy</span><span>(</span><span>SmsService</span> smsService<span>)</span> <span>{</span>
        <span>this</span><span>.</span>smsService <span>=</span> smsService<span>;</span>
    <span>}</span>

    <span>@Override</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method send()"</span><span>)</span><span>;</span>
        smsService<span>.</span><span>send</span><span>(</span>message<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method send()"</span><span>)</span><span>;</span>
        <span>return</span> <span>null</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br></div></div><p><strong>4.实际使用</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>Main</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>SmsService</span> smsService <span>=</span> <span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>;</span>
        <span>SmsProxy</span> smsProxy <span>=</span> <span>new</span> <span>SmsProxy</span><span>(</span>smsService<span>)</span><span>;</span>
        smsProxy<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send<span>(</span><span>)</span>
send message:java
after method send<span>(</span><span>)</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h2 id="动态代理"> 动态代理</h2>
<p>相比于静态代理来说，动态代理更加灵活。我们不需要针对每个目标类都单独创建一个代理类，并且也不需要我们必须实现接口，我们可以直接代理实现类( <em>CGLIB 动态代理机制</em>)。</p>
<blockquote>
<p><strong>从 JVM 角度来说，动态代理是在运行时动态生成类字节码，并加载到 JVM 中的</strong></p>
</blockquote>
<p><strong>动态代理在我们日常开发中使用的相对较少，但是在框架中的几乎是必用的一门技术。学会了动态代理之后，对于我们理解和学习各种框架的原理也非常有帮助。</strong></p>
<p>就 Java 来说，动态代理的实现方式有很多种，比如 <strong>JDK 动态代理</strong>、<strong>CGLIB 动态代理</strong>等等。</p>
<h3 id="jdk-动态代理机制"> JDK 动态代理机制</h3>
<h4 id="介绍"> 介绍</h4>
<p><strong>在 Java 动态代理机制中 <code>InvocationHandler</code> 接口和 <code>Proxy</code> 类是核心。</strong></p>
<p><code>Proxy</code> 类中使用频率最高的方法是：<code>newProxyInstance()</code> ，这个方法主要用来生成一个代理对象。</p>
<div><pre><code><span>public</span> <span>static</span> <span>Object</span> <span>newProxyInstance</span><span>(</span><span>ClassLoader</span> loader<span>,</span> <span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span><span>[</span><span>]</span> interfaces<span>,</span>
                                      <span>InvocationHandler</span> h<span>)</span>
    <span>throws</span> <span>IllegalArgumentException</span> <span>{</span>
    <span>.</span><span>.</span><span>.</span><span>.</span><span>.</span><span>.</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这个方法一共有 3 个参数：</p>
<ol>
<li><strong>loader</strong> :类加载器，用于加载代理对象。</li>
<li><strong>interfaces</strong> : 被代理类实现的一些接口；</li>
<li><strong>h</strong> : 实现了 <code>InvocationHandler</code> 接口的对象；</li>
</ol>
<p>要实现动态代理的话，还必须需要实现<code>InvocationHandler</code> 来自定义处理逻辑。 当我们的动态代理对象调用一个方法时，这个方法的调用就会被转发到实现<code>InvocationHandler</code> 接口类的 <code>invoke</code> 方法来调用。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>InvocationHandler</span> <span>{</span>

    <span>/**
     * 当你使用代理对象调用方法的时候实际会调用到这个方法
     */</span>
    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span>
        <span>throws</span> <span>Throwable</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><code>invoke()</code> 方法有下面三个参数：</p>
<ol>
<li><strong>proxy</strong> :动态生成的代理类</li>
<li><strong>method</strong> : 与代理类对象调用的方法相对应</li>
<li><strong>args</strong> : 当前 method 方法的参数</li>
</ol>
<blockquote>
<p>也就是说：<strong>你通过<code>Proxy</code> 类的 <code>newProxyInstance()</code> 创建的代理对象在调用方法的时候，实际会调用到实现<code>InvocationHandler</code> 接口的类的 <code>invoke()</code>方法。</strong> 你可以在 <code>invoke()</code> 方法中自定义处理逻辑，比如在方法执行前后做什么事情。</p>
</blockquote>
<h4 id="使用步骤"> 使用步骤</h4>
<ol>
<li>定义一个接口及其实现类；</li>
<li>自定义 <code>InvocationHandler</code> 并重写<code>invoke</code>方法，在 <code>invoke</code> 方法中我们会调用原生方法（被代理类的方法）并自定义一些处理逻辑；</li>
<li>通过 <code>Proxy.newProxyInstance(ClassLoader loader,Class&lt;?&gt;[] interfaces,InvocationHandler h)</code> 方法创建代理对象；</li>
</ol>
<h4 id="代码示例"> 代码示例</h4>
<p><strong>1.定义发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>interface</span> <span>SmsService</span> <span>{</span>
    <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>2.实现发送短信的接口</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>SmsServiceImpl</span> <span>implements</span> <span>SmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p><strong>3.定义一个 JDK 动态代理类</strong></p>
<div><pre><code><span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationHandler</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>InvocationTargetException</span><span>;</span>
<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>/**
 * @author shuang.kou
 * @createTime 2020年05月11日 11:23:00
 */</span>
<span>public</span> <span>class</span> <span>DebugInvocationHandler</span> <span>implements</span> <span>InvocationHandler</span> <span>{</span>
    <span>/**
     * 代理类中的真实对象
     */</span>
    <span>private</span> <span>final</span> <span>Object</span> target<span>;</span>

    <span>public</span> <span>DebugInvocationHandler</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>this</span><span>.</span>target <span>=</span> target<span>;</span>
    <span>}</span>


    <span>public</span> <span>Object</span> <span>invoke</span><span>(</span><span>Object</span> proxy<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>)</span> <span>throws</span> <span>InvocationTargetException</span><span>,</span> <span>IllegalAccessException</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> result <span>=</span> method<span>.</span><span>invoke</span><span>(</span>target<span>,</span> args<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> result<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><code>invoke()</code> 方法: 当我们的动态代理对象调用原生方法的时候，最终实际上调用到的是 <code>invoke()</code> 方法，然后 <code>invoke()</code> 方法代替我们去调用了被代理对象的原生方法。</p>
<p><strong>4.获取代理对象的工厂类</strong></p>
<div><pre><code><span>public</span> <span>class</span> <span>JdkProxyFactory</span> <span>{</span>
    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Object</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>Proxy</span><span>.</span><span>newProxyInstance</span><span>(</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>,</span> <span>// 目标类的类加载</span>
                target<span>.</span><span>getClass</span><span>(</span><span>)</span><span>.</span><span>getInterfaces</span><span>(</span><span>)</span><span>,</span>  <span>// 代理需要实现的接口，可指定多个</span>
                <span>new</span> <span>DebugInvocationHandler</span><span>(</span>target<span>)</span>   <span>// 代理对象对应的自定义 InvocationHandler</span>
        <span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><p><code>getProxy()</code> ：主要通过<code>Proxy.newProxyInstance（）</code>方法获取某个类的代理对象</p>
<p><strong>5.实际使用</strong></p>
<div><pre><code><span>SmsService</span> smsService <span>=</span> <span>(</span><span>SmsService</span><span>)</span> <span>JdkProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>new</span> <span>SmsServiceImpl</span><span>(</span><span>)</span><span>)</span><span>;</span>
smsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="cglib-动态代理机制"> CGLIB 动态代理机制</h3>
<h4 id="介绍-2"> 介绍</h4>
<p><strong>JDK 动态代理有一个最致命的问题是其只能代理实现了接口的类。为了解决这个问题，我们可以用 CGLIB 动态代理机制来避免。</strong></p>
<p><a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB  (opens new window)</a>(<em>Code Generation Library</em>)是一个基于<a href="http://www.baeldung.com/java-asm" target="_blank" rel="noopener noreferrer">ASM  (opens new window)</a>的字节码生成库，它允许我们在运行时对字节码进行修改和动态生成。CGLIB 通过继承方式实现代理。很多知名的开源框架都使用到了<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB  (opens new window)</a>， 例如 Spring 中的 AOP 模块中：如果目标对象实现了接口，则默认采用 JDK 动态代理，否则采用 CGLIB 动态代理。</p>
<p><strong>在 CGLIB 动态代理机制中 <code>MethodInterceptor</code> 接口和 <code>Enhancer</code> 类是核心。</strong></p>
<p>你需要自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法。</p>
<div><pre><code><span>public</span> <span>interface</span> <span>MethodInterceptor</span>
<span>extends</span> <span>Callback</span><span>{</span>
    <span>// 拦截被代理类中的方法</span>
    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> obj<span>,</span> <span><span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span>
                               <span>MethodProxy</span> proxy<span>)</span> <span>throws</span> <span>Throwable</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><ol>
<li><strong>obj</strong> :被代理的对象（需要增强的对象）</li>
<li><strong>method</strong> :被拦截的方法（需要增强的方法）</li>
<li><strong>args</strong> :方法入参</li>
<li><strong>proxy</strong> :用于调用原始方法</li>
</ol>
<p>你可以通过 <code>Enhancer</code>类来动态获取被代理类，当代理类调用方法的时候，实际调用的是 <code>MethodInterceptor</code> 中的 <code>intercept</code> 方法。</p>
<h4 id="使用步骤-2"> 使用步骤</h4>
<ol>
<li>定义一个类；</li>
<li>自定义 <code>MethodInterceptor</code> 并重写 <code>intercept</code> 方法，<code>intercept</code> 用于拦截增强被代理类的方法，和 JDK 动态代理中的 <code>invoke</code> 方法类似；</li>
<li>通过 <code>Enhancer</code> 类的 <code>create()</code>创建代理类；</li>
</ol>
<h4 id="代码示例-2"> 代码示例</h4>
<p>不同于 JDK 动态代理不需要额外的依赖。<a href="https://github.com/cglib/cglib" target="_blank" rel="noopener noreferrer">CGLIB  (opens new window)</a>(<em>Code Generation Library</em>) 实际是属于一个开源项目，如果你要使用它的话，需要手动添加相关依赖。</p>
<div><pre><code><span><span><span>&lt;</span>dependency</span><span>></span></span>
  <span><span><span>&lt;</span>groupId</span><span>></span></span>cglib<span><span><span>&lt;/</span>groupId</span><span>></span></span>
  <span><span><span>&lt;</span>artifactId</span><span>></span></span>cglib<span><span><span>&lt;/</span>artifactId</span><span>></span></span>
  <span><span><span>&lt;</span>version</span><span>></span></span>3.3.0<span><span><span>&lt;/</span>version</span><span>></span></span>
<span><span><span>&lt;/</span>dependency</span><span>></span></span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p><strong>1.实现一个使用阿里云发送短信的类</strong></p>
<div><pre><code><span>package</span> <span>github<span>.</span>javaguide<span>.</span>dynamicProxy<span>.</span>cglibDynamicProxy</span><span>;</span>

<span>public</span> <span>class</span> <span>AliSmsService</span> <span>{</span>
    <span>public</span> <span>String</span> <span>send</span><span>(</span><span>String</span> message<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"send message:"</span> <span>+</span> message<span>)</span><span>;</span>
        <span>return</span> message<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><p><strong>2.自定义 <code>MethodInterceptor</code>（方法拦截器）</strong></p>
<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodInterceptor</span><span>;</span>
<span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>MethodProxy</span><span>;</span>

<span>import</span> <span>java<span>.</span>lang<span>.</span>reflect<span>.</span></span><span>Method</span><span>;</span>

<span>/**
 * 自定义MethodInterceptor
 */</span>
<span>public</span> <span>class</span> <span>DebugMethodInterceptor</span> <span>implements</span> <span>MethodInterceptor</span> <span>{</span>


    <span>/**
     * @param o           代理对象（增强的对象）
     * @param method      被拦截的方法（需要增强的方法）
     * @param args        方法入参
     * @param methodProxy 用于调用原始方法
     */</span>
    <span>@Override</span>
    <span>public</span> <span>Object</span> <span>intercept</span><span>(</span><span>Object</span> o<span>,</span> <span>Method</span> method<span>,</span> <span>Object</span><span>[</span><span>]</span> args<span>,</span> <span>MethodProxy</span> methodProxy<span>)</span> <span>throws</span> <span>Throwable</span> <span>{</span>
        <span>//调用方法之前，我们可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"before method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>Object</span> object <span>=</span> methodProxy<span>.</span><span>invokeSuper</span><span>(</span>o<span>,</span> args<span>)</span><span>;</span>
        <span>//调用方法之后，我们同样可以添加自己的操作</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"after method "</span> <span>+</span> method<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>return</span> object<span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br></div></div><p><strong>3.获取代理类</strong></p>
<div><pre><code><span>import</span> <span>net<span>.</span>sf<span>.</span>cglib<span>.</span>proxy<span>.</span></span><span>Enhancer</span><span>;</span>

<span>public</span> <span>class</span> <span>CglibProxyFactory</span> <span>{</span>

    <span>public</span> <span>static</span> <span>Object</span> <span>getProxy</span><span>(</span><span>Class</span><span><span>&lt;</span><span>?</span><span>></span></span> clazz<span>)</span> <span>{</span>
        <span>// 创建动态代理增强类</span>
        <span>Enhancer</span> enhancer <span>=</span> <span>new</span> <span>Enhancer</span><span>(</span><span>)</span><span>;</span>
        <span>// 设置类加载器</span>
        enhancer<span>.</span><span>setClassLoader</span><span>(</span>clazz<span>.</span><span>getClassLoader</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 设置被代理类</span>
        enhancer<span>.</span><span>setSuperclass</span><span>(</span>clazz<span>)</span><span>;</span>
        <span>// 设置方法拦截器</span>
        enhancer<span>.</span><span>setCallback</span><span>(</span><span>new</span> <span>DebugMethodInterceptor</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>// 创建代理类</span>
        <span>return</span> enhancer<span>.</span><span>create</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p><strong>4.实际使用</strong></p>
<div><pre><code><span>AliSmsService</span> aliSmsService <span>=</span> <span>(</span><span>AliSmsService</span><span>)</span> <span>CglibProxyFactory</span><span>.</span><span>getProxy</span><span>(</span><span>AliSmsService</span><span>.</span><span>class</span><span>)</span><span>;</span>
aliSmsService<span>.</span><span>send</span><span>(</span><span>"java"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>运行上述代码之后，控制台打印出：</p>
<div><pre><code>before method send
send message:java
after method send
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="对比"> 对比</h3>
<ul>
<li>
<p><strong>JDK 动态代理只能代理实现了接口的类或者直接代理接口，而 CGLIB 可以代理未实现任何接口的类。</strong> 另外， CGLIB 动态代理是通过生成一个被代理类的子类来拦截被代理类的方法调用，因此不能代理声明为 final 类型的类和方法。</p>
</li>
<li>
<p>就二者的效率来说，大部分情况都是 JDK 动态代理更优秀，随着 JDK 版本的升级，这个优势更加明显。</p>
</li>
</ul>
<h2 id="静态代理和动态代理的对比"> 静态代理和动态代理的对比</h2>
<ol>
<li><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接口，可以直接代理实现类，并且可以不需要针对每个目标类都创建一个代理类。另外，静态代理中，接口一旦新增加方法，目标对象和代理对象都要进行修改，这是非常麻烦的！</li>
<li><strong>JVM 层面</strong> ：静态代理在编译时就将接口、实现类、代理类这些都变成了一个个实际的 class 文件。而动态代理是在运行时动态生成类字节码，并加载到 JVM 中的。</li>
</ol>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java 集合框架基础知识</title>
    <id>https://vue-blog.lllllan.cn/1-java/3-container/1-collection-basic/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/3-container/1-collection-basic/"/>
    <updated>2022-01-25T02:54:47.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/collection/java%E9%9B%86%E5%90%88%E6%A1%86%E6%9E%B6%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86&amp;%E9%9D%A2%E8%AF%95%E9%A2%98%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">Java集合框架基础知识&amp;面试题总结 | JavaGuide</a>，略有改动</p>
</div>
<h2 id="一、集合概述"> 一、集合概述</h2>
<h3 id="_1-0-java集合概览"> 1.0 Java集合概览</h3>
<p><img src="./README.assets/java-collection-hierarchy.71519bdb.png" alt="img" /></p>
<h3 id="_1-1-集合框架底层数据结构"> 1.1 集合框架底层数据结构</h3>
<ul>
<li><code>Collection</code>
<ul>
<li><code>List</code>
<ul>
<li><code>ArrayList</code>: Object[] 数组</li>
<li><code>Vector</code>: Object[] 数组</li>
<li><code>LinkedList</code>: 双向链表</li>
</ul>
</li>
<li><code>Set</code>
<ul>
<li><code>HashSet</code>（无序）: 基于 <code>HashMap</code> 实现</li>
<li><code>LinkedHashSet</code>: <code>HashSet</code> 的子类，基于 <code>LinkedHashMap</code> 实现</li>
<li><code>TreeSet</code>（有序）: 红黑树（自平衡的排序二叉树）</li>
</ul>
</li>
<li><code>Queue</code>
<ul>
<li><code>PriorityQueue</code> : Object[] 数组实现二叉堆</li>
<li><code>ArrayQueue</code> : Object[] 数组 + 双指针</li>
</ul>
</li>
</ul>
</li>
<li><code>Map</code>
<ul>
<li><code>HashMap</code> : 数组 + 链表 + 红黑树（链表根据大小和阈值进行扩容，扩容到一定大小转换为红黑树）</li>
<li><code>LinkedMap</code> : 继承自 <code>HashMap</code>，增加一条双向链表以保持插入顺序</li>
<li><code>Hashtable</code> : 数组 + 链表</li>
<li><code>TreeMap</code> : 红黑树</li>
</ul>
</li>
</ul>
<h3 id="_1-2-集合的选择"> 1.2 集合的选择</h3>
<p><img src="./README.assets/image-20220118101609300.png" alt="image-20220118101609300" /></p>
<h2 id="二、list"> 二、List</h2>
<h3 id="_2-1-arraylist-和-vector-的区别"> 2.1 ArrayList 和 Vector 的区别</h3>
<p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全的（代价就是效率差一些）。</p>
<h3 id="_2-2-arraylist-和-linkedlist-的区别"> 2.2 ArrayList  和 LinkedList 的区别</h3>
<p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h3 id="_2-3-randomaccess-接口"> 2.3 RandomAccess 接口</h3>
<div><pre><code><span>public</span> <span>interface</span> <span>RandomAccess</span> <span>{</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>查看源码我们发现实际上 <code>RandomAccess</code> 接口中什么都没有定义。所以，在我看来 <code>RandomAccess</code> 接口不过是一个标识罢了。标识什么？ 标识实现这个接口的类具有随机访问功能。</p>
<p>在 <code>binarySearch()</code>方法中，它要判断传入的 list 是否 <code>RamdomAccess</code>的实例，如果是，调用<code>indexedBinarySearch()</code>方法，如果不是，那么调用<code>iteratorBinarySearch()</code>方法</p>
<div><pre><code><span>public</span> <span>static</span> <span><span>&lt;</span><span>T</span><span>></span></span>
    <span>int</span> <span>binarySearch</span><span>(</span><span>List</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>Comparable</span><span>&lt;</span><span>?</span> <span>super</span> <span>T</span><span>></span><span>></span></span> list<span>,</span> <span>T</span> key<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>list <span>instanceof</span> <span>RandomAccess</span> <span>||</span> list<span>.</span><span>size</span><span>(</span><span>)</span><span>&lt;</span>BINARYSEARCH_THRESHOLD<span>)</span>
        <span>return</span> <span>Collections</span><span>.</span><span>indexedBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
    <span>else</span>
        <span>return</span> <span>Collections</span><span>.</span><span>iteratorBinarySearch</span><span>(</span>list<span>,</span> key<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口， 而 <code>LinkedList</code> 没有实现。为什么呢？我觉得还是和底层数据结构有关！<code>ArrayList</code> 底层是数组，而 <code>LinkedList</code> 底层是链表。数组天然支持随机访问，时间复杂度为 O(1)，所以称为快速随机访问。链表需要遍历到特定位置才能访问特定位置的元素，时间复杂度为 O(n)，所以不支持快速随机访问。，<code>ArrayList</code> 实现了 <code>RandomAccess</code> 接口，就表明了他具有快速随机访问功能。 <code>RandomAccess</code> 接口只是标识，并不是说 <code>ArrayList</code> 实现 <code>RandomAccess</code> 接口才具有快速随机访问功能的！</p>
<h3 id="_2-4-arraylist-扩容机制"> 2.4 ArrayList 扩容机制</h3>
<p>详见另一篇 <a href="../2-source-code/1-arraylist">ArrayList 源码解读</a></p>
<h2 id="三、set"> 三、Set</h2>
<h3 id="_3-1-comparable-和-comparator-的区别"> 3.1 comparable 和 Comparator 的区别</h3>
<ul>
<li><code>comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li>
<li><code>comparator</code>接口实际上是出自 java.util 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li>
</ul>
<h4 id="_3-1-1-comparator-定制排序"> 3.1.1 Comparator 定制排序</h4>
<div><pre><code><span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span> arrayList <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>1</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>3</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>5</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>7</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>4</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>9</span><span>)</span><span>;</span>
arrayList<span>.</span><span>add</span><span>(</span><span>-</span><span>7</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"原始数组:"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>// void reverse(List list)：反转</span>
<span>Collections</span><span>.</span><span>reverse</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.reverse(arrayList):"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>

<span>// void sort(List list),按自然排序的升序排序</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"Collections.sort(arrayList):"</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
<span>// 定制排序的用法</span>
<span>Collections</span><span>.</span><span>sort</span><span>(</span>arrayList<span>,</span> <span>new</span> <span>Comparator</span><span><span>&lt;</span><span>Integer</span><span>></span></span><span>(</span><span>)</span> <span>{</span>

    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compare</span><span>(</span><span>Integer</span> o1<span>,</span> <span>Integer</span> o2<span>)</span> <span>{</span>
        <span>return</span> o2<span>.</span><span>compareTo</span><span>(</span>o1<span>)</span><span>;</span>
    <span>}</span>
<span>}</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"定制排序后："</span><span>)</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>arrayList<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br></div></div><p>Output:</p>
<div><pre><code>原始数组:
[-1, 3, 3, -5, 7, 4, -9, -7]
Collections.reverse(arrayList):
[-7, -9, 4, 7, -5, 3, 3, -1]
Collections.sort(arrayList):
[-9, -7, -5, -1, 3, 3, 4, 7]
定制排序后：
[7, 4, 3, 3, -1, -5, -7, -9]
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br></div></div><h4 id="_3-1-2-重写-compareto-方法"> 3.1.2 重写 compareTo 方法</h4>
<div><pre><code><span>// person对象没有实现Comparable接口，所以必须实现，这样才不会出错，才可以使treemap中的数据按顺序排列</span>
<span>// 前面一个例子的String类已经默认实现了Comparable接口，详细可以查看String类的API文档，另外其他</span>
<span>// 像Integer类等都已经实现了Comparable接口，所以不需要另外实现了</span>
<span>public</span>  <span>class</span> <span>Person</span> <span>implements</span> <span>Comparable</span><span><span>&lt;</span><span>Person</span><span>></span></span> <span>{</span>
    <span>private</span> <span>String</span> name<span>;</span>
    <span>private</span> <span>int</span> age<span>;</span>

    <span>public</span> <span>Person</span><span>(</span><span>String</span> name<span>,</span> <span>int</span> age<span>)</span> <span>{</span>
        <span>super</span><span>(</span><span>)</span><span>;</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>getName</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setName</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>getAge</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> age<span>;</span>
    <span>}</span>

    <span>public</span> <span>void</span> <span>setAge</span><span>(</span><span>int</span> age<span>)</span> <span>{</span>
        <span>this</span><span>.</span>age <span>=</span> age<span>;</span>
    <span>}</span>

    <span>/**
     * T重写compareTo方法实现按年龄来排序
     */</span>
    <span>@Override</span>
    <span>public</span> <span>int</span> <span>compareTo</span><span>(</span><span>Person</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>></span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>1</span><span>;</span>
        <span>}</span>
        <span>if</span> <span>(</span><span>this</span><span>.</span>age <span>&lt;</span> o<span>.</span><span>getAge</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>return</span> <span>-</span><span>1</span><span>;</span>
        <span>}</span>
        <span>return</span> <span>0</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br></div></div><div><pre><code><span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
    <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span> pdata <span>=</span> <span>new</span> <span>TreeMap</span><span><span>&lt;</span><span>Person</span><span>,</span> <span>String</span><span>></span></span><span>(</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"张三"</span><span>,</span> <span>30</span><span>)</span><span>,</span> <span>"zhangsan"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"李四"</span><span>,</span> <span>20</span><span>)</span><span>,</span> <span>"lisi"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"王五"</span><span>,</span> <span>10</span><span>)</span><span>,</span> <span>"wangwu"</span><span>)</span><span>;</span>
    pdata<span>.</span><span>put</span><span>(</span><span>new</span> <span>Person</span><span>(</span><span>"小红"</span><span>,</span> <span>5</span><span>)</span><span>,</span> <span>"xiaohong"</span><span>)</span><span>;</span>
    <span>// 得到key的值的同时得到key所对应的值</span>
    <span>Set</span><span><span>&lt;</span><span>Person</span><span>></span></span> keys <span>=</span> pdata<span>.</span><span>keySet</span><span>(</span><span>)</span><span>;</span>
    <span>for</span> <span>(</span><span>Person</span> key <span>:</span> keys<span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>key<span>.</span><span>getAge</span><span>(</span><span>)</span> <span>+</span> <span>"-"</span> <span>+</span> key<span>.</span><span>getName</span><span>(</span><span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>Output：</p>
<div><pre><code>5-小红
10-王五
20-李四
30-张三
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">ArrayList 源码解读</title>
    <id>https://vue-blog.lllllan.cn/1-java/3-container/2-source-code/1-arraylist/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/3-container/2-source-code/1-arraylist/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/collection/arraylist-source-code/" target="_blank" rel="noopener noreferrer">ArrayList源码&amp;扩容机制分析 | JavaGuide</a>，略有改动</p>
</div>
<h2 id="一、arraylist-简介"> 一、ArrayList 简介</h2>
<p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p>
<p><code>ArrayList</code>继承于 <strong><code>AbstractList</code></strong> ，实现了 <strong><code>List</code></strong>, <strong><code>RandomAccess</code></strong>, <strong><code>Cloneable</code></strong>, <strong><code>java.io.Serializable</code></strong> 这些接口。</p>
<div><pre><code><span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span><span>{</span>

  <span>}</span><span>Copy</span> <span>to</span> <span>clipboardErrorCopied</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br></div></div><ul>
<li><code>RandomAccess</code> 是一个标志接口，表明实现这个这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li>
<li><code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li>
<li><code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li>
</ul>
<h3 id="_1-1-arraylist-和-vector-的区别"> 1.1 ArrayList 和 Vector 的区别</h3>
<p><code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，适用于频繁的查找工作，线程不安全 ；</p>
<p><code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，线程安全的（代价就是效率差一些）。</p>
<h3 id="_1-2-arraylist-和-linkedlist-的区别"> 1.2 ArrayList  和 LinkedList 的区别</h3>
<p><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</p>
<p><strong>底层数据结构：</strong> <code>Arraylist</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构（JDK1.6 之前为循环链表，JDK1.7 取消了循环。注意双向链表和双向循环链表的区别，下面有介绍到！）</p>
<p><strong>插入和删除是否受元素位置的影响：</strong></p>
<ul>
<li><code>ArrayList</code> 采用数组存储，所以插入和删除元素的时间复杂度受元素位置的影响。 比如：执行<code>add(E e)</code>方法的时候， <code>ArrayList</code> 会默认在将指定的元素追加到此列表的末尾，这种情况时间复杂度就是 O(1)。但是如果要在指定位置 i 插入和删除元素的话（<code>add(int index, E element)</code>）时间复杂度就为 O(n-i)。因为在进行上述操作的时候集合中第 i 和第 i 个元素之后的(n-i)个元素都要执行向后位/向前移一位的操作。</li>
<li><code>LinkedList</code> 采用链表存储，所以，如果是在头尾插入或者删除元素不受元素位置的影响（<code>add(E e)</code>、<code>addFirst(E e)</code>、<code>addLast(E e)</code>、<code>removeFirst()</code> 、 <code>removeLast()</code>），近似 O(1)，如果是要在指定位置 <code>i</code> 插入和删除元素的话（<code>add(int index, E element)</code>，<code>remove(Object o)</code>） 时间复杂度近似为 O(n) ，因为需要先移动到指定位置再插入。</li>
</ul>
<p><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。快速随机访问就是通过元素的序号快速获取元素对象(对应于<code>get(int index)</code>方法)。</p>
<p><strong>内存空间占用：</strong> ArrayList 的空 间浪费主要体现在在 list 列表的结尾会预留一定的容量空间，而 LinkedList 的空间花费则体现在它的每一个元素都需要消耗比 ArrayList 更多的空间（因为要存放直接后继和直接前驱以及数据）。</p>
<h2 id="二、arraylist-核心源码"> 二、ArrayList 核心源码</h2>
<div><pre><code><span>package</span> <span>java<span>.</span>util</span><span>;</span>

<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Consumer</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>Predicate</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span>function<span>.</span></span><span>UnaryOperator</span><span>;</span>
<span>import</span> <span>sun<span>.</span>misc<span>.</span></span><span>SharedSecrets</span><span>;</span>

<span>public</span> <span>class</span> <span>ArrayList</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>extends</span> <span>AbstractList</span><span><span>&lt;</span><span>E</span><span>></span></span>
        <span>implements</span> <span>List</span><span><span>&lt;</span><span>E</span><span>></span></span><span>,</span> <span>RandomAccess</span><span>,</span> <span>Cloneable</span><span>,</span> <span><span>java<span>.</span>io<span>.</span></span>Serializable</span> <span>{</span>
    <span>private</span> <span>static</span> <span>final</span> <span>long</span> serialVersionUID <span>=</span> <span>8683452581122892189L</span><span>;</span>

    <span>/**
     * Default initial capacity. 默认/初始 容量大小为10
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>int</span> DEFAULT_CAPACITY <span>=</span> <span>10</span><span>;</span>

    <span>/**
     * 空数组（用于空实例）
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>/**
     * 另一个空数组（用于无参构造）
     */</span>
    <span>private</span> <span>static</span> <span>final</span> <span>Object</span><span>[</span><span>]</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA <span>=</span> <span>{</span><span>}</span><span>;</span>

    <span>/**
     * 真正保存数据的数组
     */</span>
    <span>transient</span> <span>Object</span><span>[</span><span>]</span> elementData<span>;</span> <span>// non-private to simplify nested class access</span>

    <span>/**
     * 数组中的元素个数
     */</span>
    <span>private</span> <span>int</span> size<span>;</span>

    <span>/**
     * 有参构造（指定数组的初始大小）
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>// 如果指定大小 > 0，创建指定大小的数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 如果指定大小 == 0，创建空数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 如果指定大小 &lt; 0，抛出异常</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span> initialCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 默认无参构造函数
     * 存放数据的数组指向了另一个空数组，当添加第一个元素之后，才将数组扩容至 10
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>

    <span>/**
     * 有参构造（指定集合）
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>// 将指定集合转换为数组</span>
        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>(</span>size <span>=</span> a<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 数组长度不为零的情况</span>
            <span>if</span> <span>(</span>c<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> <span>ArrayList</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>// 如果数据类型相同，直接使用该数组</span>
                elementData <span>=</span> a<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// 如果数据类型不相同，则复制一份相同数据类型的数组</span>
                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 数组长度为零，指向空数组</span>
            elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 修改数组容量为当前元素个数，以最小化实例的存储
     */</span>
    <span>public</span> <span>void</span> <span>trimToSize</span><span>(</span><span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>// size为数组中元素个数，len为数组（容量）大小</span>
        <span>if</span> <span>(</span>size <span>&lt;</span> elementData<span>.</span>length<span>)</span> <span>{</span>
            <span>// 如果个数为零，指向空数组</span>
            <span>// 否则复制一个大小为 size 的数组</span>
            elementData <span>=</span> <span>(</span>size <span>==</span> <span>0</span><span>)</span> <span>?</span> EMPTY_ELEMENTDATA <span>:</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 核心扩容机制见后面解释
     */</span>

    <span>/**
     * 获取元素个数
     */</span>
    <span>public</span> <span>int</span> <span>size</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> size<span>;</span>
    <span>}</span>

    <span>/**
     * 判断列表是否为空
     */</span>
    <span>public</span> <span>boolean</span> <span>isEmpty</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> size <span>==</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 判断列表中是否包含目标元素
     */</span>
    <span>public</span> <span>boolean</span> <span>contains</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>return</span> <span>indexOf</span><span>(</span>o<span>)</span> <span>>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1
     */</span>
    <span>public</span> <span>int</span> <span>indexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 如果是 null，需要单独判断</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.
     */</span>
    <span>public</span> <span>int</span> <span>lastIndexOf</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 如果是 null，需要单独判断</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>i<span>]</span><span>==</span><span>null</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> i <span>=</span> size<span>-</span><span>1</span><span>;</span> i <span>>=</span> <span>0</span><span>;</span> i<span>--</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>i<span>]</span><span>)</span><span>)</span>
                    <span>return</span> i<span>;</span>
        <span>}</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回实例的浅拷贝 ！！！浅拷贝
     */</span>
    <span>public</span> <span>Object</span> <span>clone</span><span>(</span><span>)</span> <span>{</span>
        <span>try</span> <span>{</span>
            <span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span> v <span>=</span> <span>(</span><span>ArrayList</span><span><span>&lt;</span><span>?</span><span>></span></span><span>)</span> <span>super</span><span>.</span><span>clone</span><span>(</span><span>)</span><span>;</span>
            v<span>.</span>elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
            v<span>.</span>modCount <span>=</span> <span>0</span><span>;</span>
            <span>return</span> v<span>;</span>
        <span>}</span> <span>catch</span> <span>(</span><span>CloneNotSupportedException</span> e<span>)</span> <span>{</span>
            <span>// this shouldn't happen, since we are Cloneable</span>
            <span>throw</span> <span>new</span> <span>InternalError</span><span>(</span>e<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。
     */</span>
    <span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;
     * 返回数组的类型，需要时运行时类型
     */</span>
    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>public</span> <span><span>&lt;</span><span>T</span><span>></span></span> <span>T</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>T</span><span>[</span><span>]</span> a<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>a<span>.</span>length <span>&lt;</span> size<span>)</span>
            <span>// 新建一个运行时类型的数组，但是内容为该列表的元素</span>
            <span>return</span> <span>(</span><span>T</span><span>[</span><span>]</span><span>)</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>,</span> a<span>.</span><span>getClass</span><span>(</span><span>)</span><span>)</span><span>;</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> <span>0</span><span>,</span> a<span>,</span> <span>0</span><span>,</span> size<span>)</span><span>;</span>
        <span>if</span> <span>(</span>a<span>.</span>length <span>></span> size<span>)</span>
            a<span>[</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>return</span> a<span>;</span>
    <span>}</span>

    <span>// Positional Access Operations</span>

    <span>@SuppressWarnings</span><span>(</span><span>"unchecked"</span><span>)</span>
    <span>E</span> <span>elementData</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>(</span><span>E</span><span>)</span> elementData<span>[</span>index<span>]</span><span>;</span>
    <span>}</span>

    <span>/**
     * 获取索引 index 处的元素
     */</span>
    <span>public</span> <span>E</span> <span>get</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        <span>return</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 修改索引 index 处的元素为 element，并返回原元素
     */</span>
    <span>public</span> <span>E</span> <span>set</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>// 检查 index 是否合法</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>/**
     * 在列表最后面插入一个元素
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>// 如有必要，进行扩容</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * 在索引 index 处插入一个元素
     */</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>// 检查 index 是否合法</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>// 如有必要，进行扩容</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  
        <span>// 整体后移</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        size<span>++</span><span>;</span>
    <span>}</span>

    <span>/**
     * 删除指定索引 index 处的元素，并返回该元素
     */</span>
    <span>public</span> <span>E</span> <span>remove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>// 先检查 index 是否合法</span>
        <span>rangeCheck</span><span>(</span>index<span>)</span><span>;</span>

        modCount<span>++</span><span>;</span>
        <span>E</span> oldValue <span>=</span> <span>elementData</span><span>(</span>index<span>)</span><span>;</span>

        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span> numMoved<span>)</span><span>;</span>
        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>

        <span>return</span> oldValue<span>;</span>
    <span>}</span>

    <span>/**
     * 从列表中删除第一个出现的元素 o
     * 返回是否成功删除（如果列表中不含该元素，则为 false）
     */</span>
    <span>public</span> <span>boolean</span> <span>remove</span><span>(</span><span>Object</span> o<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>o <span>==</span> <span>null</span><span>)</span> <span>{</span>
            <span>// 如果目标元素是 null，则需要特别判断</span>
            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
                <span>if</span> <span>(</span>elementData<span>[</span>index<span>]</span> <span>==</span> <span>null</span><span>)</span> <span>{</span>
                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>for</span> <span>(</span><span>int</span> index <span>=</span> <span>0</span><span>;</span> index <span>&lt;</span> size<span>;</span> index<span>++</span><span>)</span>
                <span>if</span> <span>(</span>o<span>.</span><span>equals</span><span>(</span>elementData<span>[</span>index<span>]</span><span>)</span><span>)</span> <span>{</span>
                    <span>fastRemove</span><span>(</span>index<span>)</span><span>;</span>
                    <span>return</span> <span>true</span><span>;</span>
                <span>}</span>
        <span>}</span>
        <span>return</span> <span>false</span><span>;</span>
    <span>}</span>

    <span>/*
     * （快速）删除指定索引 index 处的元素，无返回值
     */</span>
    <span>private</span> <span>void</span> <span>fastRemove</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>int</span> numMoved <span>=</span> size <span>-</span> index <span>-</span> <span>1</span><span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>+</span><span>1</span><span>,</span> elementData<span>,</span> index<span>,</span> numMoved<span>)</span><span>;</span>
        elementData<span>[</span><span>--</span>size<span>]</span> <span>=</span> <span>null</span><span>;</span> <span>// clear to let GC do its work</span>
    <span>}</span>

    <span>/**
     * 删除列表中所有元素
     */</span>
    <span>public</span> <span>void</span> <span>clear</span><span>(</span><span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>

        <span>// clear to let GC do its work</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span>
            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>

        size <span>=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 将指定集合的所有元素插入到列表最后
     */</span>
    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
        <span>// 如有必要则进行扩容</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> size<span>,</span> numNew<span>)</span><span>;</span>
        size <span>+=</span> numNew<span>;</span>
        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 将指定集合 c 中的所有元素，插入到该列表索引 index 处
     */</span>
    <span>public</span> <span>boolean</span> <span>addAll</span><span>(</span><span>int</span> index<span>,</span> <span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>// 先检查 index 是否合法</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>int</span> numNew <span>=</span> a<span>.</span>length<span>;</span>
        <span>// 如有必要则进行扩容</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> numNew<span>)</span><span>;</span>  <span>// Increments modCount</span>

        <span>int</span> numMoved <span>=</span> size <span>-</span> index<span>;</span>
        <span>if</span> <span>(</span>numMoved <span>></span> <span>0</span><span>)</span>
            <span>// 如有必要，将原 index 索引及后续所有元素整体后移</span>
            <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> numNew<span>,</span> numMoved<span>)</span><span>;</span>

        <span>// 将集合中的所有元素复制进来</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>a<span>,</span> <span>0</span><span>,</span> elementData<span>,</span> index<span>,</span> numNew<span>)</span><span>;</span>
        size <span>+=</span> numNew<span>;</span>
        <span>return</span> numNew <span>!=</span> <span>0</span><span>;</span>
    <span>}</span>

    <span>/**
     * 删除 fromIndex 到 toIndex 之间的所有元素
     */</span>
    <span>protected</span> <span>void</span> <span>removeRange</span><span>(</span><span>int</span> fromIndex<span>,</span> <span>int</span> toIndex<span>)</span> <span>{</span>
        modCount<span>++</span><span>;</span>
        <span>int</span> numMoved <span>=</span> size <span>-</span> toIndex<span>;</span>
        <span>// 将 toIndex 索引开始 numMoved 个元素整体复制（移动）到 fromIndex 索引处</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> toIndex<span>,</span> elementData<span>,</span> fromIndex<span>,</span> numMoved<span>)</span><span>;</span>

        <span>// 计算得到删除后的元素个数，将后面所有元素赋为 null</span>
        <span>int</span> newSize <span>=</span> size <span>-</span> <span>(</span>toIndex<span>-</span>fromIndex<span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> newSize<span>;</span> i <span>&lt;</span> size<span>;</span> i<span>++</span><span>)</span> <span>{</span>
            elementData<span>[</span>i<span>]</span> <span>=</span> <span>null</span><span>;</span>
        <span>}</span>
        size <span>=</span> newSize<span>;</span>
    <span>}</span>

    <span>/**
     * 检查给定索引是否在范围内
     * 对比的是（元素个数）size，而不是 （容量大小）length
     */</span>
    <span>private</span> <span>void</span> <span>rangeCheck</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>>=</span> size<span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * add 和 addAll 前检查 index 的范围是否有异常
     * 对比的是（元素个数）size，而不是 （容量大小）length
     */</span>
    <span>private</span> <span>void</span> <span>rangeCheckForAdd</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>></span> size <span>||</span> index <span>&lt;</span> <span>0</span><span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>outOfBoundsMsg</span><span>(</span>index<span>)</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回 outOfBoundsMsg 的具体信息
     */</span>
    <span>private</span> <span>String</span> <span>outOfBoundsMsg</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>return</span> <span>"Index: "</span><span>+</span>index<span>+</span><span>", Size: "</span><span>+</span>size<span>;</span>
    <span>}</span>

    <span>/**
     * 从此列表中删除（指定集合 c 中出现过的所有）元素
     */</span>
    <span>public</span> <span>boolean</span> <span>removeAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>false</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 仅保留此列表中（在指定集合 c 中出现过的）元素
     */</span>
    <span>public</span> <span>boolean</span> <span>retainAll</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>Objects</span><span>.</span><span>requireNonNull</span><span>(</span>c<span>)</span><span>;</span>
        <span>return</span> <span>batchRemove</span><span>(</span>c<span>,</span> <span>true</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 返回第 index 个元素的迭代器
     */</span>
    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>int</span> index<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>index <span>&lt;</span> <span>0</span> <span>||</span> index <span>></span> size<span>)</span>
            <span>throw</span> <span>new</span> <span>IndexOutOfBoundsException</span><span>(</span><span>"Index: "</span><span>+</span>index<span>)</span><span>;</span>
        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span>index<span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 获取第一个元素的迭代器
     */</span>
    <span>public</span> <span>ListIterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>listIterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>ListItr</span><span>(</span><span>0</span><span>)</span><span>;</span>
    <span>}</span>

    <span>/**
     * 以正确的顺序返回该列表中的元素的迭代器
     */</span>
    <span>public</span> <span>Iterator</span><span><span>&lt;</span><span>E</span><span>></span></span> <span>iterator</span><span>(</span><span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>Itr</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>

<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br><span>56</span><br><span>57</span><br><span>58</span><br><span>59</span><br><span>60</span><br><span>61</span><br><span>62</span><br><span>63</span><br><span>64</span><br><span>65</span><br><span>66</span><br><span>67</span><br><span>68</span><br><span>69</span><br><span>70</span><br><span>71</span><br><span>72</span><br><span>73</span><br><span>74</span><br><span>75</span><br><span>76</span><br><span>77</span><br><span>78</span><br><span>79</span><br><span>80</span><br><span>81</span><br><span>82</span><br><span>83</span><br><span>84</span><br><span>85</span><br><span>86</span><br><span>87</span><br><span>88</span><br><span>89</span><br><span>90</span><br><span>91</span><br><span>92</span><br><span>93</span><br><span>94</span><br><span>95</span><br><span>96</span><br><span>97</span><br><span>98</span><br><span>99</span><br><span>100</span><br><span>101</span><br><span>102</span><br><span>103</span><br><span>104</span><br><span>105</span><br><span>106</span><br><span>107</span><br><span>108</span><br><span>109</span><br><span>110</span><br><span>111</span><br><span>112</span><br><span>113</span><br><span>114</span><br><span>115</span><br><span>116</span><br><span>117</span><br><span>118</span><br><span>119</span><br><span>120</span><br><span>121</span><br><span>122</span><br><span>123</span><br><span>124</span><br><span>125</span><br><span>126</span><br><span>127</span><br><span>128</span><br><span>129</span><br><span>130</span><br><span>131</span><br><span>132</span><br><span>133</span><br><span>134</span><br><span>135</span><br><span>136</span><br><span>137</span><br><span>138</span><br><span>139</span><br><span>140</span><br><span>141</span><br><span>142</span><br><span>143</span><br><span>144</span><br><span>145</span><br><span>146</span><br><span>147</span><br><span>148</span><br><span>149</span><br><span>150</span><br><span>151</span><br><span>152</span><br><span>153</span><br><span>154</span><br><span>155</span><br><span>156</span><br><span>157</span><br><span>158</span><br><span>159</span><br><span>160</span><br><span>161</span><br><span>162</span><br><span>163</span><br><span>164</span><br><span>165</span><br><span>166</span><br><span>167</span><br><span>168</span><br><span>169</span><br><span>170</span><br><span>171</span><br><span>172</span><br><span>173</span><br><span>174</span><br><span>175</span><br><span>176</span><br><span>177</span><br><span>178</span><br><span>179</span><br><span>180</span><br><span>181</span><br><span>182</span><br><span>183</span><br><span>184</span><br><span>185</span><br><span>186</span><br><span>187</span><br><span>188</span><br><span>189</span><br><span>190</span><br><span>191</span><br><span>192</span><br><span>193</span><br><span>194</span><br><span>195</span><br><span>196</span><br><span>197</span><br><span>198</span><br><span>199</span><br><span>200</span><br><span>201</span><br><span>202</span><br><span>203</span><br><span>204</span><br><span>205</span><br><span>206</span><br><span>207</span><br><span>208</span><br><span>209</span><br><span>210</span><br><span>211</span><br><span>212</span><br><span>213</span><br><span>214</span><br><span>215</span><br><span>216</span><br><span>217</span><br><span>218</span><br><span>219</span><br><span>220</span><br><span>221</span><br><span>222</span><br><span>223</span><br><span>224</span><br><span>225</span><br><span>226</span><br><span>227</span><br><span>228</span><br><span>229</span><br><span>230</span><br><span>231</span><br><span>232</span><br><span>233</span><br><span>234</span><br><span>235</span><br><span>236</span><br><span>237</span><br><span>238</span><br><span>239</span><br><span>240</span><br><span>241</span><br><span>242</span><br><span>243</span><br><span>244</span><br><span>245</span><br><span>246</span><br><span>247</span><br><span>248</span><br><span>249</span><br><span>250</span><br><span>251</span><br><span>252</span><br><span>253</span><br><span>254</span><br><span>255</span><br><span>256</span><br><span>257</span><br><span>258</span><br><span>259</span><br><span>260</span><br><span>261</span><br><span>262</span><br><span>263</span><br><span>264</span><br><span>265</span><br><span>266</span><br><span>267</span><br><span>268</span><br><span>269</span><br><span>270</span><br><span>271</span><br><span>272</span><br><span>273</span><br><span>274</span><br><span>275</span><br><span>276</span><br><span>277</span><br><span>278</span><br><span>279</span><br><span>280</span><br><span>281</span><br><span>282</span><br><span>283</span><br><span>284</span><br><span>285</span><br><span>286</span><br><span>287</span><br><span>288</span><br><span>289</span><br><span>290</span><br><span>291</span><br><span>292</span><br><span>293</span><br><span>294</span><br><span>295</span><br><span>296</span><br><span>297</span><br><span>298</span><br><span>299</span><br><span>300</span><br><span>301</span><br><span>302</span><br><span>303</span><br><span>304</span><br><span>305</span><br><span>306</span><br><span>307</span><br><span>308</span><br><span>309</span><br><span>310</span><br><span>311</span><br><span>312</span><br><span>313</span><br><span>314</span><br><span>315</span><br><span>316</span><br><span>317</span><br><span>318</span><br><span>319</span><br><span>320</span><br><span>321</span><br><span>322</span><br><span>323</span><br><span>324</span><br><span>325</span><br><span>326</span><br><span>327</span><br><span>328</span><br><span>329</span><br><span>330</span><br><span>331</span><br><span>332</span><br><span>333</span><br><span>334</span><br><span>335</span><br><span>336</span><br><span>337</span><br><span>338</span><br><span>339</span><br><span>340</span><br><span>341</span><br><span>342</span><br><span>343</span><br><span>344</span><br><span>345</span><br><span>346</span><br><span>347</span><br><span>348</span><br><span>349</span><br><span>350</span><br><span>351</span><br><span>352</span><br><span>353</span><br><span>354</span><br><span>355</span><br><span>356</span><br><span>357</span><br><span>358</span><br><span>359</span><br><span>360</span><br><span>361</span><br><span>362</span><br><span>363</span><br><span>364</span><br><span>365</span><br><span>366</span><br><span>367</span><br><span>368</span><br><span>369</span><br><span>370</span><br><span>371</span><br><span>372</span><br><span>373</span><br><span>374</span><br><span>375</span><br><span>376</span><br><span>377</span><br><span>378</span><br><span>379</span><br><span>380</span><br><span>381</span><br><span>382</span><br><span>383</span><br><span>384</span><br><span>385</span><br><span>386</span><br><span>387</span><br><span>388</span><br><span>389</span><br><span>390</span><br><span>391</span><br><span>392</span><br><span>393</span><br><span>394</span><br><span>395</span><br><span>396</span><br><span>397</span><br><span>398</span><br><span>399</span><br><span>400</span><br><span>401</span><br><span>402</span><br><span>403</span><br><span>404</span><br><span>405</span><br><span>406</span><br><span>407</span><br><span>408</span><br><span>409</span><br><span>410</span><br><span>411</span><br><span>412</span><br><span>413</span><br><span>414</span><br><span>415</span><br><span>416</span><br><span>417</span><br><span>418</span><br><span>419</span><br><span>420</span><br><span>421</span><br><span>422</span><br><span>423</span><br><span>424</span><br><span>425</span><br></div></div><h2 id="三、arraylist-扩容机制"> 三、ArrayList 扩容机制</h2>
<h3 id="_3-1-arraylist-的构造方法"> 3.1 ArrayList 的构造方法</h3>
<p><strong>以无参数构造方法创建 <code>ArrayList</code> 时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p>
<div><pre><code> 	<span>public</span> <span>ArrayList</span><span>(</span><span>int</span> initialCapacity<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>initialCapacity <span>></span> <span>0</span><span>)</span> <span>{</span>
            <span>// 如果指定大小 > 0，创建指定大小的数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> <span>new</span> <span>Object</span><span>[</span>initialCapacity<span>]</span><span>;</span>
        <span>}</span> <span>else</span> <span>if</span> <span>(</span>initialCapacity <span>==</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 如果指定大小 == 0，创建空数组</span>
            <span>this</span><span>.</span>elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 如果指定大小 &lt; 0，抛出异常</span>
            <span>throw</span> <span>new</span> <span>IllegalArgumentException</span><span>(</span><span>"Illegal Capacity: "</span><span>+</span> initialCapacity<span>)</span><span>;</span>
        <span>}</span>
    <span>}</span>

    <span>/**
     * 默认无参构造函数
     * 存放数据的数组指向了另一个空数组，当添加第一个元素之后，才将数组扩容至 10
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>)</span> <span>{</span>
        <span>this</span><span>.</span>elementData <span>=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>;</span>
    <span>}</span>

    <span>/**
     * 有参构造（指定集合）
     */</span>
    <span>public</span> <span>ArrayList</span><span>(</span><span>Collection</span><span><span>&lt;</span><span>?</span> <span>extends</span> <span>E</span><span>></span></span> c<span>)</span> <span>{</span>
        <span>// 将指定集合转换为数组</span>
        <span>Object</span><span>[</span><span>]</span> a <span>=</span> c<span>.</span><span>toArray</span><span>(</span><span>)</span><span>;</span>
        <span>if</span> <span>(</span><span>(</span>size <span>=</span> a<span>.</span>length<span>)</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
            <span>// 数组长度不为零的情况</span>
            <span>if</span> <span>(</span>c<span>.</span><span>getClass</span><span>(</span><span>)</span> <span>==</span> <span>ArrayList</span><span>.</span><span>class</span><span>)</span> <span>{</span>
                <span>// 如果数据类型相同，直接使用该数组</span>
                elementData <span>=</span> a<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>// 如果数据类型不相同，则复制一份相同数据类型的数组</span>
                elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>a<span>,</span> size<span>,</span> <span>Object</span><span>[</span><span>]</span><span>.</span><span>class</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span> <span>else</span> <span>{</span>
            <span>// 数组长度为零，指向空数组</span>
            elementData <span>=</span> EMPTY_ELEMENTDATA<span>;</span>
        <span>}</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br></div></div><h3 id="_3-2-add-方法"> 3.2 <code>add</code> 方法</h3>
<p>每次添加元素之前，都会调用一次 <code>ensureCapacityInternal()</code>，如有需要，则会进行扩容。然后才会执行添加元素的操作。</p>
<div><pre><code> 	<span>/**
     * 在列表最后面插入一个元素
     */</span>
    <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>E</span> e<span>)</span> <span>{</span>
        <span>// 如有必要，进行扩容</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
        elementData<span>[</span>size<span>++</span><span>]</span> <span>=</span> e<span>;</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>

    <span>/**
     * 在索引 index 处插入一个元素
     */</span>
    <span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
        <span>// 检查 index 是否合法</span>
        <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

        <span>// 如有必要，进行扩容</span>
        <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  
        <span>// 整体后移</span>
        <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>
        elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
        size<span>++</span><span>;</span>
    <span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="_3-3-ensurecapacityinternal-方法"> 3.3 <code>ensureCapacityInternal()</code> 方法</h3>
<ol>
<li>先调用 <code>calculateCapacity</code>，计算一个得到一个合适的容量</li>
<li>再调用 <code>ensureExplicitCapacity</code> ，正式判断是否需要扩容</li>
</ol>
<div><pre><code><span>private</span> <span>void</span> <span>ensureCapacityInternal</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>ensureExplicitCapacity</span><span>(</span><span>calculateCapacity</span><span>(</span>elementData<span>,</span> minCapacity<span>)</span><span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><h3 id="_3-4-calculatecapacity-方法"> 3.4 <code>calculateCapacity()</code> 方法</h3>
<p>判断是否需要扩容之前，需要计算一个 <strong>理论容量</strong>（我自己取的名字）：</p>
<ul>
<li>如果原数组是一个空数组，ArrayList 提供了一个初始的默认大小为10，与传入的参数比较取较大值</li>
<li>如果原数组是一个非空数组，那就直接返回这个传入的参数即可</li>
</ul>
<blockquote>
<p>个人认为，让空数组第一次扩容至少获得 10 大小的容量。是为了防止 <code>1、2、3、4</code> 这类低效的扩容存在</p>
</blockquote>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>calculateCapacity</span><span>(</span><span>Object</span><span>[</span><span>]</span> elementData<span>,</span> <span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>// 如果是空数组，取 minCapacity 与 10 之间的较大值</span>
    <span>if</span> <span>(</span>elementData <span>==</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span> <span>{</span>
        <span>return</span> <span>Math</span><span>.</span><span>max</span><span>(</span>DEFAULT_CAPACITY<span>,</span> minCapacity<span>)</span><span>;</span>
    <span>}</span>
    <span>return</span> minCapacity<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_3-5-ensureexplicitcapacity-方法"> 3.5 <code>ensureExplicitCapacity()</code> 方法</h3>
<p>判断需要扩容之后，调用 <code>grow()</code> 方法</p>
<div><pre><code><span>private</span> <span>void</span> <span>ensureExplicitCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    modCount<span>++</span><span>;</span>

    <span>// 如果“理论容量”超过了当前容量，则进行扩容</span>
    <span>if</span> <span>(</span>minCapacity <span>-</span> elementData<span>.</span>length <span>></span> <span>0</span><span>)</span>
        <span>grow</span><span>(</span>minCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_3-6-grow-方法"> 3.6 <code>grow()</code> 方法</h3>
<p>单次扩容理论上是扩容1.5倍（防止每次增加1个大小这类低效的扩容），如果小于传入的指定大小，则会扩容更大。</p>
<div><pre><code><span>private</span> <span>void</span> <span>grow</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>// overflow-conscious code</span>
    <span>int</span> oldCapacity <span>=</span> elementData<span>.</span>length<span>;</span>
    <span>// 原容量 * 1.5 得到一个扩容的 容量</span>
    <span>int</span> newCapacity <span>=</span> oldCapacity <span>+</span> <span>(</span>oldCapacity <span>>></span> <span>1</span><span>)</span><span>;</span>
    <span>// 如果传入的参数更大，则将扩容容量修改为该参数</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> minCapacity <span>&lt;</span> <span>0</span><span>)</span>
        newCapacity <span>=</span> minCapacity<span>;</span>
    <span>// 如果扩容容量甚至比 MAX_ARRAY_SIZE 还大，则调用 hugeCapacity 获得一个指定大小进行扩容</span>
    <span>if</span> <span>(</span>newCapacity <span>-</span> MAX_ARRAY_SIZE <span>></span> <span>0</span><span>)</span>
        newCapacity <span>=</span> <span>hugeCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>// minCapacity is usually close to size, so this is a win:</span>
    elementData <span>=</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> newCapacity<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_3-7-hugecapacity-方法"> 3.7 <code>hugeCapacity()</code> 方法</h3>
<p>如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code></p>
<div><pre><code><span>private</span> <span>static</span> <span>int</span> <span>hugeCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>minCapacity <span>&lt;</span> <span>0</span><span>)</span> <span>// overflow</span>
        <span>throw</span> <span>new</span> <span>OutOfMemoryError</span><span>(</span><span>)</span><span>;</span>
    <span>//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>
    <span>return</span> <span>(</span>minCapacity <span>></span> MAX_ARRAY_SIZE<span>)</span> <span>?</span> <span>Integer</span><span>.</span>MAX_VALUE <span>:</span> MAX_ARRAY_SIZE<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_3-9-具体的扩容模拟"> 3.9 具体的扩容模拟</h3>
<p>具体的模拟详见 <a href="https://javaguide.cn/java/collection/arraylist-source-code/#_3-2-4-grow-%E6%96%B9%E6%B3%95" target="_blank" rel="noopener noreferrer">ArrayList源码&amp;扩容机制分析 | JavaGuide</a></p>
<h2 id="四、数组复制"> 四、数组复制</h2>
<h3 id="_4-1-system-arraycopy-方法"> 4.1 <code>System.arraycopy()</code> 方法</h3>
<p>源码：</p>
<div><pre><code>    <span>// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span>
    <span>/**
    *   复制数组
    * @param src 源数组
    * @param srcPos 源数组中的起始位置
    * @param dest 目标数组
    * @param destPos 目标数组中的起始位置
    * @param length 要复制的数组元素的数量
    */</span>
    <span>public</span> <span>static</span> <span>native</span> <span>void</span> <span>arraycopy</span><span>(</span><span>Object</span> src<span>,</span>  <span>int</span>  srcPos<span>,</span>
                                        <span>Object</span> dest<span>,</span> <span>int</span> destPos<span>,</span>
                                        <span>int</span> length<span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><p>场景：</p>
<div><pre><code><span>/**
 * 在此列表中的指定位置插入指定的元素。
 *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；
 *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。
 */</span>
<span>public</span> <span>void</span> <span>add</span><span>(</span><span>int</span> index<span>,</span> <span>E</span> element<span>)</span> <span>{</span>
    <span>rangeCheckForAdd</span><span>(</span>index<span>)</span><span>;</span>

    <span>ensureCapacityInternal</span><span>(</span>size <span>+</span> <span>1</span><span>)</span><span>;</span>  <span>// Increments modCount!!</span>
    <span>//arraycopy()方法实现数组自己复制自己</span>
    <span>//elementData:源数组;index:源数组中的起始位置;elementData：目标数组；index + 1：目标数组中的起始位置； size - index：要复制的数组元素的数量；</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>elementData<span>,</span> index<span>,</span> elementData<span>,</span> index <span>+</span> <span>1</span><span>,</span> size <span>-</span> index<span>)</span><span>;</span>
    elementData<span>[</span>index<span>]</span> <span>=</span> element<span>;</span>
    size<span>++</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_4-2-arrays-copyof-方法"> 4.2 <code>Arrays.copyOf()</code>方法</h3>
<p>源码：</p>
<div><pre><code><span>public</span> <span>static</span> <span>int</span><span>[</span><span>]</span> <span>copyOf</span><span>(</span><span>int</span><span>[</span><span>]</span> original<span>,</span> <span>int</span> newLength<span>)</span> <span>{</span>
    <span>// 申请一个新的数组</span>
    <span>int</span><span>[</span><span>]</span> copy <span>=</span> <span>new</span> <span>int</span><span>[</span>newLength<span>]</span><span>;</span>
    <span>// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>
    <span>System</span><span>.</span><span>arraycopy</span><span>(</span>original<span>,</span> <span>0</span><span>,</span> copy<span>,</span> <span>0</span><span>,</span> <span>Math</span><span>.</span><span>min</span><span>(</span>original<span>.</span>length<span>,</span> newLength<span>)</span><span>)</span><span>;</span>
    <span>return</span> copy<span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p>场景：</p>
<div><pre><code><span>/**
以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）; 返回的数组的运行时类型是指定数组的运行时类型。
*/</span>
<span>public</span> <span>Object</span><span>[</span><span>]</span> <span>toArray</span><span>(</span><span>)</span> <span>{</span>
    <span>//elementData：要复制的数组；size：要复制的长度</span>
    <span>return</span> <span>Arrays</span><span>.</span><span>copyOf</span><span>(</span>elementData<span>,</span> size<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><h3 id="_4-3-联系和区别"> 4.3 联系和区别</h3>
<p><strong>联系：</strong></p>
<p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p>
<p><strong>区别：</strong></p>
<p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组</p>
<h2 id="五、ensurecapacity方法"> 五、<code>ensureCapacity</code>方法</h2>
<p>ArrayList 源码中有一个 <code>ensureCapacity</code> 方法， ArrayList 内部没有被调用过，所以很显然是提供给用户调用的，那么这个方法有什么作用呢？</p>
<p><strong>最好在 add 大量元素之前用 <code>ensureCapacity</code> 方法，以减少增量重新分配的次数</strong></p>
<div><pre><code><span>/**
如有必要，增加此 ArrayList 实例的容量，以确保它至少可以容纳由minimum capacity参数指定的元素数。
*
* @param   minCapacity   所需的最小容量
*/</span>
<span>public</span> <span>void</span> <span>ensureCapacity</span><span>(</span><span>int</span> minCapacity<span>)</span> <span>{</span>
    <span>int</span> minExpand <span>=</span> <span>(</span>elementData <span>!=</span> DEFAULTCAPACITY_EMPTY_ELEMENTDATA<span>)</span>
        <span>// any size if not default element table</span>
        <span>?</span> <span>0</span>
        <span>// larger than default for default empty table. It's already</span>
        <span>// supposed to be at default size.</span>
        <span>:</span> DEFAULT_CAPACITY<span>;</span>

    <span>if</span> <span>(</span>minCapacity <span>></span> minExpand<span>)</span> <span>{</span>
        <span>ensureExplicitCapacity</span><span>(</span>minCapacity<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><p>我们通过下面的代码实际测试以下这个方法的效果：</p>
<div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>
	<span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
		<span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
		<span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>
		<span>long</span> startTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
		<span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
			list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
		<span>}</span>
		<span>long</span> endTime <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
		<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用ensureCapacity方法前："</span><span>+</span><span>(</span>endTime <span>-</span> startTime<span>)</span><span>)</span><span>;</span>

	<span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><p>运行结果：</p>
<div><pre><code>使用ensureCapacity方法前：2158
</code></pre>
<div><span>1</span><br></div></div><div><pre><code><span>public</span> <span>class</span> <span>EnsureCapacityTest</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span> list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>final</span> <span>int</span> <span>N</span> <span>=</span> <span>10000000</span><span>;</span>
        list <span>=</span> <span>new</span> <span>ArrayList</span><span><span>&lt;</span><span>Object</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>long</span> startTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        list<span>.</span><span>ensureCapacity</span><span>(</span><span>N</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> <span>N</span><span>;</span> i<span>++</span><span>)</span> <span>{</span>
            list<span>.</span><span>add</span><span>(</span>i<span>)</span><span>;</span>
        <span>}</span>
        <span>long</span> endTime1 <span>=</span> <span>System</span><span>.</span><span>currentTimeMillis</span><span>(</span><span>)</span><span>;</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"使用ensureCapacity方法后："</span><span>+</span><span>(</span>endTime1 <span>-</span> startTime1<span>)</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><p>运行结果：</p>
<div><pre><code>使用ensureCapacity方法后：1773
</code></pre>
<div><span>1</span><br></div></div><p>通过运行结果，我们可以看出向 ArrayList 添加大量元素之前最好先使用<code>ensureCapacity</code> 方法，以减少增量重新分配的次数。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-22T11:37:26.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">java 内存区域详解</title>
    <id>https://vue-blog.lllllan.cn/1-java/2-jvm/1-memory-area-details/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/2-jvm/1-memory-area-details/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/java/jvm/memory-area/" target="_blank" rel="noopener noreferrer">Java 内存区域详解 | JavaGuide Java 内存区域详解</a></p>
<p>这部分内容未免有些太过抽象，这次作为 <strong>泛读</strong>，大概看一眼有一个印象，<s>（因为实在是看不懂）</s></p>
</div>
<h1 id="一-概述"> 一 概述</h1>
<p>对于 Java 程序员来说，在虚拟机自动内存管理机制下，不再需要像 C/C++程序开发程序员这样为每一个 new 操作去写对应的 delete/free 操作，不容易出现内存泄漏和内存溢出问题。正是因为 Java 程序员把内存控制权利交给 Java 虚拟机，一旦出现内存泄漏和溢出方面的问题，如果不了解虚拟机是怎样使用内存的，那么排查错误将会是一个非常艰巨的任务</p>
<h1 id="二-运行时数据区域"> 二 运行时数据区域</h1>
<p><strong>JDK 1.8 之前：</strong></p>
<p><img src="./README.assets/JVM运行时数据区域.150c33e1.png" alt="img" /></p>
<p><strong>JDK 1.8 ：</strong></p>
<p><img src="./README.assets/Java运行时数据区域JDK1.8.37016205.png" alt="img" /></p>
<p><strong>线程私有的：</strong></p>
<ul>
<li>程序计数器</li>
<li>虚拟机栈</li>
<li>本地方法栈</li>
</ul>
<p><strong>线程共享的：</strong></p>
<ul>
<li>堆</li>
<li>方法区</li>
<li>直接内存 (非运行时数据区的一部分)</li>
</ul>
<h2 id="_2-1-程序计数器"> 2.1 程序计数器</h2>
<p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。<strong>字节码解释器工作时通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等功能都需要依赖这个计数器来完成。</strong></p>
<p>另外，<strong>为了线程切换后能恢复到正确的执行位置，每条线程都需要有一个独立的程序计数器，各线程之间计数器互不影响，独立存储，我们称这类内存区域为“线程私有”的内存。</strong></p>
<p><strong>从上面的介绍中我们知道程序计数器主要有两个作用：</strong></p>
<ol>
<li>字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li>
<li>在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li>
</ol>
<p><strong>注意：程序计数器是唯一一个不会出现 <code>OutOfMemoryError</code> 的内存区域，它的生命周期随着线程的创建而创建，随着线程的结束而死亡</strong></p>
<h2 id="_2-2-java-虚拟机栈"> 2.2 Java 虚拟机栈</h2>
<p><strong>与程序计数器一样，<u>Java 虚拟机栈也是线程私有的</u>，它的生命周期和线程相同，描述的是 Java 方法执行的内存模型，每次方法调用的数据都是通过栈传递的。</strong></p>
<p><strong>Java 内存可以粗糙的区分为堆内存（Heap）和栈内存 (Stack)，其中栈就是现在说的虚拟机栈，或者说是虚拟机栈中局部变量表部分。</strong> （实际上，Java 虚拟机栈是由一个个栈帧组成，而每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出口信息。）</p>
<p><strong>局部变量表主要存放了编译期可知的各种数据类型</strong>（boolean、byte、char、short、int、float、long、double）、<strong>对象引用</strong>（reference 类型，它不同于对象本身，可能是一个指向对象起始地址的引用指针，也可能是指向一个代表对象的句柄或其他与此对象相关的位置）。</p>
<p><strong>Java 虚拟机栈会出现两种错误：<code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code>。</strong></p>
<ul>
<li><strong><code>StackOverFlowError</code>：</strong> 若 Java 虚拟机栈的内存大小不允许动态扩展，那么当线程请求栈的深度超过当前 Java 虚拟机栈的最大深度的时候，就抛出 StackOverFlowError 错误。</li>
<li><strong><code>OutOfMemoryError</code>：</strong> Java 虚拟机栈的内存大小可以动态扩展， 如果虚拟机在动态扩展栈时无法申请到足够的内存空间，则抛出<code>OutOfMemoryError</code>异常。</li>
</ul>
<p><img src="./README.assets/《深入理解虚拟机》第三版的第2章-虚拟机栈.5cc9c70c.png" alt="img" /></p>
<p>Java 虚拟机栈也是线程私有的，每个线程都有各自的 Java 虚拟机栈，而且随着线程的创建而创建，随着线程的死亡而死亡。</p>
<p><strong>扩展：那么方法/函数如何调用？</strong></p>
<p>Java 栈可以类比数据结构中栈，Java 栈中保存的主要内容是栈帧，每一次函数调用都会有一个对应的栈帧被压入 Java 栈，每一个函数调用结束后，都会有一个栈帧被弹出。</p>
<p>Java 方法有两种返回方式：</p>
<ol>
<li>return 语句。</li>
<li>抛出异常。</li>
</ol>
<p>不管哪种返回方式都会导致栈帧被弹出。</p>
<h2 id="_2-3-本地方法栈"> 2.3 本地方法栈</h2>
<p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> 在 HotSpot 虚拟机中和 Java 虚拟机栈合二为一。</p>
<p>本地方法被执行的时候，在本地方法栈也会创建一个栈帧，用于存放该本地方法的局部变量表、操作数栈、动态链接、出口信息。</p>
<p>方法执行完毕后相应的栈帧也会出栈并释放内存空间，也会出现 <code>StackOverFlowError</code> 和 <code>OutOfMemoryError</code> 两种错误</p>
<h2 id="_2-4-堆"> 2.4 堆</h2>
<p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p>
<p>Java 世界中“几乎”所有的对象都在堆中分配，但是，随着 JIT 编译器的发展与逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化，所有的对象都分配到堆上也渐渐变得不那么“绝对”了。从 JDK 1.7 开始已经默认开启逃逸分析，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p>
<p>Java 堆是垃圾收集器管理的主要区域，因此也被称作<strong>GC 堆（Garbage Collected Heap）</strong>。从垃圾回收的角度，由于现在收集器基本都采用分代垃圾收集算法，所以 Java 堆还可以细分为：新生代和老年代；再细致一点有：Eden 空间、From Survivor、To Survivor 空间等。<strong>进一步划分的目的是更好地回收内存，或者更快地分配内存。</strong></p>
<p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p>
<ol>
<li>新生代内存(Young Generation)</li>
<li>老生代(Old Generation)</li>
<li>永生代(Permanent Generation)</li>
</ol>
<p><img src="./README.assets/JVM堆内存结构-JDK7.7d9166eb.png" alt="JVM堆内存结构-JDK7" /></p>
<p>JDK 8 版本之后方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p><img src="./README.assets/JVM堆内存结构-jdk8.919b9959.png" alt="JVM堆内存结构-JDK8" /></p>
<p><strong>上图所示的 Eden 区、两个 Survivor 区都属于新生代（为了区分，这两个 Survivor 区域按照顺序被命名为 from 和 to），中间一层属于老年代。</strong></p>
<p>大部分情况，对象都会首先在 Eden 区域分配，在一次新生代垃圾回收后，如果对象还存活，则会进入 s0 或者 s1，并且对象的年龄还会加 1(Eden 区-&gt;Survivor 区后对象的初始年龄变为 1)，当它的年龄增加到一定程度（默认为 15 岁），就会被晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数 <code>-XX:MaxTenuringThreshold</code> 来设置。</p>
<p>堆这里最容易出现的就是 OutOfMemoryError 错误，并且出现这种错误之后的表现形式还会有几种，比如：</p>
<ol>
<li><strong><code>java.lang.OutOfMemoryError: GC Overhead Limit Exceeded</code></strong> ： 当 JVM 花太多时间执行垃圾回收并且只能回收很少的堆空间时，就会发生此错误。</li>
<li><strong><code>java.lang.OutOfMemoryError: Java heap space</code></strong> :假如在创建新的对象时, 堆内存中的空间不足以存放新创建的对象, 就会引发此错误。(和配置的最大堆内存有关，且受制于物理内存大小。最大堆内存可通过<code>-Xmx</code>参数配置，若没有特别配置，将会使用默认值，详见：<a href="https://stackoverflow.com/questions/28272923/default-xmxsize-in-java-8-max-heap-size" target="_blank" rel="noopener noreferrer">Default Java 8 max heap size  (opens new window)</a>)</li>
<li>......</li>
</ol>
<h2 id="_2-5-方法区"> 2.5 方法区</h2>
<p>方法区与 Java 堆一样，是各个线程共享的内存区域，它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。虽然 <strong>Java 虚拟机规范把方法区描述为堆的一个逻辑部分</strong>，但是它却有一个别名叫做 <strong>Non-Heap（非堆）</strong>，目的应该是与 Java 堆区分开来。</p>
<p>方法区也被称为永久代。很多人都会分不清方法区和永久代的关系，为此我也查阅了文献。</p>
<h3 id="_2-5-1-方法区和永久代的关系"> 2.5.1 方法区和永久代的关系</h3>
<p>《Java 虚拟机规范》只是规定了有方法区这么个概念和它的作用，并没有规定如何去实现它。那么，在不同的 JVM 上方法区的实现肯定是不同的了。 <strong>方法区和永久代的关系很像 Java 中接口和类的关系，类实现了接口，而永久代就是 HotSpot 虚拟机对虚拟机规范中方法区的一种实现方式。</strong> 也就是说，永久代是 HotSpot 的概念，方法区是 Java 虚拟机规范中的定义，是一种规范，而永久代是一种实现，一个是标准一个是实现，其他的虚拟机实现并没有永久代这一说法。</p>
<h3 id="_2-5-2-常用参数"> 2.5.2 常用参数</h3>
<p>JDK 1.8 之前永久代还没被彻底移除的时候通常通过下面这些参数来调节方法区大小</p>
<div><pre><code><span>-</span>XX<span>:</span><span>PermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 初始大小</span>
<span>-</span>XX<span>:</span><span>MaxPermSize</span><span>=</span><span>N</span> <span>//方法区 (永久代) 最大大小,超过这个值将会抛出 OutOfMemoryError 异常:java.lang.OutOfMemoryError: PermGen</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>相对而言，垃圾收集行为在这个区域是比较少出现的，但并非数据进入方法区后就“永久存在”了。</p>
<p>JDK 1.8 的时候，方法区（HotSpot 的永久代）被彻底移除了（JDK1.7 就已经开始了），取而代之是元空间，元空间使用的是直接内存。</p>
<p>下面是一些常用参数：</p>
<div><pre><code><span>-</span>XX<span>:</span><span>MetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的初始（和最小大小）</span>
<span>-</span>XX<span>:</span><span>MaxMetaspaceSize</span><span>=</span><span>N</span> <span>//设置 Metaspace 的最大大小</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><p>与永久代很大的不同就是，如果不指定大小的话，随着更多类的创建，虚拟机会耗尽所有可用的系统内存。</p>
<h3 id="_2-5-3-为什么要将永久代-permgen-替换为元空间-metaspace-呢"> 2.5.3 为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</h3>
<p><img src="./README.assets/20210425134508117.png" alt="img" /></p>
<ol>
<li>
<p>整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整，而元空间使用的是直接内存，受本机可用内存的限制，虽然元空间仍旧可能溢出，但是比原来出现的几率会更小。</p>
<blockquote>
<p>当元空间溢出时会得到如下错误： <code>java.lang.OutOfMemoryError: MetaSpace</code></p>
</blockquote>
<p>你可以使用 <code>-XX：MaxMetaspaceSize</code> 标志设置最大元空间大小，默认值为 unlimited，这意味着它只受系统内存的限制。<code>-XX：MetaspaceSize</code> 调整标志定义元空间的初始大小如果未指定此标志，则 Metaspace 将根据运行时的应用程序需求动态地重新调整大小。</p>
</li>
<li>
<p>元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p>
</li>
<li>
<p>在 JDK8，合并 HotSpot 和 JRockit 的代码时, JRockit 从来没有一个叫永久代的东西, 合并之后就没有必要额外的设置这么一个永久代的地方了。</p>
</li>
</ol>
<h2 id="_2-6-运行时常量池"> 2.6 运行时常量池</h2>
<p>运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池表（用于存放编译期生成的各种字面量和符号引用）</p>
<p>既然运行时常量池是方法区的一部分，自然受到方法区内存的限制，当常量池无法再申请到内存时会抛出 OutOfMemoryError 错误。</p>
<blockquote>
<ol>
<li>
<p><strong>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区, 此时 hotspot 虚拟机对方法区的实现为永久代</strong></p>
</li>
<li>
<p><strong>JDK1.7 字符串常量池被从方法区拿到了堆中, 这里没有提到运行时常量池,也就是说字符串常量池被单独拿到堆,运行时常量池剩下的东西还在方法区, 也就是 hotspot 中的永久代</strong> 。</p>
</li>
<li>
<p><strong>JDK1.8 hotspot 移除了永久代用元空间(Metaspace)取而代之, 这时候字符串常量池还在堆, 运行时常量池还在方法区, 只不过方法区的实现从永久代变成了元空间(Metaspace)</strong></p>
</li>
</ol>
</blockquote>
<h2 id="_2-7-直接内存"> 2.7 直接内存</h2>
<p><strong>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用。而且也可能导致 OutOfMemoryError 错误出现。</strong></p>
<p>JDK1.4 中新加入的 <strong>NIO(New Input/Output) 类</strong>，引入了一种基于**通道（Channel）**与**缓存区（Buffer）*<em>的 I/O 方式，它可以直接使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样就能在一些场景中显著提高性能，因为*<em>避免了在 Java 堆和 Native 堆之间来回复制数据</em></em>。</p>
<p>本机直接内存的分配不会受到 Java 堆的限制，但是，既然是内存就会受到本机总内存大小以及处理器寻址空间的限制。</p>
<h1 id="三-hotspot-虚拟机对象"> 三 HotSpot 虚拟机对象</h1>
<h2 id="_3-1-对象的创建"> 3.1 对象的创建</h2>
<p><img src="./README.assets/Java创建对象的过程.dbe33c41.png" alt="Java创建对象的过程" /></p>
<h3 id="_3-1-1-类加载检查"> 3.1.1 类加载检查</h3>
<p>虚拟机遇到一条 new 指令时，首先将去检查这个指令的参数是否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p>
<h3 id="_3-1-2-分配内存"> 3.1.2 分配内存</h3>
<p>在<strong>类加载检查</strong>通过后，接下来虚拟机将为新生对象<strong>分配内存</strong>。对象所需的内存大小在类加载完成后便可确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。<strong>分配方式</strong>有 <strong>“指针碰撞”</strong> 和 <strong>“空闲列表”</strong> 两种，<strong>选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定</strong>。</p>
<p><img src="./README.assets/内存分配的两种方式.9ecae4c9.png" alt="" /></p>
<p>在创建对象的时候有一个很重要的问题，就是线程安全，因为在实际开发过程中，创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的，通常来讲，虚拟机采用两种方式来保证线程安全：</p>
<ul>
<li><strong>CAS+失败重试：</strong> CAS 是乐观锁的一种实现方式。所谓乐观锁就是，每次不加锁而是假设没有冲突而去完成某项操作，如果因为冲突失败就重试，直到成功为止。<strong>虚拟机采用 CAS 配上失败重试的方式保证更新操作的原子性。</strong></li>
<li><strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配</li>
</ul>
<h3 id="_3-1-3-初始化零值"> 3.1.3 初始化零值</h3>
<p>内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），这一步操作保证了对象的实例字段在 Java 代码中可以不赋初始值就直接使用，程序能访问到这些字段的数据类型所对应的零值。</p>
<h3 id="_3-1-4-设置对象头"> 3.1.4 设置对象头</h3>
<p>初始化零值完成之后，<strong>虚拟机要对对象进行必要的设置</strong>，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 <strong>这些信息存放在对象头中。</strong> 另外，根据虚拟机当前运行状态的不同，如是否启用偏向锁等，对象头会有不同的设置方式。</p>
<h3 id="_3-1-5-执行-init-方法"> 3.1.5 执行 init 方法</h3>
<p>在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。所以一般来说，执行 new 指令之后会接着执行 <code>&lt;init&gt;</code> 方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算完全产生出来。</p>
<h2 id="_3-2-对象的内存布局"> 3.2 对象的内存布局</h2>
<blockquote>
<p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p>
</blockquote>
<p><strong>Hotspot 虚拟机的对象头包括两部分信息</strong>，<strong>第一部分用于存储对象自身的运行时数据</strong>（哈希码、GC 分代年龄、锁状态标志等等），<strong>另一部分是类型指针</strong>，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是那个类的实例。</p>
<p><strong>实例数据部分是对象真正存储的有效信息</strong>，也是在程序中所定义的各种类型的字段内容。</p>
<p><strong>对齐填充部分不是必然存在的，也没有什么特别的含义，仅仅起占位作用。</strong> 因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，换句话说就是对象的大小必须是 8 字节的整数倍。而对象头部分正好是 8 字节的倍数（1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p>
<h2 id="_3-3-对象的访问定位"> 3.3 对象的访问定位</h2>
<p>建立对象就是为了使用对象，我们的 Java 程序通过栈上的 reference 数据来操作堆上的具体对象。对象的访问方式由虚拟机实现而定，目前主流的访问方式有<strong>① 使用句柄</strong>和<strong>② 直接指针</strong>两种：</p>
<blockquote>
<p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p>
</blockquote>
<ol>
<li><strong>句柄：</strong> 如果使用句柄的话，那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息；</li>
</ol>
<p><img src="./README.assets/对象的访问定位-使用句柄.53859387.png" alt="对象的访问定位-使用句柄" /></p>
<ol start="2">
<li><strong>直接指针：</strong> 如果使用直接指针访问，那么 Java 堆对象的布局中就必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象的地址</li>
</ol>
<p><img src="./README.assets/对象的访问定位-直接指针.c3bbe790.png" alt="对象的访问定位-直接指针" /></p>
<h1 id="四-重点补充内容"> 四 重点补充内容</h1>
<h2 id="_4-1-字符串常量池常见问题"> 4.1 字符串常量池常见问题</h2>
<h3 id="_4-1-1-和-equals"> 4.1.1 <code>==</code> 和 <code>equals</code></h3>
<blockquote>
<p><strong>注意</strong> ：比较 String 字符串的值是否相等，可以使用 <code>equals()</code> 方法。 <code>String</code> 中的 <code>equals</code> 方法是被重写过的。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址，而 <code>String</code> 的 <code>equals</code> 方法比较的是字符串的值是否相等。如果你使用 <code>==</code> 比较两个字符串是否相等的话，IDEA 还是提示你使用 <code>equals()</code> 方法替换。</p>
</blockquote>
<p><img src="./README.assets/image-20210817123252441.png" alt="img" /></p>
<blockquote>
<p>对于基本数据类型来说，== 比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</p>
</blockquote>
<h3 id="_4-1-2-存入常量池"> 4.1.2 存入常量池</h3>
<p><strong>对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。</strong></p>
<blockquote>
<p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针为字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p>
<div><pre><code><span>String</span> aa <span>=</span> <span>"ab"</span><span>;</span> <span>// 放在常量池中</span>
<span>String</span> bb <span>=</span> <span>"ab"</span><span>;</span> <span>// 从常量池中查找</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>aa<span>==</span>bb<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p>JDK1.7 之前运行时常量池逻辑包含字符串常量池存放在方法区。JDK1.7 的时候，字符串常量池被从方法区拿到了堆中。</p>
</blockquote>
<p>并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。</p>
<p>并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：</p>
<ol>
<li>基本数据类型(byte、boolean、short、char、int、float、long、double)以及字符串常量</li>
<li><code>final</code> 修饰的基本数据类型和字符串变量</li>
<li>字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（&lt;&lt;、&gt;&gt;、&gt;&gt;&gt; ）</li>
</ol>
<h3 id="_4-1-3-字符串拼接"> 4.1.3 字符串拼接</h3>
<p>对象引用和“+”的字符串拼接方式，实际上是通过 <code>StringBuilder</code> 调用 <code>append()</code> 方法实现的，拼接完成之后调用 <code>toString()</code> 得到一个 <code>String</code> 对象 。</p>
<div><pre><code><span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>//常量池中的对象</span>
<span>String</span> str4 <span>=</span> str1 <span>+</span> str2<span>;</span> <span>//在堆上创建的新的对象</span>
<span>String</span> str5 <span>=</span> <span>"string"</span><span>;</span><span>//常量池中的对象</span>

<span>String</span> str4 <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>)</span><span>.</span><span>append</span><span>(</span>str1<span>)</span><span>.</span><span>append</span><span>(</span>str2<span>)</span><span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br></div></div><p><img src="./README.assets/字符串拼接-常量池.png" alt="img" /></p>
<p>我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 <code>StringBuilder</code> 或者 <code>StringBuffer</code>。</p>
<p>不过，字符串使用 <code>final</code> 关键字声明之后，可以让编译器当做常量来处理。</p>
<div><pre><code><span>final</span> <span>String</span> str1 <span>=</span> <span>"str"</span><span>;</span>
<span>final</span> <span>String</span> str2 <span>=</span> <span>"ing"</span><span>;</span>
<span>// 下面两个表达式其实是等价的</span>
<span>String</span> c <span>=</span> <span>"str"</span> <span>+</span> <span>"ing"</span><span>;</span><span>// 常量池中的对象</span>
<span>String</span> d <span>=</span> str1 <span>+</span> str2<span>;</span> <span>// 常量池中的对象</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>c <span>==</span> d<span>)</span><span>;</span><span>// true</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><h3 id="_4-1-4-创建字符串对象的方式"> 4.1.4 创建字符串对象的方式</h3>
<div><pre><code><span>// 从字符串常量池中拿对象</span>
<span>String</span> str1 <span>=</span> <span>"abcd"</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br></div></div><div><pre><code><span>// 直接在堆内存空间创建一个新的对象。</span>
<span>String</span> str2 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
<span>String</span> str3 <span>=</span> <span>new</span> <span>String</span><span>(</span><span>"abcd"</span><span>)</span><span>;</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div><p><strong>只要使用 new 的方式创建对象，便需要创建新的对象</strong> 。</p>
<p>使用 new 的方式创建对象的方式如下，可以简单概括为 3 步：</p>
<ol>
<li>在堆中创建一个字符串对象</li>
<li>检查字符串常量池中是否有和 new 的字符串值相等的字符串常量</li>
<li>如果没有的话需要在字符串常量池中也创建一个值相等的字符串常量，如果有的话，就直接返回堆中的字符串实例对象地址。</li>
</ol>
<h3 id="_4-1-5-总结"> 4.1.5 总结</h3>
<ol>
<li>对于基本数据类型来说，==比较的是值。对于引用数据类型来说，==比较的是对象的内存地址。</li>
<li>在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 <strong>常量折叠(Constant Folding)</strong> 的代码优化。常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。</li>
<li>一般来说，我们要尽量避免通过 new 的方式创建字符串。使用双引号声明的 <code>String</code> 对象（ <code>String s1 = &quot;java&quot;</code> ）更利于让编译器有机会优化我们的代码，同时也更易于阅读。</li>
<li>被 <code>final</code> 关键字修改之后的 <code>String</code> 会被编译器当做常量来处理，编译器程序编译期就可以确定它的值，其效果就想到于访问常量。</li>
</ol>
<h2 id="_4-2-string-s1-new-string-abc-这句话创建了几个字符串对象"> 4.2 String s1 = new String(&quot;abc&quot;);这句话创建了几个字符串对象？</h2>
<p><strong>会创建 1 或 2 个字符串：</strong></p>
<ul>
<li>如果字符串常量池中已存在字符串常量“abc”，则只会在堆空间创建一个字符串常量“abc”。</li>
<li>如果字符串常量池中没有字符串常量“abc”，<strong>那么它将首先在字符串常量池中创建</strong>，然后在堆空间中创建，因此将创建总共 2 个字符串对象。</li>
</ul>
<h2 id="_4-3-8-种基本类型的包装类和常量池"> 4.3 8 种基本类型的包装类和常量池</h2>
<p>Java 基本类型的包装类的大部分都实现了常量池技术。</p>
<p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> Or <code>False</code>。</p>
<p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现常量池技术。</p>
<blockquote>
<h2 id="常量池技术的作用"> 常量池技术的作用</h2>
<p>常量池是为了避免频繁的创建和销毁对象而影响系统性能，其实现了对象的共享。
例如字符串常量池，在编译阶段就把所有的字符串文字放到一个常量池中。</p>
<ol>
<li>节省内存空间：常量池中所有相同的字符串常量被合并，只占用一个空间。</li>
<li>节省运行时间：比较字符串时，==比equals()快。对于两个引用变量，只用==判断引用是否相等，也就可以判断实际值是否相等。</li>
</ol>
</blockquote>
<div><pre><code><span>Integer</span> i1 <span>=</span> <span>33</span><span>;</span>
<span>Integer</span> i2 <span>=</span> <span>33</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i1 <span>==</span> i2<span>)</span><span>;</span><span>// 输出 true</span>
<span>Integer</span> i11 <span>=</span> <span>333</span><span>;</span>
<span>Integer</span> i22 <span>=</span> <span>333</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i11 <span>==</span> i22<span>)</span><span>;</span><span>// 输出 false</span>
<span>Double</span> i3 <span>=</span> <span>1.2</span><span>;</span>
<span>Double</span> i4 <span>=</span> <span>1.2</span><span>;</span>
<span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>i3 <span>==</span> i4<span>)</span><span>;</span><span>// 输出 false</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br></div></div><h3 id="_4-3-0-整型包装类对象之间的比较"> 4.3.0 整型包装类对象之间的比较</h3>
<p><img src="./README.assets/20210313164740893.png" alt="img" /></p>
<h3 id="_4-3-1-integer-缓存源代码"> 4.3.1 <code>Integer</code> 缓存源代码</h3>
<div><pre><code><span>/**
*此方法将始终缓存-128 到 127（包括端点）范围内的值，并可以缓存此范围之外的其他值。
*/</span>
<span>public</span> <span>static</span> <span>Integer</span> <span>valueOf</span><span>(</span><span>int</span> i<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>i <span>>=</span> <span>IntegerCache</span><span>.</span>low <span>&amp;&amp;</span> i <span>&lt;=</span> <span>IntegerCache</span><span>.</span>high<span>)</span>
      <span>return</span> <span>IntegerCache</span><span>.</span>cache<span>[</span>i <span>+</span> <span>(</span><span>-</span><span>IntegerCache</span><span>.</span>low<span>)</span><span>]</span><span>;</span>
    <span>return</span> <span>new</span> <span>Integer</span><span>(</span>i<span>)</span><span>;</span>
<span>}</span>
<span>private</span> <span>static</span> <span>class</span> <span>IntegerCache</span> <span>{</span>
    <span>static</span> <span>final</span> <span>int</span> low <span>=</span> <span>-</span><span>128</span><span>;</span>
    <span>static</span> <span>final</span> <span>int</span> high<span>;</span>
    <span>static</span> <span>final</span> <span>Integer</span> cache<span>[</span><span>]</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br></div></div><h3 id="_4-3-2-character-缓存源码"> 4.3.2 <code>Character</code> 缓存源码</h3>
<div><pre><code><span>public</span> <span>static</span> <span>Character</span> <span>valueOf</span><span>(</span><span>char</span> c<span>)</span> <span>{</span>
    <span>if</span> <span>(</span>c <span>&lt;=</span> <span>127</span><span>)</span> <span>{</span> <span>// must cache</span>
      <span>return</span> <span>CharacterCache</span><span>.</span>cache<span>[</span><span>(</span><span>int</span><span>)</span>c<span>]</span><span>;</span>
    <span>}</span>
    <span>return</span> <span>new</span> <span>Character</span><span>(</span>c<span>)</span><span>;</span>
<span>}</span>

<span>private</span> <span>static</span> <span>class</span> <span>CharacterCache</span> <span>{</span>
    <span>private</span> <span>CharacterCache</span><span>(</span><span>)</span><span>{</span><span>}</span>

    <span>static</span> <span>final</span> <span>Character</span> cache<span>[</span><span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>[</span><span>127</span> <span>+</span> <span>1</span><span>]</span><span>;</span>
    <span>static</span> <span>{</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>;</span> i <span>&lt;</span> cache<span>.</span>length<span>;</span> i<span>++</span><span>)</span>
            cache<span>[</span>i<span>]</span> <span>=</span> <span>new</span> <span>Character</span><span>(</span><span>(</span><span>char</span><span>)</span>i<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_4-3-3-boolean-缓存源码"> 4.3.3 <code>Boolean</code> 缓存源码</h3>
<div><pre><code><span>public</span> <span>static</span> <span>Boolean</span> <span>valueOf</span><span>(</span><span>boolean</span> b<span>)</span> <span>{</span>
    <span>return</span> <span>(</span>b <span>?</span> TRUE <span>:</span> FALSE<span>)</span><span>;</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T08:35:36.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">认识 JVM</title>
    <id>https://vue-blog.lllllan.cn/1-java/2-jvm/3-know-the-jvm/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/2-jvm/3-know-the-jvm/"/>
    <updated>2022-01-29T01:59:35.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://juejin.cn/post/6844904048013869064#heading-28" target="_blank" rel="noopener noreferrer">大白话带你认识JVM</a>，略有改动</p>
</div>
<h2 id="一、jvm的基本介绍"> 一、JVM的基本介绍</h2>
<p>JVM，Java Virtual Machine。是一个虚构出来的计算机，是一种规范。</p>
<p><img src="./README.assets/16f8a7af019b098dtplv-t2oaga2asx-watermark.png" alt="img" /></p>
<h3 id="_1-1-java-文件如何被运行"> 1.1 Java 文件如何被运行</h3>
<p>比如我们现在写了一个 <code>HelloWorld.java</code> 好了，那这个 <code>HelloWorld.java</code> 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。</p>
<p>那我们的 <strong>JVM</strong> 是不认识文本文件的，所以它需要一个 <strong>编译</strong> ，让其成为一个它会读二进制文件的 <code>HelloWorld.class</code></p>
<h4 id="_1-1-1-类加载器"> 1.1.1 类加载器</h4>
<p>如果 <code>JVM</code> 想要执行这个 <code>.class</code> 文件，我们需要将其装进一个 <strong>类加载器</strong> 中，它就像一个搬运工一样，会把所有的 <code>.class</code> 文件全部搬进JVM里面来。</p>
<p><img src="./README.assets/16f8a9d3cd16cc5ftplv-t2oaga2asx-watermark.png" alt="img" /></p>
<h4 id="_1-1-2-方法区"> 1.1.2 方法区</h4>
<p><strong>方法区</strong> 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等</p>
<p>类加载器将 <code>.class</code> 文件搬过来就是先丢到这一块上</p>
<h4 id="_1-1-3-堆"> 1.1.3 堆</h4>
<p><strong>堆</strong> 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 <strong>线程共享区域</strong> 。也就是说它们都是 <strong>线程不安全</strong> 的</p>
<h4 id="_1-1-4-栈"> 1.1.4 栈</h4>
<p><strong>栈</strong> 这是我们的代码运行空间。我们编写的每一个方法都会放到 <strong>栈</strong> 里面运行。</p>
<p>我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系。</p>
<h4 id="_1-1-5-程序计数器"> 1.1.5 程序计数器</h4>
<p>主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 <strong>线程独享</strong> 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。</p>
<p><img src="./README.assets/16f8ab42da5a81cdtplv-t2oaga2asx-watermark.png" alt="img" /></p>
<h4 id="小结"> 小结</h4>
<ol>
<li>Java文件经过编译后变成 <code>.class</code> 字节码文件</li>
<li>字节码文件通过 <strong>类加载器</strong> 被搬运到 JVM 虚拟机中</li>
<li>虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行</li>
</ol>
<h3 id="_1-2-简单例子"> 1.2 简单例子</h3>
<p>一个简单的学生类：</p>
<div><pre><code><span>public</span> <span>class</span> <span>Student</span> <span>{</span>
    <span>public</span> <span>String</span> name<span>;</span>
    
    <span>public</span> <span>Student</span><span>(</span><span>String</span> name<span>)</span> <span>{</span>
        <span>this</span><span>.</span>name <span>=</span> name<span>;</span>
    <span>}</span>
    
    <span>public</span> <span>void</span> <span>sayName</span><span>(</span><span>)</span> <span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"student's name is "</span> <span>+</span> name<span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br></div></div><p>一个 main 方法：</p>
<div><pre><code><span>public</span> <span>class</span> <span>App</span> <span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>String</span><span>[</span><span>]</span> args<span>)</span> <span>{</span>
        <span>Student</span> student <span>=</span> <span>new</span> <span>Student</span><span>(</span><span>"jack"</span><span>)</span><span>;</span>
        student<span>.</span><span>sayName</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br></div></div><p>执行步骤：</p>
<ol>
<li>编译好 <code>App.java</code> 后得到 <code>App.class</code> 后，执行 <code>App.class</code>，系统会启动一个 JVM 进程，从 <code>classpath</code> 路径中找到一个名为 <code>App.class</code> 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 <strong>App 类的加载</strong></li>
<li>JVM 找到 App 的主程序入口，执行main方法</li>
<li>这个main中的第一条语句为 Student student = new Student(&quot;tellUrDream&quot;) ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中</li>
<li>加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 <strong>指向方法区中的 Student 类的类型信息</strong> 的引用</li>
<li>执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。</li>
<li>执行sayName()</li>
</ol>
<h2 id="二、类加载器"> 二、类加载器</h2>
<p>之前也提到了它是负责加载 <code>.class</code> 文件的，它们在文件开头会有特定的文件标示，将 <code>.class</code> 文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且 <code>ClassLoader</code> 只负责 <code>.class</code> 文件的加载，而是否能够运行则由 <code>Execution Engine</code> 来决定</p>
<h3 id="_2-1-类加载器的流程"> 2.1 类加载器的流程</h3>
<p>从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中 <strong>验证，准备，解析三个部分统称为连接</strong></p>
<h4 id="_2-1-1-加载"> 2.1.1 加载</h4>
<ol>
<li>将 <code>.class</code> 文件加载到内存</li>
<li>将静态数据结构转化成方法区中运行时的数据结构</li>
<li>在堆中生成一个代表这个类的 <code>java.lang.Class</code> 对象作为数据访问的入口</li>
</ol>
<h4 id="_2-1-2-连接"> 2.1.2 连接</h4>
<ol>
<li><strong>验证</strong>：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个<u>安全检查</u></li>
<li><strong>准备</strong>：为 <code>static</code> 变量在方法区中分配内存空间，设置变量的初始值，例如 <code>static int a = 3</code> （注意：<strong>准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）</strong></li>
<li><strong>解析</strong>：虚拟机将常量池内的<u>符号引用替换为直接引用</u>的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）</li>
</ol>
<h4 id="_2-1-3-初始化"> 2.1.3 初始化</h4>
<p>初始化其实就是一个赋值的操作，它会执行一个类构造器的 <code>&lt;clinit&gt;()</code> 方法。由编译器自动收集类中所有变量的赋值动作，此时准备阶段时的那个 static int a = 3 的例子，在这个时候就正式赋值为3</p>
<h4 id="_2-1-4-卸载"> 2.1.4 卸载</h4>
<p>GC将无用对象从内存中卸载</p>
<h3 id="_2-2-类加载器的加载顺序"> 2.2 类加载器的加载顺序</h3>
<p>加载一个 <code>Class</code> 类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的</p>
<ol>
<li>BootStrap ClassLoader：rt.jar</li>
<li>Extention ClassLoader: 加载扩展的jar包</li>
<li>App ClassLoader：指定的classpath下面的jar包</li>
<li>Custom ClassLoader：自定义的类加载器</li>
</ol>
<h3 id="_2-3-双亲委派机制"> 2.3 双亲委派机制</h3>
<p>当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要new一个 <code>Person</code> ，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 <code>App ClassLoader</code> ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的Class）时，子类加载器才会自行尝试加载</p>
<p>这样做的好处是，加载位于 <code>rt.jar</code> 包中的类时不管是哪个加载器加载，最终都会委托到 <code>BootStrap ClassLoader</code> 进行加载，这样<strong>保证了使用不同的类加载器得到的都是同一个结果</strong>。</p>
<p>其实这个也是一个隔离的作用，避免了我们的代码影响了JDK的代码，比如我现在要来一个</p>
<div><pre><code><span>public</span> <span>class</span> <span>String</span><span>(</span><span>)</span><span>{</span>
    <span>public</span> <span>static</span> <span>void</span> <span>main</span><span>(</span><span>)</span><span>{</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span><span>"hello world"</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br></div></div><p>这种时候，我们的代码肯定会报错，因为在加载的时候其实是找到了 <code>rt.jar</code> 中的 <code>String.class</code>，然后发现这也没有main方法</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-26T12:14:06.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">Java 笔记</title>
    <id>https://vue-blog.lllllan.cn/1-java/</id>
    <link href="https://vue-blog.lllllan.cn/1-java/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>重要声明</p>
<p>本篇笔记，大部分内容均转载自各位聚聚的博客和整理，并非原创。为了尊重原作者的劳动，此处以及每篇文章都会列出原文出处。如有遗漏，欢迎指出</p>
</div>
<h2 id="参考"> 参考</h2>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p><a href="https://www.r2coding.com/#/" target="_blank" rel="noopener noreferrer">Road 2 Coding</a></p>
</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="Java"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T09:33:02.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">MySQL 笔记</title>
    <id>https://vue-blog.lllllan.cn/2-mysql/</id>
    <link href="https://vue-blog.lllllan.cn/2-mysql/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<p><a href="https://www.bilibili.com/video/BV1iq4y1u7vj" target="_blank" rel="noopener noreferrer">【宋红康】MySQL数据库（安装/基础/高级/优化）_哔哩哔哩_bilibili</a></p>
<p>MySQL上过一个学期，可以说啥也没听，啥也没学，基本的语句全靠临时百度。</p>
<p>现在跟着这个视频，重新学一遍MySQL，希望能加深理解。</p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="MySQL"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第二章、用电信号传输 TCP/IP 数据</title>
    <id>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/2-transmission-of-electrical-signal/</id>
    <link href="https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/2-transmission-of-electrical-signal/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文作为 《网络是怎样连接的》 的笔记，绝大部分内容均抄自该书。</p>
</div>
<h2 id="零、前情提要"> 零、前情提要</h2>
<ol>
<li>创建套接字。</li>
<li>连接服务器。</li>
<li>收发数据。</li>
<li>断开连接并删除套接字。</li>
<li>IP与以太网的包收发操作。</li>
<li>用UDP协议收发数据的操作。</li>
</ol>
<p><img src="./README.assets/image-20211226140619512.png" alt="image-20211226140619512" /></p>
<h2 id="一、创建套接字"> 一、创建套接字</h2>
<h3 id="_1-1-协议栈的内部结构"> 1.1 协议栈的内部结构</h3>
<p><img src="./README.assets/image-20211226140825219.png" alt="image-20211226140825219" /></p>
<blockquote>
<p>浏览器、邮件等<strong>一般应用程序收发数据时用TCP</strong>；</p>
<p><strong>DNS查询等收发较短的控制数据时用UDP</strong>。</p>
</blockquote>
<blockquote>
<p><strong>ICMP用于告知网络包传送过程中产生的错误以及各种控制消息</strong>；</p>
<p><strong>ARP用于根据IP地址查询相应的以太网MAC地址</strong>。</p>
</blockquote>
<h3 id="_1-2-套接字的实体就是通信控制信息"> 1.2 套接字的实体就是通信控制信息</h3>
<blockquote>
<p>协议栈是根据套接字中记录的控制信息来工作的。</p>
</blockquote>
<p><img src="./README.assets/image-20211226141825503.png" alt="image-20211226141825503" /></p>
<p><img src="./README.assets/image-20211226141937848.png" alt="image-20211226141937848" /></p>
<h3 id="_1-3-调用-socket-时的操作"> 1.3 调用 socket 时的操作</h3>
<blockquote>
<p>创建套接字时，首先分配一个套接字所需的内存空间，让后向其中写入初始状态。</p>
</blockquote>
<p><img src="./README.assets/image-20211226142213413.png" alt="image-20211226142213413" /></p>
<h2 id="二、连接服务器"> 二、连接服务器</h2>
<h3 id="_2-1-连接"> 2.1 连接</h3>
<blockquote>
<p>连接实际上是通信双方交换控制信息，在套接字中记录一些必要信息并准备数据收发的一连串操作。</p>
</blockquote>
<ul>
<li>把服务器的IP地址和端口号等信息告知协议栈</li>
<li>客户端向服务器传达开始通信的请求</li>
<li>开辟一个空间作为缓冲区</li>
</ul>
<h3 id="_2-2-负责保存控制信息的头部"> 2.2 负责保存控制信息的头部</h3>
<p>通信操作中使用的控制信息分为两类：</p>
<ul>
<li>头部中记录的信息</li>
<li>套接字中记录的信息</li>
</ul>
<p><img src="../../../../../../data/r2coding/4.计算机基础/1.计算机网络/1.网络是怎样连接的/网络是怎样连接的.assets/image-20211227214442175.png" alt="image-20211227214442175" style="zoom:150%;" /><img src="./README.assets/image-20211227214507743.png" alt="image-20211227214507743" /></p>
<h3 id="_2-3-连接操作的实际过程"> 2.3 连接操作的实际过程</h3>
<ul>
<li>在TCP模块处创建表示连接控制信息的头部</li>
<li>通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字
<ul>
<li>TCP模块将信息发送给IP模块并委托它进行发送</li>
<li>IP模块执行网络包发送到达服务器</li>
<li>服务器上的IP模块将接收的信息传递给TCP模块</li>
<li>服务器上的TCP模块根据TCP头部中的信息找到端口号对应的套接字</li>
<li>在套接字中写入相应信息，修改状态为正在连接，并向客户端返回响应</li>
</ul>
</li>
<li>客户端接收到服务器的套接字信息，向服务器再次发回消息表示接收成功</li>
</ul>
<h2 id="三、收发数据"> 三、收发数据</h2>
<h3 id="_3-1-将-http-请求交给协议栈"> 3.1 将 HTTP 请求交给协议栈</h3>
<p>协议栈接收到数据后，先将数据存到内部的发送缓冲区。根据以下两个维度的判断，再将HTTP请求发送出去：</p>
<ul>
<li>当从应用程序收到的数据长度超过或接近MSS时再发送出去，可以避免发送大量小包的问题。
<ul>
<li><strong>MTU</strong>：一个网络包的最大长度，一般是1500字节</li>
<li><strong>MSS</strong>：除去头部之后，一个网络包所能容纳的TCP数据的最大长度</li>
</ul>
</li>
<li>协议栈内部有一个计时器，当经过一定时间以后，就会把网络包发送出去。</li>
</ul>
<blockquote>
<p>应用程序在发送数据时可以指定一些选项，比如指定“不等待填满缓冲区直接发送“，协议栈就会按照要求直接发送。</p>
</blockquote>
<h3 id="_3-2-对较大数据进行拆分"> 3.2 对较大数据进行拆分</h3>
<p>当一个HTTP请求的长度，超过了网络包的最大长度，就需要对该请求进行拆分。</p>
<p><img src="./README.assets/image-20211228205521676.png" alt="image-20211228205521676" /></p>
<h3 id="_3-3-使用ack号确认网络包收到"> 3.3 使用ACK号确认网络包收到</h3>
<ul>
<li>发送方：从第xxx字节开始，共有xxx字节</li>
<li>接收方：收到到第xxx字节之前的全部数据</li>
</ul>
<img src="README.assets/image-20211229180218040.png" alt="image-20211229180218040" style="zoom: 150%;" />
<p><img src="./README.assets/image-20211229181203165.png" alt="image-20211229181203165" /><img src="./README.assets/image-20211229181227356.png" alt="image-20211229181227356" /></p>
<blockquote>
<p>在得到对方的确认之前，发送过的包会保存在发送缓存区。如果对方一直没有返回某些包的ACK号，就会重新发送这些包。</p>
</blockquote>
<h3 id="_3-4-根据网络包平均往返时间调整ack号等待时间"> 3.4 根据网络包平均往返时间调整ACK号等待时间</h3>
<p>TCP会在发送数据的过程中持续测量ACK号的返回时间，如果ACK号返回变慢，则相应延长等待时间；如果ACK号马上就能返回，则相应缩短等待时间。</p>
<h3 id="_3-5-使用窗口有效管理ack号"> 3.5 使用窗口有效管理ACK号</h3>
<blockquote>
<p>滑动窗口：在发送一个包之后，不等待ACK号返回，直接发送后续的一系列包。</p>
<p>接收方需要告诉发送方自己最多能接收多少数据，然后发送方根据这个值对数据发送操作进行控制，这就是滑动窗口的基本思路。</p>
</blockquote>
<p><img src="./README.assets/image-20211229190220706.png" alt="image-20211229190220706" /></p>
<p>如果不等待ACK号返回一直自顾自地持续发送，就可能出现发送包的频率超过接收方的处理能力的情况。</p>
<p>接收方收到包之后会保存在接收缓冲区中，计算ACK号并返回给发送方，还要将数据传递给应用程序。如果这些操作还未完成，就有新的数据包到达，都会暂存早接收缓冲区中。但是当接收缓冲区中已经存满，再发送数据包也不可能存的下，这时候发送方的发送频率就超出了接收方的处理能力。</p>
<p>因此接收方会实现告知发送方自己的处理能力（接收缓冲区的大小），发送方会根据已发送的数据包、接收方的缓冲区计算，判断是否还可以继续发送数据。</p>
<p><img src="./README.assets/image-20211229190610804.png" alt="image-20211229190610804" /></p>
<h3 id="_3-6-ack与窗口的合并"> 3.6 ACK与窗口的合并</h3>
<p><strong>问题描述：</strong></p>
<p>当接收方接收到一个数据包，计算好ACK号返回给发送方。假设接收方的接收缓冲区中就只够保存一个数据包，返回了ACK号并不代表他可以继续接收新的数据包。因为还需要将这个数据传递给应用程序，到这个时候才可以从缓冲区将数据包删除，腾出空间来接收新的数据包。</p>
<p>从这个角度出发，接收方收到一个数据包，分别要返回一个ACK号和更新窗口的信息。如果是这样的话，要返回的包就太多了，会导致网络效率的下降。</p>
<p><strong>解决：</strong></p>
<p>接收方计算好ACK号时、窗口更新时，不会马上把包发送出去。</p>
<p>而是等ACK号和窗口更新，或者多个ACK号一起合并发送，以此来减少包的数量。</p>
<h3 id="_3-7-接收http响应消息"> 3.7 接收HTTP响应消息</h3>
<p><img src="./README.assets/image-20211229200045483.png" alt="image-20211229200045483" /></p>
<h2 id="四、从服务器断开并删除套接字"> 四、从服务器断开并删除套接字</h2>
<h3 id="_4-1-断开连接"> 4.1 断开连接</h3>
<blockquote>
<ul>
<li>协议栈在设计上允许<strong>任何一方</strong>（客户端/服务器端）先发起断开过程</li>
<li>无论哪种，完成数据发送的一方都会发起断开过程。（无非谁先谁后而已）</li>
</ul>
</blockquote>
<p>eg：</p>
<ul>
<li>服务器端先断开连接：
<ul>
<li>调用 Socket 库中的 close</li>
<li>生成一个包含断开信息的 TCP 头部，控制位中 <strong>FIN</strong> 比特位为1</li>
<li>协议栈委托 IP 模块向客户端发送数据</li>
<li>套接字中记录断开操作的信息</li>
</ul>
</li>
<li>客户端接收断开信息：
<ul>
<li>收到服务器发来的 <strong>FIN</strong> 为1的 TCP 头部</li>
<li>协议栈将套接字标记为断开操作状态</li>
<li>向服务器返回一个 <strong>ACK</strong> 号</li>
</ul>
</li>
<li>客户端断开连接：
<ul>
<li>执行和服务器相同的操作</li>
<li>服务器也向客户端返回一个 <strong>ACK</strong> 号</li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20220107205801563.png" alt="image-20220107205801563" /></p>
<h3 id="_4-2-删除套接字"> 4.2 删除套接字</h3>
<blockquote>
<p>通信结束以后，会等待一段时间再删除套接字</p>
</blockquote>
<p><strong>原因：</strong></p>
<div><pre><code>	如果服务器向客户端发送 **FIN**，而客户端向服务器返回的 **ACK** 号丢失了，那么服务器可能会重新发送一次 **FIN**。但是服务器没有等待，直接删除了这个套接字。
</code></pre>
</div><p>​		之后新的任务到达，有一个新的套接字分配得到了这个端口号。而客户端因为服务器重新发送的 <strong>FIN</strong>，返回的 <strong>ACK</strong> 号达到了。这时候服务器就会断开这个刚刚创建的新的套接字。</p>
<h3 id="_4-3-数据收发小结"> 4.3 数据收发小结</h3>
<p><img src="./README.assets/image-20220107214550624.png" alt="image-20220107214550624" /></p>
<h2 id="五、ip-与以太网的包的收发操作"> 五、IP 与以太网的包的收发操作</h2>
<h3 id="_5-1-包的基本知识"> 5.1 包的基本知识</h3>
<p><img src="./README.assets/image-20220108091227641.png" alt="image-20220108091227641" /></p>
<p>数据收发过程中的双方，在不同时刻可能互为接收方和发送方，因此统称为 <strong>终端节点</strong></p>
<p>数据包会经过一个个的网络转发设备，最后到达接收方。</p>
<ul>
<li>发送方将接收方的 IP 地址写入 IP头部</li>
<li>IP 协议根据这一 IP地址查找包的传输方向，从而确定下一个路由器的位置</li>
<li><strong>IP协议查出下一个路由器的以太网地址（MAC地址）</strong>，并将地址写入MAC头部</li>
<li>IP协议委托以太网协议将包传输</li>
</ul>
<blockquote>
<ul>
<li>路由器根据目标地址判断下一个路由器的位置 —— IP协议</li>
<li>集线器在子网中将网络包传输到下一个路由 —— 以太网协议</li>
</ul>
</blockquote>
<p><img src="./README.assets/image-20220108093602850.png" alt="image-20220108093602850" /></p>
<h3 id="_5-2-包收发操作概览"> 5.2 包收发操作概览</h3>
<ol>
<li>TCP模块委托IP模块发送包：
<ul>
<li>TCP模块在数据块前面加上TCP头部</li>
<li><strong>指定通信对象的IP地址</strong></li>
<li>整个传递给IP模块</li>
</ul>
</li>
<li>IP模块封装数据包：
<ul>
<li><strong>IP模块会添加IP头部和MAC头部</strong></li>
<li>转交给网络硬件</li>
</ul>
</li>
<li>网络包在网卡间传递</li>
<li>接收方接收网络包：
<ul>
<li>网卡将包转化为数字信息传递给IP模块</li>
<li>IP模块解除IP头部和MAC头部，将TCP头部和数据块传递给TCP模块</li>
<li>TCP模块处理数据</li>
</ul>
</li>
</ol>
<p><img src="./README.assets/image-20220108105125589.png" alt="image-20220108105125589" /></p>
<blockquote>
<p><strong>IP模块的职责就是将委托的东西打包送到对方手里。不关心TCP头部和数据内容，也不关心TCP的操作。</strong></p>
</blockquote>
<h3 id="_5-3-ip头部"> 5.3 IP头部</h3>
<img src="README.assets/image-20220108124243007.png" alt="image-20220108124243007" style="zoom:150%;" />
<p><img src="./README.assets/image-20220108124706189.png" alt="image-20220108124706189" /></p>
<h3 id="_5-4-mac头部"> 5.4 MAC头部</h3>
<p>IP模块根据路由表 Gateway 栏的内容判断应该把包发送给谁。</p>
<p>再根据IP地址查询MAC地址</p>
<p><img src="./README.assets/image-20220108161553247.png" alt="image-20220108161553247" /></p>
<h3 id="_5-5-arp查询目标路由器的mac地址"> 5.5 ARP查询目标路由器的MAC地址</h3>
<ul>
<li>ARP利用广播对所有设备问 <code>XX这个IP地址是谁的，请把你的MAC地址告诉我</code>，然后等待目标路由器将MAC地址返回</li>
</ul>
<p><img src="./README.assets/image-20220108162056855.png" alt="image-20220108162056855" /></p>
<ul>
<li>ARP缓存</li>
</ul>
<p><img src="./README.assets/image-20220108163905777.png" alt="image-20220108163905777" /></p>
<ul>
<li>MAC地址</li>
</ul>
<p><img src="./README.assets/image-20220108163921704.png" alt="image-20220108163921704" /></p>
<ul>
<li>ARP缓存过几分钟就会将原记录删除，以防因为IP地址的改变而导致通信异常</li>
</ul>
<h3 id="_5-6-以太网基本知识"> 5.6 以太网基本知识</h3>
<img src="README.assets/image-20220108164652863.png" alt="image-20220108164652863" style="zoom:150%;" />
<h3 id="_5-7-发送光电信号"> 5.7 发送光电信号</h3>
<blockquote>
<p>网卡的ROM中保存着全世界唯一的MAC地址，这是在生产网卡时写入的</p>
<p>网卡中保存的MAC地址会由网卡驱动程序读取并分配给MAC模块</p>
</blockquote>
<p><img src="./README.assets/image-20220108165951786.png" alt="image-20220108165951786" /></p>
<h3 id="_5-8-给网络包添加控制数据"> 5.8 给网络包添加控制数据</h3>
<blockquote>
<p>MAC模块将网络包从缓存中取出，并在开头加上 <strong>报头</strong> 和 <strong>起始帧分节符</strong>，在末尾加上 <strong>帧校验序列(FCS)</strong></p>
</blockquote>
<p><img src="./README.assets/image-20220109091031789.png" alt="image-20220109091031789" /></p>
<ul>
<li>用电信号来表达数字信息，让0和1分别对应特定的电压和电流
<ul>
<li><strong>数据信号如果出现连续的1或0，由于电流和电压没有变化，我们没办法判断其中每个比特从哪里切分</strong></li>
</ul>
</li>
<li>再发送一组用来区分比特间隔的时钟信号
<ul>
<li><strong>当距离较远、网线较长时，两条线路的长度可能会发生差异，数据信号和时钟信号的传输会产生时间差，时钟就会偏移</strong></li>
</ul>
</li>
<li>将数据信号和时钟信号叠加在一起
<ul>
<li><strong>由于时钟信号是按固定频率变化的，只要找到这个变化的周期就能从中提取出时钟信号，进而计算出数据信号</strong></li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20220109091740442.png" alt="image-20220109091740442" /></p>
<h3 id="_5-9-向集线器发送网络包"> 5.9 向集线器发送网络包</h3>
<blockquote>
<p>发送信号的两种操作：使用集线器的<strong>半双工模式</strong>、使用交换机的<strong>全双工模式</strong></p>
</blockquote>
<p>​	半双工模式中，需要先判断网线中是否存在其他设备发送的信号。如果有，需要等待信号传输完毕才能发送，否则两组信号会发生碰撞。</p>
<ol>
<li>
<p><strong>MAC 模块将数字信号按每个比特转换成电信号</strong></p>
</li>
<li>
<p><strong>PHY（MAU）模块将该信号进行格式转换</strong>并通过网线发送出去、监控接受线路中有无信号进来</p>
</li>
</ol>
<blockquote>
<p>协议栈的TCP会负责搞定可能发生的错误，因此发送信号是没有必要检查错误</p>
</blockquote>
<h3 id="_5-10-接受返回包"> 5.10 接受返回包</h3>
<p><strong>接受步骤：</strong></p>
<ol>
<li>把通过接受线路的所有信号都接收进来</li>
<li>PHY（MAU）模块将信号转换成通用格式并发送给 MAC 模块</li>
<li>MAC 模块从头开始将信号转换成数字信息，并存放到缓冲区</li>
<li>检查 FCS 和 MAC 地址，将数据受污染和地址不一致的包直接丢弃</li>
<li>网卡通过 <strong>中断机制</strong> 通知计算机收到一个包
<ol>
<li>网卡向扩展总线中的中断信号发送信号</li>
<li>该信号通过中断控制器连接到CPU</li>
<li>CPU暂时挂起正在处理的任务，切换到中断处理程序</li>
<li>中断处理程序调用网卡驱动</li>
<li>网卡执行接收操作</li>
</ol>
</li>
<li>网卡根据包中不同协议类型，将包发送给不同的栈</li>
</ol>
<h3 id="_5-11-将服务器的响应包从ip传递给tcp"> 5.11 将服务器的响应包从IP传递给TCP</h3>
<p><strong>IP模块的任务：</strong></p>
<ol>
<li>检查IP头部，确认格式是否正确</li>
<li>查看接收方IP地址，如果有误通过ICMP消息告知对方</li>
<li>分片重组：如果原始的包被分成了多个小包，需要将他们还原成原始的包</li>
</ol>
<p><img src="./README.assets/image-20220111144946393.png" alt="image-20220111144946393" /></p>
<p><strong>TCP模块的任务：</strong></p>
<ol>
<li>找到对应套接字，根据通信记录执行操作：
<ul>
<li>如果包的内容是应用程序数据，则返回确认接收的包，并将数据放入缓冲区，等待应用程序来读取</li>
<li>如果是建立或断开连接的控制包，则返回相应的响应控制包，并告知应用程序建立或断开连接的操作状态</li>
</ul>
</li>
</ol>
<h2 id="六、udp-协议的收发操作"> 六、UDP 协议的收发操作</h2>
<h3 id="_6-1-不需要重发的数据用-udp-更高效"> 6.1 不需要重发的数据用 UDP 更高效</h3>
<blockquote>
<p>TCP为了实现可靠性和高效传输，需要将数据分片发送，并将对方未接收的数据包重新发送。</p>
</blockquote>
<h3 id="_6-2-控制用的短数据"> 6.2 控制用的短数据</h3>
<p>像DNS查询等交换控制信息的操作基本上都可以在一个包的大小范围内解决，这种场景既可以用UDP来代替TCP</p>
<blockquote>
<p>UDP只负责发送包，不管任何可能出现的错误</p>
</blockquote>
<p><img src="./README.assets/image-20220111153930637.png" alt="image-20220111153930637" /></p>
<h3 id="_6-3-音频和视频数据"> 6.3 音频和视频数据</h3>
<p>音频和视频数据必须在规定时间内送达，（一旦错过播放时间，重发数据也没用）因此无需重发数据。这种情况下使用UDP发送数据的效率更高</p>
<h2 id="七、本章回顾"> 七、本章回顾</h2>
<ul>
<li>表示网络包收件人的接收方IP地址是位于IP头部还是TCP头部？</li>
</ul>
<blockquote>
<p>**IP头部。**接收方IP地址最初从应用程序获得， 经由TCP模块告知IP模块</p>
</blockquote>
<ul>
<li>端口号所用来指定服务器程序的种类，那么他位于TCP头部还是IP头部？</li>
</ul>
<blockquote>
<p>**TCP头部。**连接操作的第一步是在TCP模块处创建表示连接控制信息的头部。通过TCP头部中的发送方和接收方端口号可以找到要连接的套接字。</p>
</blockquote>
<ul>
<li>会对包是否正确送达进行确认的是TCP还是IP呢？</li>
</ul>
<blockquote>
<p>TCP</p>
</blockquote>
<ul>
<li>根据IP地址查询MAC地址的机制叫什么？</li>
</ul>
<blockquote>
<p>ARP</p>
<p>在以太网中，有一种叫作广播的方法，可以把包发给连接在同一以太网中的所有设备。ARP就是利用广播对所有设备提问：“××这个IP地址是谁的？请把你的MAC地址告诉我。”然后就会有人回答：“这个IP地址是我的，我的MAC地址是××××。”</p>
</blockquote>
<ul>
<li>在收到ACK号之前继续发送下一个包的方式叫什么？</li>
</ul>
<blockquote>
<p>滑动窗口方式</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-21T02:30:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第三章、从网线到网络设备</title>
    <id>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/3-network-cables-to-network-devices/</id>
    <link href="https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/3-network-cables-to-network-devices/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文作为 《网络是怎样连接的》 的笔记，绝大部分内容均抄自该书。</p>
</div>
<h2 id="一、信号在网线和集线器中传输"> 一、信号在网线和集线器中传输</h2>
<h3 id="_1-1-每个包都是独立传输的"> 1.1 每个包都是独立传输的</h3>
<p><img src="./README.assets/image-20220113145717884.png" alt="image-20220113145717884" /></p>
<h3 id="_1-2-网线中的信号衰减"> 1.2 网线中的信号衰减</h3>
<p>以太网信号的本质是正负变化的电压。</p>
<p>信号在网线的传输过程中，能量会逐渐损失。网线越长，信号衰减就越严重。</p>
<p>同时噪声也会进一步加剧信号的失真。</p>
<h3 id="_1-3-双绞线抑制噪声"> 1.3 双绞线抑制噪声</h3>
<blockquote>
<p>产生噪声的原因是网线周围的电磁波，当电磁波接触到金属等导体时，在其中就会产生电流。信号和噪声的电流混杂在一起之后，导致信号的波形发生失真。</p>
</blockquote>
<p>影响网线的电磁波分为两种：</p>
<h4 id="来自网线之外的其他设备"> 来自网线之外的其他设备：</h4>
<p>当电磁波接触到信号线时，会沿电磁波传播的右旋方向产生电流。</p>
<p>如果我们将信号线缠绕在一起，信号线就变成了螺旋形，其中两根信号线产生的噪声电流方向就会相反，从而使得噪声电流相互抵消。</p>
<p><img src="./README.assets/image-20220113150630538.png" alt="image-20220113150630538" /></p>
<p><img src="./README.assets/image-20220113150651814.png" alt="image-20220113150651814" /></p>
<h4 id="相邻信号线泄露出来"> 相邻信号线泄露出来：</h4>
<p>这种内部产生的噪声称为 <strong>串扰</strong></p>
<p><img src="./README.assets/image-20220113151240119.png" alt="image-20220113151240119" /></p>
<p><img src="./README.assets/image-20220113151203170.png" alt="image-20220113151203170" /></p>
<h3 id="_1-4-集线器将信号发往所有线路"> 1.4 集线器将信号发往所有线路</h3>
<blockquote>
<p>集线器将信号发送给所有连接在它上面的线路。</p>
</blockquote>
<p><img src="./README.assets/image-20220113151435359.png" alt="image-20220113151435359" /></p>
<p><img src="./README.assets/image-20220113151613603.png" alt="image-20220113151613603" /></p>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-21T02:30:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">第一章、浏览器生成消息</title>
    <id>https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/1-browser-generated-messages/</id>
    <link href="https://vue-blog.lllllan.cn/3-cs-basic/1-network/1-how-is-the-network-connected/1-browser-generated-messages/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文作为 《网络是怎样连接的》 的笔记，绝大部分内容均抄自该书。</p>
</div>
<h2 id="一、生成-http-请求消息"> 一、生成 HTTP 请求消息</h2>
<h3 id="_1-1-网址-url-uniform-resource-locator"> 1.1 网址（URL, Uniform Resource Locator）</h3>
<p><img src="./README.assets/image-20211217214228466.png" alt="image-20211217214228466" /></p>
<h3 id="_1-2-解析-url"> 1.2 解析 URL</h3>
<p><img src="./README.assets/image-20211217214541708.png" alt="image-20211217214541708" /></p>
<p><img src="./README.assets/image-20211217214555087.png" alt="image-20211217214555087" /></p>
<h3 id="_1-3-文件名省略"> 1.3 文件名省略</h3>
<ul>
<li>当 URL 以 <code>/</code> 结尾时，服务器会默认访问该路径下的 <code>index.html</code> 或 <code>default.html</code> 文件</li>
<li>当 URL 连 <code>/</code> 和文件类型都省略的时候：</li>
</ul>
<p><img src="./README.assets/image-20211217215354653.png" alt="image-20211217215354653" /></p>
<p>（实测：当一个文件没有文件类型的时候，不允许和一个同名文件夹同时存在。而当这个文件有后缀时，应该会访问同名文件夹）</p>
<h3 id="_1-4-http-基本思路"> 1.4 HTTP 基本思路</h3>
<ul>
<li>对什么 + 进行怎样的操作</li>
</ul>
<p><img src="./README.assets/image-20211217215856796.png" alt="image-20211217215856796" /></p>
<p><img src="./README.assets/image-20211217215922575.png" alt="image-20211217215922575" /></p>
<h3 id="_1-5-生成-http-请求信息"> 1.5 生成 HTTP 请求信息</h3>
<blockquote>
<p><strong>一条请求消息中只能写一个URI</strong>。如果需要获取多个文件，必须对每个文件单独发送一条请求</p>
</blockquote>
<p><img src="./README.assets/image-20211217223257489.png" alt="image-20211217223257489" /></p>
<p><img src="./../../../../../../data/r2coding/4.计算机基础/1.计算机网络/1.网络是怎样连接的/网络是怎样连接的.assets/image-20211217223351942.png" alt="image-20211217223351942" /></p>
<p>更多字段信息见文档 44 页。</p>
<h3 id="_1-6-服务器响应"> 1.6 服务器响应</h3>
<p><img src="./README.assets/image-20211217223257489.png" alt="image-20211217223257489" /></p>
<blockquote>
<p>状态码时一个数字，主要用来向程序告知执行的结果</p>
<p>响应短语是一段文字，用来向人们告知执行的结果</p>
</blockquote>
<p><img src="./README.assets/image-20211217224050584.png" alt="image-20211217224050584" /></p>
<p><img src="./README.assets/image-20211217224916808.png" alt="image-20211217224916808" /></p>
<h2 id="二、向-dns-服务器查询-web-服务器的-ip-地址"> 二、向 DNS 服务器查询 Web 服务器的 IP 地址</h2>
<h3 id="_2-1-ip-地址的基本知识"> 2.1 IP 地址的基本知识</h3>
<p><img src="./README.assets/image-20211219221243726.png" alt="image-20211219221243726" /></p>
<p><img src="./README.assets/image-20211219221343432.png" alt="image-20211219221343432" /></p>
<ul>
<li>IP 地址是 32 比特的数字，被分成了4组</li>
<li>子网掩码也是 32 比特的数字
<ul>
<li><strong>左边全1的部分表示网络号</strong></li>
<li><strong>右边全0的部分表示主机号</strong></li>
</ul>
</li>
</ul>
<p><img src="./README.assets/image-20211219222137630.png" alt="image-20211219222137630" /></p>
<p><img src="./README.assets/image-20211219222245701.png" alt="image-20211219222245701" /></p>
<h3 id="_2-2-域名和ip地址并用的理由"> 2.2 域名和IP地址并用的理由</h3>
<ul>
<li>域名比IP地址更容易记忆</li>
<li>IP地址的传输比域名更高效（IP地址只是4字节的数字，域名最长可以是255字节的字符）</li>
</ul>
<p>于是让人来使用域名，让路由器来使用IP地址，这个机制就是<strong>DNS</strong>。</p>
<h3 id="_2-3-socket-库提供查询-ip-地址的功能"> 2.3 Socket 库提供查询 IP 地址的功能</h3>
<blockquote>
<p><strong>域名解析</strong>：通过DNS查询IP地址的操作。</p>
</blockquote>
<blockquote>
<p><strong>解析器</strong>：负责执行域名解析的DNS客户端。（解析器实际上是一段程序。）</p>
</blockquote>
<p>​	库是一堆通用程序组件的集合，他们具有诸多好处：</p>
<ul>
<li>节省编程工作量</li>
<li>实现程序的标准化</li>
<li>等等</li>
</ul>
<p>​	Socket库也是一种库，其中包含的程序组件可以让其他的应用程序调用操作系统的网络功能，而解析器就是这个库中的其中一种程序组件。</p>
<h3 id="_2-4-通过解析器向dns服务器发出查询"> 2.4 通过解析器向DNS服务器发出查询</h3>
<ul>
<li>调用解析器</li>
<li>解析器向DNS服务器发送查询消息</li>
<li>DNS服务器返回响应消息</li>
<li>解析器从响应消息中取出IP地址并写入内存</li>
</ul>
<p><img src="./README.assets/image-20211223215500444.png" alt="image-20211223215500444" /></p>
<p>根据域名查询IP地址时，浏览器会使用Socket库中的解析器。</p>
<h3 id="_2-5-解析器的内部原理"> 2.5 解析器的内部原理</h3>
<blockquote>
<p><strong>控制流程转移</strong>：由于调用了其他程序，原本运行的程序进入暂停状态，而被调用的程序开始运行。</p>
</blockquote>
<ul>
<li>从上往下顺序执行应用程序编写的操作内容，当到达需要调用解析器的部分时</li>
<li>控制流程转移到解析器，解析器会生成要发送给DNS服务器的查询消息</li>
<li>委托操作系统内部的协议栈来发送这个消息（因为解析器本身并不具备使用网络收发数据的功能</li>
</ul>
<p><img src="./README.assets/image-20211224205322811.png" alt="image-20211224205322811" /></p>
<p>向DNS服务器发送消息时，也需要知道DNS服务器的IP地址。这是这个地址实现设置好了，不需要再查询。</p>
<p><img src="./README.assets/image-20211224213701480.png" alt="image-20211224213701480" /></p>
<h2 id="三、dns-服务器"> 三、DNS 服务器</h2>
<h3 id="_3-1-dns-服务器的基本工作"> 3.1 DNS 服务器的基本工作</h3>
<p>DNS 服务器的基本工作就是根据需要查询的域名和记录类型查找相关的记录，并向客户端返回响应消息。</p>
<ul>
<li>域名：服务器、邮件服务器（邮件地址@后面的部分）的名称</li>
<li>Class：代表互联网的IN</li>
<li>记录类型：表示域名对应何种类型的记录。</li>
</ul>
<p><img src="./README.assets/image-20211224215024279.png" alt="image-20211224215024279" /></p>
<h3 id="_3-2-域名的层次结构"> 3.2 域名的层次结构</h3>
<p>由于存在着不计其数的服务器，不可能将所有服务器的信息保存在一台DNS服务器中，只能是将这些信息分布保存在多台DNS服务器中。</p>
<ul>
<li>按域名以分层次的结构来保存</li>
<li>域名中越靠右的位置表示气层级越高</li>
<li>每个域都是作为一个整体存放在DNS服务器中的</li>
</ul>
<h3 id="_3-3-寻找相应的-dns-服务器并获取-ip-地址"> 3.3 寻找相应的 DNS 服务器并获取 IP 地址</h3>
<ul>
<li>负责管理下级域的 DNS 服务器的 IP 地址注册到他们的上级 DNS 服务器中</li>
<li>com和jp 的上面存在一个 根域</li>
<li>所有 DNS 服务器中都保存有根域的 DNS 服务器信息</li>
</ul>
<p><img src="./README.assets/image-20211224220739596.png" alt="image-20211224220739596" /></p>
<p><img src="./README.assets/image-20211224220802400.png" alt="image-20211224220802400" /></p>
<h3 id="_3-4-通过缓存加快-dns-服务器的响应"> 3.4 通过缓存加快 DNS 服务器的响应</h3>
<p>DNS 服务器有一个缓存功能，可以记住之前查询过的域名</p>
<ul>
<li>如果要查询的域名和相关信息已经在缓存中，那么就可以直接返回响应。</li>
<li>当查询的域名不存在时，“不存在”这一响应结果也会被缓存</li>
<li>缓存信息设置有一个有效期，当信息超过有效期后，数据会从缓存中删除</li>
<li>DNS服务器返回响应时，会告知这一响应结果是来自缓存还是来自负责管理该域名的DNS服务器</li>
</ul>
<h2 id="四、委托协议栈发送消息"> 四、委托协议栈发送消息</h2>
<h3 id="_4-1-数据收发操作概览"> 4.1 数据收发操作概览</h3>
<blockquote>
<p>委托操作系统内部的协议栈发送HTTP消息，适用于<strong>任何</strong>网络应用程序。</p>
</blockquote>
<p><img src="./README.assets/image-20211225120920801.png" alt="image-20211225120920801" /></p>
<ul>
<li>创建套接字（出入口） —— <strong>创建套接字阶段</strong></li>
<li>【客户端】向【服务器端】套接字连接管道 —— <strong>连接阶段</strong></li>
<li>收发数据 —— <strong>通信阶段</strong></li>
<li>断开管道并删除套接字 —— <strong>断开阶段</strong></li>
</ul>
<blockquote>
<p>这个管道中，<em>数据流动是<strong>双向</strong>的</em></p>
</blockquote>
<h3 id="_4-2-创建套接字阶段"> 4.2 创建套接字阶段</h3>
<blockquote>
<p>创建套接字需要调用 Socket 库中的 <strong>socket 程序组件</strong></p>
</blockquote>
<p>客户端创建套接字：</p>
<ul>
<li>调用 Socket 库中的 socket 程序组件</li>
<li>控制流程转移到 socket 内部并执行创建套接字操作</li>
<li>控制流程交回应用程序</li>
</ul>
<p><img src="./README.assets/image-20211225122553775.png" alt="image-20211225122553775" /></p>
<blockquote>
<p>套接字创建完成以后，协议栈返回一个<strong>描述符</strong>，用来标识该套接字</p>
</blockquote>
<h3 id="_4-3-连接阶段"> 4.3 连接阶段</h3>
<blockquote>
<p>连接阶段需要调用 Socket 库中的 <strong>connect 程序组件</strong></p>
</blockquote>
<p>调用 connect 时需要指定三个参数：描述符、服务器IP地址、端口号</p>
<p><img src="./README.assets/image-20211225130205613.png" alt="image-20211225130205613" /></p>
<h3 id="_4-4-通信阶段"> 4.4 通信阶段</h3>
<blockquote>
<p>通信阶段需要调用 Socket 库中的 <strong>write 程序组件</strong>、<strong>read 程序组件</strong></p>
</blockquote>
<p>发送数据：</p>
<ul>
<li>生成 HTTP 请求消息</li>
<li>指定描述符和要发送的数据，由协议栈将数据发送到服务器</li>
</ul>
<p>接收数据：</p>
<ul>
<li>指定存放响应消息的内存地址（称为接收缓冲区）</li>
<li>read 将接收到的响应消息存放到接收缓冲区中</li>
</ul>
<h3 id="_4-5-断开阶段"> 4.5 断开阶段</h3>
<blockquote>
<p>断开阶段需要调用 Socket 库中的 <strong>close 程序组件</strong></p>
</blockquote>
<ul>
<li>Web服务器在发送完响应消息之后，会首先调用 close 来断开连接</li>
<li>客户端中 read 执行接收数据时，会告知浏览器通信阶段已结束</li>
<li>浏览器调用 close 进入断开阶段</li>
</ul>
<h3 id="_4-6-各阶段功能和调用组件"> 4.6 各阶段功能和调用组件</h3>
<table>
<thead>
<tr>
<th style="text-align:center">阶段</th>
<th style="text-align:center">组件</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">创建套接字</td>
<td style="text-align:center">socket</td>
</tr>
<tr>
<td style="text-align:center">连接</td>
<td style="text-align:center">connect</td>
</tr>
<tr>
<td style="text-align:center">通信</td>
<td style="text-align:center">发送：write<br>接收：read</td>
</tr>
<tr>
<td style="text-align:center">断开</td>
<td style="text-align:center">close</td>
</tr>
</tbody>
</table>
<h2 id="五、本章回顾"> 五、本章回顾</h2>
<ul>
<li>网址前的 <code>http</code> 代表什么意思</li>
</ul>
<blockquote>
<p>HTTP，即超文本传输协议，是 HyperText Transfer Protocol的缩写。</p>
</blockquote>
<ul>
<li>用来识别连接在互联网上的计算机和服务器的地址叫什么</li>
</ul>
<blockquote>
<p>IP 地址</p>
</blockquote>
<ul>
<li>根据Web服务器的域名来查询IP地址时所用的服务器叫什么</li>
</ul>
<blockquote>
<p>DNS 服务器</p>
</blockquote>
<ul>
<li>向DNS服务器发送请求消息的程序叫什么</li>
</ul>
<blockquote>
<p>协议栈</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-21T02:30:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">数组练习</title>
    <id>https://vue-blog.lllllan.cn/4-practice/1-group/1-array/</id>
    <link href="https://vue-blog.lllllan.cn/4-practice/1-group/1-array/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Info</p>
<p>感谢 <a href="https://mp.weixin.qq.com/s/3olK6pBq1tzdoz2EzQZ6Gg" target="_blank" rel="noopener noreferrer">「代码随想录」刷题攻略 (qq.com)</a> 的整理，本章是数组相关题型的简单整理</p>
</div>
<h2 id="二分"> 二分</h2>
<p><a href="https://blog.csdn.net/qq_45978890/article/details/116094046" target="_blank" rel="noopener noreferrer">【二分查找】详细图解</a></p>
<h3 id="_1-704-二分查找"> 1. <a href="https://leetcode-cn.com/problems/binary-search/" target="_blank" rel="noopener noreferrer">704-二分查找</a></h3>
<blockquote>
<p>给定一个 n 个元素有序的（升序）整型数组 nums 和一个目标值 target  ，写一个函数搜索 nums 中的 target，如果目标值存在返回下标，否则返回 -1。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>search</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>;</span>
        <span>int</span> r <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>

        <span>int</span> mid <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>l <span>>=</span> nums<span>.</span>length <span>||</span> nums<span>[</span>l<span>]</span> <span>!=</span> target<span>)</span> l <span>=</span> <span>-</span><span>1</span><span>;</span>

        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br></div></div><h3 id="_2-35-搜索插入位置"> 2. <a href="https://leetcode-cn.com/problems/search-insert-position/" target="_blank" rel="noopener noreferrer">35-搜索插入位置</a></h3>
<blockquote>
<p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p>
<p>请必须使用时间复杂度为 O(log n) 的算法。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>searchInsert</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>

        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> target<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span> 

        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h3 id="_3-34-在排序数组中查找元素的第一个和最后一个位置"> 3. <a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array/" target="_blank" rel="noopener noreferrer">34-在排序数组中查找元素的第一个和最后一个位置</a></h3>
<blockquote>
<p>给定一个按照升序排列的整数数组 nums，和一个目标值 target。找出给定目标值在数组中的开始位置和结束位置。</p>
<p>如果数组中不存在目标值 target，返回 [-1, -1]。</p>
<p>进阶：</p>
<p>你可以设计并实现时间复杂度为 O(log n) 的算法解决此问题吗？</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>bs</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>,</span> <span>int</span> tmp<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> nums<span>.</span>length <span>-</span> <span>1</span><span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>if</span> <span>(</span>nums<span>[</span>mid<span>]</span> <span>&lt;</span> val<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        l <span>-=</span> tmp<span>;</span>
        <span>if</span> <span>(</span>l <span>>=</span> <span>0</span> <span>&amp;&amp;</span> l <span>&lt;</span> nums<span>.</span>length <span>&amp;&amp;</span> nums<span>[</span>l<span>]</span> <span>==</span> val <span>-</span> tmp<span>)</span> <span>return</span> l<span>;</span>
        <span>return</span> <span>-</span><span>1</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>searchRange</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> target<span>)</span> <span>{</span>
        <span>return</span> <span>new</span> <span>int</span><span>[</span><span>]</span><span>{</span><span>bs</span><span>(</span>nums<span>,</span> target<span>,</span> <span>0</span><span>)</span><span>,</span> <span>bs</span><span>(</span>nums<span>,</span> target <span>+</span> <span>1</span><span>,</span> <span>1</span><span>)</span><span>}</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br></div></div><h3 id="_4-69-sqrt-x"> 4. <a href="https://leetcode-cn.com/problems/sqrtx/" target="_blank" rel="noopener noreferrer">69-Sqrt(x)</a></h3>
<blockquote>
<p>给你一个非负整数 x ，计算并返回 x 的 算术平方根 。</p>
<p>由于返回类型是整数，结果只保留 整数部分 ，小数部分将被 舍去 。</p>
<p>注意：不允许使用任何内置指数函数和算符，例如 pow(x, 0.5) 或者 x ** 0.5 。</p>
</blockquote>
<p>注意x的范围，无脑平方可能会爆出int的范围</p>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>mySqrt</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> x<span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> mid <span>*</span> mid<span>;</span>
            <span>if</span> <span>(</span>tmp <span>&lt;</span> x<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> l <span>*</span> l<span>;</span>
        <span>if</span> <span>(</span>tmp <span>></span> x<span>)</span> l<span>--</span><span>;</span>
        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br></div></div><h3 id="_5-367-有效的完全平方数"> 5. <a href="https://leetcode-cn.com/problems/valid-perfect-square/" target="_blank" rel="noopener noreferrer">367-有效的完全平方数</a></h3>
<blockquote>
<p>给定一个 正整数 num ，编写一个函数，如果 num 是一个完全平方数，则返回 true ，否则返回 false 。</p>
<p>进阶：不要 使用任何内置的库函数，如  sqrt 。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>boolean</span> <span>isPerfectSquare</span><span>(</span><span>int</span> num<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> num<span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> mid <span>=</span> l <span>+</span> <span>(</span>r <span>-</span> l<span>)</span> <span>/</span> <span>2</span><span>;</span>
            <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> mid <span>*</span> mid<span>;</span>
            <span>if</span> <span>(</span>tmp <span>&lt;</span> num<span>)</span> <span>{</span>
                l <span>=</span> mid <span>+</span> <span>1</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r <span>=</span> mid <span>-</span> <span>1</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>long</span> tmp <span>=</span> <span>1l</span> <span>*</span> l <span>*</span> l<span>;</span>
        <span>return</span> tmp <span>==</span> num<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br></div></div><h2 id="移除元素-双指针"> 移除元素/双指针</h2>
<h3 id="_1-27-移除元素"> 1. <a href="https://leetcode-cn.com/problems/remove-element/" target="_blank" rel="noopener noreferrer">27-移除元素</a></h3>
<blockquote>
<p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。</p>
<p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>removeElement</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>,</span> <span>int</span> val<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> num <span>:</span> nums<span>)</span> <span>{</span>

            <span>if</span> <span>(</span>num <span>!=</span> val<span>)</span> nums<span>[</span>l<span>++</span><span>]</span> <span>=</span> num<span>;</span>
        <span>}</span>

        <span>return</span> l<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br></div></div><h3 id="_2-26-删除有序数组中的重复项"> 2. <a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array/" target="_blank" rel="noopener noreferrer">26-删除有序数组中的重复项</a></h3>
<blockquote>
<p>给你一个有序数组 nums ，请你 原地 删除重复出现的元素，使每个元素 只出现一次 ，返回删除后数组的新长度。</p>
<p>不要使用额外的数组空间，你必须在 原地 修改输入数组 并在使用 O(1) 额外空间的条件下完成。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>removeDuplicates</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>if</span> <span>(</span>nums <span>==</span> <span>null</span> <span>||</span> nums<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>0</span><span>;</span>

        <span>int</span> ans <span>=</span> <span>0</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>1</span><span>,</span> len <span>=</span> nums<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> nums<span>[</span>ans<span>]</span><span>)</span> <span>{</span>
                nums<span>[</span><span>++</span>ans<span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> ans <span>+</span> <span>1</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br></div></div><h3 id="_3-283-移动零"> 3. <a href="https://leetcode-cn.com/problems/move-zeroes/" target="_blank" rel="noopener noreferrer">283-移动零</a></h3>
<blockquote>
<p>给定一个数组 <code>nums</code>，编写一个函数将所有 <code>0</code> 移动到数组的末尾，同时保持非零元素的相对顺序。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>void</span> <span>moveZeroes</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> l <span>=</span> <span>0</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> nums<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>nums<span>[</span>i<span>]</span> <span>!=</span> <span>0</span><span>)</span> <span>{</span>
                nums<span>[</span>l<span>++</span><span>]</span> <span>=</span> nums<span>[</span>i<span>]</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> l<span>,</span> len <span>=</span> nums<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            nums<span>[</span>i<span>]</span> <span>=</span> <span>0</span><span>;</span>
        <span>}</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br></div></div><h3 id="_4-844-比较含退格的字符串"> 4. <a href="https://leetcode-cn.com/problems/backspace-string-compare/" target="_blank" rel="noopener noreferrer">844-比较含退格的字符串</a></h3>
<blockquote>
<p>给定 s 和 t 两个字符串，当它们分别被输入到空白的文本编辑器后，请你判断二者是否相等。# 代表退格字符。</p>
<p>如果相等，返回 true ；否则，返回 false 。</p>
<p>注意：如果对空文本输入退格字符，文本继续为空。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>boolean</span> <span>backspaceCompare</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
        <span>String</span> ss <span>=</span> <span>back</span><span>(</span>s<span>)</span><span>;</span>
        <span>String</span> tt <span>=</span> <span>back</span><span>(</span>t<span>)</span><span>;</span>
        <span>return</span> ss<span>.</span><span>equals</span><span>(</span>tt<span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>String</span> <span>back</span><span>(</span><span>String</span> s<span>)</span> <span>{</span>
        <span>StringBuilder</span> sb <span>=</span> <span>new</span> <span>StringBuilder</span><span>(</span><span>""</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span> <span>==</span> <span>'#'</span><span>)</span> <span>{</span>
                <span>int</span> sz <span>=</span> sb<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>sz <span>></span> <span>0</span><span>)</span> <span>{</span>
                    sb<span>.</span><span>deleteCharAt</span><span>(</span>sz <span>-</span> <span>1</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span> <span>else</span> <span>{</span>
                sb<span>.</span><span>append</span><span>(</span>s<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>)</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> sb<span>.</span><span>toString</span><span>(</span><span>)</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br></div></div><h3 id="_5-977-有序数组的平方"> 5. <a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array/" target="_blank" rel="noopener noreferrer">977-有序数组的平方</a></h3>
<blockquote>
<p>给你一个按 <strong>非递减顺序</strong> 排序的整数数组 <code>nums</code>，返回 <strong>每个数字的平方</strong> 组成的新数组，要求也按 <strong>非递减顺序</strong> 排序。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span><span>[</span><span>]</span> <span>sortedSquares</span><span>(</span><span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span><span>[</span><span>]</span> ans <span>=</span> <span>new</span> <span>int</span><span>[</span>len<span>]</span><span>;</span>

        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> <span>--</span>len<span>;</span>
        <span>while</span> <span>(</span>l <span>&lt;=</span> r<span>)</span> <span>{</span>
            <span>int</span> lef <span>=</span> nums<span>[</span>l<span>]</span> <span>*</span> nums<span>[</span>l<span>]</span><span>;</span>
            <span>int</span> rig <span>=</span> nums<span>[</span>r<span>]</span> <span>*</span> nums<span>[</span>r<span>]</span><span>;</span>
            <span>if</span> <span>(</span>lef <span>>=</span> rig<span>)</span> <span>{</span>
                l<span>++</span><span>;</span>
                ans<span>[</span>len<span>--</span><span>]</span> <span>=</span> lef<span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                r<span>--</span><span>;</span>
                ans<span>[</span>len<span>--</span><span>]</span> <span>=</span> rig<span>;</span>
            <span>}</span>
        <span>}</span>

        <span>return</span> ans<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br></div></div><h2 id="滑动窗口"> 滑动窗口</h2>
<h3 id="_1-209-长度最小的子数组"> 1. <a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum/" target="_blank" rel="noopener noreferrer">209-长度最小的子数组</a></h3>
<blockquote>
<p>给定一个含有 n 个正整数的数组和一个正整数 target 。</p>
<p>找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, ..., numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>public</span> <span>int</span> <span>minSubArrayLen</span><span>(</span><span>int</span> target<span>,</span> <span>int</span><span>[</span><span>]</span> nums<span>)</span> <span>{</span>
        <span>int</span> len <span>=</span> nums<span>.</span>length<span>;</span>
        <span>int</span> ans <span>=</span> len<span>;</span>

        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> <span>0</span><span>,</span> sum <span>=</span> <span>0</span><span>;</span>
        <span>while</span> <span>(</span>r <span>&lt;</span> len<span>)</span> <span>{</span>
            sum <span>+=</span> nums<span>[</span>r<span>++</span><span>]</span><span>;</span>
            <span>if</span> <span>(</span>sum <span>>=</span> target<span>)</span> <span>{</span>
                ans <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>ans<span>,</span> r <span>-</span> l<span>)</span><span>;</span>
            <span>}</span>
            <span>while</span> <span>(</span>l <span>&lt;</span> r<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>sum <span>-</span> nums<span>[</span>l<span>]</span> <span>>=</span> target<span>)</span> <span>{</span>
                    sum <span>-=</span> nums<span>[</span>l<span>++</span><span>]</span><span>;</span>
                    ans <span>=</span> <span>Math</span><span>.</span><span>min</span><span>(</span>ans<span>,</span> r <span>-</span> l<span>)</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>
        <span>}</span>
        <span>if</span> <span>(</span>sum <span>&lt;</span> target<span>)</span> <span>return</span> <span>0</span><span>;</span>

        <span>return</span> ans<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br></div></div><h3 id="_2-904-水果成篮"> 2. <a href="https://leetcode-cn.com/problems/fruit-into-baskets/" target="_blank" rel="noopener noreferrer">904-水果成篮</a></h3>
<blockquote>
<p>你正在探访一家农场，农场从左到右种植了一排果树。这些树用一个整数数组 fruits 表示，其中 fruits[i] 是第 i 棵树上的水果 种类 。</p>
<p>你想要尽可能多地收集水果。然而，农场的主人设定了一些严格的规矩，你必须按照要求采摘水果：</p>
<p>你只有 两个 篮子，并且每个篮子只能装 单一类型 的水果。每个篮子能够装的水果总量没有限制。
你可以选择任意一棵树开始采摘，你必须从 每棵 树（包括开始采摘的树）上 恰好摘一个水果 。采摘的水果应当符合篮子中的水果类型。每采摘一次，你将会向右移动到下一棵树，并继续采摘。
一旦你走到某棵树前，但水果不符合篮子的水果类型，那么就必须停止采摘。
给你一个整数数组 fruits ，返回你可以收集的水果的 最大 数目。</p>
</blockquote>
<div><pre><code><span>class</span> <span>Solution</span> <span>{</span>
    <span>class</span> node <span>{</span>
        <span>private</span> <span>int</span> num<span>;</span>
        <span>private</span> <span>int</span> cnt<span>;</span>

        <span>public</span> <span>node</span><span>(</span><span>)</span> <span>{</span>
            num <span>=</span> cnt <span>=</span> <span>0</span><span>;</span>
        <span>}</span>

        <span>public</span> <span>boolean</span> <span>add</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>cnt <span>==</span> <span>0</span><span>)</span> <span>{</span>
                num <span>=</span> x<span>;</span>
                cnt <span>=</span> <span>1</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>if</span> <span>(</span>num <span>==</span> x<span>)</span> <span>{</span>
                cnt<span>++</span><span>;</span>
                <span>return</span> <span>true</span><span>;</span>
            <span>}</span> <span>else</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>

        <span>public</span> <span>void</span> <span>del</span><span>(</span><span>int</span> x<span>)</span> <span>{</span>
            <span>if</span> <span>(</span>num <span>==</span> x <span>&amp;&amp;</span> cnt <span>></span> <span>0</span><span>)</span> <span>{</span>
                cnt<span>--</span><span>;</span>
            <span>}</span>
        <span>}</span>
    <span>}</span>

    <span>public</span> <span>int</span> <span>totalFruit</span><span>(</span><span>int</span><span>[</span><span>]</span> fruits<span>)</span> <span>{</span>
        <span>int</span> ans <span>=</span> <span>0</span><span>,</span> right <span>=</span> <span>0</span><span>;</span>

        node a <span>=</span> <span>new</span> <span>node</span><span>(</span><span>)</span><span>,</span> b <span>=</span> <span>new</span> <span>node</span><span>(</span><span>)</span><span>;</span>

        <span>if</span> <span>(</span>fruits<span>.</span>length <span>==</span> <span>0</span><span>)</span> <span>return</span> <span>0</span><span>;</span>
        a<span>.</span><span>add</span><span>(</span>fruits<span>[</span>right<span>++</span><span>]</span><span>)</span><span>;</span>

        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> fruits<span>.</span>length<span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>while</span> <span>(</span>right <span>&lt;</span> len<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>a<span>.</span><span>add</span><span>(</span>fruits<span>[</span>right<span>]</span><span>)</span> <span>||</span> b<span>.</span><span>add</span><span>(</span>fruits<span>[</span>right<span>]</span><span>)</span><span>)</span> <span>{</span>
                    right<span>++</span><span>;</span>
                <span>}</span> <span>else</span> <span>{</span>
                    <span>break</span><span>;</span>
                <span>}</span>
            <span>}</span>

            ans <span>=</span> <span>Math</span><span>.</span><span>max</span><span>(</span>ans<span>,</span> right <span>-</span> i<span>)</span><span>;</span>

            a<span>.</span><span>del</span><span>(</span>fruits<span>[</span>i<span>]</span><span>)</span><span>;</span>
            b<span>.</span><span>del</span><span>(</span>fruits<span>[</span>i<span>]</span><span>)</span><span>;</span>
        <span>}</span>

        <span>return</span> ans<span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br><span>55</span><br></div></div><h3 id="_3-76-最小覆盖子串"> 3. <a href="https://leetcode-cn.com/problems/minimum-window-substring/" target="_blank" rel="noopener noreferrer">76-最小覆盖子串</a></h3>
<p>给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 &quot;&quot; 。</p>
<p>注意：</p>
<p>对于 t 中重复字符，我们寻找的子字符串中该字符数量必须不少于 t 中该字符数量。
如果 s 中存在这样的子串，我们保证它是唯一的答案。</p>
<div><pre><code><span>import</span> <span>java<span>.</span>util<span>.</span></span><span>HashMap</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Iterator</span><span>;</span>
<span>import</span> <span>java<span>.</span>util<span>.</span></span><span>Map</span><span>;</span>

<span>class</span> <span>Solution</span> <span>{</span>

    <span>public</span> <span>String</span> <span>minWindow</span><span>(</span><span>String</span> s<span>,</span> <span>String</span> t<span>)</span> <span>{</span>
        <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> target <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>for</span> <span>(</span><span>int</span> i <span>=</span> <span>0</span><span>,</span> len <span>=</span> t<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span> i <span>&lt;</span> len<span>;</span> <span>++</span>i<span>)</span> <span>{</span>
            <span>char</span> c <span>=</span> t<span>.</span><span>charAt</span><span>(</span>i<span>)</span><span>;</span>
            target<span>.</span><span>put</span><span>(</span>c<span>,</span> target<span>.</span><span>getOrDefault</span><span>(</span>c<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
        <span>}</span>
        <span>System</span><span>.</span>out<span>.</span><span>println</span><span>(</span>target<span>)</span><span>;</span>

        <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> now <span>=</span> <span>new</span> <span>HashMap</span><span><span>&lt;</span><span>></span></span><span>(</span><span>)</span><span>;</span>
        <span>int</span> ansL <span>=</span> <span>-</span><span>1</span><span>,</span> ansR <span>=</span> <span>-</span><span>1</span><span>;</span>
        <span>int</span> l <span>=</span> <span>0</span><span>,</span> r <span>=</span> <span>0</span><span>,</span> len <span>=</span> s<span>.</span><span>length</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>r <span>&lt;</span> len<span>)</span> <span>{</span>
            <span>Character</span> c <span>=</span> s<span>.</span><span>charAt</span><span>(</span>r<span>)</span><span>;</span>
            <span>if</span> <span>(</span>target<span>.</span><span>containsKey</span><span>(</span>c<span>)</span><span>)</span> <span>{</span>
                now<span>.</span><span>put</span><span>(</span>c<span>,</span> now<span>.</span><span>getOrDefault</span><span>(</span>c<span>,</span> <span>0</span><span>)</span> <span>+</span> <span>1</span><span>)</span><span>;</span>
            <span>}</span>

            <span>while</span> <span>(</span><span>check</span><span>(</span>now<span>,</span> target<span>)</span> <span>&amp;&amp;</span> l <span>&lt;=</span> r<span>)</span> <span>{</span>
                <span>if</span> <span>(</span>ansL <span>==</span> <span>-</span><span>1</span> <span>||</span> r <span>-</span> l <span>&lt;</span> ansR <span>-</span> ansL<span>)</span> <span>{</span>
                    ansL <span>=</span> l<span>;</span>
                    ansR <span>=</span> r<span>;</span>
                <span>}</span>

                <span>char</span> c1 <span>=</span> s<span>.</span><span>charAt</span><span>(</span>l<span>++</span><span>)</span><span>;</span>
                <span>if</span> <span>(</span>target<span>.</span><span>containsKey</span><span>(</span>c1<span>)</span><span>)</span> <span>{</span>
                    now<span>.</span><span>put</span><span>(</span>c1<span>,</span> now<span>.</span><span>getOrDefault</span><span>(</span>c1<span>,</span> <span>0</span><span>)</span> <span>-</span> <span>1</span><span>)</span><span>;</span>
                <span>}</span>
            <span>}</span>

            <span>++</span>r<span>;</span>
        <span>}</span>

        <span>return</span> ansL <span>==</span> <span>-</span><span>1</span> <span>?</span> <span>""</span> <span>:</span> s<span>.</span><span>substring</span><span>(</span>ansL<span>,</span> ansR <span>+</span> <span>1</span><span>)</span><span>;</span>
    <span>}</span>

    <span>public</span> <span>boolean</span> <span>check</span><span>(</span><span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> now<span>,</span> <span>Map</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> tar<span>)</span> <span>{</span>
        <span>Iterator</span><span><span>&lt;</span><span>Map<span>.</span>Entry</span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span><span>></span></span> iterator <span>=</span> tar<span>.</span><span>entrySet</span><span>(</span><span>)</span><span>.</span><span>iterator</span><span>(</span><span>)</span><span>;</span>
        <span>while</span> <span>(</span>iterator<span>.</span><span>hasNext</span><span>(</span><span>)</span><span>)</span> <span>{</span>
            <span>Map<span>.</span>Entry</span><span><span>&lt;</span><span>Character</span><span>,</span> <span>Integer</span><span>></span></span> next <span>=</span> iterator<span>.</span><span>next</span><span>(</span><span>)</span><span>;</span>
            <span>Character</span> key <span>=</span> next<span>.</span><span>getKey</span><span>(</span><span>)</span><span>;</span>
            <span>Integer</span> value <span>=</span> next<span>.</span><span>getValue</span><span>(</span><span>)</span><span>;</span>
            <span>if</span> <span>(</span>now<span>.</span><span>getOrDefault</span><span>(</span>key<span>,</span> <span>0</span><span>)</span> <span>&lt;</span> value<span>)</span> <span>{</span>
                <span>return</span> <span>false</span><span>;</span>
            <span>}</span>
        <span>}</span>
        <span>return</span> <span>true</span><span>;</span>
    <span>}</span>
<span>}</span>
</code></pre>
<div><span>1</span><br><span>2</span><br><span>3</span><br><span>4</span><br><span>5</span><br><span>6</span><br><span>7</span><br><span>8</span><br><span>9</span><br><span>10</span><br><span>11</span><br><span>12</span><br><span>13</span><br><span>14</span><br><span>15</span><br><span>16</span><br><span>17</span><br><span>18</span><br><span>19</span><br><span>20</span><br><span>21</span><br><span>22</span><br><span>23</span><br><span>24</span><br><span>25</span><br><span>26</span><br><span>27</span><br><span>28</span><br><span>29</span><br><span>30</span><br><span>31</span><br><span>32</span><br><span>33</span><br><span>34</span><br><span>35</span><br><span>36</span><br><span>37</span><br><span>38</span><br><span>39</span><br><span>40</span><br><span>41</span><br><span>42</span><br><span>43</span><br><span>44</span><br><span>45</span><br><span>46</span><br><span>47</span><br><span>48</span><br><span>49</span><br><span>50</span><br><span>51</span><br><span>52</span><br><span>53</span><br><span>54</span><br></div></div>]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="刷题"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-21T11:45:45.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">计算机基础</title>
    <id>https://vue-blog.lllllan.cn/3-cs-basic/</id>
    <link href="https://vue-blog.lllllan.cn/3-cs-basic/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>重要声明</p>
<p>既然作为笔记，就存在着大量的摘抄（也就是俗话说的copy）。为了尊重原作者的劳动，此处以及每篇文章都会列出原文出处。如有遗漏，欢迎指出</p>
</div>
<h2 id="参考"> 参考</h2>
<ul>
<li>
<p><a href="https://javaguide.cn/" target="_blank" rel="noopener noreferrer">JavaGuide</a></p>
</li>
<li>
<p>《网络是怎样连接的》</p>
</li>
</ul>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">计算机网络-常见面试题</title>
    <id>https://vue-blog.lllllan.cn/3-cs-basic/1-network/2-interview-questions/</id>
    <link href="https://vue-blog.lllllan.cn/3-cs-basic/1-network/2-interview-questions/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/cs-basics/network/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98/" target="_blank" rel="noopener noreferrer">计算机网络常见面试题 | JavaGuide</a>，略有改动。</p>
</div>
<h2 id="一、osi-与-tcp-ip-各层的结构与功能-都有哪些协议"> 一、OSI 与 TCP/ IP 各层的结构与功能，都有哪些协议？</h2>
<blockquote>
<p><strong>开放式系统互联通信参考模型</strong>（英语：Open System Interconnection Reference Model，缩写为 OSI），简称为<strong>OSI模型</strong>（OSI model），一种<a href="https://baike.baidu.com/item/%E6%A6%82%E5%BF%B5%E6%A8%A1%E5%9E%8B/3187025" target="_blank" rel="noopener noreferrer">概念模型</a>，由<a href="https://baike.baidu.com/item/%E5%9B%BD%E9%99%85%E6%A0%87%E5%87%86%E5%8C%96%E7%BB%84%E7%BB%87/779832" target="_blank" rel="noopener noreferrer">国际标准化组织</a>提出，一个试图使各种计算机在世界范围内互连为网络的标准框架。</p>
<p>TCP/IP传输协议，即传输控制/网络协议，也叫作网络通讯协议。</p>
</blockquote>
<p><img src="./README.assets/五层体系结构.png" alt="五层体系结构" /></p>
<h3 id="_1-1-应用层-进程之间"> 1.1 应用层 - 进程之间</h3>
<p><strong>应用层(application-layer）的任务是通过应用进程间的交互来完成特定网络应用</strong>。应用层协议定义的是应用进程（进程：主机中正在运行的程序）间的通信和交互的规则。对于不同的网络应用需要不同的应用层协议。在互联网中应用层协议很多，如<strong>域名系统 DNS</strong>，支持万维网应用的 <strong>HTTP 协议</strong>，支持电子邮件的 <strong>SMTP 协议</strong>等等。我们把应用层交互的数据单元称为<strong>报文</strong>。</p>
<h3 id="_1-2-运输层-主机之间"> 1.2 运输层 - 主机之间</h3>
<p><strong>运输层(transport layer)的主要任务就是负责向两台主机进程之间的通信提供通用的数据传输服务</strong>。应用进程利用该服务传送应用层报文。“通用的”是指并不针对某一个特定的网络应用，而是多种应用可以使用同一个运输层服务。由于一台主机可同时运行多个线程，因此运输层有复用和分用的功能。所谓复用就是指多个应用层进程可同时使用下面运输层的服务，分用和复用相反，是运输层把收到的信息分别交付上面应用层中的相应进程。</p>
<h4 id="运输层使用协议"> 运输层使用协议</h4>
<ol>
<li><strong>传输控制协议 TCP</strong>（Transmission Control Protocol）--提供<strong>面向连接</strong>的，<strong>可靠的</strong>数据传输服务。</li>
<li><strong>用户数据协议 UDP</strong>（User Datagram Protocol）--提供<strong>无连接</strong>的，尽最大努力的数据传输服务（<strong>不保证数据传输的可靠性</strong>）。</li>
</ol>
<h3 id="_1-3-网络层"> 1.3 网络层</h3>
<p><strong>在计算机网络中进行通信的两个计算机之间可能会经过很多个数据链路，也可能还要经过很多通信子网。网络层的任务就是选择合适的网间路由和交换结点， 确保数据及时传送。</strong> 在发送数据时，网络层把运输层产生的报文段或用户数据报封装成分组和包进行传送。在 TCP/IP 体系结构中，由于网络层使用 <strong>IP 协议</strong>，因此分组也叫 <strong>IP 数据报</strong> ，简称 <strong>数据报</strong>。</p>
<p>互联网是由大量的异构（heterogeneous）网络通过路由器（router）相互连接起来的。互联网使用的网络层协议是无连接的网际协议（Internet Protocol）和许多路由选择协议，因此互联网的网络层也叫做<strong>网际层</strong>或<strong>IP 层</strong>。</p>
<h3 id="_1-4-数据链路层"> 1.4 数据链路层</h3>
<p><strong>数据链路层(data link layer)通常简称为链路层。两台主机之间的数据传输，总是在一段一段的链路上传送的，这就需要使用专门的链路层的协议。</strong> 在两个相邻节点之间传送数据时，<strong>数据链路层将网络层交下来的 IP 数据报组装成帧</strong>，在两个相邻节点间的链路上传送帧。每一帧包括数据和必要的控制信息（如同步信息，地址信息，差错控制等）。</p>
<blockquote>
<p>数据链路层不仅要查错，还要纠错。</p>
</blockquote>
<h3 id="_1-5-物理层"> 1.5 物理层</h3>
<p><strong>物理层(physical layer)的作用是实现相邻计算机节点之间比特流的透明传送，尽可能屏蔽掉具体传输介质和物理设备的差异，</strong> 使其上面的数据链路层不必考虑网络的具体传输介质是什么。“透明传送比特流”表示经实际电路传送后的比特流没有发生变化，对传送的比特流来说，这个电路好像是看不见的。</p>
<h3 id="总结-协议记不住"> 总结（协议记不住）</h3>
<p><img src="./README.assets/七层体系结构图.png" alt="七层体系结构图" /></p>
<h2 id="二、tcp-三次握手"> 二、TCP 三次握手</h2>
<p>为了准确无误地把数据送达目标处，TCP 协议采用了三次握手策略。</p>
<h3 id="_2-0-tcp-三次握手漫画图解"> 2.0 TCP 三次握手漫画图解</h3>
<ul>
<li>客户端–发送带有 SYN 标志的数据包–一次握手–服务端</li>
<li>服务端–发送带有 SYN/ACK 标志的数据包–二次握手–客户端</li>
<li>客户端–发送带有带有 ACK 标志的数据包–三次握手–服务端</li>
</ul>
<p><img src="./README.assets/三次握手.png" alt="TCP三次握手" /></p>
<h3 id="_2-1-三次握手流程"> 2.1 三次握手流程</h3>
<blockquote>
<p><strong>最开始的时候客户端和服务器都是处于CLOSED状态。主动打开连接的为客户端，被动打开连接的是服务器。</strong></p>
</blockquote>
<ol>
<li>TCP服务器进程先创建传输控制块TCB，时刻准备接受客户进程的连接请求，此时服务器就进入了LISTEN（监听）状态；</li>
<li>TCP客户进程也是先创建传输控制块TCB，然后向服务器发出连接请求报文，这是报文首部中的同部位<strong>SYN=1</strong>，同时选择一个<strong>初始序列号 seq=x</strong> ，此时，TCP客户端进程进入了 SYN-SENT（同步已发送状态）状态。TCP规定，SYN报文段（SYN=1的报文段）不能携带数据，但需要消耗掉一个序号。</li>
<li>TCP服务器收到请求报文后，如果同意连接，则发出确认报文。确认报文中应该 <strong>ACK=1，SYN=1</strong>，<strong>确认号是ack=x+1</strong>，同时也要为自己初始化一个<strong>序列号 seq=y</strong>，此时，TCP服务器进程进入了SYN-RCVD（同步收到）状态。这个报文也不能携带数据，但是同样要消耗一个序号。</li>
<li>TCP客户进程收到确认后，还要向服务器给出确认。确认报文的<strong>ACK=1，ack=y+1</strong>，自己的<strong>序列号seq=x+1</strong>，此时，TCP连接建立，客户端进入ESTABLISHED（已建立连接）状态。TCP规定，ACK报文段可以携带数据，但是如果不携带数据则不消耗序号。</li>
<li>当服务器收到客户端的确认后也进入ESTABLISHED状态，此后双方就可以开始通信了。</li>
</ol>
<p><img src="./README.assets/0c9f470819684156cfdc27c682db4def.png" alt="img" /></p>
<h3 id="_2-2-为什么要三次握手"> 2.2 为什么要三次握手</h3>
<p><strong>三次握手的目的是建立可靠的通信信道，就是双方确认自己与对方的发送与接收是正常的。</strong></p>
<ol>
<li>第一次握手：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li>
<li>第二次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li>
<li>第三次握手：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li>
</ol>
<h3 id="_2-3-第二次握手传回了ack-为什么还要传syn"> 2.3 第二次握手传回了ACK，为什么还要传SYN？</h3>
<blockquote>
<p>接收端传回发送端所发送的 ACK 是为了告诉客户端，我接收到的信息确实就是你所发送的信号了，这表明从客户端到服务端的通信是正常的。而回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>
</blockquote>
<p>**SYN 同步序列编号(**Synchronize Sequence Numbers) 是 TCP/IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递</p>
<h3 id="_2-4-为什么还需要第三次握手"> 2.4 为什么还需要第三次握手？</h3>
<p><strong>主要防止已经失效的连接请求报文突然又传送到了服务器，从而产生错误。</strong></p>
<p>如果使用的是两次握手建立连接，假设有这样一种场景，客户端发送了第一个请求连接并且没有丢失，只是因为在网络结点中滞留的时间太长了，由于TCP的客户端迟迟没有收到确认报文，以为服务器没有收到，此时重新向服务器发送这条报文，此后客户端和服务器经过两次握手完成连接，传输数据，然后关闭连接。此时此前滞留的那一次请求连接，网络通畅了到达了服务器，这个报文本该是失效的，但是，两次握手的机制将会让客户端和服务器再次建立连接，这将导致不必要的错误和资源的浪费。</p>
<p>如果采用的是三次握手，就算是那一次失效的报文传送过来了，服务端接受到了那条失效报文并且回复了确认报文，但是客户端不会再次发出确认。由于服务器收不到确认，就知道客户端并没有请求连接。</p>
<h2 id="三、tcp四次挥手"> 三、TCP四次挥手</h2>
<h3 id="_3-0-为什么要四次挥手"> 3.0 为什么要四次挥手</h3>
<p>断开一个 TCP 连接则需要“四次挥手”：</p>
<ul>
<li>客户端-发送一个 FIN，用来关闭客户端到服务器的数据传送</li>
<li>服务器-收到这个 FIN，它发回一 个 ACK，确认序号为收到的序号加 1 。和 SYN 一样，一个 FIN 将占用一个序号</li>
<li>服务器-关闭与客户端的连接，发送一个 FIN 给客户端</li>
<li>客户端-发回 ACK 报文确认，并将确认序号设置为收到序号加 1</li>
</ul>
<p><img src="./README.assets/TCP四次挥手.png" alt="TCP四次挥手" /></p>
<p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p>
<p>举个例子：A 和 B 打电话，通话即将结束后，A 说“我没啥要说的了”，B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话，于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”，A 回答“知道了”，这样通话才算结束。</p>
<h3 id="_3-1-四次挥手流程"> 3.1 四次挥手流程</h3>
<blockquote>
<p>数据传输完毕后，双方都可释放连接。最开始的时候，客户端和服务器都是处于ESTABLISHED状态，<strong>然后客户端主动关闭，服务器被动关闭</strong>。</p>
</blockquote>
<ol>
<li>客户端进程发出连接释放报文，并且停止发送数据。释放数据报文首部，<strong>FIN=1，其序列号为seq=u</strong>（等于前面已经传送过来的数据的最后一个字节的序号加1），此时，客户端进入FIN-WAIT-1（终止等待1）状态。 TCP规定，FIN报文段即使不携带数据，也要消耗一个序号。</li>
<li>服务器收到连接释放报文，发出确认报文，<strong>ACK=1，ack=u+1，并且带上自己的序列号seq=v</strong>，此时，服务端就进入了CLOSE-WAIT（关闭等待）状态。TCP服务器通知高层的应用进程，客户端向服务器的方向就释放了，这时候处于半关闭状态，即客户端已经没有数据要发送了，但是服务器若发送数据，客户端依然要接受。这个状态还要持续一段时间，也就是整个CLOSE-WAIT状态持续的时间。</li>
<li>客户端收到服务器的确认请求后，此时，客户端就进入FIN-WAIT-2（终止等待2）状态，等待服务器发送连接释放报文（在这之前还需要接受服务器发送的最后的数据）。</li>
<li>服务器将最后的数据发送完毕后，就向客户端发送连接释放报文，<strong>FIN=1，ack=u+1</strong>，由于在半关闭状态，服务器很可能又发送了一些数据，假定此时的<strong>序列号为seq=w</strong>，此时，服务器就进入了LAST-ACK（最后确认）状态，等待客户端的确认。</li>
<li>客户端收到服务器的连接释放报文后，必须发出确认，<strong>ACK=1，ack=w+1，而自己的序列号是seq=u+1</strong>，此时，客户端就进入了TIME-WAIT（时间等待）状态。<span style="color:red"><strong>注意此时TCP连接还没有释放，必须经过2∗MSL（最长报文段寿命）的时间后，当客户端撤销相应的TCB后，才进入CLOSED状态</strong></span>。</li>
<li>服务器只要收到了客户端发出的确认，立即进入CLOSED状态。同样，撤销TCB后，就结束了这次的TCP连接。可以看到，服务器结束TCP连接的时间要比客户端早一些。</li>
</ol>
<p><img src="./README.assets/format,png.png" alt="四次挥手" /></p>
<h3 id="_3-2-为什么客户端最后还要等待2msl"> 3.2 为什么客户端最后还要等待2MSL？</h3>
<p>MSL（Maximum Segment Lifetime）（最长报文段寿命），TCP允许不同的实现可以设置不同的MSL值。</p>
<p>第一，保证客户端发送的最后一个ACK报文能够到达服务器，因为这个ACK报文可能丢失，站在服务器的角度看来，我已经发送了FIN+ACK报文请求断开了，客户端还没有给我回应，应该是我发送的请求断开报文它没有收到，于是服务器又会重新发送一次，而客户端就能在这个2MSL时间段内收到这个重传的报文，接着给出回应报文，并且会重启2MSL计时器。</p>
<p>第二，防止类似与“三次握手”中提到了的“已经失效的连接请求报文段”出现在本连接中。客户端发送完最后一个确认报文后，在这个2MSL时间中，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样新的连接中不会出现旧连接的请求报文。</p>
<h3 id="_3-3-为什么建立连接是三次握手-关闭连接确是四次挥手呢"> 3.3 为什么建立连接是三次握手，关闭连接确是四次挥手呢？</h3>
<p>客户端和服务端未必能同时结束通信，存在一方发送完全部数据、而另一方还有数据要继续发送的情况。所以双方都必须分别发送连接释放报文和ACK</p>
<h3 id="_3-4-如果已经建立了连接-但是客户端突然出现故障了怎么办"> 3.4 如果已经建立了连接，但是客户端突然出现故障了怎么办？</h3>
<p>TCP还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75秒发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。</p>
<h2 id="四、tcp、udp协议的区别"> 四、TCP、UDP协议的区别</h2>
<p><img src="./README.assets/tcp-vs-udp.jpg" alt="TCP、UDP协议的区别" /></p>
<p>UDP 在传送数据之前不需要先建立连接，远地主机在收到 UDP 报文后，不需要给出任何确认。虽然 UDP 不提供可靠交付，但在某些情况下 UDP 却是一种最有效的工作方式（一般用于即时通信），比如： QQ 语音、 QQ 视频 、直播等等</p>
<p>TCP 提供面向连接的服务。在传送数据之前必须先建立连接，数据传送结束后要释放连接。 TCP 不提供广播或多播服务。由于 TCP 要提供可靠的，面向连接的传输服务（TCP 的可靠体现在 TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制，在数据传完后，还会断开连接用来节约系统资源），这一难以避免增加了许多开销，如确认，流量控制，计时器以及连接管理等。这不仅使协议数据单元的首部增大很多，还要占用许多处理机资源。TCP 一般用于文件传输、发送和接收邮件、远程登录等场景。</p>
<h2 id="五、tcp协议如何保证可靠传输"> 五、TCP协议如何保证可靠传输</h2>
<ol>
<li>应用数据被分割成 TCP 认为最适合发送的数据块。</li>
<li>TCP 给发送的每一个包进行编号，接收方对数据包进行排序，把有序数据传送给应用层。</li>
<li><strong>校验和：</strong> TCP 将保持它首部和数据的检验和。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>
<li>TCP 的接收端会丢弃重复的数据。</li>
<li><strong>流量控制：</strong> TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议。 （TCP 利用滑动窗口实现流量控制）</li>
<li><strong>拥塞控制：</strong> 当网络拥塞时，减少数据的发送。</li>
<li><strong>ARQ 协议：</strong> 也是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认。在收到确认后再发下一个分组。</li>
<li><strong>超时重传：</strong> 当 TCP 发出一个段后，它启动一个定时器，等待目的端确认收到这个报文段。如果不能及时收到一个确认，将重发这个报文段。</li>
</ol>
<h3 id="_5-1-arq协议"> 5.1 ARQ协议</h3>
<p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认帧，它通常会重新发送。ARQ 包括<u>停止等待 ARQ 协议和连续 ARQ 协议</u>。</p>
<h4 id="_5-1-1-停止等待-arq-协议"> 5.1.1 停止等待 ARQ 协议</h4>
<p>停止等待协议是为了实现可靠传输的，它的基本原理就是每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组。</p>
<p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p>
<div><p>优缺点</p>
<ul>
<li><strong>优点：</strong> 简单</li>
<li><strong>缺点：</strong> 信道利用率低，等待时间长</li>
</ul>
</div>
<ol>
<li>
<p><strong>无差错情况:</strong></p>
<p>发送方发送分组, 接收方在规定时间内收到, 并且回复确认. 发送方再次发送。</p>
</li>
<li>
<p><strong>出现差错情况（超时重传）:</strong></p>
<p>停止等待协议中超时重传是指只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。因此每发送完一个分组需要设置一个超时计时器，其重传时间应比数据在分组传输的平均往返时间更长一些。这种自动重传方式常称为 <strong>自动重传请求 ARQ</strong> 。另外在停止等待协议中若收到重复分组，就丢弃该分组，但同时还要发送确认。<strong>连续 ARQ 协议</strong> 可提高信道利用率。发送维持一个发送窗口，凡位于发送窗口内的分组可连续发送出去，而不需要等待对方确认。接收方一般采用累积确认，对按序到达的最后一个分组发送确认，表明到这个分组位置的所有分组都已经正确收到了。</p>
</li>
<li>
<p><strong>确认丢失和确认迟到</strong></p>
<ul>
<li>
<p><strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。（不会认为已经发送过了，就不再发送。A 能重传，就证明 B 的确认消息丢失）。</p>
</li>
<li>
<p><strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</p>
</li>
</ul>
</li>
</ol>
<h4 id="_5-1-2-连续-arq-协议"> 5.1.2 连续 ARQ 协议</h4>
<p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p>
<div><p>优缺点</p>
<ul>
<li><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</li>
<li><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。这也叫 Go-Back-N（回退 N），表示需要退回来重传已经发送过的 N 个消息。</li>
</ul>
</div>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-21T02:30:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">刷题笔记</title>
    <id>https://vue-blog.lllllan.cn/4-practice/</id>
    <link href="https://vue-blog.lllllan.cn/4-practice/"/>
    <updated>2022-01-24T10:20:23.000Z</updated>
    <author>
      <name>lllllan</name>
    </author>
    <category term="刷题"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-20T14:33:14.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">操作系统-常见面试题</title>
    <id>https://vue-blog.lllllan.cn/3-cs-basic/2-operating-system/1-interview-questions/</id>
    <link href="https://vue-blog.lllllan.cn/3-cs-basic/2-operating-system/1-interview-questions/"/>
    <updated>2022-01-24T13:26:10.000Z</updated>
    <content type="html"><![CDATA[<div><p>Note</p>
<p>本文转载自 <a href="https://javaguide.cn/cs-basics/operating-system/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%B8%B8%E8%A7%81%E9%9D%A2%E8%AF%95%E9%A2%98&amp;%E7%9F%A5%E8%AF%86%E7%82%B9%E6%80%BB%E7%BB%93/" target="_blank" rel="noopener noreferrer">操作系统常见面试题总结 | JavaGuide</a>、<a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener noreferrer">进程间通信IPC (InterProcess Communication)</a></p>
</div>
<h2 id="一、操作系统基础"> 一、操作系统基础</h2>
<h3 id="_1-1-操作系统"> 1.1 操作系统</h3>
<p><a href="https://zhuanlan.zhihu.com/p/105945721" target="_blank" rel="noopener noreferrer">什么是操作系统？ - 知乎 (zhihu.com)</a></p>
<p>操作系统(Operation System, OS) 是指控制和管理整个计算机系统的硬件和软件资源，并合理的组织和调度计算机的工作和资源的分配，以提供给用户和其它软件方便的接口和环境，它是计算机系统中最基本的系统软件。</p>
<img src="README.assets/v2-9e3753e45963e8de97ec5af05aa4f6e9_720w.jpg" alt="img" style="zoom: 33%;" />
<p><strong>操作系统说明：</strong></p>
<ol>
<li>负责管理协调硬件、软件等计算机资源的工作</li>
<li>为上层的应用程序、用户提供简单易用的服务</li>
<li>操作系统是系统软件，而不是硬件</li>
</ol>
<p><img src="./README.assets/v2-80e382880632b6067b9c1b7c679de331_720w.jpg" alt="img" /></p>
<h3 id="_1-2-系统调用"> 1.2 系统调用</h3>
<p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p>
<ol>
<li>用户态(user mode)：用户态运行的进程可以直接读取用户程序的数据。</li>
<li>内核态(kernel mode)：可以简单的理解系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li>
</ol>
<p>我们运行的程序基本都是运行在用户态，如果我们调用操作系统提供的系统态级别的子功能咋办呢？那就需要系统调用了！</p>
<p>也就是说在我们运行的用户程序中，凡是与系统态级别的资源有关的操作（如文件管理、进程控制、内存管理等)，都必须通过系统调用方式向操作系统提出服务请求，并由操作系统代为完成。</p>
<p>这些系统调用按功能大致可分为如下几类：</p>
<ul>
<li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li>
<li>文件管理。完成文件的读、写、创建及删除等功能。</li>
<li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li>
<li>进程通信。完成进程之间的消息传递或信号传递等功能。</li>
<li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li>
</ul>
<h2 id="二、进程和线程"> 二、进程和线程</h2>
<h3 id="_2-1-进程和线程的区别"> 2.1 进程和线程的区别</h3>
<p><strong>概念：</strong></p>
<ul>
<li><strong>进程</strong>：是并发执行的程序在执行过程中<u>分配和管理资源的基本单位</u>，是一个动态概念，竞争计算机系统资源的基本单位。</li>
<li><strong>线程</strong>：是进程的一个执行单元，是进程内科调度实体。比进程更小的独立运行的基本单位。线程也被称为轻量级进程。</li>
</ul>
<p><strong>关系：</strong></p>
<ol>
<li>一个线程只属于一个进程，一个进程至少有一个线程</li>
<li>资源分配给进程，同一进程的所有线程共享该进程的资源</li>
<li>处理及分配给线程，真正在处理机上运行的是线程</li>
<li>线程在执行过程中，需要协作同步。不同进程的线程间要利用消息通信的办法实现同步。</li>
</ol>
<p><strong>区别：</strong></p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">进程</th>
<th style="text-align:center">线程</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">调度</td>
<td style="text-align:center">分配和管理资源的基本单位</td>
<td style="text-align:center">调度和分配的基本单位</td>
</tr>
<tr>
<td style="text-align:center">资源</td>
<td style="text-align:center">相互间独立</td>
<td style="text-align:center">共享本进程的资源</td>
</tr>
<tr>
<td style="text-align:center">健壮性</td>
<td style="text-align:center">一个进程的崩溃不会影响其他进程</td>
<td style="text-align:center">一个线程的崩溃会影响整个进程</td>
</tr>
<tr>
<td style="text-align:center">并发性</td>
<td style="text-align:center">可以并发执行</td>
<td style="text-align:center">可以并发执行</td>
</tr>
<tr>
<td style="text-align:center">系统开销</td>
<td style="text-align:center">大</td>
<td style="text-align:center">小</td>
</tr>
</tbody>
</table>
<p><strong>JVM角度：</strong></p>
<p>一个进程中可以有多个线程，多个线程共享进程的<strong>堆</strong>和<strong>方法区 (JDK1.8 之后的元空间)资源，但是每个线程有自己的程序计数器</strong>、<strong>虚拟机栈</strong> 和 <strong>本地方法栈</strong>。</p>
<p><img src="./README.assets/up-cd8ac705f6f004c01e0a1312f1599430ba5.png" alt="img" /></p>
<h3 id="_2-2-进程的状态"> 2.2 进程的状态</h3>
<ul>
<li><strong>创建状态(new)</strong> ：进程正在被创建，尚未到就绪状态。</li>
<li><strong>就绪状态(ready)</strong> ：进程已处于准备运行状态，即进程获得了除了处理器之外的一切所需资源，一旦得到处理器资源(处理器分配的时间片)即可运行。</li>
<li><strong>运行状态(running)</strong> ：进程正在处理器上上运行(单核 CPU 下任意时刻只有一个进程处于运行状态)。</li>
<li><strong>阻塞状态(waiting)</strong> ：又称为等待状态，进程正在等待某一事件而暂停运行如等待某资源为可用或等待 IO 操作完成。即使处理器空闲，该进程也不能运行。</li>
<li><strong>结束状态(terminated)</strong> ：进程正在从系统中消失。可能是进程正常结束或其他原因中断退出运行。</li>
</ul>
<p><img src="./README.assets/20160906192211991.png" alt="这里写图片描述" /></p>
<h3 id="_2-3-进程间的通信方式"> 2.3 进程间的通信方式</h3>
<p>下面部分转载自 <a href="https://www.jianshu.com/p/c1015f5ffa74" target="_blank" rel="noopener noreferrer">进程间通信IPC (InterProcess Communication)</a></p>
<p>每个进程各自有不同的用户地址空间，任何一个进程的全局变量在另一个进程中都看不到，所以进程之间要交换数据必须通过内核，在内核中开辟一块缓冲区，进程1把数据从用户空间拷到内核缓冲区，进程2再从内核缓冲区把数据读走，内核提供的这种机制称为<strong>进程间通信</strong></p>
<p><img src="./README.assets/webp.png" alt="img" /></p>
<h4 id="_2-3-1-管道-匿名管道"> 2.3.1 管道/匿名管道</h4>
<p><strong>用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</strong></p>
<blockquote>
<p>管道的实质是一个内核缓冲区，进程以先进先出的方式从缓冲区存取数据，管道一端的进程顺序的将数据写入缓冲区，另一端的进程则顺序的读出数据。
该缓冲区可以看做是一个循环队列，读和写的位置都是自动增长的，不能随意改变，一个数据只能被读一次，读出来以后在缓冲区就不复存在了。
当缓冲区读空或者写满时，有一定的规则控制相应的读进程或者写进程进入等待队列，当空的缓冲区有新数据写入或者满的缓冲区有数据读出来时，就唤醒等待队列中的进程继续读写。</p>
</blockquote>
<p>特点和局限：</p>
<ul>
<li>只支持单向数据流</li>
<li>只能用于具有亲缘关系的进程之间</li>
<li>没有名字</li>
<li>管道的缓冲区是有限的（管道制存在于内存中，在管道创建时，为缓冲区分配一个页面大小）</li>
<li>管道所传送的是无格式字节流，这就要求管道的读出方和写入方必须事先约定好数据的格式，比如多少字节算作一个消息（或命令、或记录）等等；</li>
</ul>
<h4 id="_2-3-2-有名管道-fifo"> 2.3.2 有名管道 FIFO</h4>
<p><strong>有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</strong></p>
<blockquote>
<p>有名管道不同于匿名管道之处在于它提供了一个路径名与之关联，<strong>以有名管道的文件形式存在于文件系统中</strong>，这样，<strong>即使与有名管道的创建进程不存在亲缘关系的进程，只要可以访问该路径，就能够彼此通过有名管道相互通信</strong>，因此，通过有名管道不相关的进程也能交换数据。值的注意的是，有名管道严格遵循<strong>先进先出(first in first out)</strong>,对匿名管道及有名管道的读总是从开始处返回数据，对它们的写则把数据添加到末尾。它们不支持诸如lseek()等文件定位操作。<strong>有名管道的名字存在于文件系统中，内容存放在内存中。</strong></p>
</blockquote>
<p>管道总结：</p>
<ul>
<li>管道是特殊类型的文件，在满足<strong>先入先出</strong>的原则条件下可以进行读写，但不能进行定位读写。</li>
<li>管道都是单向的。其中匿名管道只能在有亲缘关系的进程间通信；有名管道以磁盘文件的方式存在，可以实现本机任意两个进程通信。</li>
<li><strong>匿名管道阻塞问题：</strong> 匿名管道无需显示打开，创建时直接返回文件描述符，在读写时需要确定对方的存在，否则将退出。如果当前进程向无名管道的一端写数据，必须确定另一端有某一进程。如果写入无名管道的数据超过其最大值，写操作将阻塞，如果管道中没有数据，读操作将阻塞，如果管道发现另一端断开，将自动退出。</li>
<li><strong>有名管道阻塞问题：</strong> 有名管道在打开时需要确实对方的存在，否则将阻塞。即以读方式打开某管道，在此之前必须一个进程以写方式打开管道，否则阻塞。此外，可以以读写（O_RDWR）模式打开有名管道，即当前进程读，当前进程写，不会阻塞。</li>
</ul>
<h4 id="_2-3-3-信号"> 2.3.3 信号</h4>
<p><strong>信号是一种比较复杂的通信方式，用于通知接收进程某个事件已经发生</strong></p>
<ul>
<li>信号是Linux系统中用于进程间互相通信或者操作的一种机制，信号可以在任何时候发给某一进程，而无需知道该进程的状态。</li>
<li>如果该进程当前并未处于执行状态，则该信号就有内核保存起来，知道该进程回复执行并传递给它为止。</li>
<li>如果一个信号被进程设置为阻塞，则该信号的传递被延迟，直到其阻塞被取消是才被传递给进程。</li>
</ul>
<p><img src="./README.assets/webp-16430301339574.png" alt="img" /></p>
<h4 id="_2-3-4-消息队列"> 2.3.4 消息队列</h4>
<p><strong>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识。</strong></p>
<p>特点总结：</p>
<ul>
<li>消息队列是消息的链表,具有特定的格式,存放在内存中并由消息队列标识符标识</li>
<li>消息队列允许一个或多个进程向它写入与读取消息</li>
<li>管道和消息队列的通信数据都是先进先出的原则</li>
<li>消息队列可以实现消息的随机查询,消息不一定要以先进先出的次序读取,也可以按消息的类型读取.比FIFO更有优势</li>
<li>消息队列克服了信号承载信息量少，管道只能承载无格式字 节流以及缓冲区大小受限等缺</li>
<li>目前主要有两种类型的消息队列：POSIX消息队列以及System V消息队列，系统V消息队列目前被大量使用。系统V消息队列是随内核持续的，只有在内核重起或者人工删除时，该消息队列才会被删除。</li>
</ul>
<h4 id="_2-3-5-共享内存"> 2.3.5 共享内存</h4>
<p><strong>使得多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新。这种方式需要依靠某种同步操作，如互斥锁和信号量等。可以说这是最有用的进程间通信方式。</strong></p>
<ul>
<li>使得多个进程可以可以直接读写同一块内存空间，是最快的可用IPC形式。是针对其他通信机制运行效率较低而设计的。</li>
<li>为了在多个进程间交换信息，内核专门留出了一块内存区，可以由需要访问的进程将其映射到自己的私有地址空间。进程就可以直接读写这一块内存而不需要进行数据的拷贝，从而大大提高效率。</li>
<li>由于多个进程共享一段内存，因此需要依靠某种同步机制（如信号量）来达到进程间的同步及互斥。</li>
</ul>
<p><img src="./README.assets/webp-16430303402166.png" alt="img" /></p>
<h4 id="_2-3-6-信号量"> 2.3.6 信号量</h4>
<p><strong>信号量是一个计数器，用于多进程对共享数据的访问，信号量的意图在于进程间同步。这种通信方式主要用于解决与同步相关的问题并避免竞争条件。</strong></p>
<blockquote>
<p>操作流程：</p>
<ol>
<li><strong>创建一个信号量</strong>：这要求调用者指定初始值，对于二值信号量来说，它通常是1，也可是0。</li>
<li><strong>等待一个信号量</strong>：该操作会测试这个信号量的值，如果小于0，就阻塞。也称为P操作。</li>
<li><strong>挂出一个信号量</strong>：该操作将信号量的值加1，也称为V操作。</li>
</ol>
</blockquote>
<p><img src="./README.assets/image-20220124212125134.png" alt="image-20220124212125134" /></p>
<h4 id="_2-3-7-套接字"> 2.3.7 套接字</h4>
<p><strong>主要用于在客户端和服务器之间通过网络进行通信</strong></p>
<blockquote>
<p>套接字是一种通信机制，凭借这种机制，客户/服务器（即要进行通信的进程）系统的开发工作既可以在本地单机上进行，也可以跨网络进行。也就是说它可以让不在同一台计算机但通过网络连接计算机上的进程进行通信。</p>
<p>套接字是支持TCP/IP的网络通信的基本操作单元，可以看做是不同主机之间的进程进行双向通信的端点，简单的说就是通信的两方的一种约定，用套接字中的相关函数来完成通信过程。</p>
</blockquote>
]]></content>
    <author>
      <name>lllllan</name>
    </author>
    <category term="计算机基础"/>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <published>2022-01-21T02:30:27.000Z</published>
    <rights>Copyright by lllllan</rights>
  </entry>
  <entry>
    <title type="html">项目主页</title>
    <id>https://vue-blog.lllllan.cn/</id>
    <link href="https://vue-blog.lllllan.cn/"/>
    <updated>2022-01-29T14:27:42.817Z</updated>
    <author>
      <name>lllllan</name>
    </author>
    <contributor>
      <name>lllllan</name>
    </contributor>
    <rights>Copyright by lllllan</rights>
  </entry>
</feed>